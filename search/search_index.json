{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u901a\u8fc7\u6e90\u7801\u5206\u6790nodejs\u539f\u7406 \u00b6 \u77e5\u4e4e\uff1a Node.js\u6e90\u7801\u5206\u6790 \u4e3a\u4ec0\u4e48\u8981\u8bfbNode.js\u6e90\u7801\uff1f Node.js\u7684\u5e95\u5c42\u539f\u7406 \u300aNode.js\u6e90\u7801\u89e3\u67901.0.0\u5e26\u6807\u7b7e\u7248\u300b \u8ba9\u6211\u4eec\u5f00\u59cb\u5b66\u4e60 Node.js \u5427\ud83d\udd25 \u6700\u540e\u66f4\u65b0: 2021-09-23","title":"Home"},{"location":"#nodejs","text":"\u77e5\u4e4e\uff1a Node.js\u6e90\u7801\u5206\u6790 \u4e3a\u4ec0\u4e48\u8981\u8bfbNode.js\u6e90\u7801\uff1f Node.js\u7684\u5e95\u5c42\u539f\u7406 \u300aNode.js\u6e90\u7801\u89e3\u67901.0.0\u5e26\u6807\u7b7e\u7248\u300b \u8ba9\u6211\u4eec\u5f00\u59cb\u5b66\u4e60 Node.js \u5427\ud83d\udd25 \u6700\u540e\u66f4\u65b0: 2021-09-23","title":"\u901a\u8fc7\u6e90\u7801\u5206\u6790nodejs\u539f\u7406"},{"location":"chapter00-%E5%89%8D%E8%A8%80/","text":"\u524d\u8a00 \u00b6 \u6211\u5f88\u559c\u6b22JS\u8fd9\u95e8\u8bed\u8a00\uff0c\u611f\u89c9\u5b83\u548cC\u8bed\u8a00\u4e00\u6837\uff0c\u5728C\u8bed\u8a00\u91cc\uff0c\u5f88\u591a\u4e1c\u897f\u90fd\u9700\u8981\u81ea\u5df1\u5b9e\u73b0\uff0c\u8ba9\u6211\u4eec\u53ef\u4ee5\u53d1\u6325\u65e0\u9650\u7684\u521b\u9020\u529b\u548c\u60f3\u8c61\u529b\u3002\u5728JS\u4e2d\uff0c\u867d\u7136\u5f88\u591a\u4e1c\u897f\u5728V8\u91cc\u5df2\u7ecf\u63d0\u4f9b\uff0c\u4f46\u662f\u7528JS\uff0c\u4f9d\u7136\u53ef\u4ee5\u521b\u9020\u5f88\u591a\u597d\u73a9\u7684\u4e1c\u897f\uff0c\u8fd8\u6709\u597d\u73a9\u7684\u5199\u6cd5\u3002\u53e6\u5916\uff0cJS\u5e94\u8be5\u6211\u89c1\u8fc7\u552f\u4e00\u7684\u4e00\u95e8\u6ca1\u6709\u5b9e\u73b0\u7f51\u7edc\u548c\u6587\u4ef6\u529f\u80fd\u7684\u8bed\u8a00\uff0c\u7f51\u7edc\u548c\u6587\u4ef6\uff0c\u662f\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u80fd\u529b\uff0c\u5bf9\u4e8e\u7a0b\u5e8f\u5458\u6765\u8bf4\uff0c\u4e5f\u662f\u5f88\u6838\u5fc3\u5f88\u57fa\u7840\u7684\u77e5\u8bc6\u3002\u5f88\u5e78\u8fd0\uff0cNode.js\u88ab\u521b\u9020\u51fa\u6765\u4e86\uff0cNode.js\u5728JS\u7684\u57fa\u7840\u4e0a\uff0c\u4f7f\u7528V8\u548cLibuv\u63d0\u4f9b\u7684\u80fd\u529b\uff0c\u6781\u5927\u5730\u62d3\u5c55\u3001\u4e30\u5bcc\u4e86JS\u7684\u80fd\u529b\uff0c\u5c24\u5176\u662f\u7f51\u7edc\u548c\u6587\u4ef6\uff0c\u8fd9\u6837\u6211\u5c31\u4e0d\u4ec5\u53ef\u4ee5\u4f7f\u7528JS\uff0c\u8fd8\u53ef\u4ee5\u4f7f\u7528\u7f51\u7edc\u3001\u6587\u4ef6\u7b49\u529f\u80fd\uff0c\u8fd9\u662f\u6211\u9010\u6e10\u8f6c\u5411Node.js\u65b9\u5411\u7684\u539f\u56e0\u4e4b\u4e00\uff0c\u4e5f\u662f\u6211\u5f00\u59cb\u7814\u7a76Node.js\u6e90\u7801\u7684\u539f\u56e0\u4e4b\u4e00\u3002\u867d\u7136Node.js\u6ee1\u8db3\u4e86\u6211\u559c\u597d\u548c\u6280\u672f\u4e0a\u7684\u9700\u6c42\uff0c\u4e0d\u8fc7\u4e00\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u6211\u5e76\u6ca1\u6709\u5168\u8eab\u5fc3\u5730\u6295\u5165\u4ee3\u7801\u7684\u7814\u7a76\uff0c\u53ea\u662f\u5076\u5c14\u4f1a\u770b\u4e00\u4e0b\u67d0\u4e9b\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u771f\u6b63\u7684\u5f00\u59cb\uff0c\u662f\u4e3a\u4e86\u505a\u300aNode.js\u662f\u5982\u4f55\u5229\u7528Libuv\u5b9e\u73b0\u4e8b\u4ef6\u5faa\u73af\u548c\u5f02\u6b65\u300b\u7684\u5206\u4eab\uff0c\u4ece\u90a3\u65f6\u5019\u8d77\uff0c\u5927\u90e8\u5206\u4e1a\u4f59\u65f6\u95f4\u548c\u7cbe\u529b\u90fd\u6295\u5165\u6e90\u7801\u7684\u7814\u7a76\u3002 \u6211\u9996\u5148\u4eceLibuv\u5f00\u59cb\u7814\u7a76\uff0c\u56e0\u4e3aLibuv\u662fNode.js\u7684\u6838\u5fc3\u4e4b\u4e00\u3002\u7531\u4e8e\u66fe\u7ecf\u7814\u7a76\u8fc7\u4e00\u4e9bLinux\u7684\u6e90\u7801\uff0c\u4e5f\u4e00\u76f4\u5728\u5b66\u4e60\u64cd\u4f5c\u7cfb\u7edf\u7684\u4e00\u4e9b\u539f\u7406\u548c\u5b9e\u73b0\uff0c\u6240\u4ee5\u5728\u9605\u8bfbLibuv\u7684\u65f6\u5019\uff0c\u7b97\u662f\u6ca1\u6709\u9047\u5230\u592a\u5927\u7684\u56f0\u96be\uff0cC\u8bed\u8a00\u51fd\u6570\u7684\u4f7f\u7528\u548c\u539f\u7406\uff0c\u57fa\u672c\u90fd\u53ef\u4ee5\u770b\u660e\u767d\uff0c\u91cd\u70b9\u5728\u4e8e\u9700\u8981\u628a\u5404\u4e2a\u903b\u8f91\u634b\u6e05\u695a\u3002\u6211\u4f7f\u7528\u7684\u65b9\u6cd5\u5c31\u662f\u6ce8\u91ca\u548c\u753b\u56fe\uff0c\u6211\u4e2a\u4eba\u6bd4\u8f83\u559c\u6b22\u5199\u6ce8\u91ca\u3002\u867d\u7136\u8bf4\u4ee3\u7801\u662f\u6700\u597d\u7684\u6ce8\u91ca\uff0c\u4f46\u662f\u6211\u8fd8\u662f\u613f\u610f\u82b1\u65f6\u95f4\u7528\u6ce8\u91ca\u53bb\u628a\u4ee3\u7801\u7684\u80cc\u666f\u548c\u610f\u4e49\u9610\u8ff0\u4e00\u4e0b\uff0c\u800c\u4e14\u6ce8\u91ca\u4f1a\u8ba9\u5927\u90e8\u5206\u4eba\u66f4\u5feb\u5730\u80fd\u8bfb\u61c2\u4ee3\u7801\u7684\u542b\u4e49\u3002\u8bfbLibuv\u7684\u65f6\u5019\uff0c\u4e5f\u7a7f\u63d2\u5730\u8bfb\u4e86\u4e00\u4e9bJS\u548cC++\u5c42\u7684\u4ee3\u7801\u3002\u6211\u9605\u8bfbNode.js\u6e90\u7801\u7684\u65b9\u5f0f\u662f\uff0c\u9009\u62e9\u4e00\u4e2a\u6a21\u5757\uff0c\u5782\u76f4\u5730\u4eceJS\u5c42\u5206\u6790\u5230C++\u5c42\uff0c\u7136\u540e\u5230Libuv\u5c42\u3002 \u8bfb\u5b8cLibuv\uff0c\u63a5\u4e0b\u6765\u8bfb\u7684\u662fJS\u5c42\u7684\u4ee3\u7801\uff0cJS\u867d\u7136\u5bb9\u6613\u770b\u61c2\uff0c\u4f46\u662fJS\u5c42\u7684\u4ee3\u7801\u975e\u5e38\u591a\uff0c\u800c\u4e14\u6211\u611f\u89c9\u903b\u8f91\u4e0a\u4e5f\u975e\u5e38\u7ed5\uff0c\u6240\u4ee5\u81f3\u4eca\uff0c\u6211\u8fd8\u6709\u5f88\u591a\u6ca1\u6709\u7ec6\u8bfb\uff0c\u8fd9\u4e2a\u4f5c\u4e3a\u540e\u7eed\u7684\u8ba1\u5212\u3002Node.js\u4e2d\uff0cC++\u7b97\u662f\u80f6\u6c34\u5c42\uff0c\u5f88\u591a\u65f6\u5019\uff0c\u4e0d\u4f1aC++\uff0c\u5176\u5b9e\u4e5f\u4e0d\u5f71\u54cdNode.js\u6e90\u7801\u7684\u9605\u8bfb\uff0c\u56e0\u4e3aC++\u5f88\u591a\u65f6\u5019\uff0c\u53ea\u662f\u4e00\u79cd\u900f\u4f20\u7684\u529f\u80fd\uff0c\u5b83\u628aJS\u5c42\u7684\u8bf7\u6c42\uff0c\u901a\u8fc7V8\uff0c\u4f20\u7ed9Libuv\uff0c\u7136\u540e\u518d\u53cd\u8fc7\u6765\uff0c\u6240\u4ee5C++\u5c42\u6211\u662f\u653e\u5230\u6700\u540e\u624d\u7ec6\u8bfb\u3002C++\u5c42\u6211\u89c9\u5f97\u662f\u6700\u96be\u7684\uff0c\u8fd9\u65f6\u5019\uff0c\u6211\u53c8\u4e0d\u5f97\u4e0d\u5f00\u59cb\u8bfbV8\u7684\u6e90\u7801\u4e86\uff0c\u7406\u89e3V8\u975e\u5e38\u96be\uff0c\u6211\u9009\u53d6\u7684\u51e0\u4e4e\u662f\u6700\u65e9\u7684\u7248\u672c0.1.5\uff0c\u7136\u540e\u7ed3\u54088.x\u7248\u672c\u3002\u901a\u8fc7\u65e9\u671f\u7248\u672c\uff0c\u5148\u5b66\u4e60V8\u7684\u5927\u6982\u539f\u7406\u548c\u4e00\u4e9b\u65e9\u671f\u5b9e\u73b0\u4e0a\u7684\u7ec6\u8282\u3002\u56e0\u4e3a\u540e\u7eed\u7684\u7248\u672c\u867d\u7136\u53d8\u5316\u5f88\u5927\uff0c\u4f46\u662f\u66f4\u591a\u53ea\u662f\u529f\u80fd\u7684\u589e\u5f3a\u548c\u4f18\u5316\uff0c\u6709\u5f88\u591a\u6838\u5fc3\u7684\u6982\u5ff5\u8fd8\u662f\u6ca1\u6709\u53d8\u5316\u7684\uff0c\u8fd9\u662f\u6211\u9009\u53d6\u65e9\u671f\u7248\u672c\u7684\u539f\u56e0\uff0c\u907f\u514d\u4e00\u5f00\u59cb\u5c31\u9677\u5165\u65e0\u7a77\u65e0\u5c3d\u7684\u4ee3\u7801\u4e2d\uff0c\u8ff7\u5931\u4e86\u65b9\u5411\uff0c\u5931\u53bb\u4e86\u52a8\u529b\u3002\u4f46\u662f\u54ea\u6015\u662f\u65e9\u671f\u7684\u7248\u672c\uff0c\u6709\u5f88\u591a\u5185\u5bb9\u4f9d\u7136\u975e\u5e38\u590d\u6742\uff0c\u7ed3\u5408\u65b0\u7248\u672c\u662f\u56e0\u4e3a\u6709\u4e9b\u529f\u80fd\u5728\u65e9\u671f\u7248\u672c\u91cc\u6ca1\u6709\u5b9e\u73b0\uff0c\u8fd9\u65f6\u5019\u8981\u660e\u767d\u5b83\u7684\u539f\u7406\uff0c\u5c31\u53ea\u80fd\u770b\u65b0\u7248\u7684\u4ee3\u7801\uff0c\u6709\u4e86\u65e9\u671f\u7248\u672c\u7684\u7ecf\u9a8c\uff0c\u9605\u8bfb\u65b0\u7248\u7684\u4ee3\u7801\u4e5f\u6709\u4e00\u5b9a\u7684\u597d\u5904\uff0c\u591a\u5c11\u4e5f\u77e5\u9053\u4e86\u4e00\u4e9b\u9605\u8bfb\u6280\u5de7\u3002 Node.js\u7684\u5927\u90e8\u5206\u4ee3\u7801\u90fd\u5728C++\u548cJS\u5c42\uff0c\u6240\u4ee5\u76ee\u524d\u4ecd\u7136\u662f\u5728\u4e0d\u65ad\u5730\u9605\u8bfb\u8fd9\u4e24\u5c42\u7684\u4ee3\u7801\u3002\u8fd8\u662f\u6309\u7167\u6a21\u5757\u5782\u76f4\u5206\u6790\u3002\u9605\u8bfbNode.js\u4ee3\u7801\uff0c\u8ba9\u6211\u66f4\u4e86\u89e3Node.js\u7684\u539f\u7406\uff0c\u4e5f\u66f4\u4e86\u89e3JS\u3002\u4e0d\u8fc7\u4ee3\u7801\u91cf\u975e\u5e38\u5927\uff0c\u9700\u8981\u6e90\u6e90\u4e0d\u65ad\u7684\u65f6\u95f4\u548c\u7cbe\u529b\u6295\u5165\u3002\u4f46\u662f\u505a\u6280\u672f\uff0c\u77e5\u5176\u7136\u77e5\u5176\u6240\u4ee5\u7136\u7684\u611f\u89c9\u662f\u975e\u5e38\u7f8e\u5999\u7684\uff0c\u4f60\u9760\u7740\u4e00\u95e8\u6280\u672f\u8c0b\u751f\uff0c\u5374\u5bf9\u5b83\u77e5\u4e4b\u751a\u5c11\uff0c\u8fd9\u79cd\u611f\u89c9\u5e76\u4e0d\u597d\u3002\u9605\u8bfb\u6e90\u7801\uff0c\u867d\u7136\u4e0d\u4f1a\u4e3a\u4f60\u5e26\u6765\u76f4\u63a5\u7684\u3001\u8fc5\u901f\u7684\u6536\u76ca\uff0c\u4f46\u662f\u6709\u51e0\u4e2a\u597d\u5904\u662f\u5fc5\u7136\u7684\u3002\u7b2c\u4e00\u662f\u5b83\u4f1a\u51b3\u5b9a\u4f60\u7684\u9ad8\u5ea6\uff0c\u7b2c\u4e8c\u4f60\u5199\u4ee3\u7801\u7684\u65f6\u5019\uff0c\u4f60\u770b\u5230\u7684\u4e0d\u518d\u662f\u4e00\u4e9b\u51b0\u51b7\u51b7\u3001\u65e0\u751f\u547d\u7684\u5b57\u7b26\u3002\u8fd9\u53ef\u80fd\u6709\u70b9\u5938\u5f20\uff0c\u4f46\u662f\u4f60\u4e86\u89e3\u4e86\u6280\u672f\u7684\u539f\u7406\uff0c\u4f60\u5728\u4f7f\u7528\u6280\u672f\u7684\u65f6\u5019\uff0c\u7684\u786e\u4f1a\u6709\u4e0d\u540c\u7684\u4f53\u9a8c\uff0c\u4f60\u7684\u601d\u7ef4\u4e5f\u4f1a\u6709\u4e86\u66f4\u591a\u7684\u53d8\u5316\u3002\u7b2c\u4e09\u662f\u63d0\u9ad8\u4e86\u4f60\u7684\u5b66\u4e60\u80fd\u529b\uff0c\u5f53\u4f60\u5bf9\u5e95\u5c42\u539f\u7406\u6709\u4e86\u66f4\u591a\u7684\u4e86\u89e3\u548c\u7406\u89e3\uff0c\u4f60\u5728\u5b66\u4e60\u5176\u5b83\u6280\u672f\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u66f4\u5feb\u5730\u5b66\u4f1a\uff0c\u6bd4\u5982\u4f60\u4e86\u89e3\u4e86epoll\u7684\u539f\u7406\uff0c\u90a3\u4f60\u770bNginx\u3001Redis\u3001Libuv\u7b49\u6e90\u7801\u7684\u65f6\u5019\uff0c\u5173\u4e8e\u4e8b\u4ef6\u9a71\u52a8\u7684\u903b\u8f91\uff0c\u57fa\u672c\u4e0a\u5f88\u5feb\u5c31\u80fd\u770b\u61c2\u3002\u5f88\u9ad8\u5174\u6709\u8fd9\u4e9b\u7ecf\u5386\uff0c\u4e5f\u6295\u5165\u4e86\u5f88\u591a\u65f6\u95f4\u548c\u7ecf\u7cbe\u529b\uff0c\u5e0c\u671b\u4ee5\u540e\u5bf9Node.js\u6709\u66f4\u591a\u7684\u7406\u89e3\u548c\u4e86\u89e3\uff0c\u4e5f\u5e0c\u671b\u5728Node.js\u65b9\u5411\u6709\u66f4\u591a\u7684\u5b9e\u8df5\u3002 \u672c\u4e66\u7684\u76ee\u7684 \u00b6 \u9605\u8bfbNode.js\u6e90\u7801\u7684\u521d\u8877\u662f\u8ba9\u81ea\u5df1\u6df1\u5165\u7406\u89e3Node.js\u7684\u539f\u7406\uff0c\u4f46\u662f\u6211\u53d1\u73b0\u6709\u5f88\u591a\u540c\u5b66\u5bf9Node.js\u539f\u7406\u4e5f\u975e\u5e38\u611f\u5174\u8da3\uff0c\u56e0\u4e3a\u4e1a\u4f59\u65f6\u95f4\u91cc\u4e5f\u4e00\u76f4\u5728\u5199\u4e00\u4e9b\u5173\u4e8eNode.js\u6e90\u7801\u5206\u6790\u7684\u6587\u7ae0\uff08\u57fa\u4e8eNode.js V10\u548cV14\uff09\uff0c\u6240\u4ee5\u5c31\u6253\u7b97\u628a\u8fd9\u4e9b\u5185\u5bb9\u6574\u7406\u6210\u4e00\u672c\u6709\u4f53\u7cfb\u7684\u4e66\uff0c\u8ba9\u611f\u5174\u8da3\u7684\u540c\u5b66\u80fd\u7cfb\u7edf\u5730\u53bb\u4e86\u89e3\u548c\u7406\u89e3Node.js\u7684\u539f\u7406\u3002\u4e0d\u8fc7\u6211\u66f4\u5e0c\u671b\u7684\u662f\uff0c\u8bfb\u8005\u4ece\u4e66\u4e2d\u4e0d\u4ec5\u5b66\u5230Node.js\u7684\u77e5\u8bc6\uff0c\u800c\u4e14\u4e5f\u5b66\u5230\u5982\u4f55\u9605\u8bfbNode.js\u6e90\u7801\uff0c\u53ef\u4ee5\u81ea\u5df1\u72ec\u7acb\u5b8c\u6210\u6e90\u7801\u7684\u7814\u7a76\u3002\u4e5f\u5e0c\u671b\u66f4\u591a\u540c\u5b66\u5206\u4eab\u81ea\u5df1\u7684\u5fc3\u5f97\u3002\u672c\u4e66\u4e0d\u662fNode.js\u7684\u5168\u90e8\uff0c\u4f46\u662f\u5c3d\u91cf\u53bb\u8bb2\u5f97\u66f4\u591a\uff0c\u6e90\u7801\u975e\u5e38\u591a\uff0c\u9519\u7efc\u590d\u6742\uff0c\u7406\u89e3\u4e0a\u53ef\u80fd\u6709\u4e0d\u5bf9\u4e4b\u5904\uff0c\u6b22\u8fce\u4ea4\u6d41\u3002\u56e0\u4e3a\u770b\u8fc7Linux\u65e9\u671f\u5185\u6838\uff080.11\u548c1.2.13\uff09\u548c\u65e9\u671fV8\uff080.1.5\uff09\u7684\u4e00\u4e9b\u5b9e\u73b0\uff0c\u6587\u7ae0\u4f1a\u5f15\u7528\u5176\u4e2d\u7684\u4e00\u4e9b\u4ee3\u7801\uff0c\u76ee\u7684\u5728\u4e8e\u8ba9\u8bfb\u8005\u53ef\u4ee5\u66f4\u4e86\u89e3\u4e00\u4e2a\u77e5\u8bc6\u70b9\u7684\u5927\u81f4\u5b9e\u73b0\u539f\u7406\uff0c\u5982\u679c\u8bfb\u8005\u6709\u5174\u8da3\uff0c\u53ef\u4ee5\u81ea\u884c\u9605\u8bfb\u76f8\u5173\u4ee3\u7801\u3002 \u672c\u4e66\u7ed3\u6784 \u00b6 \u672c\u4e66\u5171\u5206\u4e3a\u4e8c\u5341\u4e8c\u7ae0\uff0c\u8bb2\u89e3\u7684\u4ee3\u7801\u90fd\u662f\u57fa\u4e8eLinux\u7cfb\u7edf\u7684\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u7684\u7ec4\u6210\u548c\u6574\u4f53\u7684\u5de5\u4f5c\u539f\u7406\uff0c\u53e6\u5916\u5206\u6790\u4e86Node.js\u542f\u52a8\u7684\u8fc7\u7a0b\uff0c\u6700\u540e\u4ecb\u7ecd\u4e86\u670d\u52a1\u5668\u67b6\u6784\u7684\u6f14\u53d8\u548cNode.js\u7684\u6240\u9009\u53d6\u7684\u67b6\u6784\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2d\u7684\u57fa\u7840\u6570\u636e\u7ed3\u6784\u548c\u901a\u7528\u7684\u903b\u8f91\uff0c\u5728\u540e\u9762\u7684\u7ae0\u8282\u4f1a\u7528\u5230\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Libuv\u7684\u4e8b\u4ef6\u5faa\u73af\uff0c\u8fd9\u662fNode.js\u7684\u6838\u5fc3\u6240\u5728,\u672c\u7ae0\u5177\u4f53\u4ecb\u7ecd\u4e86\u4e8b\u4ef6\u5faa\u73af\u4e2d\u6bcf\u4e2a\u9636\u6bb5\u7684\u5b9e\u73b0\u3002 \u4e3b\u8981\u5206\u6790\u4e86Libuv\u4e2d\u7ebf\u7a0b\u6c60\u7684\u5b9e\u73b0\uff0cLibuv\u7ebf\u7a0b\u6c60\u5bf9Node.js\u6765\u8bf4\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0cNode.js\u4e2d\u5f88\u591a\u6a21\u5757\u90fd\u9700\u8981\u4f7f\u7528\u7ebf\u7a0b\u6c60\uff0c\u5305\u62eccrypto\u3001fs\u3001dns\u7b49\u3002\u5982\u679c\u6ca1\u6709\u7ebf\u7a0b\u6c60\uff0cNode.js\u7684\u529f\u80fd\u5c06\u4f1a\u5927\u6253\u6298\u6263\u3002\u540c\u65f6\u5206\u6790\u4e86Libuv\u4e2d\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u7684\u901a\u4fe1\u673a\u5236\u3002\u540c\u6837\u9002\u5408\u5176\u5b83\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u3002 \u4e3b\u8981\u5206\u6790\u4e86Libuv\u4e2d\u6d41\u7684\u5b9e\u73b0\uff0c\u6d41\u5728Node.js\u6e90\u7801\u4e2d\u5f88\u591a\u5730\u65b9\u90fd\u7528\u5230\uff0c\u53ef\u4ee5\u8bf4\u662f\u975e\u5e38\u6838\u5fc3\u7684\u6982\u5ff5\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2dC++\u5c42\u7684\u4e00\u4e9b\u91cd\u8981\u6a21\u5757\u548c\u901a\u7528\u903b\u8f91\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u7684\u4fe1\u53f7\u5904\u7406\u673a\u5236\uff0c\u4fe1\u53f7\u662f\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u53e6\u4e00\u79cd\u65b9\u5f0f\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u7684dns\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u5305\u62eccares\u7684\u4f7f\u7528\u548c\u539f\u7406\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2dpipe\u6a21\u5757\uff08Unix\u57df\uff09\u7684\u5b9e\u73b0\u548c\u4f7f\u7528\uff0cUnix\u57df\u662f\u5b9e\u73b0\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u65b9\u5f0f\uff0c\u5b83\u89e3\u51b3\u4e86\u6ca1\u6709\u7ee7\u627f\u7684\u8fdb\u7a0b\u65e0\u6cd5\u901a\u4fe1\u7684\u95ee\u9898\u3002\u800c\u4e14\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u6781\u5927\u5730\u589e\u5f3a\u4e86Node.js\u7684\u80fd\u529b\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2d\u5b9a\u65f6\u5668\u6a21\u5757\u7684\u5b9e\u73b0\u3002\u5b9a\u65f6\u5668\u662f\u5b9a\u65f6\u5904\u7406\u4efb\u52a1\u7684\u5229\u5668\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js setImmediate\u548cnextTick\u7684\u5b9e\u73b0\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2d\u6587\u4ef6\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u6587\u4ef6\u64cd\u4f5c\u662f\u6211\u4eec\u7ecf\u5e38\u4f1a\u7528\u5230\u7684\u529f\u80fd\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2d\u8fdb\u7a0b\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u591a\u8fdb\u7a0b\u4f7f\u5f97Node.js\u53ef\u4ee5\u5229\u7528\u591a\u6838\u80fd\u529b\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2d\u7ebf\u7a0b\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u591a\u8fdb\u7a0b\u548c\u591a\u7ebf\u7a0b\u6709\u7c7b\u4f3c\u7684\u529f\u80fd\u4f46\u662f\u4e5f\u6709\u4e00\u4e9b\u5dee\u5f02\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2dcluster\u6a21\u5757\u7684\u4f7f\u7528\u548c\u5b9e\u73b0\u539f\u7406\uff0ccluster\u6a21\u5757\u5c01\u88c5\u4e86\u591a\u8fdb\u7a0b\u80fd\u529b\uff0c\u4f7f\u5f97Node.j\u662f\u53ef\u4ee5\u4f7f\u7528\u591a\u8fdb\u7a0b\u7684\u670d\u52a1\u5668\u67b6\u6784\uff0c\u5229\u7528\u4e86\u591a\u6838\u7684\u80fd\u529b\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2dUDP\u7684\u5b9e\u73b0\u548c\u76f8\u5173\u5185\u5bb9\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2dTCP\u6a21\u5757\u7684\u5b9e\u73b0\uff0cTCP\u662fNode.js\u7684\u6838\u5fc3\u6a21\u5757\uff0c\u6211\u4eec\u5e38\u7528\u7684HTTP\uff0cHTTPS\u90fd\u662f\u57fa\u4e8enet\u6a21\u5757\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86HTTP\u6a21\u5757\u7684\u5b9e\u73b0\u4ee5\u53caHTTP\u534f\u8bae\u7684\u4e00\u4e9b\u539f\u7406\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2d\u5404\u79cd\u6a21\u5757\u52a0\u8f7d\u7684\u539f\u7406\uff0c\u6df1\u5165\u7406\u89e3Node.js\u7684require\u51fd\u6570\u6240\u505a\u7684\u4e8b\u60c5\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86\u4e00\u4e9b\u62d3\u5c55Node.js\u7684\u65b9\u6cd5\uff0c\u4f7f\u7528Node.js\uff0c\u62d3\u5c55Node.js\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86JS\u5c42Stream\u7684\u5b9e\u73b0\uff0cStream\u6a21\u5757\u7684\u903b\u8f91\u5f88\u7ed5\uff0c\u5927\u6982\u8bb2\u89e3\u4e86\u4e00\u4e0b\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2devent\u6a21\u5757\u7684\u5b9e\u73b0\uff0cevent\u6a21\u5757\u867d\u7136\u7b80\u5355\uff0c\u4f46\u662f\u662fNode.js\u7684\u6838\u5fc3\u6a21\u5757\u3002 \u9762\u5bf9\u7684\u8bfb\u8005 \u00b6 \u672c\u4e66\u9762\u5411\u6709\u4e00\u5b9aNode.js\u4f7f\u7528\u7ecf\u9a8c\u5e76\u5bf9Node.js\u539f\u7406\u611f\u5174\u8da3\u7684\u540c\u5b66\uff0c\u56e0\u4e3a\u672c\u4e66\u662fNode.js\u6e90\u7801\u7684\u89d2\u5ea6\u53bb\u5206\u6790Node.js\u7684\u539f\u7406\uff0c\u5176\u4e2d\u90e8\u5206\u662fC\u3001C++\uff0c\u6240\u4ee5\u9700\u8981\u8bfb\u8005\u6709\u4e00\u5b9a\u7684C\u3001C++\u57fa\u7840\uff0c\u53e6\u5916\uff0c\u6709\u4e00\u5b9a\u7684\u64cd\u4f5c\u7cfb\u7edf\u3001\u8ba1\u7b97\u673a\u7f51\u7edc\u3001V8\u57fa\u7840\u4f1a\u66f4\u597d\u3002 \u9605\u8bfb\u5efa\u8bae \u00b6 \u5efa\u8bae\u9996\u5148\u9605\u8bfb\u524d\u9762\u51e0\u79cd\u57fa\u7840\u548c\u901a\u7528\u7684\u5185\u5bb9\uff0c\u7136\u540e\u518d\u9605\u8bfb\u5355\u4e2a\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u6700\u540e\u6709\u5174\u8da3\u7684\u8bdd\uff0c\u518d\u9605\u8bfb\u5982\u4f55\u62d3\u5c55Node.js\u7ae0\u8282\u3002\u5982\u679c\u4f60\u5df2\u7ecf\u6bd4\u8f83\u719f\u6089Node.js\uff0c\u53ea\u662f\u5bf9\u67d0\u4e2a\u6a21\u5757\u6216\u5185\u5bb9\u6bd4\u8f83\u611f\u5174\u8da3\uff0c\u5219\u53ef\u4ee5\u76f4\u63a5\u9605\u8bfb\u67d0\u4e2a\u7ae0\u8282\u3002\u521a\u5f00\u59cb\u9605\u8bfbNode.js\u6e90\u7801\u65f6\uff0c\u9009\u53d6\u7684\u662fV10.x\u7684\u7248\u672c\uff0c\u540e\u6765Node.js\u5df2\u7ecf\u66f4\u65b0\u5230\u4e86V14\uff0c\u6240\u4ee5\u4e66\u4e2d\u7684\u4ee3\u7801\u6709\u7684\u662fV10\u6709\u7684\u662fV14\u7684\u3002Libuv\u662fV1.23\u3002\u53ef\u4ee5\u5230\u6211\u7684github\u4e0a\u83b7\u53d6\u3002 \u6e90\u7801\u9605\u8bfb\u5efa\u8bae \u00b6 Node.js\u7684\u6e90\u7801\u7531JS\u3001C++\u3001C\u7ec4\u6210\u3002 1 Libuv\u662fC\u8bed\u8a00\u7f16\u5199\u3002\u7406\u89e3Libuv\u9664\u4e86\u9700\u8981\u4e86\u89e3C\u8bed\u6cd5\u5916\uff0c\u66f4\u591a\u7684\u662f\u5bf9\u64cd\u4f5c\u7cfb\u7edf\u548c\u7f51\u7edc\u7684\u7406\u89e3\uff0c\u6709\u4e9b\u7ecf\u5178\u7684\u4e66\u7c4d\u53ef\u4ee5\u53c2\u8003\uff0c\u6bd4\u5982\u300aUnix\u7f51\u7edc\u7f16\u7a0b\u300b1,2\u4e24\u518c\uff0c\u300aLinux\u7cfb\u7edf\u7f16\u7a0b\u624b\u518c\u300b\u4e0a\u4e0b\u4e24\u518c\uff0c\u300aTCP/IP\u6743\u5a01\u6307\u5357\u300b\u7b49\u7b49\u3002\u8fd8\u6709Linux\u7684API\u6587\u6863\u4ee5\u53ca\u7f51\u4e0a\u4f18\u79c0\u7684\u6587\u7ae0\u90fd\u53ef\u4ee5\u53c2\u8003\u4e00\u4e0b\u3002 2 C++\u4e3b\u8981\u662f\u5229\u7528V8\u63d0\u4f9b\u7684\u80fd\u529b\u5bf9JS\u8fdb\u884c\u62d3\u5c55\uff0c\u4e5f\u6709\u4e00\u90e8\u5206\u529f\u80fd\u4f7f\u7528C++\u5b9e\u73b0\uff0c\u603b\u7684\u6765\u8bf4C++\u7684\u4f5c\u7528\u66f4\u591a\u662f\u80f6\u6c34\u5c42\uff0c\u5229\u7528V8\u4f5c\u4e3a\u6865\u6881\uff0c\u8fde\u63a5Libuv\u548cJS\u3002\u4e0d\u4f1aC++\uff0c\u4e5f\u4e0d\u5b8c\u5168\u5f71\u54cd\u6e90\u7801\u7684\u9605\u8bfb\uff0c\u4f46\u662f\u4f1aC++\u4f1a\u66f4\u597d\u3002\u9605\u8bfbC++\u5c42\u4ee3\u7801\uff0c\u9664\u4e86\u8bed\u6cd5\u5916\uff0c\u8fd8\u9700\u8981\u5bf9V8\u7684\u6982\u5ff5\u548c\u4f7f\u7528\u6709\u4e00\u5b9a\u7684\u4e86\u89e3\u548c\u7406\u89e3\u3002 3 JS\u4ee3\u7801\u76f8\u4fe1\u5b66\u4e60Node.js\u7684\u540c\u5b66\u90fd\u6ca1\u4ec0\u4e48\u95ee\u9898\u3002 \u5176\u5b83\u8d44\u6e90 \u00b6 \u4e2a\u4eba\u535a\u5ba2 csdn https://blog.csdn.net/THEANARKH \u77e5\u4e4e https://www.zhihu.com/people/theanarkh github https://github.com/theanarkh \u9605\u8bfbNode.js\u6e90\u7801\u65f6\uff0c\u6240\u7528\u5230\u7684\u57fa\u7840\u77e5\u8bc6\u3001\u6240\u4f5c\u79ef\u7d2f\u548c\u8bb0\u5f55\u51e0\u4e4e\u90fd\u5728\u4e0a\u9762\u7684\u535a\u5ba2\u4e2d\u3002 \u5982\u679c\u4f60\u6709\u4efb\u4f55\u95ee\u9898\u53ef\u4ee5\u5230 https://github.com/theanarkh/understand-nodejs \u63d0issue\u6216\u8005\u8054\u7cfb\u6211\u3002","title":"\u524d\u8a00"},{"location":"chapter00-%E5%89%8D%E8%A8%80/#_1","text":"\u6211\u5f88\u559c\u6b22JS\u8fd9\u95e8\u8bed\u8a00\uff0c\u611f\u89c9\u5b83\u548cC\u8bed\u8a00\u4e00\u6837\uff0c\u5728C\u8bed\u8a00\u91cc\uff0c\u5f88\u591a\u4e1c\u897f\u90fd\u9700\u8981\u81ea\u5df1\u5b9e\u73b0\uff0c\u8ba9\u6211\u4eec\u53ef\u4ee5\u53d1\u6325\u65e0\u9650\u7684\u521b\u9020\u529b\u548c\u60f3\u8c61\u529b\u3002\u5728JS\u4e2d\uff0c\u867d\u7136\u5f88\u591a\u4e1c\u897f\u5728V8\u91cc\u5df2\u7ecf\u63d0\u4f9b\uff0c\u4f46\u662f\u7528JS\uff0c\u4f9d\u7136\u53ef\u4ee5\u521b\u9020\u5f88\u591a\u597d\u73a9\u7684\u4e1c\u897f\uff0c\u8fd8\u6709\u597d\u73a9\u7684\u5199\u6cd5\u3002\u53e6\u5916\uff0cJS\u5e94\u8be5\u6211\u89c1\u8fc7\u552f\u4e00\u7684\u4e00\u95e8\u6ca1\u6709\u5b9e\u73b0\u7f51\u7edc\u548c\u6587\u4ef6\u529f\u80fd\u7684\u8bed\u8a00\uff0c\u7f51\u7edc\u548c\u6587\u4ef6\uff0c\u662f\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u80fd\u529b\uff0c\u5bf9\u4e8e\u7a0b\u5e8f\u5458\u6765\u8bf4\uff0c\u4e5f\u662f\u5f88\u6838\u5fc3\u5f88\u57fa\u7840\u7684\u77e5\u8bc6\u3002\u5f88\u5e78\u8fd0\uff0cNode.js\u88ab\u521b\u9020\u51fa\u6765\u4e86\uff0cNode.js\u5728JS\u7684\u57fa\u7840\u4e0a\uff0c\u4f7f\u7528V8\u548cLibuv\u63d0\u4f9b\u7684\u80fd\u529b\uff0c\u6781\u5927\u5730\u62d3\u5c55\u3001\u4e30\u5bcc\u4e86JS\u7684\u80fd\u529b\uff0c\u5c24\u5176\u662f\u7f51\u7edc\u548c\u6587\u4ef6\uff0c\u8fd9\u6837\u6211\u5c31\u4e0d\u4ec5\u53ef\u4ee5\u4f7f\u7528JS\uff0c\u8fd8\u53ef\u4ee5\u4f7f\u7528\u7f51\u7edc\u3001\u6587\u4ef6\u7b49\u529f\u80fd\uff0c\u8fd9\u662f\u6211\u9010\u6e10\u8f6c\u5411Node.js\u65b9\u5411\u7684\u539f\u56e0\u4e4b\u4e00\uff0c\u4e5f\u662f\u6211\u5f00\u59cb\u7814\u7a76Node.js\u6e90\u7801\u7684\u539f\u56e0\u4e4b\u4e00\u3002\u867d\u7136Node.js\u6ee1\u8db3\u4e86\u6211\u559c\u597d\u548c\u6280\u672f\u4e0a\u7684\u9700\u6c42\uff0c\u4e0d\u8fc7\u4e00\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u6211\u5e76\u6ca1\u6709\u5168\u8eab\u5fc3\u5730\u6295\u5165\u4ee3\u7801\u7684\u7814\u7a76\uff0c\u53ea\u662f\u5076\u5c14\u4f1a\u770b\u4e00\u4e0b\u67d0\u4e9b\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u771f\u6b63\u7684\u5f00\u59cb\uff0c\u662f\u4e3a\u4e86\u505a\u300aNode.js\u662f\u5982\u4f55\u5229\u7528Libuv\u5b9e\u73b0\u4e8b\u4ef6\u5faa\u73af\u548c\u5f02\u6b65\u300b\u7684\u5206\u4eab\uff0c\u4ece\u90a3\u65f6\u5019\u8d77\uff0c\u5927\u90e8\u5206\u4e1a\u4f59\u65f6\u95f4\u548c\u7cbe\u529b\u90fd\u6295\u5165\u6e90\u7801\u7684\u7814\u7a76\u3002 \u6211\u9996\u5148\u4eceLibuv\u5f00\u59cb\u7814\u7a76\uff0c\u56e0\u4e3aLibuv\u662fNode.js\u7684\u6838\u5fc3\u4e4b\u4e00\u3002\u7531\u4e8e\u66fe\u7ecf\u7814\u7a76\u8fc7\u4e00\u4e9bLinux\u7684\u6e90\u7801\uff0c\u4e5f\u4e00\u76f4\u5728\u5b66\u4e60\u64cd\u4f5c\u7cfb\u7edf\u7684\u4e00\u4e9b\u539f\u7406\u548c\u5b9e\u73b0\uff0c\u6240\u4ee5\u5728\u9605\u8bfbLibuv\u7684\u65f6\u5019\uff0c\u7b97\u662f\u6ca1\u6709\u9047\u5230\u592a\u5927\u7684\u56f0\u96be\uff0cC\u8bed\u8a00\u51fd\u6570\u7684\u4f7f\u7528\u548c\u539f\u7406\uff0c\u57fa\u672c\u90fd\u53ef\u4ee5\u770b\u660e\u767d\uff0c\u91cd\u70b9\u5728\u4e8e\u9700\u8981\u628a\u5404\u4e2a\u903b\u8f91\u634b\u6e05\u695a\u3002\u6211\u4f7f\u7528\u7684\u65b9\u6cd5\u5c31\u662f\u6ce8\u91ca\u548c\u753b\u56fe\uff0c\u6211\u4e2a\u4eba\u6bd4\u8f83\u559c\u6b22\u5199\u6ce8\u91ca\u3002\u867d\u7136\u8bf4\u4ee3\u7801\u662f\u6700\u597d\u7684\u6ce8\u91ca\uff0c\u4f46\u662f\u6211\u8fd8\u662f\u613f\u610f\u82b1\u65f6\u95f4\u7528\u6ce8\u91ca\u53bb\u628a\u4ee3\u7801\u7684\u80cc\u666f\u548c\u610f\u4e49\u9610\u8ff0\u4e00\u4e0b\uff0c\u800c\u4e14\u6ce8\u91ca\u4f1a\u8ba9\u5927\u90e8\u5206\u4eba\u66f4\u5feb\u5730\u80fd\u8bfb\u61c2\u4ee3\u7801\u7684\u542b\u4e49\u3002\u8bfbLibuv\u7684\u65f6\u5019\uff0c\u4e5f\u7a7f\u63d2\u5730\u8bfb\u4e86\u4e00\u4e9bJS\u548cC++\u5c42\u7684\u4ee3\u7801\u3002\u6211\u9605\u8bfbNode.js\u6e90\u7801\u7684\u65b9\u5f0f\u662f\uff0c\u9009\u62e9\u4e00\u4e2a\u6a21\u5757\uff0c\u5782\u76f4\u5730\u4eceJS\u5c42\u5206\u6790\u5230C++\u5c42\uff0c\u7136\u540e\u5230Libuv\u5c42\u3002 \u8bfb\u5b8cLibuv\uff0c\u63a5\u4e0b\u6765\u8bfb\u7684\u662fJS\u5c42\u7684\u4ee3\u7801\uff0cJS\u867d\u7136\u5bb9\u6613\u770b\u61c2\uff0c\u4f46\u662fJS\u5c42\u7684\u4ee3\u7801\u975e\u5e38\u591a\uff0c\u800c\u4e14\u6211\u611f\u89c9\u903b\u8f91\u4e0a\u4e5f\u975e\u5e38\u7ed5\uff0c\u6240\u4ee5\u81f3\u4eca\uff0c\u6211\u8fd8\u6709\u5f88\u591a\u6ca1\u6709\u7ec6\u8bfb\uff0c\u8fd9\u4e2a\u4f5c\u4e3a\u540e\u7eed\u7684\u8ba1\u5212\u3002Node.js\u4e2d\uff0cC++\u7b97\u662f\u80f6\u6c34\u5c42\uff0c\u5f88\u591a\u65f6\u5019\uff0c\u4e0d\u4f1aC++\uff0c\u5176\u5b9e\u4e5f\u4e0d\u5f71\u54cdNode.js\u6e90\u7801\u7684\u9605\u8bfb\uff0c\u56e0\u4e3aC++\u5f88\u591a\u65f6\u5019\uff0c\u53ea\u662f\u4e00\u79cd\u900f\u4f20\u7684\u529f\u80fd\uff0c\u5b83\u628aJS\u5c42\u7684\u8bf7\u6c42\uff0c\u901a\u8fc7V8\uff0c\u4f20\u7ed9Libuv\uff0c\u7136\u540e\u518d\u53cd\u8fc7\u6765\uff0c\u6240\u4ee5C++\u5c42\u6211\u662f\u653e\u5230\u6700\u540e\u624d\u7ec6\u8bfb\u3002C++\u5c42\u6211\u89c9\u5f97\u662f\u6700\u96be\u7684\uff0c\u8fd9\u65f6\u5019\uff0c\u6211\u53c8\u4e0d\u5f97\u4e0d\u5f00\u59cb\u8bfbV8\u7684\u6e90\u7801\u4e86\uff0c\u7406\u89e3V8\u975e\u5e38\u96be\uff0c\u6211\u9009\u53d6\u7684\u51e0\u4e4e\u662f\u6700\u65e9\u7684\u7248\u672c0.1.5\uff0c\u7136\u540e\u7ed3\u54088.x\u7248\u672c\u3002\u901a\u8fc7\u65e9\u671f\u7248\u672c\uff0c\u5148\u5b66\u4e60V8\u7684\u5927\u6982\u539f\u7406\u548c\u4e00\u4e9b\u65e9\u671f\u5b9e\u73b0\u4e0a\u7684\u7ec6\u8282\u3002\u56e0\u4e3a\u540e\u7eed\u7684\u7248\u672c\u867d\u7136\u53d8\u5316\u5f88\u5927\uff0c\u4f46\u662f\u66f4\u591a\u53ea\u662f\u529f\u80fd\u7684\u589e\u5f3a\u548c\u4f18\u5316\uff0c\u6709\u5f88\u591a\u6838\u5fc3\u7684\u6982\u5ff5\u8fd8\u662f\u6ca1\u6709\u53d8\u5316\u7684\uff0c\u8fd9\u662f\u6211\u9009\u53d6\u65e9\u671f\u7248\u672c\u7684\u539f\u56e0\uff0c\u907f\u514d\u4e00\u5f00\u59cb\u5c31\u9677\u5165\u65e0\u7a77\u65e0\u5c3d\u7684\u4ee3\u7801\u4e2d\uff0c\u8ff7\u5931\u4e86\u65b9\u5411\uff0c\u5931\u53bb\u4e86\u52a8\u529b\u3002\u4f46\u662f\u54ea\u6015\u662f\u65e9\u671f\u7684\u7248\u672c\uff0c\u6709\u5f88\u591a\u5185\u5bb9\u4f9d\u7136\u975e\u5e38\u590d\u6742\uff0c\u7ed3\u5408\u65b0\u7248\u672c\u662f\u56e0\u4e3a\u6709\u4e9b\u529f\u80fd\u5728\u65e9\u671f\u7248\u672c\u91cc\u6ca1\u6709\u5b9e\u73b0\uff0c\u8fd9\u65f6\u5019\u8981\u660e\u767d\u5b83\u7684\u539f\u7406\uff0c\u5c31\u53ea\u80fd\u770b\u65b0\u7248\u7684\u4ee3\u7801\uff0c\u6709\u4e86\u65e9\u671f\u7248\u672c\u7684\u7ecf\u9a8c\uff0c\u9605\u8bfb\u65b0\u7248\u7684\u4ee3\u7801\u4e5f\u6709\u4e00\u5b9a\u7684\u597d\u5904\uff0c\u591a\u5c11\u4e5f\u77e5\u9053\u4e86\u4e00\u4e9b\u9605\u8bfb\u6280\u5de7\u3002 Node.js\u7684\u5927\u90e8\u5206\u4ee3\u7801\u90fd\u5728C++\u548cJS\u5c42\uff0c\u6240\u4ee5\u76ee\u524d\u4ecd\u7136\u662f\u5728\u4e0d\u65ad\u5730\u9605\u8bfb\u8fd9\u4e24\u5c42\u7684\u4ee3\u7801\u3002\u8fd8\u662f\u6309\u7167\u6a21\u5757\u5782\u76f4\u5206\u6790\u3002\u9605\u8bfbNode.js\u4ee3\u7801\uff0c\u8ba9\u6211\u66f4\u4e86\u89e3Node.js\u7684\u539f\u7406\uff0c\u4e5f\u66f4\u4e86\u89e3JS\u3002\u4e0d\u8fc7\u4ee3\u7801\u91cf\u975e\u5e38\u5927\uff0c\u9700\u8981\u6e90\u6e90\u4e0d\u65ad\u7684\u65f6\u95f4\u548c\u7cbe\u529b\u6295\u5165\u3002\u4f46\u662f\u505a\u6280\u672f\uff0c\u77e5\u5176\u7136\u77e5\u5176\u6240\u4ee5\u7136\u7684\u611f\u89c9\u662f\u975e\u5e38\u7f8e\u5999\u7684\uff0c\u4f60\u9760\u7740\u4e00\u95e8\u6280\u672f\u8c0b\u751f\uff0c\u5374\u5bf9\u5b83\u77e5\u4e4b\u751a\u5c11\uff0c\u8fd9\u79cd\u611f\u89c9\u5e76\u4e0d\u597d\u3002\u9605\u8bfb\u6e90\u7801\uff0c\u867d\u7136\u4e0d\u4f1a\u4e3a\u4f60\u5e26\u6765\u76f4\u63a5\u7684\u3001\u8fc5\u901f\u7684\u6536\u76ca\uff0c\u4f46\u662f\u6709\u51e0\u4e2a\u597d\u5904\u662f\u5fc5\u7136\u7684\u3002\u7b2c\u4e00\u662f\u5b83\u4f1a\u51b3\u5b9a\u4f60\u7684\u9ad8\u5ea6\uff0c\u7b2c\u4e8c\u4f60\u5199\u4ee3\u7801\u7684\u65f6\u5019\uff0c\u4f60\u770b\u5230\u7684\u4e0d\u518d\u662f\u4e00\u4e9b\u51b0\u51b7\u51b7\u3001\u65e0\u751f\u547d\u7684\u5b57\u7b26\u3002\u8fd9\u53ef\u80fd\u6709\u70b9\u5938\u5f20\uff0c\u4f46\u662f\u4f60\u4e86\u89e3\u4e86\u6280\u672f\u7684\u539f\u7406\uff0c\u4f60\u5728\u4f7f\u7528\u6280\u672f\u7684\u65f6\u5019\uff0c\u7684\u786e\u4f1a\u6709\u4e0d\u540c\u7684\u4f53\u9a8c\uff0c\u4f60\u7684\u601d\u7ef4\u4e5f\u4f1a\u6709\u4e86\u66f4\u591a\u7684\u53d8\u5316\u3002\u7b2c\u4e09\u662f\u63d0\u9ad8\u4e86\u4f60\u7684\u5b66\u4e60\u80fd\u529b\uff0c\u5f53\u4f60\u5bf9\u5e95\u5c42\u539f\u7406\u6709\u4e86\u66f4\u591a\u7684\u4e86\u89e3\u548c\u7406\u89e3\uff0c\u4f60\u5728\u5b66\u4e60\u5176\u5b83\u6280\u672f\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u66f4\u5feb\u5730\u5b66\u4f1a\uff0c\u6bd4\u5982\u4f60\u4e86\u89e3\u4e86epoll\u7684\u539f\u7406\uff0c\u90a3\u4f60\u770bNginx\u3001Redis\u3001Libuv\u7b49\u6e90\u7801\u7684\u65f6\u5019\uff0c\u5173\u4e8e\u4e8b\u4ef6\u9a71\u52a8\u7684\u903b\u8f91\uff0c\u57fa\u672c\u4e0a\u5f88\u5feb\u5c31\u80fd\u770b\u61c2\u3002\u5f88\u9ad8\u5174\u6709\u8fd9\u4e9b\u7ecf\u5386\uff0c\u4e5f\u6295\u5165\u4e86\u5f88\u591a\u65f6\u95f4\u548c\u7ecf\u7cbe\u529b\uff0c\u5e0c\u671b\u4ee5\u540e\u5bf9Node.js\u6709\u66f4\u591a\u7684\u7406\u89e3\u548c\u4e86\u89e3\uff0c\u4e5f\u5e0c\u671b\u5728Node.js\u65b9\u5411\u6709\u66f4\u591a\u7684\u5b9e\u8df5\u3002","title":"\u524d\u8a00"},{"location":"chapter00-%E5%89%8D%E8%A8%80/#_2","text":"\u9605\u8bfbNode.js\u6e90\u7801\u7684\u521d\u8877\u662f\u8ba9\u81ea\u5df1\u6df1\u5165\u7406\u89e3Node.js\u7684\u539f\u7406\uff0c\u4f46\u662f\u6211\u53d1\u73b0\u6709\u5f88\u591a\u540c\u5b66\u5bf9Node.js\u539f\u7406\u4e5f\u975e\u5e38\u611f\u5174\u8da3\uff0c\u56e0\u4e3a\u4e1a\u4f59\u65f6\u95f4\u91cc\u4e5f\u4e00\u76f4\u5728\u5199\u4e00\u4e9b\u5173\u4e8eNode.js\u6e90\u7801\u5206\u6790\u7684\u6587\u7ae0\uff08\u57fa\u4e8eNode.js V10\u548cV14\uff09\uff0c\u6240\u4ee5\u5c31\u6253\u7b97\u628a\u8fd9\u4e9b\u5185\u5bb9\u6574\u7406\u6210\u4e00\u672c\u6709\u4f53\u7cfb\u7684\u4e66\uff0c\u8ba9\u611f\u5174\u8da3\u7684\u540c\u5b66\u80fd\u7cfb\u7edf\u5730\u53bb\u4e86\u89e3\u548c\u7406\u89e3Node.js\u7684\u539f\u7406\u3002\u4e0d\u8fc7\u6211\u66f4\u5e0c\u671b\u7684\u662f\uff0c\u8bfb\u8005\u4ece\u4e66\u4e2d\u4e0d\u4ec5\u5b66\u5230Node.js\u7684\u77e5\u8bc6\uff0c\u800c\u4e14\u4e5f\u5b66\u5230\u5982\u4f55\u9605\u8bfbNode.js\u6e90\u7801\uff0c\u53ef\u4ee5\u81ea\u5df1\u72ec\u7acb\u5b8c\u6210\u6e90\u7801\u7684\u7814\u7a76\u3002\u4e5f\u5e0c\u671b\u66f4\u591a\u540c\u5b66\u5206\u4eab\u81ea\u5df1\u7684\u5fc3\u5f97\u3002\u672c\u4e66\u4e0d\u662fNode.js\u7684\u5168\u90e8\uff0c\u4f46\u662f\u5c3d\u91cf\u53bb\u8bb2\u5f97\u66f4\u591a\uff0c\u6e90\u7801\u975e\u5e38\u591a\uff0c\u9519\u7efc\u590d\u6742\uff0c\u7406\u89e3\u4e0a\u53ef\u80fd\u6709\u4e0d\u5bf9\u4e4b\u5904\uff0c\u6b22\u8fce\u4ea4\u6d41\u3002\u56e0\u4e3a\u770b\u8fc7Linux\u65e9\u671f\u5185\u6838\uff080.11\u548c1.2.13\uff09\u548c\u65e9\u671fV8\uff080.1.5\uff09\u7684\u4e00\u4e9b\u5b9e\u73b0\uff0c\u6587\u7ae0\u4f1a\u5f15\u7528\u5176\u4e2d\u7684\u4e00\u4e9b\u4ee3\u7801\uff0c\u76ee\u7684\u5728\u4e8e\u8ba9\u8bfb\u8005\u53ef\u4ee5\u66f4\u4e86\u89e3\u4e00\u4e2a\u77e5\u8bc6\u70b9\u7684\u5927\u81f4\u5b9e\u73b0\u539f\u7406\uff0c\u5982\u679c\u8bfb\u8005\u6709\u5174\u8da3\uff0c\u53ef\u4ee5\u81ea\u884c\u9605\u8bfb\u76f8\u5173\u4ee3\u7801\u3002","title":"\u672c\u4e66\u7684\u76ee\u7684"},{"location":"chapter00-%E5%89%8D%E8%A8%80/#_3","text":"\u672c\u4e66\u5171\u5206\u4e3a\u4e8c\u5341\u4e8c\u7ae0\uff0c\u8bb2\u89e3\u7684\u4ee3\u7801\u90fd\u662f\u57fa\u4e8eLinux\u7cfb\u7edf\u7684\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u7684\u7ec4\u6210\u548c\u6574\u4f53\u7684\u5de5\u4f5c\u539f\u7406\uff0c\u53e6\u5916\u5206\u6790\u4e86Node.js\u542f\u52a8\u7684\u8fc7\u7a0b\uff0c\u6700\u540e\u4ecb\u7ecd\u4e86\u670d\u52a1\u5668\u67b6\u6784\u7684\u6f14\u53d8\u548cNode.js\u7684\u6240\u9009\u53d6\u7684\u67b6\u6784\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2d\u7684\u57fa\u7840\u6570\u636e\u7ed3\u6784\u548c\u901a\u7528\u7684\u903b\u8f91\uff0c\u5728\u540e\u9762\u7684\u7ae0\u8282\u4f1a\u7528\u5230\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Libuv\u7684\u4e8b\u4ef6\u5faa\u73af\uff0c\u8fd9\u662fNode.js\u7684\u6838\u5fc3\u6240\u5728,\u672c\u7ae0\u5177\u4f53\u4ecb\u7ecd\u4e86\u4e8b\u4ef6\u5faa\u73af\u4e2d\u6bcf\u4e2a\u9636\u6bb5\u7684\u5b9e\u73b0\u3002 \u4e3b\u8981\u5206\u6790\u4e86Libuv\u4e2d\u7ebf\u7a0b\u6c60\u7684\u5b9e\u73b0\uff0cLibuv\u7ebf\u7a0b\u6c60\u5bf9Node.js\u6765\u8bf4\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0cNode.js\u4e2d\u5f88\u591a\u6a21\u5757\u90fd\u9700\u8981\u4f7f\u7528\u7ebf\u7a0b\u6c60\uff0c\u5305\u62eccrypto\u3001fs\u3001dns\u7b49\u3002\u5982\u679c\u6ca1\u6709\u7ebf\u7a0b\u6c60\uff0cNode.js\u7684\u529f\u80fd\u5c06\u4f1a\u5927\u6253\u6298\u6263\u3002\u540c\u65f6\u5206\u6790\u4e86Libuv\u4e2d\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u7684\u901a\u4fe1\u673a\u5236\u3002\u540c\u6837\u9002\u5408\u5176\u5b83\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u3002 \u4e3b\u8981\u5206\u6790\u4e86Libuv\u4e2d\u6d41\u7684\u5b9e\u73b0\uff0c\u6d41\u5728Node.js\u6e90\u7801\u4e2d\u5f88\u591a\u5730\u65b9\u90fd\u7528\u5230\uff0c\u53ef\u4ee5\u8bf4\u662f\u975e\u5e38\u6838\u5fc3\u7684\u6982\u5ff5\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2dC++\u5c42\u7684\u4e00\u4e9b\u91cd\u8981\u6a21\u5757\u548c\u901a\u7528\u903b\u8f91\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u7684\u4fe1\u53f7\u5904\u7406\u673a\u5236\uff0c\u4fe1\u53f7\u662f\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u53e6\u4e00\u79cd\u65b9\u5f0f\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u7684dns\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u5305\u62eccares\u7684\u4f7f\u7528\u548c\u539f\u7406\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2dpipe\u6a21\u5757\uff08Unix\u57df\uff09\u7684\u5b9e\u73b0\u548c\u4f7f\u7528\uff0cUnix\u57df\u662f\u5b9e\u73b0\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u65b9\u5f0f\uff0c\u5b83\u89e3\u51b3\u4e86\u6ca1\u6709\u7ee7\u627f\u7684\u8fdb\u7a0b\u65e0\u6cd5\u901a\u4fe1\u7684\u95ee\u9898\u3002\u800c\u4e14\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u6781\u5927\u5730\u589e\u5f3a\u4e86Node.js\u7684\u80fd\u529b\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2d\u5b9a\u65f6\u5668\u6a21\u5757\u7684\u5b9e\u73b0\u3002\u5b9a\u65f6\u5668\u662f\u5b9a\u65f6\u5904\u7406\u4efb\u52a1\u7684\u5229\u5668\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js setImmediate\u548cnextTick\u7684\u5b9e\u73b0\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2d\u6587\u4ef6\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u6587\u4ef6\u64cd\u4f5c\u662f\u6211\u4eec\u7ecf\u5e38\u4f1a\u7528\u5230\u7684\u529f\u80fd\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2d\u8fdb\u7a0b\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u591a\u8fdb\u7a0b\u4f7f\u5f97Node.js\u53ef\u4ee5\u5229\u7528\u591a\u6838\u80fd\u529b\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2d\u7ebf\u7a0b\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u591a\u8fdb\u7a0b\u548c\u591a\u7ebf\u7a0b\u6709\u7c7b\u4f3c\u7684\u529f\u80fd\u4f46\u662f\u4e5f\u6709\u4e00\u4e9b\u5dee\u5f02\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2dcluster\u6a21\u5757\u7684\u4f7f\u7528\u548c\u5b9e\u73b0\u539f\u7406\uff0ccluster\u6a21\u5757\u5c01\u88c5\u4e86\u591a\u8fdb\u7a0b\u80fd\u529b\uff0c\u4f7f\u5f97Node.j\u662f\u53ef\u4ee5\u4f7f\u7528\u591a\u8fdb\u7a0b\u7684\u670d\u52a1\u5668\u67b6\u6784\uff0c\u5229\u7528\u4e86\u591a\u6838\u7684\u80fd\u529b\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2dUDP\u7684\u5b9e\u73b0\u548c\u76f8\u5173\u5185\u5bb9\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2dTCP\u6a21\u5757\u7684\u5b9e\u73b0\uff0cTCP\u662fNode.js\u7684\u6838\u5fc3\u6a21\u5757\uff0c\u6211\u4eec\u5e38\u7528\u7684HTTP\uff0cHTTPS\u90fd\u662f\u57fa\u4e8enet\u6a21\u5757\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86HTTP\u6a21\u5757\u7684\u5b9e\u73b0\u4ee5\u53caHTTP\u534f\u8bae\u7684\u4e00\u4e9b\u539f\u7406\u3002 \u4e3b\u8981\u5206\u6790\u4e86Node.js\u4e2d\u5404\u79cd\u6a21\u5757\u52a0\u8f7d\u7684\u539f\u7406\uff0c\u6df1\u5165\u7406\u89e3Node.js\u7684require\u51fd\u6570\u6240\u505a\u7684\u4e8b\u60c5\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86\u4e00\u4e9b\u62d3\u5c55Node.js\u7684\u65b9\u6cd5\uff0c\u4f7f\u7528Node.js\uff0c\u62d3\u5c55Node.js\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86JS\u5c42Stream\u7684\u5b9e\u73b0\uff0cStream\u6a21\u5757\u7684\u903b\u8f91\u5f88\u7ed5\uff0c\u5927\u6982\u8bb2\u89e3\u4e86\u4e00\u4e0b\u3002 \u4e3b\u8981\u4ecb\u7ecd\u4e86Node.js\u4e2devent\u6a21\u5757\u7684\u5b9e\u73b0\uff0cevent\u6a21\u5757\u867d\u7136\u7b80\u5355\uff0c\u4f46\u662f\u662fNode.js\u7684\u6838\u5fc3\u6a21\u5757\u3002","title":"\u672c\u4e66\u7ed3\u6784"},{"location":"chapter00-%E5%89%8D%E8%A8%80/#_4","text":"\u672c\u4e66\u9762\u5411\u6709\u4e00\u5b9aNode.js\u4f7f\u7528\u7ecf\u9a8c\u5e76\u5bf9Node.js\u539f\u7406\u611f\u5174\u8da3\u7684\u540c\u5b66\uff0c\u56e0\u4e3a\u672c\u4e66\u662fNode.js\u6e90\u7801\u7684\u89d2\u5ea6\u53bb\u5206\u6790Node.js\u7684\u539f\u7406\uff0c\u5176\u4e2d\u90e8\u5206\u662fC\u3001C++\uff0c\u6240\u4ee5\u9700\u8981\u8bfb\u8005\u6709\u4e00\u5b9a\u7684C\u3001C++\u57fa\u7840\uff0c\u53e6\u5916\uff0c\u6709\u4e00\u5b9a\u7684\u64cd\u4f5c\u7cfb\u7edf\u3001\u8ba1\u7b97\u673a\u7f51\u7edc\u3001V8\u57fa\u7840\u4f1a\u66f4\u597d\u3002","title":"\u9762\u5bf9\u7684\u8bfb\u8005"},{"location":"chapter00-%E5%89%8D%E8%A8%80/#_5","text":"\u5efa\u8bae\u9996\u5148\u9605\u8bfb\u524d\u9762\u51e0\u79cd\u57fa\u7840\u548c\u901a\u7528\u7684\u5185\u5bb9\uff0c\u7136\u540e\u518d\u9605\u8bfb\u5355\u4e2a\u6a21\u5757\u7684\u5b9e\u73b0\uff0c\u6700\u540e\u6709\u5174\u8da3\u7684\u8bdd\uff0c\u518d\u9605\u8bfb\u5982\u4f55\u62d3\u5c55Node.js\u7ae0\u8282\u3002\u5982\u679c\u4f60\u5df2\u7ecf\u6bd4\u8f83\u719f\u6089Node.js\uff0c\u53ea\u662f\u5bf9\u67d0\u4e2a\u6a21\u5757\u6216\u5185\u5bb9\u6bd4\u8f83\u611f\u5174\u8da3\uff0c\u5219\u53ef\u4ee5\u76f4\u63a5\u9605\u8bfb\u67d0\u4e2a\u7ae0\u8282\u3002\u521a\u5f00\u59cb\u9605\u8bfbNode.js\u6e90\u7801\u65f6\uff0c\u9009\u53d6\u7684\u662fV10.x\u7684\u7248\u672c\uff0c\u540e\u6765Node.js\u5df2\u7ecf\u66f4\u65b0\u5230\u4e86V14\uff0c\u6240\u4ee5\u4e66\u4e2d\u7684\u4ee3\u7801\u6709\u7684\u662fV10\u6709\u7684\u662fV14\u7684\u3002Libuv\u662fV1.23\u3002\u53ef\u4ee5\u5230\u6211\u7684github\u4e0a\u83b7\u53d6\u3002","title":"\u9605\u8bfb\u5efa\u8bae"},{"location":"chapter00-%E5%89%8D%E8%A8%80/#_6","text":"Node.js\u7684\u6e90\u7801\u7531JS\u3001C++\u3001C\u7ec4\u6210\u3002 1 Libuv\u662fC\u8bed\u8a00\u7f16\u5199\u3002\u7406\u89e3Libuv\u9664\u4e86\u9700\u8981\u4e86\u89e3C\u8bed\u6cd5\u5916\uff0c\u66f4\u591a\u7684\u662f\u5bf9\u64cd\u4f5c\u7cfb\u7edf\u548c\u7f51\u7edc\u7684\u7406\u89e3\uff0c\u6709\u4e9b\u7ecf\u5178\u7684\u4e66\u7c4d\u53ef\u4ee5\u53c2\u8003\uff0c\u6bd4\u5982\u300aUnix\u7f51\u7edc\u7f16\u7a0b\u300b1,2\u4e24\u518c\uff0c\u300aLinux\u7cfb\u7edf\u7f16\u7a0b\u624b\u518c\u300b\u4e0a\u4e0b\u4e24\u518c\uff0c\u300aTCP/IP\u6743\u5a01\u6307\u5357\u300b\u7b49\u7b49\u3002\u8fd8\u6709Linux\u7684API\u6587\u6863\u4ee5\u53ca\u7f51\u4e0a\u4f18\u79c0\u7684\u6587\u7ae0\u90fd\u53ef\u4ee5\u53c2\u8003\u4e00\u4e0b\u3002 2 C++\u4e3b\u8981\u662f\u5229\u7528V8\u63d0\u4f9b\u7684\u80fd\u529b\u5bf9JS\u8fdb\u884c\u62d3\u5c55\uff0c\u4e5f\u6709\u4e00\u90e8\u5206\u529f\u80fd\u4f7f\u7528C++\u5b9e\u73b0\uff0c\u603b\u7684\u6765\u8bf4C++\u7684\u4f5c\u7528\u66f4\u591a\u662f\u80f6\u6c34\u5c42\uff0c\u5229\u7528V8\u4f5c\u4e3a\u6865\u6881\uff0c\u8fde\u63a5Libuv\u548cJS\u3002\u4e0d\u4f1aC++\uff0c\u4e5f\u4e0d\u5b8c\u5168\u5f71\u54cd\u6e90\u7801\u7684\u9605\u8bfb\uff0c\u4f46\u662f\u4f1aC++\u4f1a\u66f4\u597d\u3002\u9605\u8bfbC++\u5c42\u4ee3\u7801\uff0c\u9664\u4e86\u8bed\u6cd5\u5916\uff0c\u8fd8\u9700\u8981\u5bf9V8\u7684\u6982\u5ff5\u548c\u4f7f\u7528\u6709\u4e00\u5b9a\u7684\u4e86\u89e3\u548c\u7406\u89e3\u3002 3 JS\u4ee3\u7801\u76f8\u4fe1\u5b66\u4e60Node.js\u7684\u540c\u5b66\u90fd\u6ca1\u4ec0\u4e48\u95ee\u9898\u3002","title":"\u6e90\u7801\u9605\u8bfb\u5efa\u8bae"},{"location":"chapter00-%E5%89%8D%E8%A8%80/#_7","text":"\u4e2a\u4eba\u535a\u5ba2 csdn https://blog.csdn.net/THEANARKH \u77e5\u4e4e https://www.zhihu.com/people/theanarkh github https://github.com/theanarkh \u9605\u8bfbNode.js\u6e90\u7801\u65f6\uff0c\u6240\u7528\u5230\u7684\u57fa\u7840\u77e5\u8bc6\u3001\u6240\u4f5c\u79ef\u7d2f\u548c\u8bb0\u5f55\u51e0\u4e4e\u90fd\u5728\u4e0a\u9762\u7684\u535a\u5ba2\u4e2d\u3002 \u5982\u679c\u4f60\u6709\u4efb\u4f55\u95ee\u9898\u53ef\u4ee5\u5230 https://github.com/theanarkh/understand-nodejs \u63d0issue\u6216\u8005\u8054\u7cfb\u6211\u3002","title":"\u5176\u5b83\u8d44\u6e90"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/","text":"\u7b2c\u4e00\u7ae0 Node.js\u7ec4\u6210\u548c\u539f\u7406 \u00b6 1.1 Node.js\u7b80\u4ecb \u00b6 Node.js\u662f\u57fa\u4e8e\u4e8b\u4ef6\u9a71\u52a8\u7684\u5355\u8fdb\u7a0b\u5355\u7ebf\u7a0b\u5e94\u7528\uff0c\u5355\u7ebf\u7a0b\u5177\u4f53\u4f53\u73b0\u5728Node.js\u5728\u5355\u4e2a\u7ebf\u7a0b\u4e2d\u7ef4\u62a4\u4e86\u4e00\u7cfb\u5217\u4efb\u52a1\uff0c\u7136\u540e\u5728\u4e8b\u4ef6\u5faa\u73af\u4e2d\u4e0d\u65ad\u6d88\u8d39\u4efb\u52a1\u961f\u5217\u4e2d\u7684\u8282\u70b9\uff0c\u53c8\u4e0d\u65ad\u4ea7\u751f\u65b0\u7684\u4efb\u52a1\uff0c\u5728\u4efb\u52a1\u7684\u4ea7\u751f\u548c\u6d88\u8d39\u4e2d\u4e0d\u65ad\u9a71\u52a8\u7740Node.js\u7684\u6267\u884c\u3002\u4ece\u53e6\u5916\u4e00\u4e2a\u89d2\u5ea6\u6765\u8bf4\uff0cNode.js\u53c8\u53ef\u4ee5\u8bf4\u662f\u591a\u7ebf\u7a0b\u7684\uff0c\u56e0\u4e3aNode.js\u5e95\u5c42\u4e5f\u7ef4\u62a4\u4e86\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u8be5\u7ebf\u7a0b\u6c60\u4e3b\u8981\u7528\u4e8e\u5904\u7406\u4e00\u4e9b\u6587\u4ef6IO\u3001DNS\u3001CPU\u8ba1\u7b97\u7b49\u4efb\u52a1\u3002 Node.js\u4e3b\u8981\u7531V8\u3001Libuv\uff0c\u8fd8\u6709\u4e00\u4e9b\u5176\u5b83\u7684\u7b2c\u4e09\u65b9\u6a21\u5757\u7ec4\u6210\uff08cares\u5f02\u6b65DNS\u89e3\u6790\u5e93\u3001HTTP\u89e3\u6790\u5668\u3001HTTP2\u89e3\u6790\u5668\uff0c\u538b\u7f29\u5e93\u3001\u52a0\u89e3\u5bc6\u5e93\u7b49\uff09\u3002Node.js\u6e90\u7801\u5206\u4e3a\u4e09\u5c42\uff0c\u5206\u522b\u662fJS\u3001C++\u3001C\uff0cLibuv\u662f\u4f7f\u7528C\u8bed\u8a00\u7f16\u5199\uff0cC++\u5c42\u4e3b\u8981\u662f\u901a\u8fc7V8\u4e3aJS\u5c42\u63d0\u4f9b\u548c\u5e95\u5c42\u4ea4\u4e92\u7684\u80fd\u529b\uff0cC++\u5c42\u4e5f\u5b9e\u73b0\u4e86\u90e8\u5206\u529f\u80fd\uff0cJS\u5c42\u662f\u9762\u5411\u7528\u6237\u7684\uff0c\u4e3a\u7528\u6237\u63d0\u4f9b\u8c03\u7528\u5e95\u5c42\u7684\u63a5\u53e3\u3002 1.1.1 JS\u5f15\u64ceV8 \u00b6 Node.js\u662f\u57fa\u4e8eV8\u7684JS\u8fd0\u884c\u65f6\uff0c\u5b83\u5229\u7528V8\u63d0\u4f9b\u7684\u80fd\u529b\uff0c\u6781\u5927\u5730\u62d3\u5c55\u4e86JS\u7684\u80fd\u529b\u3002\u8fd9\u79cd\u62d3\u5c55\u4e0d\u662f\u4e3aJS\u589e\u52a0\u4e86\u65b0\u7684\u8bed\u8a00\u7279\u6027\uff0c\u800c\u662f\u62d3\u5c55\u4e86\u529f\u80fd\u6a21\u5757\uff0c\u6bd4\u5982\u5728\u524d\u7aef\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528Date\u8fd9\u4e2a\u51fd\u6570\uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u80fd\u4f7f\u7528TCP\u8fd9\u4e2a\u51fd\u6570\uff0c\u56e0\u4e3aJS\u4e2d\u5e76\u6ca1\u6709\u5185\u7f6e\u8fd9\u4e2a\u51fd\u6570\u3002\u800c\u5728Node.js\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528TCP\uff0c\u8fd9\u5c31\u662fNode.js\u505a\u7684\u4e8b\u60c5\uff0c\u8ba9\u7528\u6237\u53ef\u4ee5\u4f7f\u7528JS\u4e2d\u672c\u6765\u4e0d\u5b58\u5728\u7684\u529f\u80fd\uff0c\u6bd4\u5982\u6587\u4ef6\u3001\u7f51\u7edc\u3002Node.js\u4e2d\u6700\u6838\u5fc3\u7684\u90e8\u5206\u662fLibuv\u548cV8\uff0cV8\u4e0d\u4ec5\u8d1f\u8d23\u6267\u884cJS\uff0c\u8fd8\u652f\u6301\u81ea\u5b9a\u4e49\u7684\u62d3\u5c55\uff0c\u5b9e\u73b0\u4e86JS\u8c03\u7528C++\u548cC++\u8c03\u7528JS\u7684\u80fd\u529b\u3002\u6bd4\u5982\u6211\u4eec\u53ef\u4ee5\u5199\u4e00\u4e2aC++\u6a21\u5757\uff0c\u7136\u540e\u5728JS\u8c03\u7528\uff0cNode.js\u6b63\u662f\u5229\u7528\u4e86\u8fd9\u4e2a\u80fd\u529b\uff0c\u5b8c\u6210\u4e86\u529f\u80fd\u7684\u62d3\u5c55\u3002JS\u5c42\u8c03\u7528\u7684\u6240\u6709C\u3001C++\u6a21\u5757\u90fd\u662f\u901a\u8fc7V8\u6765\u5b8c\u6210\u7684\u3002 1.1.2 Libuv \u00b6 Libuv\u662fNode.js\u5e95\u5c42\u7684\u5f02\u6b65IO\u5e93\uff0c\u4f46\u5b83\u63d0\u4f9b\u7684\u529f\u80fd\u4e0d\u4ec5\u4ec5\u662fIO\uff0c\u8fd8\u5305\u62ec\u8fdb\u7a0b\u3001\u7ebf\u7a0b\u3001\u4fe1\u53f7\u3001\u5b9a\u65f6\u5668\u3001\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7b49\uff0c\u800c\u4e14Libuv\u62b9\u5e73\u4e86\u5404\u4e2a\u64cd\u4f5c\u7cfb\u7edf\u4e4b\u95f4\u7684\u5dee\u5f02\u3002Libuv\u63d0\u4f9b\u7684\u529f\u80fd\u5927\u6982\u5982\u4e0b \u2022 Full-featured event loop backed by epoll, kqueue, IOCP, event ports. \u2022 Asynchronous TCP and UDP sockets \u2022 Asynchronous DNS resolution \u2022 Asynchronous file and file system operations \u2022 File system events \u2022 ANSI escape code controlled TTY \u2022 IPC with socket sharing, using Unix domain sockets or named pipes (Windows) \u2022 Child processes \u2022 Thread pool \u2022 Signal handling \u2022 High resolution clock \u2022 Threading and synchronization primitives Libuv\u7684\u5b9e\u73b0\u662f\u4e00\u4e2a\u7ecf\u5178\u7684\u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u6a21\u578b\u3002Libuv\u5728\u6574\u4e2a\u751f\u547d\u5468\u671f\u4e2d\uff0c\u6bcf\u4e00\u8f6e\u5faa\u73af\u90fd\u4f1a\u5904\u7406\u6bcf\u4e2a\u9636\u6bb5\uff08phase\uff09\u7ef4\u62a4\u7684\u4efb\u52a1\u961f\u5217\uff0c\u7136\u540e\u9010\u4e2a\u6267\u884c\u4efb\u52a1\u961f\u5217\u4e2d\u8282\u70b9\u7684\u56de\u8c03\uff0c\u5728\u56de\u8c03\u4e2d\uff0c\u4e0d\u65ad\u751f\u4ea7\u65b0\u7684\u4efb\u52a1\uff0c\u4ece\u800c\u4e0d\u65ad\u9a71\u52a8Libuv\u3002\u4e0b\u662fLibuv\u7684\u6574\u4f53\u6267\u884c\u6d41\u7a0b \u4ece\u4e0a\u56fe\u4e2d\u6211\u4eec\u5927\u81f4\u4e86\u89e3\u5230\uff0cLibuv\u5206\u4e3a\u51e0\u4e2a\u9636\u6bb5\uff0c\u7136\u540e\u5728\u4e00\u4e2a\u5faa\u73af\u91cc\u4e0d\u65ad\u6267\u884c\u6bcf\u4e2a\u9636\u6bb5\u91cc\u7684\u4efb\u52a1\u3002\u4e0b\u9762\u6211\u4eec\u5177\u4f53\u770b\u4e00\u4e0b\u6bcf\u4e2a\u9636\u6bb5 \u66f4\u65b0\u5f53\u524d\u65f6\u95f4\uff0c\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\uff0cLibuv\u4f1a\u66f4\u65b0\u5f53\u524d\u65f6\u95f4\u5230\u53d8\u91cf\u4e2d\uff0c\u8fd9\u4e00\u8f6e\u5faa\u73af\u7684\u5269\u4e0b\u64cd\u4f5c\u53ef\u4ee5\u4f7f\u7528\u8fd9\u4e2a\u53d8\u91cf\u83b7\u53d6\u5f53\u524d\u65f6\u95f4\uff0c\u907f\u514d\u8fc7\u591a\u7684\u7cfb\u7edf\u8c03\u7528\u5f71\u54cd\u6027\u80fd\uff0c\u989d\u5916\u7684\u5f71\u54cd\u5c31\u662f\u65f6\u95f4\u4e0d\u662f\u90a3\u4e48\u7cbe\u786e\u3002\u4f46\u662f\u5728\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0cLibuv\u5728\u5fc5\u8981\u7684\u65f6\u5019\uff0c\u4f1a\u4e3b\u52a8\u66f4\u65b0\u8fd9\u4e2a\u65f6\u95f4\uff0c\u6bd4\u5982\u5728epoll\u4e2d\u963b\u585e\u4e86timeout\u65f6\u95f4\u540e\u8fd4\u56de\u65f6\uff0c\u4f1a\u518d\u6b21\u66f4\u65b0\u5f53\u524d\u65f6\u95f4\u53d8\u91cf\u3002 \u5982\u679c\u4e8b\u4ef6\u5faa\u73af\u662f\u5904\u4e8ealive\u72b6\u6001\uff0c\u5219\u5f00\u59cb\u5904\u7406\u4e8b\u4ef6\u5faa\u73af\u7684\u6bcf\u4e2a\u9636\u6bb5\uff0c\u5426\u5219\u9000\u51fa\u8fd9\u4e2a\u4e8b\u4ef6\u5faa\u73af\u3002alive\u72b6\u6001\u662f\u4ec0\u4e48\u610f\u601d\u5462\uff1f\u5982\u679c\u6709active\u548cref\u72b6\u6001\u7684handle\uff0cactive\u72b6\u6001\u7684request\u6216\u8005closing\u72b6\u6001\u7684handle\u5219\u8ba4\u4e3a\u4e8b\u4ef6\u5faa\u73af\u662falive\uff08\u5177\u4f53\u7684\u540e\u7eed\u4f1a\u8bb2\u5230\uff09\u3002 timer\u9636\u6bb5\uff1a\u5224\u65ad\u6700\u5c0f\u5806\u4e2d\u7684\u8282\u70b9\u54ea\u4e2a\u8282\u70b9\u8d85\u65f6\u4e86\uff0c\u6267\u884c\u5b83\u7684\u56de\u8c03\u3002 pending\u9636\u6bb5\uff1a\u6267\u884cpending\u56de\u8c03\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u6240\u6709\u7684IO\u56de\u8c03\uff08\u7f51\u7edc\uff0c\u6587\u4ef6\uff0cDNS\uff09\u90fd\u4f1a\u5728Poll IO\u9636\u6bb5\u6267\u884c\uff0c\u4f46\u662f\u6709\u7684\u60c5\u51b5\u4e0b\uff0cPoll IO\u9636\u6bb5\u7684\u56de\u8c03\u4f1a\u5ef6\u8fdf\u5230\u4e0b\u4e00\u6b21\u5faa\u73af\u6267\u884c\uff0c\u90a3\u4e48\u8fd9\u79cd\u56de\u8c03\u5c31\u662f\u5728pending\u9636\u6bb5\u6267\u884c\u7684\uff0c\u6bd4\u5982IO\u56de\u8c03\u91cc\u51fa\u73b0\u4e86\u9519\u8bef\u6216\u5199\u6570\u636e\u6210\u529f\u7b49\u7b49\u90fd\u4f1a\u5728\u4e0b\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af\u7684pending\u9636\u6bb5\u6267\u884c\u56de\u8c03\u3002 idle\u9636\u6bb5\uff1a\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u90fd\u4f1a\u88ab\u6267\u884c\uff08idle\u4e0d\u662f\u8bf4\u4e8b\u4ef6\u5faa\u73af\u7a7a\u95f2\u7684\u65f6\u5019\u624d\u6267\u884c\uff09\u3002 prepare\u9636\u6bb5\uff1a\u548cidle\u9636\u6bb5\u7c7b\u4f3c\u3002 Poll IO\u9636\u6bb5\uff1a\u8c03\u7528\u5404\u5e73\u53f0\u63d0\u4f9b\u7684IO\u591a\u8def\u590d\u7528\u63a5\u53e3\uff08\u6bd4\u5982Linux\u4e0b\u5c31\u662fepoll\u6a21\u5f0f\uff09\uff0c\u6700\u591a\u7b49\u5f85timeout\u65f6\u95f4\uff0c\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u3002timeout\u7684\u8ba1\u7b97\u89c4\u5219\uff1a 1 \u5982\u679c\u65f6\u95f4\u5faa\u73af\u662f\u4ee5UV_RUN_NOWAIT\u6a21\u5f0f\u8fd0\u884c\u7684\uff0c\u5219timeout\u662f0\u3002 2 \u5982\u679c\u65f6\u95f4\u5faa\u73af\u5373\u5c06\u9000\u51fa\uff08\u8c03\u7528\u4e86uv_stop\uff09\uff0c\u5219timeout\u662f0\u3002 3 \u5982\u679c\u6ca1\u6709active\u72b6\u6001\u7684handle\u6216\u8005request\uff0ctimeout\u662f0\u3002 4 \u5982\u679c\u6709idle\u9636\u6bb5\u7684\u961f\u5217\u91cc\u6709\u8282\u70b9\uff0c\u5219timeout\u662f0\u3002 5 \u5982\u679c\u6709handle\u7b49\u5f85\u88ab\u5173\u95ed\u7684\uff08\u5373\u8c03\u4e86uv_close\uff09\uff0ctimeout\u662f0\u3002 6 \u5982\u679c\u4e0a\u9762\u7684\u90fd\u4e0d\u6ee1\u8db3\uff0c\u5219\u53d6timer\u9636\u6bb5\u4e2d\u6700\u5feb\u8d85\u65f6\u7684\u8282\u70b9\u4f5c\u4e3atimeout\u3002 7 \u5982\u679c\u4e0a\u9762\u7684\u90fd\u4e0d\u6ee1\u8db3\u5219timeout\u7b49\u4e8e-1\uff0c\u5373\u4e00\u76f4\u963b\u585e\uff0c\u76f4\u5230\u6ee1\u8db3\u6761\u4ef6\u3002 check\u9636\u6bb5\uff1a\u548cidle\u3001prepare\u4e00\u6837\u3002 closing\u9636\u6bb5\uff1a\u6267\u884c\u8c03\u7528uv_close\u51fd\u6570\u65f6\u4f20\u5165\u7684\u56de\u8c03\u3002 \u5982\u679cLibuv\u662f\u4ee5UV_RUN_ONCE\u6a21\u5f0f\u8fd0\u884c\u7684\uff0c\u90a3\u4e8b\u4ef6\u5faa\u73af\u5373\u5c06\u9000\u51fa\u3002\u4f46\u662f\u6709\u4e00\u79cd\u60c5\u51b5\u662f\uff0cPoll IO\u9636\u6bb5\u7684timeout\u7684\u503c\u662ftimer\u9636\u6bb5\u7684\u8282\u70b9\u7684\u503c\uff0c\u5e76\u4e14Poll IO\u9636\u6bb5\u662f\u56e0\u4e3a\u8d85\u65f6\u8fd4\u56de\u7684\uff0c\u5373\u6ca1\u6709\u4efb\u4f55\u4e8b\u4ef6\u53d1\u751f\uff0c\u4e5f\u6ca1\u6709\u6267\u884c\u4efb\u4f55IO\u56de\u8c03\uff0c\u8fd9\u65f6\u5019\u9700\u8981\u5728\u6267\u884c\u4e00\u6b21timer\u9636\u6bb5\u3002\u56e0\u4e3a\u6709\u8282\u70b9\u8d85\u65f6\u4e86\u3002 \u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u7ed3\u675f\uff0c\u5982\u679cLibuv\u4ee5UV_RUN_NOWAIT \u6216 UV_RUN_ONCE\u6a21\u5f0f\u8fd0\u884c\u7684\uff0c\u5219\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af\uff0c\u5982\u679c\u662f\u4ee5UV_RUN_DEFAULT\u6a21\u5f0f\u8fd0\u884c\u7684\u5e76\u4e14\u72b6\u6001\u662falive\uff0c\u5219\u5f00\u59cb\u4e0b\u4e00\u8f6e\u5faa\u73af\u3002\u5426\u5219\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af\u3002 \u4e0b\u9762\u6211\u80fd\u901a\u8fc7\u4e00\u4e2a\u4f8b\u5b50\u6765\u4e86\u89e3libuv\u7684\u57fa\u672c\u539f\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <stdio.h> #include <uv.h> int64_t counter = 0 ; void wait_for_a_while ( uv_idle_t * handle ) { counter ++ ; if ( counter >= 10e6 ) uv_idle_stop ( handle ); } int main () { uv_idle_t idler ; // \u83b7\u53d6\u4e8b\u4ef6\u5faa\u73af\u7684\u6838\u5fc3\u7ed3\u6784\u4f53\u3002\u5e76\u521d\u59cb\u5316\u4e00\u4e2aidle uv_idle_init ( uv_default_loop (), & idler ); // \u5f80\u4e8b\u4ef6\u5faa\u73af\u7684idle\u9636\u6bb5\u63d2\u5165\u4e00\u4e2a\u4efb\u52a1 uv_idle_start ( & idler , wait_for_a_while ); // \u542f\u52a8\u4e8b\u4ef6\u5faa\u73af uv_run ( uv_default_loop (), UV_RUN_DEFAULT ); // \u9500\u6bc1libuv\u7684\u76f8\u5173\u6570\u636e uv_loop_close ( uv_default_loop ()); return 0 ; } \u4f7f\u7528Libuv\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u83b7\u53d6Libuv\u7684\u6838\u5fc3\u7ed3\u6784\u4f53uv_loop_t\uff0cuv_loop_t\u662f\u4e00\u4e2a\u975e\u5e38\u5927\u7684\u7ed3\u6784\u4f53\uff0c\u91cc\u9762\u8bb0\u5f55\u4e86Libuv\u6574\u4e2a\u751f\u547d\u5468\u671f\u7684\u6570\u636e\u3002uv_default_loop\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u4e2a\u9ed8\u8ba4\u5df2\u7ecf\u521d\u59cb\u5316\u4e86\u7684uv_loop_t\u7ed3\u6784\u4f53\uff0c\u5f53\u7136\u6211\u4eec\u4e5f\u53ef\u4ee5\u81ea\u5df1\u53bb\u5206\u914d\u4e00\u4e2a\uff0c\u81ea\u5df1\u521d\u59cb\u5316\u3002 1 2 3 4 5 6 7 8 9 10 11 uv_loop_t * uv_default_loop ( void ) { // \u7f13\u5b58 if ( default_loop_ptr != NULL ) return default_loop_ptr ; if ( uv_loop_init ( & default_loop_struct )) return NULL ; default_loop_ptr = & default_loop_struct ; return default_loop_ptr ; } Libuv\u7ef4\u62a4\u4e86\u4e00\u4e2a\u5168\u5c40\u7684uv_loop_t\u7ed3\u6784\u4f53\uff0c\u4f7f\u7528uv_loop_init\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u4e0d\u6253\u7b97\u5c55\u5f00\u8bb2\u89e3uv_loop_init\u51fd\u6570\uff0cw\u56e0\u4e3a\u5b83\u5927\u6982\u5c31\u662f\u5bf9uv_loop_t\u7ed3\u6784\u4f53\u5404\u4e2a\u5b57\u6bb5\u8fdb\u884c\u521d\u59cb\u5316\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0buv_idle_*\u7cfb\u5217\u7684\u51fd\u6570\u3002 1 uv_idle_init 1 2 3 4 5 6 7 8 9 int uv_idle_init ( uv_loop_t * loop , uv_idle_t * handle ) { /* \u521d\u59cb\u5316handle\u7684\u7c7b\u578b\uff0c\u6240\u5c5eloop\uff0c\u6253\u4e0aUV_HANDLE_REF\uff0c \u5e76\u4e14\u628ahandle\u63d2\u5165loop->handle_queue\u961f\u5217\u7684\u961f\u5c3e */ uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_IDLE ); handle -> idle_cb = NULL ; return 0 ; } \u6267\u884cuv_idle_init\u51fd\u6570\u540e\uff0cLibuv\u7684\u5185\u5b58\u89c6\u56fe\u5982\u4e0b\u56fe\u6240\u793a 2 uv_idle_start 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int uv_idle_start ( uv_idle_t * handle , uv_idle_cb cb ) { // \u5982\u679c\u5df2\u7ecf\u6267\u884c\u8fc7start\u51fd\u6570\u5219\u76f4\u63a5\u8fd4\u56de if ( uv__is_active ( handle )) return 0 ; // \u628ahandle\u63d2\u5165loop\u4e2didle\u7684\u961f\u5217 QUEUE_INSERT_HEAD ( & handle -> loop -> idle_handles , & handle -> queue ); // \u6302\u8f7d\u56de\u8c03\uff0c\u4e0b\u4e00\u8f6e\u5faa\u73af\u7684\u65f6\u5019\u88ab\u6267\u884c handle -> idle_cb = cb ; /* \u8bbe\u7f6eUV_HANDLE_ACTIVE\u6807\u8bb0\u4f4d\uff0c\u5e76\u4e14loop\u4e2d\u7684handle\u6570\u52a0\u4e00\uff0c init\u7684\u65f6\u5019\u53ea\u662f\u628ahandle\u6302\u8f7d\u5230loop\uff0cstart\u7684\u65f6\u5019handle\u624d \u5904\u4e8e\u6fc0\u6d3b\u6001 */ uv__handle_start ( handle ); return 0 ; } \u6267\u884c\u5b8cuv_idle_start\u7684\u5185\u5b58\u89c6\u56fe\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u7136\u540e\u6267\u884cuv_run\u8fdb\u5165Libuv\u7684\u4e8b\u4ef6\u5faa\u73af\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int uv_run ( uv_loop_t * loop , uv_run_mode mode ) { int timeout ; int r ; int ran_pending ; // \u5728uv_run\u4e4b\u524d\u8981\u5148\u63d0\u4ea4\u4efb\u52a1\u5230loop r = uv__loop_alive ( loop ); // \u6ca1\u6709\u4efb\u52a1\u9700\u8981\u5904\u7406\u6216\u8005\u8c03\u7528\u4e86uv_stop while ( r != 0 && loop -> stop_flag == 0 ) { // \u5904\u7406idle\u961f\u5217 uv__run_idle ( loop ); } // \u662f\u56e0\u4e3a\u8c03\u7528\u4e86uv_stop\u9000\u51fa\u7684\uff0c\u91cd\u7f6eflag if ( loop -> stop_flag != 0 ) loop -> stop_flag = 0 ; /* \u8fd4\u56de\u662f\u5426\u8fd8\u6709\u6d3b\u8dc3\u7684\u4efb\u52a1\uff08handle\u6216request\uff09\uff0c \u4e1a\u52a1\u4ee3\u8868\u53ef\u4ee5\u518d\u6b21\u6267\u884cuv_run */ return r ; } \u6211\u4eec\u770b\u5230\u6709\u4e00\u4e2a\u51fd\u6570\u662fuv__run_idle\uff0c\u8fd9\u5c31\u662f\u5904\u7406idle\u9636\u6bb5\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // \u5728\u6bcf\u4e00\u8f6e\u5faa\u73af\u4e2d\u6267\u884c\u8be5\u51fd\u6570\uff0c\u6267\u884c\u65f6\u673a\u89c1uv_run void uv__run_idle ( uv_loop_t * loop ) { uv_idle_t * h ; QUEUE queue ; QUEUE * q ; /* \u628a\u8be5\u7c7b\u578b\u5bf9\u5e94\u7684\u961f\u5217\u4e2d\u6240\u6709\u8282\u70b9\u6458\u4e0b\u6765\u6302\u8f7d\u5230queue\u53d8\u91cf\uff0c \u53d8\u91cf\u56de\u8c03\u91cc\u4e0d\u65ad\u63d2\u5165\u65b0\u8282\u70b9\uff0c\u5bfc\u81f4\u6b7b\u5faa\u73af */ QUEUE_MOVE ( & loop -> idle_handles , & queue ); // \u904d\u5386\u961f\u5217\uff0c\u6267\u884c\u6bcf\u4e2a\u8282\u70b9\u91cc\u9762\u7684\u51fd\u6570 while ( ! QUEUE_EMPTY ( & queue )) { // \u53d6\u4e0b\u5f53\u524d\u5f85\u5904\u7406\u7684\u8282\u70b9 q = QUEUE_HEAD ( & queue ); // \u53d6\u5f97\u8be5\u8282\u70b9\u5bf9\u5e94\u7684\u6574\u4e2a\u7ed3\u6784\u4f53\u7684\u57fa\u5730\u5740 h = QUEUE_DATA ( q , uv_idle_t , queue ); // \u628a\u8be5\u8282\u70b9\u79fb\u51fa\u5f53\u524d\u961f\u5217\uff0c\u5426\u5219\u5faa\u73af\u4e0d\u4f1a\u7ed3\u675f QUEUE_REMOVE ( q ); // \u91cd\u65b0\u63d2\u5165\u539f\u6765\u7684\u961f\u5217 QUEUE_INSERT_TAIL ( & loop -> idle_handles , q ); // \u6267\u884c\u56de\u8c03\u51fd\u6570 h -> idle_cb ( h ); } } \u6211\u4eec\u770b\u5230uv__run_idle\u7684\u903b\u8f91\u5e76\u4e0d\u590d\u6742\uff0c\u5c31\u662f\u904d\u5386idle_handles\u961f\u5217\u7684\u8282\u70b9\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03\uff0c\u5728\u56de\u8c03\u91cc\u6211\u4eec\u53ef\u4ee5\u63d2\u5165\u65b0\u7684\u8282\u70b9\uff08\u4ea7\u751f\u65b0\u4efb\u52a1\uff09\uff0c\u4ece\u800c\u4e0d\u65ad\u9a71\u52a8Libuv\u7684\u8fd0\u884c\u3002\u6211\u4eec\u770b\u5230uv_run\u9000\u51fa\u5faa\u73af\u7684\u6761\u4ef6\u4e0b\u9762\u7684\u4ee3\u7801\u4e3afalse\u3002 1 r != 0 && loop -> stop_flag == 0 stop_flag\u7531\u7528\u6237\u4e3b\u52a8\u5173\u95edLibuv\u4e8b\u4ef6\u5faa\u73af\u3002 1 2 3 void uv_stop ( uv_loop_t * loop ) { loop -> stop_flag = 1 ; } r\u662f\u4ee3\u8868\u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u8fd8\u5b58\u6d3b\uff0c\u8fd9\u4e2a\u5224\u65ad\u7684\u6807\u51c6\u662f\u7531uv__loop_alive\u63d0\u4f9b 1 2 3 4 5 static int uv__loop_alive ( const uv_loop_t * loop ) { return loop -> active_handles > 0 || loop -> active_reqs . count > 0 || loop -> closing_handles != NULL ; } \u8fd9\u65f6\u5019\u6211\u4eec\u6709\u4e00\u4e2aactived handles\uff0c\u6240\u4ee5Libuv\u4e0d\u4f1a\u9000\u51fa\u3002\u5f53\u6211\u4eec\u8c03\u7528uv_idle_stop\u51fd\u6570\u628aidle\u8282\u70b9\u79fb\u51fahandle\u961f\u5217\u7684\u65f6\u5019\uff0cLibuv\u5c31\u4f1a\u9000\u51fa\u3002\u540e\u9762\u6211\u4eec\u4f1a\u5177\u4f53\u5206\u6790Libuv\u4e8b\u4ef6\u5faa\u73af\u7684\u539f\u7406\u3002 1.1.3 \u5176\u5b83\u7b2c\u4e09\u65b9\u5e93 \u00b6 Node.js\u4e2d\u7b2c\u4e09\u65b9\u5e93\u5305\u62ec\u5f02\u6b65DNS\u89e3\u6790\uff08cares\uff09\u3001HTTP\u89e3\u6790\u5668\uff08\u65e7\u7248\u4f7f\u7528http_parser\uff0c\u65b0\u7248\u4f7f\u7528llhttp\uff09\u3001HTTP2\u89e3\u6790\u5668\uff08nghttp2\uff09\u3001\u89e3\u538b\u538b\u7f29\u5e93(zlib)\u3001\u52a0\u5bc6\u89e3\u5bc6\u5e93(openssl)\u7b49\u7b49\uff0c\u4e0d\u4e00\u4e00\u4ecb\u7ecd\u3002 1.2 Node.js\u5de5\u4f5c\u539f\u7406 \u00b6 1.2.1 Node.js\u662f\u5982\u4f55\u62d3\u5c55JS\u529f\u80fd\u7684\uff1f \u00b6 V8\u63d0\u4f9b\u4e86\u4e00\u5957\u673a\u5236\uff0c\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u5728JS\u5c42\u8c03\u7528C++\u3001C\u8bed\u8a00\u6a21\u5757\u63d0\u4f9b\u7684\u529f\u80fd\u3002Node.js\u6b63\u662f\u901a\u8fc7\u8fd9\u5957\u673a\u5236\uff0c\u5b9e\u73b0\u4e86\u5bf9JS\u80fd\u529b\u7684\u62d3\u5c55\u3002Node.js\u5728\u5e95\u5c42\u505a\u4e86\u5927\u91cf\u7684\u4e8b\u60c5\uff0c\u5b9e\u73b0\u4e86\u5f88\u591a\u529f\u80fd\uff0c\u7136\u540e\u5728JS\u5c42\u66b4\u9732\u63a5\u53e3\u7ed9\u7528\u6237\u4f7f\u7528\uff0c\u964d\u4f4e\u4e86\u7528\u6237\u6210\u672c\uff0c\u4e5f\u63d0\u9ad8\u4e86\u5f00\u53d1\u6548\u7387\u3002 1.2.2 \u5982\u4f55\u5728V8\u65b0\u589e\u4e00\u4e2a\u81ea\u5b9a\u4e49\u7684\u529f\u80fd\uff1f \u00b6 1 2 3 4 5 // C++\u91cc\u5b9a\u4e49 Handle < FunctionTemplate > Test = FunctionTemplate :: New ( cb ); global -> Set ( String :: New ( \u201c Test \"), Test); // JS\u91cc\u4f7f\u7528 const test = new Test (); \u6211\u4eec\u5148\u6709\u4e00\u4e2a\u611f\u6027\u7684\u8ba4\u8bc6\uff0c\u5728\u540e\u9762\u7684\u7ae0\u8282\u4e2d\uff0c\u4f1a\u5177\u4f53\u8bb2\u89e3\u5982\u4f55\u4f7f\u7528V8\u62d3\u5c55JS\u7684\u529f\u80fd\u3002 1.2.3 Node.js\u662f\u5982\u4f55\u5b9e\u73b0\u62d3\u5c55\u7684? \u00b6 Node.js\u5e76\u4e0d\u662f\u7ed9\u6bcf\u4e2a\u529f\u80fd\u90fd\u62d3\u5c55\u4e00\u4e2a\u5bf9\u8c61\uff0c\u7136\u540e\u6302\u8f7d\u5230\u5168\u5c40\u53d8\u91cf\u4e2d\uff0c\u800c\u662f\u62d3\u5c55\u4e00\u4e2aprocess\u5bf9\u8c61\uff0c\u518d\u901a\u8fc7process.binding\u62d3\u5c55js\u529f\u80fd\u3002Node.js\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5168\u5c40\u7684JS\u5bf9\u8c61process\uff0c\u6620\u5c04\u5230\u4e00\u4e2aC++\u5bf9\u8c61process\uff0c\u5e95\u5c42\u7ef4\u62a4\u4e86\u4e00\u4e2aC++\u6a21\u5757\u7684\u94fe\u8868\uff0cJS\u901a\u8fc7\u8c03\u7528JS\u5c42\u7684process.binding\uff0c\u8bbf\u95ee\u5230C++\u7684process\u5bf9\u8c61\uff0c\u4ece\u800c\u8bbf\u95eeC++\u6a21\u5757(\u7c7b\u4f3c\u8bbf\u95eeJS\u7684Object\u3001Date\u7b49)\u3002\u4e0d\u8fc7Node.js 14\u7248\u672c\u5df2\u7ecf\u6539\u6210internalBinding\u7684\u65b9\u5f0f\uff0c\u901a\u8fc7internalBinding\u5c31\u53ef\u4ee5\u8bbf\u95eeC++\u6a21\u5757\uff0c\u539f\u7406\u7c7b\u4f3c\u3002 1.3 Node.js\u542f\u52a8\u8fc7\u7a0b \u00b6 \u4e0b\u9762\u662fNode.js\u542f\u52a8\u7684\u4e3b\u6d41\u7a0b\u56fe\u5982\u56fe1-4\u6240\u793a\u3002 \u6211\u4eec\u4ece\u4e0a\u5f80\u4e0b\uff0c\u770b\u4e00\u4e0b\u6bcf\u4e2a\u8fc7\u7a0b\u90fd\u505a\u4e86\u4e9b\u4ec0\u4e48\u4e8b\u60c5\u3002 1.3.1 \u6ce8\u518cC++\u6a21\u5757 \u00b6 RegisterBuiltinModules\u51fd\u6570\uff08node_binding.cc\uff09\u7684\u4f5c\u7528\u662f\u6ce8\u518cC++\u6a21\u5757\u3002 1 2 3 4 5 void RegisterBuiltinModules () { #define V(modname) _register_##modname(); NODE_BUILTIN_MODULES ( V ) #undef V } NODE_BUILTIN_MODULES\u662f\u4e00\u4e2aC\u8bed\u8a00\u5b8f\uff0c\u5b8f\u5c55\u5f00\u540e\u5982\u4e0b\uff08\u7701\u7565\u7c7b\u4f3c\u903b\u8f91\uff09 1 2 3 4 5 6 7 void RegisterBuiltinModules () { #define V(modname) _register_##modname(); V ( tcp_wrap ) V ( timers ) ... \u5176\u5b83\u6a21\u5757 #undef V } \u518d\u4e00\u6b65\u5c55\u5f00\u5982\u4e0b 1 2 3 4 void RegisterBuiltinModules () { _register_tcp_wrap (); _register_timers (); } \u6267\u884c\u4e86\u4e00\u7cfb\u5217_register\u5f00\u5934\u7684\u51fd\u6570\uff0c\u4f46\u662f\u6211\u4eec\u5728Node.js\u6e90\u7801\u91cc\u627e\u4e0d\u5230\u8fd9\u4e9b\u51fd\u6570\uff0c\u56e0\u4e3a\u8fd9\u4e9b\u51fd\u6570\u662f\u5728\u6bcf\u4e2aC++\u6a21\u5757\u5b9a\u4e49\u7684\u6587\u4ef6\u91cc\uff08.cc\u6587\u4ef6\u7684\u6700\u540e\u4e00\u884c\uff09\u901a\u8fc7\u5b8f\u5b9a\u4e49\u7684\u3002\u4ee5tcp_wrap\u6a21\u5757\u4e3a\u4f8b\uff0c\u770b\u770b\u5b83\u662f\u600e\u4e48\u505a\u7684\u3002\u6587\u4ef6tcp_wrap.cc\u7684\u6700\u540e\u4e00\u53e5\u4ee3\u7801 NODE_MODULE_CONTEXT_AWARE_INTERNAL(tcp_wrap, node::TCPWrap::Initialize) \u5b8f\u5c55\u5f00\u662f 1 2 3 4 5 #define NODE_MODULE_CONTEXT_AWARE_INTERNAL(modname, regfunc) \\ NODE_MODULE_CONTEXT_AWARE_CPP ( modname , regfunc , nullptr , NM_F_INTERNAL ) \u7ee7\u7eed\u5c55\u5f00 1 2 3 4 5 6 7 8 9 10 11 12 #define NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, priv, flags\\ static node :: node_module _module = { \\ NODE_MODULE_VERSION , \\ flags , \\ nullptr , \\ __FILE__ , \\ nullptr , \\ ( node :: addon_context_register_func )( regfunc ), \\ NODE_STRINGIFY ( modname ), \\ priv , \\ nullptr }; \\ void _register_tcp_wrap () { node_module_register ( & _module ); } \u6211\u4eec\u770b\u5230\u6bcf\u4e2aC++\u6a21\u5757\u5e95\u5c42\u90fd\u5b9a\u4e49\u4e86\u4e00\u4e2a_register\u5f00\u5934\u7684\u51fd\u6570\uff0c\u5728Node.js\u542f\u52a8\u65f6\uff0c\u5c31\u4f1a\u628a\u8fd9\u4e9b\u51fd\u6570\u9010\u4e2a\u6267\u884c\u4e00\u904d\u3002\u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0b\u8fd9\u4e9b\u51fd\u6570\u90fd\u505a\u4e86\u4ec0\u4e48\uff0c\u5728\u8fd9\u4e4b\u524d\uff0c\u6211\u4eec\u8981\u5148\u4e86\u89e3\u4e00\u4e0bNode.js\u4e2d\u8868\u793aC++\u6a21\u5757\u7684\u6570\u636e\u7ed3\u6784\u3002 1 2 3 4 5 6 7 8 9 10 11 struct node_module { int nm_version ; unsigned int nm_flags ; void * nm_dso_handle ; const char * nm_filename ; node :: addon_register_func nm_register_func ; node :: addon_context_register_func nm_context_register_func ; const char * nm_modname ; void * nm_priv ; struct node_module * nm_link ; }; \u6211\u4eec\u770b\u5230_register\u5f00\u5934\u7684\u51fd\u6570\u8c03\u4e86node_module_register\uff0c\u5e76\u4f20\u5165\u4e00\u4e2anode_module\u6570\u636e\u7ed3\u6784\uff0c\u6240\u4ee5\u6211\u4eec\u770b\u4e00\u4e0bnode_module_register\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 void node_module_register ( void * m ) { struct node_module * mp = reinterpret_cast < struct node_module *> ( m ); if ( mp -> nm_flags & NM_F_INTERNAL ) { mp -> nm_link = modlist_internal ; modlist_internal = mp ; } else if ( ! node_is_initialized ) { mp -> nm_flags = NM_F_LINKED ; mp -> nm_link = modlist_linked ; modlist_linked = mp ; } else { thread_local_modpending = mp ; } } C++\u5185\u7f6e\u6a21\u5757\u7684flag\u662fNM_F_INTERNAL\uff0c\u6240\u4ee5\u4f1a\u6267\u884c\u7b2c\u4e00\u4e2aif\u7684\u903b\u8f91\uff0cmodlist_internal\u7c7b\u4f3c\u4e00\u4e2a\u5934\u6307\u9488\u3002if\u91cc\u7684\u903b\u8f91\u5c31\u662f\u5934\u63d2\u6cd5\u5efa\u7acb\u4e00\u4e2a\u5355\u94fe\u8868\u3002C++\u5185\u7f6e\u6a21\u5757\u5728Node.js\u91cc\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u5f88\u591a\u529f\u80fd\u90fd\u4f1a\u8c03\u7528\uff0c\u540e\u7eed\u6211\u4eec\u4f1a\u770b\u5230\u3002 1.3.2 \u521b\u5efaEnvironment\u5bf9\u8c61 \u00b6 1 CreateMainEnvironment Node.js\u4e2dEnvironment\u7c7b\uff08env.h\uff09\u662f\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u7c7b\uff0cNode.js\u4e2d\uff0c\u5f88\u591a\u6570\u636e\u7531Environment\u5bf9\u8c61\u8fdb\u884c\u7ba1\u7406\u3002 1 2 3 4 5 6 7 8 context = NewContext ( isolate_ ); std :: unique_ptr < Environment > env = std :: make_unique < Environment > ( isolate_data_ . get (), context , args_ , exec_args_ , static_cast < Environment :: Flags > ( Environment :: kIsMainThread | Environment :: kOwnsProcessState | Environment :: kOwnsInspector )); Isolate\uff0cContext\u662fV8\u4e2d\u7684\u6982\u5ff5\uff0cIsolate\u7528\u4e8e\u9694\u79bb\u5b9e\u4f8b\u95f4\u7684\u73af\u5883\uff0cContext\u7528\u4e8e\u63d0\u4f9bJS\u6267\u884c\u65f6\u7684\u4e0a\u4e0b\u6587\uff0ckIsMainThread\u8bf4\u660e\u5f53\u524d\u8fd0\u884c\u7684\u662f\u4e3b\u7ebf\u7a0b\uff0c\u7528\u4e8e\u533a\u5206Node.js\u4e2d\u7684worker_threads\u5b50\u7ebf\u7a0b\u3002Environment\u7c7b\u975e\u5e38\u5e9e\u5927\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u521d\u59cb\u5316\u7684\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 Environment :: Environment ( IsolateData * isolate_data , Local < Context > context , const std :: vector < std :: string >& args , const std :: vector < std :: string >& exec_args , Flags flags , uint64_t thread_id ) : isolate_ ( context -> GetIsolate ()), isolate_data_ ( isolate_data ), immediate_info_ ( context -> GetIsolate ()), tick_info_ ( context -> GetIsolate ()), timer_base_ ( uv_now ( isolate_data -> event_loop ())), exec_argv_ ( exec_args ), argv_ ( args ), exec_path_ ( GetExecPath ( args )), should_abort_on_uncaught_toggle_ ( isolate_ , 1 ), stream_base_state_ ( isolate_ , StreamBase :: kNumStreamBaseStateFields ), flags_ ( flags ), thread_id_ ( thread_id == kNoThreadId ? AllocateThreadId () : thread_id ), fs_stats_field_array_ ( isolate_ , kFsStatsBufferLength ), fs_stats_field_bigint_array_ ( isolate_ , kFsStatsBufferLength ), context_ ( context -> GetIsolate (), context ) { // \u8fdb\u5165\u5f53\u524d\u7684context HandleScope handle_scope ( isolate ()); Context :: Scope context_scope ( context ); // \u4fdd\u5b58\u73af\u5883\u53d8\u91cf set_env_vars ( per_process :: system_environment ); // \u5173\u8054context\u548cenv AssignToContext ( context , ContextInfo ( \"\" )); // \u521b\u5efa\u5176\u5b83\u5bf9\u8c61 CreateProperties (); } \u6211\u4eec\u53ea\u770b\u4e00\u4e0bAssignToContext\u548cCreateProperties\uff0cset_env_vars\u4f1a\u628a\u8fdb\u7a0b\u7ae0\u8282\u8bb2\u89e3\u3002 1.1 AssignToContext 1 2 3 4 5 6 7 8 inline void Environment::AssignToContext ( v8 :: Local < v8 :: Context > context , const ContextInfo & info ) { // \u5728context\u4e2d\u4fdd\u5b58env\u5bf9\u8c61 context -> SetAlignedPointerInEmbedderData ( ContextEmbedderIndex :: kEnvironment , this ); // Used by Environment::GetCurrent to know that we are on a node context. context -> SetAlignedPointerInEmbedderData ( ContextEmbedderIndex :: kContextTag , Environment :: kNodeContextTagPtr ); } AssignToContext\u7528\u4e8e\u4fdd\u5b58context\u548cenv\u7684\u5173\u7cfb\u3002\u8fd9\u4e2a\u903b\u8f91\u975e\u5e38\u91cd\u8981\uff0c\u56e0\u4e3a\u540e\u7eed\u6267\u884c\u4ee3\u7801\u65f6\uff0c\u6211\u4eec\u4f1a\u8fdb\u5165V8\u7684\u9886\u57df\uff0c\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u53ea\u77e5\u9053Isolate\u548ccontext\u3002\u5982\u679c\u4e0d\u4fdd\u5b58context\u548cenv\u7684\u5173\u7cfb\uff0c\u6211\u4eec\u5c31\u4e0d\u77e5\u9053\u5f53\u524d\u6240\u5c5e\u7684env\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u83b7\u53d6\u5bf9\u5e94\u7684env\u3002 1 2 3 4 5 6 7 8 9 inline Environment * Environment::GetCurrent ( v8 :: Isolate * isolate ) { v8 :: HandleScope handle_scope ( isolate ); return GetCurrent ( isolate -> GetCurrentContext ()); } inline Environment * Environment::GetCurrent ( v8 :: Local < v8 :: Context > context ) { return static_cast < Environment *> ( context -> GetAlignedPointerFromEmbedderData ( ContextEmbedderIndex :: kEnvironment )); } 1.2 CreateProperties \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bCreateProperties\u4e2d\u521b\u5efaprocess\u5bf9\u8c61\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 Isolate * isolate = env -> isolate (); EscapableHandleScope scope ( isolate ); Local < Context > context = env -> context (); // \u7533\u8bf7\u4e00\u4e2a\u51fd\u6570\u6a21\u677f Local < FunctionTemplate > process_template = FunctionTemplate :: New ( isolate ); process_template -> SetClassName ( env -> process_string ()); // \u4fdd\u5b58\u51fd\u6570\u6a21\u677f\u751f\u6210\u7684\u51fd\u6570 Local < Function > process_ctor ; // \u4fdd\u5b58\u51fd\u6570\u6a21\u5757\u751f\u6210\u7684\u51fd\u6570\u6240\u65b0\u5efa\u51fa\u6765\u7684\u5bf9\u8c61 Local < Object > process ; if ( ! process_template -> GetFunction ( context ). ToLocal ( & process_ctor ) || ! process_ctor -> NewInstance ( context ). ToLocal ( & process )) { return MaybeLocal < Object > (); } process\u6240\u4fdd\u5b58\u7684\u5bf9\u8c61\u5c31\u662f\u6211\u4eec\u5728JS\u5c42\u7528\u4f7f\u7528\u7684process\u5bf9\u8c61\u3002Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u8fd8\u6302\u8f7d\u4e86\u4e00\u4e9b\u5c5e\u6027\u3002 1 2 3 4 5 READONLY_PROPERTY ( process , \"version\" , FIXED_ONE_BYTE_STRING ( env -> isolate (), NODE_VERSION )); READONLY_STRING_PROPERTY ( process , \"arch\" , per_process :: metadata . arch );...... \u521b\u5efa\u5b8cprocess\u5bf9\u8c61\u540e\uff0cNode.js\u628aprocess\u4fdd\u5b58\u5230env\u4e2d\u3002 1 2 Local < Object > process_object = node :: CreateProcessObject ( this ). FromMaybe ( Local < Object > ()); set_process_object ( process_object ) 1.3.3 \u521d\u59cb\u5316Libuv\u4efb\u52a1 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 InitializeLibuv\u51fd\u6570\u4e2d\u7684\u903b\u8f91\u662f\u5f80Libuv\u4e2d\u63d0\u4ea4\u4efb\u52a1 \u3002 void Environment :: InitializeLibuv ( bool start_profiler_idle_notifier ) { HandleScope handle_scope ( isolate ()); Context :: Scope context_scope ( context ()); CHECK_EQ ( 0 , uv_timer_init ( event_loop (), timer_handle ())); uv_unref ( reinterpret_cast < uv_handle_t *> ( timer_handle ())); uv_check_init ( event_loop (), immediate_check_handle ()); uv_unref ( reinterpret_cast < uv_handle_t *> ( immediate_check_handle ())); uv_idle_init ( event_loop (), immediate_idle_handle ()); uv_check_start ( immediate_check_handle (), CheckImmediate ); uv_prepare_init ( event_loop (), & idle_prepare_handle_ ); uv_check_init ( event_loop (), & idle_check_handle_ ); uv_async_init ( event_loop (), & task_queues_async_ , []( uv_async_t * async ) { Environment * env = ContainerOf ( & Environment :: task_queues_async_ , async ); env -> CleanupFinalizationGroups (); env -> RunAndClearNativeImmediates (); }); uv_unref ( reinterpret_cast < uv_handle_t *> ( & idle_prepare_handle_ )); uv_unref ( reinterpret_cast < uv_handle_t *> ( & idle_check_handle_ )); uv_unref ( reinterpret_cast < uv_handle_t *> ( & task_queues_async_ )); // \u2026 } \u8fd9\u4e9b\u51fd\u6570\u90fd\u662fLibuv\u63d0\u4f9b\u7684\uff0c\u5206\u522b\u662f\u5f80Libuv\u4e0d\u540c\u9636\u6bb5\u63d2\u5165\u4efb\u52a1\u8282\u70b9\uff0cuv_unref\u662f\u4fee\u6539\u72b6\u6001\u3002 1 timer_handle\u662f\u5b9e\u73b0Node.js\u4e2d\u5b9a\u65f6\u5668\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5bf9\u5e94Libuv\u7684time\u9636\u6bb5 2 immediate_check_handle\u662f\u5b9e\u73b0Node.js\u4e2dsetImmediate\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5bf9\u5e94Libuv\u7684check\u9636\u6bb5\u3002 3 task_queues_async_\u7528\u4e8e\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u3002 1.3.4 \u521d\u59cb\u5316Loader\u548c\u6267\u884c\u4e0a\u4e0b\u6587 \u00b6 RunBootstrapping\u91cc\u8c03\u7528\u4e86BootstrapInternalLoaders\u548cBootstrapNode\u51fd\u6570\uff0c\u6211\u4eec\u4e00\u4e2a\u4e2a\u5206\u6790\u3002 1 \u521d\u59cb\u5316loader BootstrapInternalLoaders\u7528\u4e8e\u6267\u884cinternal/bootstrap/loaders.js\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u903b\u8f91\u3002\u9996\u5148\u5b9a\u4e49\u4e00\u4e2a\u53d8\u91cf\uff0c\u8be5\u53d8\u91cf\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\u6570\u7ec4\uff0c\u7528\u4e8e\u5b9a\u4e49\u51fd\u6570\u7684\u5f62\u53c2\u5217\u8868\uff0c\u4e00\u4f1a\u6211\u4eec\u4f1a\u770b\u5230\u5b83\u7684\u4f5c\u7528\u3002 1 2 3 4 5 std :: vector < Local < String >> loaders_params = { process_string (), FIXED_ONE_BYTE_STRING ( isolate_ , \"getLinkedBinding\" ), FIXED_ONE_BYTE_STRING ( isolate_ , \"getInternalBinding\" ), primordials_string ()}; \u7136\u540e\u518d\u5b9a\u4e49\u4e00\u4e2a\u53d8\u91cf\uff0c\u662f\u4e00\u4e2a\u5bf9\u8c61\u6570\u7ec4\uff0c\u7528\u4f5c\u6267\u884c\u51fd\u6570\u65f6\u7684\u5b9e\u53c2\u3002 1 2 3 4 5 6 7 8 9 std :: vector < Local < Value >> loaders_args = { process_object (), NewFunctionTemplate ( binding :: GetLinkedBinding ) -> GetFunction ( context ()) . ToLocalChecked (), NewFunctionTemplate ( binding :: GetInternalBinding ) -> GetFunction ( context ()) . ToLocalChecked (), primordials ()}; \u63a5\u7740Node.js\u7f16\u8bd1\u6267\u884cinternal/bootstrap/loaders.js\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u94fe\u8def\u975e\u5e38\u957f\uff0c\u6700\u540e\u5230V8\u5c42\uff0c\u5c31\u4e0d\u8d34\u51fa\u5177\u4f53\u7684\u4ee3\u7801\uff0c\u5177\u4f53\u7684\u903b\u8f91\u8f6c\u6210JS\u5982\u4e0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function demo ( process , getLinkedBinding , getInternalBinding , primordials ) { // internal/bootstrap/loaders.js \u7684\u4ee3\u7801 } const process = {}; function getLinkedBinding (){} function getInternalBinding () {} const primordials = {}; const export = demo ( process , getLinkedBinding , getInternalBinding , primordials ); V8\u628ainternal/bootstrap/loaders.js\u7528\u4e00\u4e2a\u51fd\u6570\u5305\u88f9\u8d77\u6765\uff0c\u5f62\u53c2\u5c31\u662floaders_params\u53d8\u91cf\u5bf9\u5e94\u7684\u56db\u4e2a\u5b57\u7b26\u4e32\u3002\u7136\u540e\u6267\u884c\u8fd9\u4e2a\u51fd\u6570\uff0c\u5e76\u4e14\u4f20\u5165loaders_args\u91cc\u7684\u90a3\u56db\u4e2a\u5bf9\u8c61\u3002internal/bootstrap/loaders.js\u4f1a\u5bfc\u51fa\u4e00\u4e2a\u5bf9\u8c61\u3002\u5728\u770binternal/bootstrap/loaders.js\u4ee3\u7801\u4e4b\u524d\uff0c\u6211\u4eec\u5148\u770b\u4e00\u4e0bgetLinkedBinding, getInternalBinding\u8fd9\u4e24\u4e2a\u51fd\u6570\uff0cNode.js\u5728C++\u5c42\u5bf9\u5916\u66b4\u9732\u4e86AddLinkedBinding\u65b9\u6cd5\u6ce8\u518c\u6a21\u5757\uff0cNode.js\u9488\u5bf9\u8fd9\u79cd\u7c7b\u578b\u7684\u6a21\u5757\uff0c\u7ef4\u62a4\u4e86\u4e00\u4e2a\u5355\u72ec\u7684\u94fe\u8868\u3002getLinkedBinding\u5c31\u662f\u6839\u636e\u6a21\u5757\u540d\u4ece\u8fd9\u4e2a\u94fe\u8868\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u6a21\u5757\uff0c\u4f46\u662f\u6211\u4eec\u4e00\u822c\u7528\u4e0d\u5230\u8fd9\u4e2a\uff0c\u6240\u4ee5\u5c31\u4e0d\u6df1\u5165\u5206\u6790\u3002\u524d\u9762\u6211\u4eec\u770b\u5230\u5bf9\u4e8eC++\u5185\u7f6e\u6a21\u5757\uff0cNode.js\u540c\u6837\u7ef4\u62a4\u4e86\u4e00\u4e2a\u94fe\u8868\uff0cgetInternalBinding\u5c31\u662f\u6839\u636e\u6a21\u5757\u540d\u4ece\u8fd9\u4e2a\u94fe\u8868\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u6a21\u5757\u3002\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u5177\u4f53\u770b\u4e00\u4e0binternal/bootstrap/loaders.js\u7684\u4ee3\u7801\u4e86\u3002 1 2 3 4 5 6 7 8 9 10 11 12 let internalBinding ; { const bindingObj = ObjectCreate ( null ); internalBinding = function internalBinding ( module ) { let mod = bindingObj [ module ]; if ( typeof mod !== 'object' ) { mod = bindingObj [ module ] = getInternalBinding ( module ); moduleLoadList . push ( `Internal Binding ${ module } ` ); } return mod ; }; } Node.js\u5728JS\u5bf9getInternalBinding\u8fdb\u884c\u4e86\u4e00\u4e2a\u5c01\u88c5\uff0c\u4e3b\u8981\u662f\u52a0\u4e86\u7f13\u5b58\u5904\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const internalBindingWhitelist = new SafeSet ([, 'tcp_wrap' , // \u4e00\u7cfb\u5217C++\u5185\u7f6e\u6a21\u5757\u540d ]); { const bindingObj = ObjectCreate ( null ); process . binding = function binding ( module ) { module = String ( module ); if ( internalBindingWhitelist . has ( module )) { return internalBinding ( module ); } throw new Error ( `No such module: ${ module } ` ); }; } \u5728process\u5bf9\u8c61\uff08\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u4f7f\u7528\u7684process\u5bf9\u8c61\uff09\u4e2d\u6302\u8f7dbinding\u51fd\u6570\uff0c\u8fd9\u4e2a\u51fd\u6570\u4e3b\u8981\u7528\u4e8e\u5185\u7f6e\u7684JS\u6a21\u5757\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u7ecf\u5e38\u770b\u5230\u3002binding\u7684\u903b\u8f91\u5c31\u662f\u6839\u636e\u6a21\u5757\u540d\u67e5\u627e\u5bf9\u5e94\u7684C++\u6a21\u5757\u3002\u4e0a\u9762\u7684\u5904\u7406\u662f\u4e3a\u4e86Node.js\u80fd\u5728JS\u5c42\u901a\u8fc7binding\u51fd\u6570\u52a0\u8f7dC++\u6a21\u5757\uff0c\u6211\u4eec\u77e5\u9053Node.js\u4e2d\u8fd8\u6709\u539f\u751f\u7684JS\u6a21\u5757\uff08lib\u6587\u4ef6\u5939\u4e0b\u7684JS\u6587\u4ef6\uff09\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0b\uff0c\u5bf9\u4e8e\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u7684\u5904\u7406\u3002Node.js\u5b9a\u4e49\u4e86\u4e00\u4e2aNativeModule\u7c7b\u8d1f\u8d23\u539f\u751fJS\u6a21\u5757\u7684\u52a0\u8f7d\u3002\u8fd8\u5b9a\u4e49\u4e86\u4e00\u4e2a\u53d8\u91cf\u4fdd\u5b58\u4e86\u539f\u751fJS\u6a21\u5757\u7684\u540d\u79f0\u5217\u8868\u3002 1 static map = new Map ( moduleIds . map (( id ) => [ id , new NativeModule ( id )])); NativeModule\u4e3b\u8981\u7684\u903b\u8f91\u5982\u4e0b 1 \u539f\u751fJS\u6a21\u5757\u7684\u4ee3\u7801\u662f\u8f6c\u6210\u5b57\u7b26\u5b58\u5728node_javascript.cc\u6587\u4ef6\u7684\uff0cNativeModule\u8d1f\u8d23\u539f\u751fJS\u6a21\u5757\u7684\u52a0\u8f7d\uff0c\u5373\u7f16\u8bd1\u548c\u6267\u884c\u3002 2 \u63d0\u4f9b\u4e00\u4e2arequire\u51fd\u6570\uff0c\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\uff0c\u5bf9\u4e8e\u6587\u4ef6\u8def\u5f84\u4ee5internal\u5f00\u5934\u7684\u6a21\u5757\uff0c\u662f\u4e0d\u80fd\u88ab\u7528\u6237require\u4f7f\u7528\u7684\u3002 \u8fd9\u662f\u539f\u751fJS\u6a21\u5757\u52a0\u8f7d\u7684\u5927\u6982\u903b\u8f91\uff0c\u5177\u4f53\u7684\u6211\u4eec\u5728Node.js\u6a21\u5757\u52a0\u8f7d\u7ae0\u8282\u5177\u4f53\u5206\u6790\u3002\u6267\u884c\u5b8cinternal/bootstrap/loaders.js\uff0c\u6700\u540e\u8fd4\u56de\u4e09\u4e2a\u53d8\u91cf\u7ed9C++\u5c42\u3002 1 2 3 4 5 return { internalBinding , NativeModule , require : nativeModuleRequire }; C++\u5c42\u4fdd\u5b58\u5176\u4e2d\u4e24\u4e2a\u51fd\u6570\uff0c\u5206\u522b\u7528\u4e8e\u52a0\u8f7d\u5185\u7f6eC++\u6a21\u5757\u548c\u539f\u751fJS\u6a21\u5757\u7684\u51fd\u6570\u3002 1 2 set_internal_binding_loader ( internal_binding_loader . As < Function > ()); set_native_module_require ( require . As < Function > ()); \u81f3\u6b64\uff0cinternal/bootstrap/loaders.js\u5206\u6790\u5b8c\u4e86\u3002 2 \u521d\u59cb\u5316\u6267\u884c\u4e0a\u4e0b\u6587 BootstrapNode\u8d1f\u8d23\u521d\u59cb\u5316\u6267\u884c\u4e0a\u4e0b\u6587\uff0c\u4ee3\u7801\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 EscapableHandleScope scope ( isolate_ ); // \u83b7\u53d6\u5168\u5c40\u53d8\u91cf\u5e76\u8bbe\u7f6eglobal\u5c5e\u6027 Local < Object > global = context () -> Global (); global -> Set ( context (), FIXED_ONE_BYTE_STRING ( isolate_ , \"global\" ), global ). Check (); /* \u6267\u884cinternal/bootstrap/node.js\u65f6\u7684\u53c2\u6570 process, require, internalBinding, primordials */ std :: vector < Local < String >> node_params = { process_string (), require_string (), internal_binding_string (), primordials_string ()}; std :: vector < Local < Value >> node_args = { process_object (), // \u539f\u751f\u6a21\u5757\u52a0\u8f7d\u5668 native_module_require (), // C++\u6a21\u5757\u52a0\u8f7d\u5668 internal_binding_loader (), primordials ()}; MaybeLocal < Value > result = ExecuteBootstrapper ( this , \"internal/bootstrap/node\" , & node_params , & node_args ); \u5728\u5168\u5c40\u5bf9\u8c61\u4e0a\u8bbe\u7f6e\u4e00\u4e2aglobal\u5c5e\u6027\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u5728Node.js\u4e2d\u4f7f\u7528\u7684global\u5bf9\u8c61\u3002\u63a5\u7740\u6267\u884cinternal/bootstrap/node.js\u8bbe\u7f6e\u4e00\u4e9b\u53d8\u91cf\uff08\u5177\u4f53\u53ef\u4ee5\u53c2\u8003nternal/bootstrap/node.js\uff09\u3002 1 2 3 4 5 process . cpuUsage = wrapped . cpuUsage ; process . resourceUsage = wrapped . resourceUsage ; process . memoryUsage = wrapped . memoryUsage ; process . kill = wrapped . kill ; process . exit = wrapped . exit ; \u8bbe\u7f6e\u5168\u5c40\u53d8\u91cf 1 2 3 4 5 6 7 8 9 10 defineOperation ( global , ' clearInterval ' , timers . clearInterval ); defineOperation ( global , ' clearTimeout ' , timers . clearTimeout ); defineOperation ( global , ' setInterval ' , timers . setInterval ); defineOperation ( global , ' setTimeout ' , timers . setTimeout ); ObjectDefineProperty ( global , ' process ' , { value : process , enumerable : false , writable : true , configurable : true }); 1.3.5 \u6267\u884c\u7528\u6237JS\u6587\u4ef6 \u00b6 StartMainThreadExecution\u8fdb\u884c\u4e00\u4e9b\u521d\u59cb\u5316\u5de5\u4f5c\uff0c\u7136\u540e\u6267\u884c\u7528\u6237JS\u4ee3\u7801\u3002 1 \u7ed9process\u5bf9\u8c61\u6302\u8f7d\u5c5e\u6027 \u6267\u884cpatchProcessObject\u51fd\u6570\uff08\u5728node_process_methods.cc\u4e2d\u5bfc\u51fa\uff09\u7ed9process\u5bf9\u8c61\u6302\u8f7d\u4e00\u4e9b\u5217\u5c5e\u6027\uff0c\u4e0d\u4e00\u4e00\u5217\u4e3e\u3002 1 2 3 4 5 6 7 8 // process.argv process -> Set ( context , FIXED_ONE_BYTE_STRING ( isolate , \"argv\" ), ToV8Value ( context , env -> argv ()). ToLocalChecked ()). Check (); READONLY_PROPERTY ( process , \"pid\" , Integer :: New ( isolate , uv_os_getpid ())); \u56e0\u4e3aNode.js\u589e\u52a0\u4e86\u5bf9\u7ebf\u7a0b\u7684\u652f\u6301\uff0c\u6709\u4e9b\u5c5e\u6027\u9700\u8981hack\u4e00\u4e0b\uff0c\u6bd4\u5982\u5728\u7ebf\u7a0b\u91cc\u4f7f\u7528process.exit\u7684\u65f6\u5019\uff0c\u9000\u51fa\u7684\u662f\u5355\u4e2a\u7ebf\u7a0b\uff0c\u800c\u4e0d\u662f\u6574\u4e2a\u8fdb\u7a0b\uff0cexit\u7b49\u51fd\u6570\u9700\u8981\u7279\u6b8a\u5904\u7406\u3002\u540e\u9762\u7ae0\u8282\u4f1a\u8be6\u7ec6\u8bb2\u89e3\u3002 2 \u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1 1 2 3 4 5 6 7 8 9 10 function setupChildProcessIpcChannel () { if ( process . env . NODE_CHANNEL_FD ) { const fd = parseInt ( process . env . NODE_CHANNEL_FD , 10 ); delete process . env . NODE_CHANNEL_FD ; const serializationMode = process . env . NODE_CHANNEL_SERIALIZATION_MODE || 'json' ; delete process . env . NODE_CHANNEL_SERIALIZATION_MODE ; require ( 'child_process' ). _forkChild ( fd , serializationMode ); } } \u73af\u5883\u53d8\u91cfNODE_CHANNEL_FD\u662f\u5728\u521b\u5efa\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\u8bbe\u7f6e\u7684\uff0c\u5982\u679c\u6709\u8bf4\u660e\u5f53\u524d\u542f\u52a8\u7684\u8fdb\u7a0b\u662f\u5b50\u8fdb\u7a0b\uff0c\u5219\u9700\u8981\u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1\u3002 3 \u5904\u7406cluster\u6a21\u5757\u7684\u8fdb\u7a0b\u95f4\u901a\u4fe1 1 2 3 4 5 6 7 function initializeclusterIPC () { if ( process . argv [ 1 ] && process . env . NODE_UNIQUE_ID ) { const cluster = require ( 'cluster' ); cluster . _setupWorker (); delete process . env . NODE_UNIQUE_ID ; } } 4 \u6267\u884c\u7528\u6237JS\u4ee3\u7801 1 require ( 'internal/modules/cjs/loader' ). Module . runMain ( process . argv [ 1 ]); internal/modules/cjs/loader.js\u662f\u8d1f\u8d23\u52a0\u8f7d\u7528\u6237JS\u7684\u6a21\u5757\uff0crunMain\u51fd\u6570\u5728pre_execution.js\u88ab\u6302\u8f7d\uff0crunMain\u505a\u7684\u4e8b\u60c5\u662f\u52a0\u8f7d\u7528\u6237\u7684JS\uff0c\u7136\u540e\u6267\u884c\u3002\u5177\u4f53\u7684\u8fc7\u7a0b\u5728\u540e\u9762\u7ae0\u8282\u8be6\u7ec6\u5206\u6790\u3002 1.3.6 \u8fdb\u5165Libuv\u4e8b\u4ef6\u5faa\u73af \u00b6 \u6267\u884c\u5b8c\u6240\u6709\u7684\u521d\u59cb\u5316\u540e\uff0cNode.js\u6267\u884c\u4e86\u7528\u6237\u7684JS\u4ee3\u7801\uff0c\u7528\u6237\u7684JS\u4ee3\u7801\u4f1a\u5f80Libuv\u6ce8\u518c\u4e00\u4e9b\u4efb\u52a1\uff0c\u6bd4\u5982\u521b\u5efa\u4e00\u4e2a\u670d\u52a1\u5668\uff0c\u6700\u540eNode.js\u8fdb\u5165Libuv\u7684\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u5f00\u59cb\u4e00\u8f6e\u53c8\u4e00\u8f6e\u7684\u4e8b\u4ef6\u5faa\u73af\u5904\u7406\u3002\u5982\u679c\u6ca1\u6709\u9700\u8981\u5904\u7406\u7684\u4efb\u52a1\uff0cLibuv\u4f1a\u9000\u51fa\uff0c\u4ece\u800cNode.js\u9000\u51fa\u3002 1 2 3 4 5 6 7 8 9 10 do { uv_run ( env -> event_loop (), UV_RUN_DEFAULT ); per_process :: v8_platform . DrainVMTasks ( isolate_ ); more = uv_loop_alive ( env -> event_loop ()); if ( more && ! env -> is_stopping ()) continue ; if ( ! uv_loop_alive ( env -> event_loop ())) { EmitBeforeExit ( env . get ()); } more = uv_loop_alive ( env -> event_loop ()); } while ( more == true && ! env -> is_stopping ()); 1.4 Node.js\u548c\u5176\u5b83\u670d\u52a1\u5668\u7684\u6bd4\u8f83 \u00b6 \u670d\u52a1\u5668\u662f\u73b0\u4ee3\u8f6f\u4ef6\u4e2d\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2a\u7ec4\u6210\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u670d\u52a1\u5668\u53d1\u5c55\u7684\u8fc7\u7a0b\u4e2d\uff0c\u90fd\u6709\u54ea\u4e9b\u8bbe\u8ba1\u67b6\u6784\u3002\u4e00\u4e2a\u57fa\u4e8eTCP\u534f\u8bae\u7684\u670d\u52a1\u5668\uff0c\u57fa\u672c\u7684\u6d41\u7a0b\u5982\u4e0b\uff08\u4f2a\u4ee3\u7801\uff09\u3002 1 2 3 4 5 6 // \u62ff\u5230\u4e00\u4e2asocket\u7528\u4e8e\u76d1\u542c const socketfd = socket ( \u534f\u8bae\u7c7b\u578b\u7b49\u914d\u7f6e ); // \u76d1\u542c\u672c\u673a\u7684\u5730\u5740\uff08ip+\u7aef\u53e3\uff09 bind ( socketfd \uff0c \u76d1\u542c\u5730\u5740 ) // \u6807\u8bb0\u8be5socket\u662f\u76d1\u542c\u578bsocket listen ( socketfd ) \u6267\u884c\u5b8c\u4ee5\u4e0a\u6b65\u9aa4\uff0c\u4e00\u4e2a\u670d\u52a1\u5668\u6b63\u5f0f\u5f00\u59cb\u670d\u52a1\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u57fa\u4e8e\u4e0a\u9762\u7684\u6a21\u578b\uff0c\u5206\u6790\u5404\u79cd\u5404\u6837\u7684\u5904\u7406\u65b9\u6cd5\u3002 1.4.1 \u4e32\u884c\u5904\u7406\u8bf7\u6c42 \u00b6 1 2 3 4 5 6 while ( 1 ) { const socketForCommunication = accept ( socket ); const data = read ( socketForCommunication ); handle ( data ); write ( socketForCommunication , data ); } \u6211\u4eec\u770b\u770b\u8fd9\u79cd\u6a21\u5f0f\u7684\u5904\u7406\u8fc7\u7a0b\uff0c\u5047\u8bbe\u6709n\u4e2a\u8bf7\u6c42\u5230\u6765\u3002\u90a3\u4e48socket\u7684\u7ed3\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u8fd9\u65f6\u5019\u8fdb\u7a0b\u4eceaccept\u4e2d\u88ab\u5524\u9192\u3002\u7136\u540e\u62ff\u5230\u4e00\u4e2a\u65b0\u7684socket\u7528\u4e8e\u901a\u4fe1\u3002\u7ed3\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 accept\u5c31\u662f\u4ece\u5df2\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u7684\u8fde\u63a5\u961f\u5217\u91cc\uff0c\u6458\u4e0b\u4e00\u4e2a\u8282\u70b9\u3002\u5f88\u591a\u540c\u5b66\u90fd\u4e86\u89e3\u4e09\u6b21\u63e1\u624b\u662f\u4ec0\u4e48\uff0c\u4f46\u662f\u53ef\u80fd\u5f88\u5c11\u540c\u5b66\u4f1a\u6df1\u5165\u601d\u8003\u6216\u8005\u770b\u5b83\u7684\u5b9e\u73b0\uff0c\u4f17\u6240\u5468\u77e5\uff0c\u4e00\u4e2a\u670d\u52a1\u5668\u542f\u52a8\u7684\u65f6\u5019\uff0c\u4f1a\u76d1\u542c\u4e00\u4e2a\u7aef\u53e3\uff0c\u5176\u5b9e\u5c31\u662f\u65b0\u5efa\u4e86\u4e00\u4e2asocket\u3002\u90a3\u4e48\u5982\u679c\u6709\u4e00\u4e2a\u8fde\u63a5\u5230\u6765\u7684\u65f6\u5019\uff0c\u6211\u4eec\u901a\u8fc7accept\u5c31\u80fd\u62ff\u5230\u8fd9\u4e2a\u65b0\u8fde\u63a5\u5bf9\u5e94\u7684socket\uff0c\u90a3\u8fd9\u4e2asocket\u548c\u76d1\u542c\u7684socket\u662f\u4e0d\u662f\u540c\u4e00\u4e2a\u5462\uff1f\u5176\u5b9esocket\u5206\u4e3a\u76d1\u542c\u578b\u548c\u901a\u4fe1\u578b\u7684\uff0c\u8868\u9762\u4e0a\uff0c\u670d\u52a1\u5668\u7528\u4e00\u4e2a\u7aef\u53e3\u5b9e\u73b0\u4e86\u591a\u4e2a\u8fde\u63a5\uff0c\u4f46\u662f\u8fd9\u4e2a\u7aef\u53e3\u662f\u7528\u4e8e\u76d1\u542c\u7684\uff0c\u5e95\u5c42\u7528\u4e8e\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5176\u5b9e\u662f\u53e6\u4e00\u4e2asocket\u3002\u6240\u4ee5\u6bcf\u4e00\u4e2a\u8fde\u63a5\u8fc7\u6765\uff0c\u8d1f\u8d23\u76d1\u542c\u7684socket\u53d1\u73b0\u662f\u4e00\u4e2a\u5efa\u7acb\u8fde\u63a5\u7684\u5305\uff08syn\u5305\uff09\uff0c\u5b83\u5c31\u4f1a\u751f\u6210\u4e00\u4e2a\u65b0\u7684socket\u4e0e\u4e4b\u901a\u4fe1\uff08accept\u7684\u65f6\u5019\u8fd4\u56de\u7684\u90a3\u4e2a\uff09\u3002\u76d1\u542csocket\u91cc\u53ea\u4fdd\u5b58\u4e86\u5b83\u76d1\u542c\u7684IP\u548c\u7aef\u53e3\uff0c\u901a\u4fe1socket\u9996\u5148\u4ece\u76d1\u542csocket\u4e2d\u590d\u5236IP\u548c\u7aef\u53e3\uff0c\u7136\u540e\u628a\u5ba2\u6237\u7aef\u7684IP\u548c\u7aef\u53e3\u4e5f\u8bb0\u5f55\u4e0b\u6765\uff0c\u5f53\u4e0b\u6b21\u6536\u5230\u4e00\u4e2a\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u6839\u636e\u56db\u5143\u7ec4\u4ecesocket\u6c60\u5b50\u91cc\u627e\u5230\u8be5socket\uff0c\u4ece\u800c\u5b8c\u6210\u6570\u636e\u7684\u5904\u7406\u3002 \u4e32\u884c\u8fd9\u79cd\u6a21\u5f0f\u5c31\u662f\u4ece\u5df2\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u7684\u961f\u5217\u91cc\u6458\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u7136\u540e\u5904\u7406\u3002\u518d\u6458\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u518d\u5904\u7406\u3002\u5982\u679c\u5904\u7406\u7684\u8fc7\u7a0b\u4e2d\u6709\u963b\u585e\u5f0fIO\uff0c\u53ef\u60f3\u800c\u77e5\uff0c\u6548\u7387\u662f\u6709\u591a\u4f4e\u3002\u800c\u4e14\u5e76\u53d1\u91cf\u6bd4\u8f83\u5927\u7684\u65f6\u5019\uff0c\u76d1\u542csocket\u5bf9\u5e94\u7684\u961f\u5217\u5f88\u5feb\u5c31\u4f1a\u88ab\u5360\u6ee1\uff08\u5df2\u5b8c\u6210\u8fde\u63a5\u961f\u5217\u6709\u4e00\u4e2a\u6700\u5927\u957f\u5ea6\uff09\u3002\u8fd9\u662f\u6700\u7b80\u5355\u7684\u6a21\u5f0f\uff0c\u867d\u7136\u670d\u52a1\u5668\u7684\u8bbe\u8ba1\u4e2d\u80af\u5b9a\u4e0d\u4f1a\u4f7f\u7528\u8fd9\u79cd\u6a21\u5f0f\uff0c\u4f46\u662f\u5b83\u8ba9\u6211\u4eec\u4e86\u89e3\u4e86\u4e00\u4e2a\u670d\u52a1\u5668\u5904\u7406\u8bf7\u6c42\u7684\u6574\u4f53\u8fc7\u7a0b\u3002 1.4.2 \u591a\u8fdb\u7a0b\u6a21\u5f0f \u00b6 \u4e32\u884c\u6a21\u5f0f\u4e2d\uff0c\u6240\u6709\u8bf7\u6c42\u90fd\u5728\u4e00\u4e2a\u8fdb\u7a0b\u4e2d\u6392\u961f\u88ab\u5904\u7406\uff0c\u8fd9\u662f\u6548\u7387\u4f4e\u4e0b\u7684\u539f\u56e0\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u628a\u8bf7\u6c42\u5206\u7ed9\u591a\u4e2a\u8fdb\u7a0b\u5904\u7406\u6765\u63d0\u4f9b\u6548\u7387\uff0c\u56e0\u4e3a\u5728\u4e32\u884c\u5904\u7406\u7684\u6a21\u5f0f\u4e2d\uff0c\u5982\u679c\u6709\u963b\u585e\u5f0fIO\u64cd\u4f5c\uff0c\u5b83\u5c31\u4f1a\u963b\u585e\u4e3b\u8fdb\u7a0b\uff0c\u4ece\u800c\u963b\u585e\u540e\u7eed\u8bf7\u6c42\u7684\u5904\u7406\u3002\u5728\u591a\u8fdb\u7a0b\u7684\u6a21\u5f0f\u4e0b\uff0c\u4e00\u4e2a\u8bf7\u6c42\u5982\u679c\u963b\u585e\u4e86\u8fdb\u7a0b\uff0c\u90a3\u4e48\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6302\u8d77\u8be5\u8fdb\u7a0b\uff0c\u63a5\u7740\u8c03\u5ea6\u5176\u5b83\u8fdb\u7a0b\u6267\u884c\uff0c\u90a3\u4e48\u5176\u5b83\u8fdb\u7a0b\u5c31\u53ef\u4ee5\u6267\u884c\u65b0\u7684\u4efb\u52a1\u3002\u591a\u8fdb\u7a0b\u6a21\u5f0f\u4e0b\u5206\u4e3a\u51e0\u79cd\u3002 1 \u4e3b\u8fdb\u7a0baccept\uff0c\u5b50\u8fdb\u7a0b\u5904\u7406\u8bf7\u6c42 \u8fd9\u79cd\u6a21\u5f0f\u4e0b\uff0c\u4e3b\u8fdb\u7a0b\u8d1f\u8d23\u6458\u53d6\u5df2\u5b8c\u6210\u8fde\u63a5\u7684\u8282\u70b9\uff0c\u7136\u540e\u628a\u8fd9\u4e2a\u8282\u70b9\u5bf9\u5e94\u7684\u8bf7\u6c42\u4ea4\u7ed9\u5b50\u8fdb\u7a0b\u5904\u7406\uff0c\u903b\u8f91\u5982\u4e0b\u3002 1 2 3 4 5 6 7 8 9 10 while ( 1 ) { const socketForCommunication = accept ( socket ); if ( fork () > 0 ) { continue ; // \u7236\u8fdb\u7a0b } else { // \u5b50\u8fdb\u7a0b handle ( socketForCommunication ); } } \u8fd9\u79cd\u6a21\u5f0f\u4e0b\uff0c\u6bcf\u6b21\u6765\u4e00\u4e2a\u8bf7\u6c42\uff0c\u5c31\u4f1a\u65b0\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u53bb\u5904\u7406\u3002\u8fd9\u79cd\u6a21\u5f0f\u6bd4\u4e32\u884c\u7684\u7a0d\u5fae\u597d\u4e86\u4e00\u70b9\uff0c\u6bcf\u4e2a\u8bf7\u6c42\u72ec\u7acb\u5904\u7406\uff0c\u5047\u8bbea\u8bf7\u6c42\u963b\u585e\u5728\u6587\u4ef6IO\uff0c\u90a3\u4e48\u4e0d\u4f1a\u5f71\u54cdb\u8bf7\u6c42\u7684\u5904\u7406\uff0c\u5c3d\u53ef\u80fd\u5730\u505a\u5230\u4e86\u5e76\u53d1\u3002\u5b83\u7684\u74f6\u9888\u5c31\u662f\u7cfb\u7edf\u7684\u8fdb\u7a0b\u6570\u6709\u9650\uff0c\u5982\u679c\u6709\u5927\u91cf\u7684\u8bf7\u6c42\uff0c\u7cfb\u7edf\u65e0\u6cd5\u625b\u5f97\u4f4f\uff0c\u518d\u8005\uff0c\u8fdb\u7a0b\u7684\u5f00\u9500\u5f88\u5927\uff0c\u5bf9\u4e8e\u7cfb\u7edf\u6765\u8bf4\u662f\u4e00\u4e2a\u6c89\u91cd\u7684\u8d1f\u62c5\u3002 2 \u8fdb\u7a0b\u6c60\u6a21\u5f0f \u5b9e\u65f6\u521b\u5efa\u548c\u9500\u6bc1\u8fdb\u7a0b\u5f00\u9500\u5927\uff0c\u6548\u7387\u4f4e\uff0c\u6240\u4ee5\u884d\u751f\u4e86\u8fdb\u7a0b\u6c60\u6a21\u5f0f\uff0c\u8fdb\u7a0b\u6c60\u6a21\u5f0f\u5c31\u662f\u670d\u52a1\u5668\u542f\u52a8\u7684\u65f6\u5019\uff0c\u9884\u5148\u521b\u5efa\u4e00\u5b9a\u6570\u91cf\u7684\u8fdb\u7a0b\uff0c\u4f46\u662f\u8fd9\u4e9b\u8fdb\u7a0b\u662fworker\u8fdb\u7a0b\u3002\u5b83\u4e0d\u8d1f\u8d23accept\u8bf7\u6c42\u3002\u5b83\u53ea\u8d1f\u8d23\u5904\u7406\u8bf7\u6c42\u3002\u4e3b\u8fdb\u7a0b\u8d1f\u8d23accept\uff0c\u5b83\u628aaccept\u8fd4\u56de\u7684socket\u4ea4\u7ed9worker\u8fdb\u7a0b\u5904\u7406\uff0c\u6a21\u5f0f\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u4f46\u662f\u548c1\u4e2d\u7684\u6a21\u5f0f\u76f8\u6bd4\uff0c\u8fdb\u7a0b\u6c60\u6a21\u5f0f\u76f8\u5bf9\u6bd4\u8f83\u590d\u6742\uff0c\u56e0\u4e3a\u5728\u6a21\u5f0f1\u4e2d\uff0c\u5f53\u4e3b\u8fdb\u7a0b\u6536\u5230\u4e00\u4e2a\u8bf7\u6c42\u7684\u65f6\u5019\uff0c\u5b9e\u65f6fork\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u8fd9\u65f6\u5019\uff0c\u8fd9\u4e2a\u5b50\u8fdb\u7a0b\u4f1a\u7ee7\u627f\u4e3b\u8fdb\u7a0b\u4e2d\u65b0\u8bf7\u6c42\u5bf9\u5e94\u7684fd\uff0c\u6240\u4ee5\u5b83\u53ef\u4ee5\u76f4\u63a5\u5904\u7406\u8be5fd\u5bf9\u5e94\u7684\u8bf7\u6c42\uff0c\u5728\u8fdb\u7a0b\u6c60\u7684\u6a21\u5f0f\u4e2d\uff0c\u5b50\u8fdb\u7a0b\u662f\u9884\u5148\u521b\u5efa\u7684\uff0c\u5f53\u4e3b\u8fdb\u7a0b\u6536\u5230\u4e00\u4e2a\u8bf7\u6c42\u7684\u65f6\u5019\uff0c\u5b50\u8fdb\u7a0b\u4e2d\u662f\u65e0\u6cd5\u62ff\u5f97\u5230\u8be5\u8bf7\u6c42\u5bf9\u5e94\u7684fd\u7684\u3002\u8fd9\u65f6\u5019\uff0c\u9700\u8981\u4e3b\u8fdb\u7a0b\u4f7f\u7528\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u6280\u672f\u628a\u8fd9\u4e2a\u8bf7\u6c42\u5bf9\u5e94\u7684fd\u4f20\u7ed9\u5b50\u8fdb\u7a0b\u3002\u4e00\u4e2a\u8fdb\u7a0b\u5176\u5b9e\u5c31\u662f\u4e00\u4e2a\u7ed3\u6784\u4f53task_struct\uff0c\u5728JS\u91cc\u6211\u4eec\u53ef\u4ee5\u8bf4\u662f\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5b83\u6709\u4e00\u4e2a\u5b57\u6bb5\u8bb0\u5f55\u4e86\u6253\u5f00\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5f53\u6211\u4eec\u8bbf\u95ee\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u6839\u636efd\u7684\u503c\uff0c\u4ecetask_struct\u4e2d\u627e\u5230fd\u5bf9\u5e94\u7684\u5e95\u5c42\u8d44\u6e90\uff0c\u6240\u4ee5\u4e3b\u8fdb\u7a0b\u7ed9\u5b50\u8fdb\u7a0b\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u65f6\u5019\uff0c\u4f20\u9012\u7684\u4e0d\u4ec5\u4ec5\u662f\u4e00\u4e2a\u6570\u5b57fd\uff0c\u56e0\u4e3a\u5982\u679c\u4ec5\u4ec5\u8fd9\u6837\u505a\uff0c\u5728\u5b50\u8fdb\u7a0b\u4e2d\u8be5fd\u53ef\u80fd\u6ca1\u6709\u5bf9\u5e94\u4efb\u4f55\u8d44\u6e90\uff0c\u6216\u8005\u5bf9\u5e94\u7684\u8d44\u6e90\u548c\u4e3b\u8fdb\u7a0b\u4e2d\u7684\u662f\u4e0d\u4e00\u81f4\u7684\u3002\u8fd9\u5176\u4e2d\u64cd\u4f5c\u7cfb\u7edf\u5e2e\u6211\u4eec\u505a\u4e86\u5f88\u591a\u4e8b\u60c5\u3002\u8ba9\u6211\u4eec\u5728\u5b50\u8fdb\u7a0b\u4e2d\u53ef\u4ee5\u901a\u8fc7fd\u8bbf\u95ee\u5230\u6b63\u786e\u7684\u8d44\u6e90\uff0c\u5373\u4e3b\u8fdb\u7a0b\u4e2d\u6536\u5230\u7684\u8bf7\u6c42\u3002 3 \u5b50\u8fdb\u7a0baccept \u8fd9\u79cd\u6a21\u5f0f\u4e0d\u662f\u7b49\u5230\u8bf7\u6c42\u6765\u7684\u65f6\u5019\u518d\u521b\u5efa\u8fdb\u7a0b\u3002\u800c\u662f\u5728\u670d\u52a1\u5668\u542f\u52a8\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u521b\u5efa\u591a\u4e2a\u8fdb\u7a0b\u3002\u7136\u540e\u591a\u4e2a\u8fdb\u7a0b\u5206\u522b\u8c03\u7528accept\u3002\u8fd9\u79cd\u6a21\u5f0f\u7684\u67b6\u6784\u5982\u56fe1-8\u6240\u793a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const socketfd = socket ( \u534f\u8bae\u7c7b\u578b\u7b49\u914d\u7f6e ); bind ( socketfd \uff0c \u76d1\u542c\u5730\u5740 ) for ( let i = 0 ; i < \u8fdb\u7a0b\u4e2a\u6570 ; i ++ ) { if ( fork () > 0 ) { // \u7236\u8fdb\u7a0b\u8d1f\u8d23\u76d1\u63a7\u5b50\u8fdb\u7a0b } else { // \u5b50\u8fdb\u7a0b\u5904\u7406\u8bf7\u6c42 listen ( socketfd ); while ( 1 ) { const socketForCommunication = accept ( socketfd ); handle ( socketForCommunication ); } } } \u8fd9\u79cd\u6a21\u5f0f\u4e0b\u591a\u4e2a\u5b50\u8fdb\u7a0b\u90fd\u963b\u585e\u5728accept\u3002\u5982\u679c\u8fd9\u65f6\u5019\u6709\u4e00\u4e2a\u8bf7\u6c42\u5230\u6765\uff0c\u90a3\u4e48\u6240\u6709\u7684\u5b50\u8fdb\u7a0b\u90fd\u4f1a\u88ab\u5524\u9192\uff0c\u4f46\u662f\u9996\u5148\u88ab\u8c03\u5ea6\u7684\u5b50\u8fdb\u7a0b\u4f1a\u9996\u5148\u6458\u4e0b\u8fd9\u4e2a\u8bf7\u6c42\u8282\u70b9\uff0c\u540e\u7eed\u7684\u8fdb\u7a0b\u88ab\u5524\u9192\u540e\u53ef\u80fd\u4f1a\u9047\u5230\u5df2\u7ecf\u6ca1\u6709\u8bf7\u6c42\u53ef\u4ee5\u5904\u7406\uff0c\u53c8\u8fdb\u5165\u7761\u7720\uff0c\u8fdb\u7a0b\u88ab\u65e0\u6548\u5524\u9192\uff0c\u8fd9\u662f\u8457\u540d\u7684\u60ca\u7fa4\u73b0\u8c61\u3002\u6539\u8fdb\u65b9\u5f0f\u5c31\u662f\u5728accpet\u4e4b\u524d\u52a0\u9501\uff0c\u62ff\u5230\u9501\u7684\u8fdb\u7a0b\u624d\u80fd\u8fdb\u884caccept\uff0c\u8fd9\u6837\u5c31\u4fdd\u8bc1\u4e86\u53ea\u6709\u4e00\u4e2a\u8fdb\u7a0b\u4f1a\u963b\u585e\u5728accept\uff0cNginx\u89e3\u51b3\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0c\u4f46\u662f\u65b0\u7248\u64cd\u4f5c\u7cfb\u7edf\u5df2\u7ecf\u5728\u5185\u6838\u5c42\u9762\u89e3\u51b3\u4e86\u8fd9\u4e2a\u95ee\u9898\u3002\u6bcf\u6b21\u53ea\u4f1a\u5524\u9192\u4e00\u4e2a\u8fdb\u7a0b\u3002\u901a\u5e38\u8fd9\u79cd\u6a21\u5f0f\u548c\u4e8b\u4ef6\u9a71\u52a8\u914d\u5408\u4f7f\u7528\u3002 1.4.3 \u591a\u7ebf\u7a0b\u6a21\u5f0f \u00b6 \u591a\u7ebf\u7a0b\u6a21\u5f0f\u548c\u591a\u8fdb\u7a0b\u6a21\u5f0f\u662f\u7c7b\u4f3c\u7684\uff0c\u4e5f\u662f\u5206\u4e3a\u4e0b\u9762\u51e0\u79cd 1 \u4e3b\u8fdb\u7a0baccept\uff0c\u521b\u5efa\u5b50\u7ebf\u7a0b\u5904\u7406 2 \u5b50\u7ebf\u7a0baccept 3 \u7ebf\u7a0b\u6c60 \u524d\u9762\u4e24\u79cd\u548c\u591a\u8fdb\u7a0b\u6a21\u5f0f\u4e2d\u662f\u4e00\u6837\u7684\uff0c\u4f46\u662f\u7b2c\u4e09\u79cd\u6bd4\u8f83\u7279\u522b\uff0c\u6211\u4eec\u4e3b\u8981\u4ecb\u7ecd\u7b2c\u4e09\u79cd\u3002\u5728\u5b50\u8fdb\u7a0b\u6a21\u5f0f\u65f6\uff0c\u6bcf\u4e2a\u5b50\u8fdb\u7a0b\u90fd\u6709\u81ea\u5df1\u7684task_struct\uff0c\u8fd9\u5c31\u610f\u5473\u7740\u5728fork\u4e4b\u540e\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u8d1f\u8d23\u7ef4\u62a4\u81ea\u5df1\u7684\u6570\u636e\uff0c\u800c\u7ebf\u7a0b\u5219\u4e0d\u4e00\u6837\uff0c\u7ebf\u7a0b\u662f\u5171\u4eab\u4e3b\u7ebf\u7a0b\uff08\u4e3b\u8fdb\u7a0b\uff09\u7684\u6570\u636e\u7684\uff0c\u5f53\u4e3b\u8fdb\u7a0b\u4eceaccept\u4e2d\u62ff\u5230\u4e00\u4e2afd\u7684\u65f6\u5019\uff0c\u4f20\u7ed9\u7ebf\u7a0b\u7684\u8bdd\uff0c\u7ebf\u7a0b\u662f\u53ef\u4ee5\u76f4\u63a5\u64cd\u4f5c\u7684\u3002\u6240\u4ee5\u5728\u7ebf\u7a0b\u6c60\u6a21\u5f0f\u65f6\uff0c\u67b6\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u4e3b\u8fdb\u7a0b\u8d1f\u8d23accept\u8bf7\u6c42\uff0c\u7136\u540e\u901a\u8fc7\u4e92\u65a5\u7684\u65b9\u5f0f\u63d2\u5165\u4e00\u4e2a\u4efb\u52a1\u5230\u5171\u4eab\u961f\u5217\u4e2d\uff0c\u7ebf\u7a0b\u6c60\u4e2d\u7684\u5b50\u7ebf\u7a0b\u540c\u6837\u662f\u901a\u8fc7\u4e92\u65a5\u7684\u65b9\u5f0f\uff0c\u4ece\u5171\u4eab\u961f\u5217\u4e2d\u6458\u53d6\u8282\u70b9\u8fdb\u884c\u5904\u7406\u3002 1.4.4 \u4e8b\u4ef6\u9a71\u52a8 \u00b6 \u73b0\u5728\u5f88\u591a\u670d\u52a1\u5668\uff08Nginx\uff0cNode.js\uff0cRedis\uff09\u90fd\u5f00\u59cb\u4f7f\u7528\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5f0f\u53bb\u8bbe\u8ba1\u3002\u4ece\u4e4b\u524d\u7684\u8bbe\u8ba1\u6a21\u5f0f\u4e2d\u6211\u4eec\u77e5\u9053\uff0c\u4e3a\u4e86\u5e94\u5bf9\u5927\u91cf\u7684\u8bf7\u6c42\uff0c\u670d\u52a1\u5668\u9700\u8981\u5927\u91cf\u7684\u8fdb\u7a0b/\u7ebf\u7a0b\u3002\u8fd9\u4e2a\u662f\u4e2a\u975e\u5e38\u5927\u7684\u5f00\u9500\u3002\u800c\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5f0f\uff0c\u4e00\u822c\u662f\u914d\u5408\u5355\u8fdb\u7a0b\uff08\u5355\u7ebf\u7a0b\uff09\uff0c\u518d\u591a\u7684\u8bf7\u6c42\uff0c\u4e5f\u662f\u5728\u4e00\u4e2a\u8fdb\u7a0b\u91cc\u5904\u7406\u7684\u3002\u4f46\u662f\u56e0\u4e3a\u662f\u5355\u8fdb\u7a0b\uff0c\u6240\u4ee5\u4e0d\u9002\u5408CPU\u5bc6\u96c6\u578b\uff0c\u56e0\u4e3a\u4e00\u4e2a\u4efb\u52a1\u4e00\u76f4\u5728\u5360\u636eCPU\u7684\u8bdd\uff0c\u540e\u7eed\u7684\u4efb\u52a1\u5c31\u65e0\u6cd5\u6267\u884c\u4e86\u3002\u5b83\u66f4\u9002\u5408IO\u5bc6\u96c6\u7684\uff08\u4e00\u822c\u90fd\u4f1a\u63d0\u4f9b\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u8d1f\u8d23\u5904\u7406CPU\u6216\u8005\u963b\u585e\u578b\u7684\u4efb\u52a1\uff09\u3002\u800c\u4f7f\u7528\u591a\u8fdb\u7a0b/\u7ebf\u7a0b\u6a21\u5f0f\u7684\u65f6\u5019\uff0c\u4e00\u4e2a\u8fdb\u7a0b/\u7ebf\u7a0b\u662f\u65e0\u6cd5\u4e00\u76f4\u5360\u636eCPU\u7684\uff0c\u6267\u884c\u4e00\u5b9a\u65f6\u95f4\u540e\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6267\u884c\u4efb\u52a1\u8c03\u5ea6\u3002\u8ba9\u5176\u5b83\u7ebf\u7a0b\u4e5f\u6709\u673a\u4f1a\u6267\u884c\uff0c\u8fd9\u6837\u5c31\u4e0d\u4f1a\u524d\u9762\u7684\u4efb\u52a1\u963b\u585e\u540e\u9762\u7684\u4efb\u52a1\uff0c\u51fa\u73b0\u9965\u997f\u60c5\u51b5\u3002\u5927\u90e8\u5206\u64cd\u4f5c\u7cfb\u7edf\u90fd\u63d0\u4f9b\u4e86\u4e8b\u4ef6\u9a71\u52a8\u7684API\u3002\u4f46\u662f\u4e8b\u4ef6\u9a71\u52a8\u5728\u4e0d\u540c\u7cfb\u7edf\u4e2d\u5b9e\u73b0\u4e0d\u4e00\u6837\u3002\u6240\u4ee5\u4e00\u822c\u90fd\u4f1a\u6709\u4e00\u5c42\u62bd\u8c61\u5c42\u62b9\u5e73\u8fd9\u4e2a\u5dee\u5f02\u3002\u8fd9\u91cc\u4ee5Linux\u7684epoll\u4e3a\u4f8b\u5b50\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // \u521b\u5efa\u4e00\u4e2aepoll var epollFD = epoll_create (); /* \u5728epoll\u7ed9\u67d0\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u6ce8\u518c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u8fd9\u91cc\u662f\u76d1\u542c\u7684socket\uff0c\u6ce8\u518c\u53ef \u8bfb\u4e8b\u4ef6\uff0c\u5373\u8fde\u63a5\u5230\u6765 event = { event: \u53ef\u8bfb fd\uff1a \u76d1\u542csocket // \u4e00\u4e9b\u4e0a\u4e0b\u6587 } */ epoll_ctl ( epollFD , EPOLL_CTL_ADD , socket , event ); while ( 1 ) { // \u963b\u585e\u7b49\u5f85\u4e8b\u4ef6\u5c31\u7eea\uff0cevents\u4fdd\u5b58\u5c31\u7eea\u4e8b\u4ef6\u7684\u4fe1\u606f\uff0ctotal\u662f\u4e2a\u6570 var total = epoll_wait ( epollFD , \u4fdd\u5b58\u5c31\u7eea\u4e8b\u4ef6\u7684\u7ed3\u6784 events , \u4e8b\u4ef6\u4e2a\u6570 , timeout ); for ( let i = 0 ; i < total ; i ++ ) { if ( events [ i ]. fd === \u76d1\u542c socket ) { var newSocket = accpet ( socket ); /* \u628a\u65b0\u7684socket\u4e5f\u6ce8\u518c\u5230epoll\uff0c\u7b49\u5f85\u53ef\u8bfb\uff0c \u5373\u53ef\u8bfb\u53d6\u5ba2\u6237\u7aef\u6570\u636e */ epoll_ctl ( epollFD , EPOLL_CTL_ADD , newSocket , \u53ef\u8bfb\u4e8b\u4ef6 ); } else { // \u4eceevents[i]\u4e2d\u62ff\u5230\u4e00\u4e9b\u4e0a\u4e0b\u6587\uff0c\u6267\u884c\u76f8\u5e94\u7684\u56de\u8c03 } } } \u8fd9\u5c31\u662f\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5f0f\u7684\u5927\u81f4\u8fc7\u7a0b\uff0c\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u8ba2\u9605/\u53d1\u5e03\u6a21\u5f0f\u3002\u670d\u52a1\u5668\u901a\u8fc7\u6ce8\u518c\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u4e8b\u4ef6\u5230epoll\u4e2d\uff0cepoll\u5f00\u59cb\u963b\u585e\uff0c\u7b49\u5230epoll\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u5b83\u4f1a\u544a\u8bc9\u670d\u52a1\u5668\u54ea\u4e9bfd\u7684\u54ea\u4e9b\u4e8b\u4ef6\u89e6\u53d1\u4e86\uff0c\u8fd9\u65f6\u5019\u670d\u52a1\u5668\u904d\u5386\u5c31\u7eea\u4e8b\u4ef6\uff0c\u7136\u540e\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\uff0c\u5728\u56de\u8c03\u91cc\u53ef\u4ee5\u518d\u6b21\u6ce8\u518c\u65b0\u7684\u4e8b\u4ef6\uff0c\u5c31\u662f\u8fd9\u6837\u4e0d\u65ad\u9a71\u52a8\u7740\u3002epoll\u7684\u539f\u7406\u5176\u5b9e\u4e5f\u7c7b\u4f3c\u4e8b\u4ef6\u9a71\u52a8\uff0cepoll\u5e95\u5c42\u7ef4\u62a4\u7528\u6237\u6ce8\u518c\u7684\u4e8b\u4ef6\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cepoll\u672c\u8eab\u4e5f\u4f1a\u5728\u6587\u4ef6\u63cf\u8ff0\u7b26\u5bf9\u5e94\u7684\u6587\u4ef6/socket/\u7ba1\u9053\u5904\u6ce8\u518c\u4e00\u4e2a\u56de\u8c03\uff0c\u7136\u540e\u81ea\u8eab\u8fdb\u5165\u963b\u585e\uff0c\u7b49\u5230\u522b\u4eba\u901a\u77e5epoll\u6709\u4e8b\u4ef6\u53d1\u751f\u7684\u65f6\u5019\uff0cepoll\u5c31\u4f1a\u628afd\u548c\u4e8b\u4ef6\u8fd4\u56de\u7ed9\u7528\u6237\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 function epoll_wait () { for \u4e8b\u4ef6\u4e2a\u6570 // \u8c03\u7528\u6587\u4ef6\u7cfb\u7edf\u7684\u51fd\u6570\u5224\u65ad if ( \u4e8b\u4ef6 [ i ] \u4e2d\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e2d\u6709\u67d0\u4e2a\u7528\u6237\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u53d1\u751f ? ) { \u63d2\u5165\u5c31\u7eea\u4e8b\u4ef6\u961f\u5217 } else { /* \u5728\u4e8b\u4ef6[i]\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u6240\u5bf9\u5e94\u7684\u6587\u4ef6/socket/\u7ba1\u9053\u7b49indeo\u8282 \u70b9\u6ce8\u518c\u56de\u8c03\u3002\u5373\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u89e6\u53d1\u540e\u56de\u8c03epoll\uff0c\u56de\u8c03epoll\u540e\uff0c epoll\u628a\u8be5event[i]\u63d2\u5165\u5c31\u7eea\u4e8b\u4ef6\u961f\u5217\u8fd4\u56de\u7ed9\u7528\u6237 */ } } \u4ee5\u4e0a\u5c31\u662f\u670d\u52a1\u5668\u8bbe\u8ba1\u7684\u4e00\u4e9b\u57fa\u672c\u4ecb\u7ecd\u3002\u73b0\u5728\u7684\u670d\u52a1\u5668\u7684\u8bbe\u8ba1\u4e2d\u8fd8\u4f1a\u6d89\u53ca\u5230\u534f\u7a0b\u3002\u4e0d\u8fc7\u76ee\u524d\u8fd8\u6ca1\u6709\u770b\u8fc7\u5177\u4f53\u7684\u5b9e\u73b0\uff0c\u6240\u4ee5\u6682\u4e0d\u5c55\u5f00\u4ecb\u7ecd\uff0c\u6709\u5174\u8da3\u7684\u901a\u4fe1\u53ef\u4ee5\u770b\u4e00\u4e0b\u534f\u7a0b\u5e93libtask\u4e86\u89e3\u4e00\u4e0b\u5982\u4f55\u4f7f\u7528\u534f\u7a0b\u5b9e\u73b0\u4e00\u4e2a\u670d\u52a1\u5668\u3002 Node.js\u662f\u57fa\u4e8e\u5355\u8fdb\u7a0b\uff08\u5355\u7ebf\u7a0b\uff09\u7684\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5f0f\u3002\u8fd9\u4e5f\u662f\u4e3a\u4ec0\u4e48Node.js\u64c5\u957f\u5904\u7406\u9ad8\u5e76\u53d1IO\u578b\u4efb\u52a1\u800c\u4e0d\u64c5\u957f\u5904\u7406CPU\u578b\u4efb\u52a1\u7684\u539f\u56e0\uff0cNginx\u3001Redis\u4e5f\u662f\u8fd9\u79cd\u6a21\u5f0f\u3002\u53e6\u5916Node.js\u662f\u4e00\u4e2a\u53caweb\u670d\u52a1\u5668\u548c\u5e94\u7528\u670d\u52a1\u5668\u4e8e\u4e00\u8eab\u7684\u670d\u52a1\u5668\uff0c\u50cfNginx\u8fd9\u79cd\u5c5e\u4e8eweb\u670d\u52a1\u5668\uff0c\u5b83\u4eec\u53ea\u5904\u7406HTTP\u534f\u8bae\uff0c\u4e0d\u5177\u5907\u811a\u672c\u8bed\u8a00\u6765\u5904\u7406\u5177\u4f53\u7684\u4e1a\u52a1\u903b\u8f91\u3002\u5b83\u9700\u8981\u628a\u8bf7\u6c42\u8f6c\u53d1\u5230\u771f\u6b63\u7684web\u670d\u52a1\u5668\u4e2d\u53bb\u5904\u7406\uff0c\u6bd4\u5982PHP\u3002\u800cNode.js\u4e0d\u4ec5\u53ef\u4ee5\u89e3\u6790HTTP\u534f\u8bae\uff0c\u8fd8\u53ef\u4ee5\u5904\u7406\u5177\u4f53\u7684\u4e1a\u52a1\u903b\u8f91\u3002","title":"01-Node.js\u7ec4\u6210\u548c\u539f\u7406"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#nodejs","text":"","title":"\u7b2c\u4e00\u7ae0 Node.js\u7ec4\u6210\u548c\u539f\u7406"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#11-nodejs","text":"Node.js\u662f\u57fa\u4e8e\u4e8b\u4ef6\u9a71\u52a8\u7684\u5355\u8fdb\u7a0b\u5355\u7ebf\u7a0b\u5e94\u7528\uff0c\u5355\u7ebf\u7a0b\u5177\u4f53\u4f53\u73b0\u5728Node.js\u5728\u5355\u4e2a\u7ebf\u7a0b\u4e2d\u7ef4\u62a4\u4e86\u4e00\u7cfb\u5217\u4efb\u52a1\uff0c\u7136\u540e\u5728\u4e8b\u4ef6\u5faa\u73af\u4e2d\u4e0d\u65ad\u6d88\u8d39\u4efb\u52a1\u961f\u5217\u4e2d\u7684\u8282\u70b9\uff0c\u53c8\u4e0d\u65ad\u4ea7\u751f\u65b0\u7684\u4efb\u52a1\uff0c\u5728\u4efb\u52a1\u7684\u4ea7\u751f\u548c\u6d88\u8d39\u4e2d\u4e0d\u65ad\u9a71\u52a8\u7740Node.js\u7684\u6267\u884c\u3002\u4ece\u53e6\u5916\u4e00\u4e2a\u89d2\u5ea6\u6765\u8bf4\uff0cNode.js\u53c8\u53ef\u4ee5\u8bf4\u662f\u591a\u7ebf\u7a0b\u7684\uff0c\u56e0\u4e3aNode.js\u5e95\u5c42\u4e5f\u7ef4\u62a4\u4e86\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u8be5\u7ebf\u7a0b\u6c60\u4e3b\u8981\u7528\u4e8e\u5904\u7406\u4e00\u4e9b\u6587\u4ef6IO\u3001DNS\u3001CPU\u8ba1\u7b97\u7b49\u4efb\u52a1\u3002 Node.js\u4e3b\u8981\u7531V8\u3001Libuv\uff0c\u8fd8\u6709\u4e00\u4e9b\u5176\u5b83\u7684\u7b2c\u4e09\u65b9\u6a21\u5757\u7ec4\u6210\uff08cares\u5f02\u6b65DNS\u89e3\u6790\u5e93\u3001HTTP\u89e3\u6790\u5668\u3001HTTP2\u89e3\u6790\u5668\uff0c\u538b\u7f29\u5e93\u3001\u52a0\u89e3\u5bc6\u5e93\u7b49\uff09\u3002Node.js\u6e90\u7801\u5206\u4e3a\u4e09\u5c42\uff0c\u5206\u522b\u662fJS\u3001C++\u3001C\uff0cLibuv\u662f\u4f7f\u7528C\u8bed\u8a00\u7f16\u5199\uff0cC++\u5c42\u4e3b\u8981\u662f\u901a\u8fc7V8\u4e3aJS\u5c42\u63d0\u4f9b\u548c\u5e95\u5c42\u4ea4\u4e92\u7684\u80fd\u529b\uff0cC++\u5c42\u4e5f\u5b9e\u73b0\u4e86\u90e8\u5206\u529f\u80fd\uff0cJS\u5c42\u662f\u9762\u5411\u7528\u6237\u7684\uff0c\u4e3a\u7528\u6237\u63d0\u4f9b\u8c03\u7528\u5e95\u5c42\u7684\u63a5\u53e3\u3002","title":"1.1 Node.js\u7b80\u4ecb"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#111-jsv8","text":"Node.js\u662f\u57fa\u4e8eV8\u7684JS\u8fd0\u884c\u65f6\uff0c\u5b83\u5229\u7528V8\u63d0\u4f9b\u7684\u80fd\u529b\uff0c\u6781\u5927\u5730\u62d3\u5c55\u4e86JS\u7684\u80fd\u529b\u3002\u8fd9\u79cd\u62d3\u5c55\u4e0d\u662f\u4e3aJS\u589e\u52a0\u4e86\u65b0\u7684\u8bed\u8a00\u7279\u6027\uff0c\u800c\u662f\u62d3\u5c55\u4e86\u529f\u80fd\u6a21\u5757\uff0c\u6bd4\u5982\u5728\u524d\u7aef\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528Date\u8fd9\u4e2a\u51fd\u6570\uff0c\u4f46\u662f\u6211\u4eec\u4e0d\u80fd\u4f7f\u7528TCP\u8fd9\u4e2a\u51fd\u6570\uff0c\u56e0\u4e3aJS\u4e2d\u5e76\u6ca1\u6709\u5185\u7f6e\u8fd9\u4e2a\u51fd\u6570\u3002\u800c\u5728Node.js\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528TCP\uff0c\u8fd9\u5c31\u662fNode.js\u505a\u7684\u4e8b\u60c5\uff0c\u8ba9\u7528\u6237\u53ef\u4ee5\u4f7f\u7528JS\u4e2d\u672c\u6765\u4e0d\u5b58\u5728\u7684\u529f\u80fd\uff0c\u6bd4\u5982\u6587\u4ef6\u3001\u7f51\u7edc\u3002Node.js\u4e2d\u6700\u6838\u5fc3\u7684\u90e8\u5206\u662fLibuv\u548cV8\uff0cV8\u4e0d\u4ec5\u8d1f\u8d23\u6267\u884cJS\uff0c\u8fd8\u652f\u6301\u81ea\u5b9a\u4e49\u7684\u62d3\u5c55\uff0c\u5b9e\u73b0\u4e86JS\u8c03\u7528C++\u548cC++\u8c03\u7528JS\u7684\u80fd\u529b\u3002\u6bd4\u5982\u6211\u4eec\u53ef\u4ee5\u5199\u4e00\u4e2aC++\u6a21\u5757\uff0c\u7136\u540e\u5728JS\u8c03\u7528\uff0cNode.js\u6b63\u662f\u5229\u7528\u4e86\u8fd9\u4e2a\u80fd\u529b\uff0c\u5b8c\u6210\u4e86\u529f\u80fd\u7684\u62d3\u5c55\u3002JS\u5c42\u8c03\u7528\u7684\u6240\u6709C\u3001C++\u6a21\u5757\u90fd\u662f\u901a\u8fc7V8\u6765\u5b8c\u6210\u7684\u3002","title":"1.1.1 JS\u5f15\u64ceV8"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#112-libuv","text":"Libuv\u662fNode.js\u5e95\u5c42\u7684\u5f02\u6b65IO\u5e93\uff0c\u4f46\u5b83\u63d0\u4f9b\u7684\u529f\u80fd\u4e0d\u4ec5\u4ec5\u662fIO\uff0c\u8fd8\u5305\u62ec\u8fdb\u7a0b\u3001\u7ebf\u7a0b\u3001\u4fe1\u53f7\u3001\u5b9a\u65f6\u5668\u3001\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7b49\uff0c\u800c\u4e14Libuv\u62b9\u5e73\u4e86\u5404\u4e2a\u64cd\u4f5c\u7cfb\u7edf\u4e4b\u95f4\u7684\u5dee\u5f02\u3002Libuv\u63d0\u4f9b\u7684\u529f\u80fd\u5927\u6982\u5982\u4e0b \u2022 Full-featured event loop backed by epoll, kqueue, IOCP, event ports. \u2022 Asynchronous TCP and UDP sockets \u2022 Asynchronous DNS resolution \u2022 Asynchronous file and file system operations \u2022 File system events \u2022 ANSI escape code controlled TTY \u2022 IPC with socket sharing, using Unix domain sockets or named pipes (Windows) \u2022 Child processes \u2022 Thread pool \u2022 Signal handling \u2022 High resolution clock \u2022 Threading and synchronization primitives Libuv\u7684\u5b9e\u73b0\u662f\u4e00\u4e2a\u7ecf\u5178\u7684\u751f\u4ea7\u8005-\u6d88\u8d39\u8005\u6a21\u578b\u3002Libuv\u5728\u6574\u4e2a\u751f\u547d\u5468\u671f\u4e2d\uff0c\u6bcf\u4e00\u8f6e\u5faa\u73af\u90fd\u4f1a\u5904\u7406\u6bcf\u4e2a\u9636\u6bb5\uff08phase\uff09\u7ef4\u62a4\u7684\u4efb\u52a1\u961f\u5217\uff0c\u7136\u540e\u9010\u4e2a\u6267\u884c\u4efb\u52a1\u961f\u5217\u4e2d\u8282\u70b9\u7684\u56de\u8c03\uff0c\u5728\u56de\u8c03\u4e2d\uff0c\u4e0d\u65ad\u751f\u4ea7\u65b0\u7684\u4efb\u52a1\uff0c\u4ece\u800c\u4e0d\u65ad\u9a71\u52a8Libuv\u3002\u4e0b\u662fLibuv\u7684\u6574\u4f53\u6267\u884c\u6d41\u7a0b \u4ece\u4e0a\u56fe\u4e2d\u6211\u4eec\u5927\u81f4\u4e86\u89e3\u5230\uff0cLibuv\u5206\u4e3a\u51e0\u4e2a\u9636\u6bb5\uff0c\u7136\u540e\u5728\u4e00\u4e2a\u5faa\u73af\u91cc\u4e0d\u65ad\u6267\u884c\u6bcf\u4e2a\u9636\u6bb5\u91cc\u7684\u4efb\u52a1\u3002\u4e0b\u9762\u6211\u4eec\u5177\u4f53\u770b\u4e00\u4e0b\u6bcf\u4e2a\u9636\u6bb5 \u66f4\u65b0\u5f53\u524d\u65f6\u95f4\uff0c\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\uff0cLibuv\u4f1a\u66f4\u65b0\u5f53\u524d\u65f6\u95f4\u5230\u53d8\u91cf\u4e2d\uff0c\u8fd9\u4e00\u8f6e\u5faa\u73af\u7684\u5269\u4e0b\u64cd\u4f5c\u53ef\u4ee5\u4f7f\u7528\u8fd9\u4e2a\u53d8\u91cf\u83b7\u53d6\u5f53\u524d\u65f6\u95f4\uff0c\u907f\u514d\u8fc7\u591a\u7684\u7cfb\u7edf\u8c03\u7528\u5f71\u54cd\u6027\u80fd\uff0c\u989d\u5916\u7684\u5f71\u54cd\u5c31\u662f\u65f6\u95f4\u4e0d\u662f\u90a3\u4e48\u7cbe\u786e\u3002\u4f46\u662f\u5728\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0cLibuv\u5728\u5fc5\u8981\u7684\u65f6\u5019\uff0c\u4f1a\u4e3b\u52a8\u66f4\u65b0\u8fd9\u4e2a\u65f6\u95f4\uff0c\u6bd4\u5982\u5728epoll\u4e2d\u963b\u585e\u4e86timeout\u65f6\u95f4\u540e\u8fd4\u56de\u65f6\uff0c\u4f1a\u518d\u6b21\u66f4\u65b0\u5f53\u524d\u65f6\u95f4\u53d8\u91cf\u3002 \u5982\u679c\u4e8b\u4ef6\u5faa\u73af\u662f\u5904\u4e8ealive\u72b6\u6001\uff0c\u5219\u5f00\u59cb\u5904\u7406\u4e8b\u4ef6\u5faa\u73af\u7684\u6bcf\u4e2a\u9636\u6bb5\uff0c\u5426\u5219\u9000\u51fa\u8fd9\u4e2a\u4e8b\u4ef6\u5faa\u73af\u3002alive\u72b6\u6001\u662f\u4ec0\u4e48\u610f\u601d\u5462\uff1f\u5982\u679c\u6709active\u548cref\u72b6\u6001\u7684handle\uff0cactive\u72b6\u6001\u7684request\u6216\u8005closing\u72b6\u6001\u7684handle\u5219\u8ba4\u4e3a\u4e8b\u4ef6\u5faa\u73af\u662falive\uff08\u5177\u4f53\u7684\u540e\u7eed\u4f1a\u8bb2\u5230\uff09\u3002 timer\u9636\u6bb5\uff1a\u5224\u65ad\u6700\u5c0f\u5806\u4e2d\u7684\u8282\u70b9\u54ea\u4e2a\u8282\u70b9\u8d85\u65f6\u4e86\uff0c\u6267\u884c\u5b83\u7684\u56de\u8c03\u3002 pending\u9636\u6bb5\uff1a\u6267\u884cpending\u56de\u8c03\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u6240\u6709\u7684IO\u56de\u8c03\uff08\u7f51\u7edc\uff0c\u6587\u4ef6\uff0cDNS\uff09\u90fd\u4f1a\u5728Poll IO\u9636\u6bb5\u6267\u884c\uff0c\u4f46\u662f\u6709\u7684\u60c5\u51b5\u4e0b\uff0cPoll IO\u9636\u6bb5\u7684\u56de\u8c03\u4f1a\u5ef6\u8fdf\u5230\u4e0b\u4e00\u6b21\u5faa\u73af\u6267\u884c\uff0c\u90a3\u4e48\u8fd9\u79cd\u56de\u8c03\u5c31\u662f\u5728pending\u9636\u6bb5\u6267\u884c\u7684\uff0c\u6bd4\u5982IO\u56de\u8c03\u91cc\u51fa\u73b0\u4e86\u9519\u8bef\u6216\u5199\u6570\u636e\u6210\u529f\u7b49\u7b49\u90fd\u4f1a\u5728\u4e0b\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af\u7684pending\u9636\u6bb5\u6267\u884c\u56de\u8c03\u3002 idle\u9636\u6bb5\uff1a\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u90fd\u4f1a\u88ab\u6267\u884c\uff08idle\u4e0d\u662f\u8bf4\u4e8b\u4ef6\u5faa\u73af\u7a7a\u95f2\u7684\u65f6\u5019\u624d\u6267\u884c\uff09\u3002 prepare\u9636\u6bb5\uff1a\u548cidle\u9636\u6bb5\u7c7b\u4f3c\u3002 Poll IO\u9636\u6bb5\uff1a\u8c03\u7528\u5404\u5e73\u53f0\u63d0\u4f9b\u7684IO\u591a\u8def\u590d\u7528\u63a5\u53e3\uff08\u6bd4\u5982Linux\u4e0b\u5c31\u662fepoll\u6a21\u5f0f\uff09\uff0c\u6700\u591a\u7b49\u5f85timeout\u65f6\u95f4\uff0c\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u3002timeout\u7684\u8ba1\u7b97\u89c4\u5219\uff1a 1 \u5982\u679c\u65f6\u95f4\u5faa\u73af\u662f\u4ee5UV_RUN_NOWAIT\u6a21\u5f0f\u8fd0\u884c\u7684\uff0c\u5219timeout\u662f0\u3002 2 \u5982\u679c\u65f6\u95f4\u5faa\u73af\u5373\u5c06\u9000\u51fa\uff08\u8c03\u7528\u4e86uv_stop\uff09\uff0c\u5219timeout\u662f0\u3002 3 \u5982\u679c\u6ca1\u6709active\u72b6\u6001\u7684handle\u6216\u8005request\uff0ctimeout\u662f0\u3002 4 \u5982\u679c\u6709idle\u9636\u6bb5\u7684\u961f\u5217\u91cc\u6709\u8282\u70b9\uff0c\u5219timeout\u662f0\u3002 5 \u5982\u679c\u6709handle\u7b49\u5f85\u88ab\u5173\u95ed\u7684\uff08\u5373\u8c03\u4e86uv_close\uff09\uff0ctimeout\u662f0\u3002 6 \u5982\u679c\u4e0a\u9762\u7684\u90fd\u4e0d\u6ee1\u8db3\uff0c\u5219\u53d6timer\u9636\u6bb5\u4e2d\u6700\u5feb\u8d85\u65f6\u7684\u8282\u70b9\u4f5c\u4e3atimeout\u3002 7 \u5982\u679c\u4e0a\u9762\u7684\u90fd\u4e0d\u6ee1\u8db3\u5219timeout\u7b49\u4e8e-1\uff0c\u5373\u4e00\u76f4\u963b\u585e\uff0c\u76f4\u5230\u6ee1\u8db3\u6761\u4ef6\u3002 check\u9636\u6bb5\uff1a\u548cidle\u3001prepare\u4e00\u6837\u3002 closing\u9636\u6bb5\uff1a\u6267\u884c\u8c03\u7528uv_close\u51fd\u6570\u65f6\u4f20\u5165\u7684\u56de\u8c03\u3002 \u5982\u679cLibuv\u662f\u4ee5UV_RUN_ONCE\u6a21\u5f0f\u8fd0\u884c\u7684\uff0c\u90a3\u4e8b\u4ef6\u5faa\u73af\u5373\u5c06\u9000\u51fa\u3002\u4f46\u662f\u6709\u4e00\u79cd\u60c5\u51b5\u662f\uff0cPoll IO\u9636\u6bb5\u7684timeout\u7684\u503c\u662ftimer\u9636\u6bb5\u7684\u8282\u70b9\u7684\u503c\uff0c\u5e76\u4e14Poll IO\u9636\u6bb5\u662f\u56e0\u4e3a\u8d85\u65f6\u8fd4\u56de\u7684\uff0c\u5373\u6ca1\u6709\u4efb\u4f55\u4e8b\u4ef6\u53d1\u751f\uff0c\u4e5f\u6ca1\u6709\u6267\u884c\u4efb\u4f55IO\u56de\u8c03\uff0c\u8fd9\u65f6\u5019\u9700\u8981\u5728\u6267\u884c\u4e00\u6b21timer\u9636\u6bb5\u3002\u56e0\u4e3a\u6709\u8282\u70b9\u8d85\u65f6\u4e86\u3002 \u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u7ed3\u675f\uff0c\u5982\u679cLibuv\u4ee5UV_RUN_NOWAIT \u6216 UV_RUN_ONCE\u6a21\u5f0f\u8fd0\u884c\u7684\uff0c\u5219\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af\uff0c\u5982\u679c\u662f\u4ee5UV_RUN_DEFAULT\u6a21\u5f0f\u8fd0\u884c\u7684\u5e76\u4e14\u72b6\u6001\u662falive\uff0c\u5219\u5f00\u59cb\u4e0b\u4e00\u8f6e\u5faa\u73af\u3002\u5426\u5219\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af\u3002 \u4e0b\u9762\u6211\u80fd\u901a\u8fc7\u4e00\u4e2a\u4f8b\u5b50\u6765\u4e86\u89e3libuv\u7684\u57fa\u672c\u539f\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <stdio.h> #include <uv.h> int64_t counter = 0 ; void wait_for_a_while ( uv_idle_t * handle ) { counter ++ ; if ( counter >= 10e6 ) uv_idle_stop ( handle ); } int main () { uv_idle_t idler ; // \u83b7\u53d6\u4e8b\u4ef6\u5faa\u73af\u7684\u6838\u5fc3\u7ed3\u6784\u4f53\u3002\u5e76\u521d\u59cb\u5316\u4e00\u4e2aidle uv_idle_init ( uv_default_loop (), & idler ); // \u5f80\u4e8b\u4ef6\u5faa\u73af\u7684idle\u9636\u6bb5\u63d2\u5165\u4e00\u4e2a\u4efb\u52a1 uv_idle_start ( & idler , wait_for_a_while ); // \u542f\u52a8\u4e8b\u4ef6\u5faa\u73af uv_run ( uv_default_loop (), UV_RUN_DEFAULT ); // \u9500\u6bc1libuv\u7684\u76f8\u5173\u6570\u636e uv_loop_close ( uv_default_loop ()); return 0 ; } \u4f7f\u7528Libuv\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u83b7\u53d6Libuv\u7684\u6838\u5fc3\u7ed3\u6784\u4f53uv_loop_t\uff0cuv_loop_t\u662f\u4e00\u4e2a\u975e\u5e38\u5927\u7684\u7ed3\u6784\u4f53\uff0c\u91cc\u9762\u8bb0\u5f55\u4e86Libuv\u6574\u4e2a\u751f\u547d\u5468\u671f\u7684\u6570\u636e\u3002uv_default_loop\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u4e00\u4e2a\u9ed8\u8ba4\u5df2\u7ecf\u521d\u59cb\u5316\u4e86\u7684uv_loop_t\u7ed3\u6784\u4f53\uff0c\u5f53\u7136\u6211\u4eec\u4e5f\u53ef\u4ee5\u81ea\u5df1\u53bb\u5206\u914d\u4e00\u4e2a\uff0c\u81ea\u5df1\u521d\u59cb\u5316\u3002 1 2 3 4 5 6 7 8 9 10 11 uv_loop_t * uv_default_loop ( void ) { // \u7f13\u5b58 if ( default_loop_ptr != NULL ) return default_loop_ptr ; if ( uv_loop_init ( & default_loop_struct )) return NULL ; default_loop_ptr = & default_loop_struct ; return default_loop_ptr ; } Libuv\u7ef4\u62a4\u4e86\u4e00\u4e2a\u5168\u5c40\u7684uv_loop_t\u7ed3\u6784\u4f53\uff0c\u4f7f\u7528uv_loop_init\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u4e0d\u6253\u7b97\u5c55\u5f00\u8bb2\u89e3uv_loop_init\u51fd\u6570\uff0cw\u56e0\u4e3a\u5b83\u5927\u6982\u5c31\u662f\u5bf9uv_loop_t\u7ed3\u6784\u4f53\u5404\u4e2a\u5b57\u6bb5\u8fdb\u884c\u521d\u59cb\u5316\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0buv_idle_*\u7cfb\u5217\u7684\u51fd\u6570\u3002 1 uv_idle_init 1 2 3 4 5 6 7 8 9 int uv_idle_init ( uv_loop_t * loop , uv_idle_t * handle ) { /* \u521d\u59cb\u5316handle\u7684\u7c7b\u578b\uff0c\u6240\u5c5eloop\uff0c\u6253\u4e0aUV_HANDLE_REF\uff0c \u5e76\u4e14\u628ahandle\u63d2\u5165loop->handle_queue\u961f\u5217\u7684\u961f\u5c3e */ uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_IDLE ); handle -> idle_cb = NULL ; return 0 ; } \u6267\u884cuv_idle_init\u51fd\u6570\u540e\uff0cLibuv\u7684\u5185\u5b58\u89c6\u56fe\u5982\u4e0b\u56fe\u6240\u793a 2 uv_idle_start 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int uv_idle_start ( uv_idle_t * handle , uv_idle_cb cb ) { // \u5982\u679c\u5df2\u7ecf\u6267\u884c\u8fc7start\u51fd\u6570\u5219\u76f4\u63a5\u8fd4\u56de if ( uv__is_active ( handle )) return 0 ; // \u628ahandle\u63d2\u5165loop\u4e2didle\u7684\u961f\u5217 QUEUE_INSERT_HEAD ( & handle -> loop -> idle_handles , & handle -> queue ); // \u6302\u8f7d\u56de\u8c03\uff0c\u4e0b\u4e00\u8f6e\u5faa\u73af\u7684\u65f6\u5019\u88ab\u6267\u884c handle -> idle_cb = cb ; /* \u8bbe\u7f6eUV_HANDLE_ACTIVE\u6807\u8bb0\u4f4d\uff0c\u5e76\u4e14loop\u4e2d\u7684handle\u6570\u52a0\u4e00\uff0c init\u7684\u65f6\u5019\u53ea\u662f\u628ahandle\u6302\u8f7d\u5230loop\uff0cstart\u7684\u65f6\u5019handle\u624d \u5904\u4e8e\u6fc0\u6d3b\u6001 */ uv__handle_start ( handle ); return 0 ; } \u6267\u884c\u5b8cuv_idle_start\u7684\u5185\u5b58\u89c6\u56fe\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u7136\u540e\u6267\u884cuv_run\u8fdb\u5165Libuv\u7684\u4e8b\u4ef6\u5faa\u73af\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int uv_run ( uv_loop_t * loop , uv_run_mode mode ) { int timeout ; int r ; int ran_pending ; // \u5728uv_run\u4e4b\u524d\u8981\u5148\u63d0\u4ea4\u4efb\u52a1\u5230loop r = uv__loop_alive ( loop ); // \u6ca1\u6709\u4efb\u52a1\u9700\u8981\u5904\u7406\u6216\u8005\u8c03\u7528\u4e86uv_stop while ( r != 0 && loop -> stop_flag == 0 ) { // \u5904\u7406idle\u961f\u5217 uv__run_idle ( loop ); } // \u662f\u56e0\u4e3a\u8c03\u7528\u4e86uv_stop\u9000\u51fa\u7684\uff0c\u91cd\u7f6eflag if ( loop -> stop_flag != 0 ) loop -> stop_flag = 0 ; /* \u8fd4\u56de\u662f\u5426\u8fd8\u6709\u6d3b\u8dc3\u7684\u4efb\u52a1\uff08handle\u6216request\uff09\uff0c \u4e1a\u52a1\u4ee3\u8868\u53ef\u4ee5\u518d\u6b21\u6267\u884cuv_run */ return r ; } \u6211\u4eec\u770b\u5230\u6709\u4e00\u4e2a\u51fd\u6570\u662fuv__run_idle\uff0c\u8fd9\u5c31\u662f\u5904\u7406idle\u9636\u6bb5\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // \u5728\u6bcf\u4e00\u8f6e\u5faa\u73af\u4e2d\u6267\u884c\u8be5\u51fd\u6570\uff0c\u6267\u884c\u65f6\u673a\u89c1uv_run void uv__run_idle ( uv_loop_t * loop ) { uv_idle_t * h ; QUEUE queue ; QUEUE * q ; /* \u628a\u8be5\u7c7b\u578b\u5bf9\u5e94\u7684\u961f\u5217\u4e2d\u6240\u6709\u8282\u70b9\u6458\u4e0b\u6765\u6302\u8f7d\u5230queue\u53d8\u91cf\uff0c \u53d8\u91cf\u56de\u8c03\u91cc\u4e0d\u65ad\u63d2\u5165\u65b0\u8282\u70b9\uff0c\u5bfc\u81f4\u6b7b\u5faa\u73af */ QUEUE_MOVE ( & loop -> idle_handles , & queue ); // \u904d\u5386\u961f\u5217\uff0c\u6267\u884c\u6bcf\u4e2a\u8282\u70b9\u91cc\u9762\u7684\u51fd\u6570 while ( ! QUEUE_EMPTY ( & queue )) { // \u53d6\u4e0b\u5f53\u524d\u5f85\u5904\u7406\u7684\u8282\u70b9 q = QUEUE_HEAD ( & queue ); // \u53d6\u5f97\u8be5\u8282\u70b9\u5bf9\u5e94\u7684\u6574\u4e2a\u7ed3\u6784\u4f53\u7684\u57fa\u5730\u5740 h = QUEUE_DATA ( q , uv_idle_t , queue ); // \u628a\u8be5\u8282\u70b9\u79fb\u51fa\u5f53\u524d\u961f\u5217\uff0c\u5426\u5219\u5faa\u73af\u4e0d\u4f1a\u7ed3\u675f QUEUE_REMOVE ( q ); // \u91cd\u65b0\u63d2\u5165\u539f\u6765\u7684\u961f\u5217 QUEUE_INSERT_TAIL ( & loop -> idle_handles , q ); // \u6267\u884c\u56de\u8c03\u51fd\u6570 h -> idle_cb ( h ); } } \u6211\u4eec\u770b\u5230uv__run_idle\u7684\u903b\u8f91\u5e76\u4e0d\u590d\u6742\uff0c\u5c31\u662f\u904d\u5386idle_handles\u961f\u5217\u7684\u8282\u70b9\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03\uff0c\u5728\u56de\u8c03\u91cc\u6211\u4eec\u53ef\u4ee5\u63d2\u5165\u65b0\u7684\u8282\u70b9\uff08\u4ea7\u751f\u65b0\u4efb\u52a1\uff09\uff0c\u4ece\u800c\u4e0d\u65ad\u9a71\u52a8Libuv\u7684\u8fd0\u884c\u3002\u6211\u4eec\u770b\u5230uv_run\u9000\u51fa\u5faa\u73af\u7684\u6761\u4ef6\u4e0b\u9762\u7684\u4ee3\u7801\u4e3afalse\u3002 1 r != 0 && loop -> stop_flag == 0 stop_flag\u7531\u7528\u6237\u4e3b\u52a8\u5173\u95edLibuv\u4e8b\u4ef6\u5faa\u73af\u3002 1 2 3 void uv_stop ( uv_loop_t * loop ) { loop -> stop_flag = 1 ; } r\u662f\u4ee3\u8868\u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u8fd8\u5b58\u6d3b\uff0c\u8fd9\u4e2a\u5224\u65ad\u7684\u6807\u51c6\u662f\u7531uv__loop_alive\u63d0\u4f9b 1 2 3 4 5 static int uv__loop_alive ( const uv_loop_t * loop ) { return loop -> active_handles > 0 || loop -> active_reqs . count > 0 || loop -> closing_handles != NULL ; } \u8fd9\u65f6\u5019\u6211\u4eec\u6709\u4e00\u4e2aactived handles\uff0c\u6240\u4ee5Libuv\u4e0d\u4f1a\u9000\u51fa\u3002\u5f53\u6211\u4eec\u8c03\u7528uv_idle_stop\u51fd\u6570\u628aidle\u8282\u70b9\u79fb\u51fahandle\u961f\u5217\u7684\u65f6\u5019\uff0cLibuv\u5c31\u4f1a\u9000\u51fa\u3002\u540e\u9762\u6211\u4eec\u4f1a\u5177\u4f53\u5206\u6790Libuv\u4e8b\u4ef6\u5faa\u73af\u7684\u539f\u7406\u3002","title":"1.1.2 Libuv"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#113","text":"Node.js\u4e2d\u7b2c\u4e09\u65b9\u5e93\u5305\u62ec\u5f02\u6b65DNS\u89e3\u6790\uff08cares\uff09\u3001HTTP\u89e3\u6790\u5668\uff08\u65e7\u7248\u4f7f\u7528http_parser\uff0c\u65b0\u7248\u4f7f\u7528llhttp\uff09\u3001HTTP2\u89e3\u6790\u5668\uff08nghttp2\uff09\u3001\u89e3\u538b\u538b\u7f29\u5e93(zlib)\u3001\u52a0\u5bc6\u89e3\u5bc6\u5e93(openssl)\u7b49\u7b49\uff0c\u4e0d\u4e00\u4e00\u4ecb\u7ecd\u3002","title":"1.1.3 \u5176\u5b83\u7b2c\u4e09\u65b9\u5e93"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#12-nodejs","text":"","title":"1.2 Node.js\u5de5\u4f5c\u539f\u7406"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#121-nodejsjs","text":"V8\u63d0\u4f9b\u4e86\u4e00\u5957\u673a\u5236\uff0c\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u5728JS\u5c42\u8c03\u7528C++\u3001C\u8bed\u8a00\u6a21\u5757\u63d0\u4f9b\u7684\u529f\u80fd\u3002Node.js\u6b63\u662f\u901a\u8fc7\u8fd9\u5957\u673a\u5236\uff0c\u5b9e\u73b0\u4e86\u5bf9JS\u80fd\u529b\u7684\u62d3\u5c55\u3002Node.js\u5728\u5e95\u5c42\u505a\u4e86\u5927\u91cf\u7684\u4e8b\u60c5\uff0c\u5b9e\u73b0\u4e86\u5f88\u591a\u529f\u80fd\uff0c\u7136\u540e\u5728JS\u5c42\u66b4\u9732\u63a5\u53e3\u7ed9\u7528\u6237\u4f7f\u7528\uff0c\u964d\u4f4e\u4e86\u7528\u6237\u6210\u672c\uff0c\u4e5f\u63d0\u9ad8\u4e86\u5f00\u53d1\u6548\u7387\u3002","title":"1.2.1 Node.js\u662f\u5982\u4f55\u62d3\u5c55JS\u529f\u80fd\u7684\uff1f"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#122-v8","text":"1 2 3 4 5 // C++\u91cc\u5b9a\u4e49 Handle < FunctionTemplate > Test = FunctionTemplate :: New ( cb ); global -> Set ( String :: New ( \u201c Test \"), Test); // JS\u91cc\u4f7f\u7528 const test = new Test (); \u6211\u4eec\u5148\u6709\u4e00\u4e2a\u611f\u6027\u7684\u8ba4\u8bc6\uff0c\u5728\u540e\u9762\u7684\u7ae0\u8282\u4e2d\uff0c\u4f1a\u5177\u4f53\u8bb2\u89e3\u5982\u4f55\u4f7f\u7528V8\u62d3\u5c55JS\u7684\u529f\u80fd\u3002","title":"1.2.2 \u5982\u4f55\u5728V8\u65b0\u589e\u4e00\u4e2a\u81ea\u5b9a\u4e49\u7684\u529f\u80fd\uff1f"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#123-nodejs","text":"Node.js\u5e76\u4e0d\u662f\u7ed9\u6bcf\u4e2a\u529f\u80fd\u90fd\u62d3\u5c55\u4e00\u4e2a\u5bf9\u8c61\uff0c\u7136\u540e\u6302\u8f7d\u5230\u5168\u5c40\u53d8\u91cf\u4e2d\uff0c\u800c\u662f\u62d3\u5c55\u4e00\u4e2aprocess\u5bf9\u8c61\uff0c\u518d\u901a\u8fc7process.binding\u62d3\u5c55js\u529f\u80fd\u3002Node.js\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5168\u5c40\u7684JS\u5bf9\u8c61process\uff0c\u6620\u5c04\u5230\u4e00\u4e2aC++\u5bf9\u8c61process\uff0c\u5e95\u5c42\u7ef4\u62a4\u4e86\u4e00\u4e2aC++\u6a21\u5757\u7684\u94fe\u8868\uff0cJS\u901a\u8fc7\u8c03\u7528JS\u5c42\u7684process.binding\uff0c\u8bbf\u95ee\u5230C++\u7684process\u5bf9\u8c61\uff0c\u4ece\u800c\u8bbf\u95eeC++\u6a21\u5757(\u7c7b\u4f3c\u8bbf\u95eeJS\u7684Object\u3001Date\u7b49)\u3002\u4e0d\u8fc7Node.js 14\u7248\u672c\u5df2\u7ecf\u6539\u6210internalBinding\u7684\u65b9\u5f0f\uff0c\u901a\u8fc7internalBinding\u5c31\u53ef\u4ee5\u8bbf\u95eeC++\u6a21\u5757\uff0c\u539f\u7406\u7c7b\u4f3c\u3002","title":"1.2.3 Node.js\u662f\u5982\u4f55\u5b9e\u73b0\u62d3\u5c55\u7684?"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#13-nodejs","text":"\u4e0b\u9762\u662fNode.js\u542f\u52a8\u7684\u4e3b\u6d41\u7a0b\u56fe\u5982\u56fe1-4\u6240\u793a\u3002 \u6211\u4eec\u4ece\u4e0a\u5f80\u4e0b\uff0c\u770b\u4e00\u4e0b\u6bcf\u4e2a\u8fc7\u7a0b\u90fd\u505a\u4e86\u4e9b\u4ec0\u4e48\u4e8b\u60c5\u3002","title":"1.3 Node.js\u542f\u52a8\u8fc7\u7a0b"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#131-c","text":"RegisterBuiltinModules\u51fd\u6570\uff08node_binding.cc\uff09\u7684\u4f5c\u7528\u662f\u6ce8\u518cC++\u6a21\u5757\u3002 1 2 3 4 5 void RegisterBuiltinModules () { #define V(modname) _register_##modname(); NODE_BUILTIN_MODULES ( V ) #undef V } NODE_BUILTIN_MODULES\u662f\u4e00\u4e2aC\u8bed\u8a00\u5b8f\uff0c\u5b8f\u5c55\u5f00\u540e\u5982\u4e0b\uff08\u7701\u7565\u7c7b\u4f3c\u903b\u8f91\uff09 1 2 3 4 5 6 7 void RegisterBuiltinModules () { #define V(modname) _register_##modname(); V ( tcp_wrap ) V ( timers ) ... \u5176\u5b83\u6a21\u5757 #undef V } \u518d\u4e00\u6b65\u5c55\u5f00\u5982\u4e0b 1 2 3 4 void RegisterBuiltinModules () { _register_tcp_wrap (); _register_timers (); } \u6267\u884c\u4e86\u4e00\u7cfb\u5217_register\u5f00\u5934\u7684\u51fd\u6570\uff0c\u4f46\u662f\u6211\u4eec\u5728Node.js\u6e90\u7801\u91cc\u627e\u4e0d\u5230\u8fd9\u4e9b\u51fd\u6570\uff0c\u56e0\u4e3a\u8fd9\u4e9b\u51fd\u6570\u662f\u5728\u6bcf\u4e2aC++\u6a21\u5757\u5b9a\u4e49\u7684\u6587\u4ef6\u91cc\uff08.cc\u6587\u4ef6\u7684\u6700\u540e\u4e00\u884c\uff09\u901a\u8fc7\u5b8f\u5b9a\u4e49\u7684\u3002\u4ee5tcp_wrap\u6a21\u5757\u4e3a\u4f8b\uff0c\u770b\u770b\u5b83\u662f\u600e\u4e48\u505a\u7684\u3002\u6587\u4ef6tcp_wrap.cc\u7684\u6700\u540e\u4e00\u53e5\u4ee3\u7801 NODE_MODULE_CONTEXT_AWARE_INTERNAL(tcp_wrap, node::TCPWrap::Initialize) \u5b8f\u5c55\u5f00\u662f 1 2 3 4 5 #define NODE_MODULE_CONTEXT_AWARE_INTERNAL(modname, regfunc) \\ NODE_MODULE_CONTEXT_AWARE_CPP ( modname , regfunc , nullptr , NM_F_INTERNAL ) \u7ee7\u7eed\u5c55\u5f00 1 2 3 4 5 6 7 8 9 10 11 12 #define NODE_MODULE_CONTEXT_AWARE_CPP(modname, regfunc, priv, flags\\ static node :: node_module _module = { \\ NODE_MODULE_VERSION , \\ flags , \\ nullptr , \\ __FILE__ , \\ nullptr , \\ ( node :: addon_context_register_func )( regfunc ), \\ NODE_STRINGIFY ( modname ), \\ priv , \\ nullptr }; \\ void _register_tcp_wrap () { node_module_register ( & _module ); } \u6211\u4eec\u770b\u5230\u6bcf\u4e2aC++\u6a21\u5757\u5e95\u5c42\u90fd\u5b9a\u4e49\u4e86\u4e00\u4e2a_register\u5f00\u5934\u7684\u51fd\u6570\uff0c\u5728Node.js\u542f\u52a8\u65f6\uff0c\u5c31\u4f1a\u628a\u8fd9\u4e9b\u51fd\u6570\u9010\u4e2a\u6267\u884c\u4e00\u904d\u3002\u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0b\u8fd9\u4e9b\u51fd\u6570\u90fd\u505a\u4e86\u4ec0\u4e48\uff0c\u5728\u8fd9\u4e4b\u524d\uff0c\u6211\u4eec\u8981\u5148\u4e86\u89e3\u4e00\u4e0bNode.js\u4e2d\u8868\u793aC++\u6a21\u5757\u7684\u6570\u636e\u7ed3\u6784\u3002 1 2 3 4 5 6 7 8 9 10 11 struct node_module { int nm_version ; unsigned int nm_flags ; void * nm_dso_handle ; const char * nm_filename ; node :: addon_register_func nm_register_func ; node :: addon_context_register_func nm_context_register_func ; const char * nm_modname ; void * nm_priv ; struct node_module * nm_link ; }; \u6211\u4eec\u770b\u5230_register\u5f00\u5934\u7684\u51fd\u6570\u8c03\u4e86node_module_register\uff0c\u5e76\u4f20\u5165\u4e00\u4e2anode_module\u6570\u636e\u7ed3\u6784\uff0c\u6240\u4ee5\u6211\u4eec\u770b\u4e00\u4e0bnode_module_register\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 void node_module_register ( void * m ) { struct node_module * mp = reinterpret_cast < struct node_module *> ( m ); if ( mp -> nm_flags & NM_F_INTERNAL ) { mp -> nm_link = modlist_internal ; modlist_internal = mp ; } else if ( ! node_is_initialized ) { mp -> nm_flags = NM_F_LINKED ; mp -> nm_link = modlist_linked ; modlist_linked = mp ; } else { thread_local_modpending = mp ; } } C++\u5185\u7f6e\u6a21\u5757\u7684flag\u662fNM_F_INTERNAL\uff0c\u6240\u4ee5\u4f1a\u6267\u884c\u7b2c\u4e00\u4e2aif\u7684\u903b\u8f91\uff0cmodlist_internal\u7c7b\u4f3c\u4e00\u4e2a\u5934\u6307\u9488\u3002if\u91cc\u7684\u903b\u8f91\u5c31\u662f\u5934\u63d2\u6cd5\u5efa\u7acb\u4e00\u4e2a\u5355\u94fe\u8868\u3002C++\u5185\u7f6e\u6a21\u5757\u5728Node.js\u91cc\u662f\u975e\u5e38\u91cd\u8981\u7684\uff0c\u5f88\u591a\u529f\u80fd\u90fd\u4f1a\u8c03\u7528\uff0c\u540e\u7eed\u6211\u4eec\u4f1a\u770b\u5230\u3002","title":"1.3.1 \u6ce8\u518cC++\u6a21\u5757"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#132-environment","text":"1 CreateMainEnvironment Node.js\u4e2dEnvironment\u7c7b\uff08env.h\uff09\u662f\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u7c7b\uff0cNode.js\u4e2d\uff0c\u5f88\u591a\u6570\u636e\u7531Environment\u5bf9\u8c61\u8fdb\u884c\u7ba1\u7406\u3002 1 2 3 4 5 6 7 8 context = NewContext ( isolate_ ); std :: unique_ptr < Environment > env = std :: make_unique < Environment > ( isolate_data_ . get (), context , args_ , exec_args_ , static_cast < Environment :: Flags > ( Environment :: kIsMainThread | Environment :: kOwnsProcessState | Environment :: kOwnsInspector )); Isolate\uff0cContext\u662fV8\u4e2d\u7684\u6982\u5ff5\uff0cIsolate\u7528\u4e8e\u9694\u79bb\u5b9e\u4f8b\u95f4\u7684\u73af\u5883\uff0cContext\u7528\u4e8e\u63d0\u4f9bJS\u6267\u884c\u65f6\u7684\u4e0a\u4e0b\u6587\uff0ckIsMainThread\u8bf4\u660e\u5f53\u524d\u8fd0\u884c\u7684\u662f\u4e3b\u7ebf\u7a0b\uff0c\u7528\u4e8e\u533a\u5206Node.js\u4e2d\u7684worker_threads\u5b50\u7ebf\u7a0b\u3002Environment\u7c7b\u975e\u5e38\u5e9e\u5927\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u521d\u59cb\u5316\u7684\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 Environment :: Environment ( IsolateData * isolate_data , Local < Context > context , const std :: vector < std :: string >& args , const std :: vector < std :: string >& exec_args , Flags flags , uint64_t thread_id ) : isolate_ ( context -> GetIsolate ()), isolate_data_ ( isolate_data ), immediate_info_ ( context -> GetIsolate ()), tick_info_ ( context -> GetIsolate ()), timer_base_ ( uv_now ( isolate_data -> event_loop ())), exec_argv_ ( exec_args ), argv_ ( args ), exec_path_ ( GetExecPath ( args )), should_abort_on_uncaught_toggle_ ( isolate_ , 1 ), stream_base_state_ ( isolate_ , StreamBase :: kNumStreamBaseStateFields ), flags_ ( flags ), thread_id_ ( thread_id == kNoThreadId ? AllocateThreadId () : thread_id ), fs_stats_field_array_ ( isolate_ , kFsStatsBufferLength ), fs_stats_field_bigint_array_ ( isolate_ , kFsStatsBufferLength ), context_ ( context -> GetIsolate (), context ) { // \u8fdb\u5165\u5f53\u524d\u7684context HandleScope handle_scope ( isolate ()); Context :: Scope context_scope ( context ); // \u4fdd\u5b58\u73af\u5883\u53d8\u91cf set_env_vars ( per_process :: system_environment ); // \u5173\u8054context\u548cenv AssignToContext ( context , ContextInfo ( \"\" )); // \u521b\u5efa\u5176\u5b83\u5bf9\u8c61 CreateProperties (); } \u6211\u4eec\u53ea\u770b\u4e00\u4e0bAssignToContext\u548cCreateProperties\uff0cset_env_vars\u4f1a\u628a\u8fdb\u7a0b\u7ae0\u8282\u8bb2\u89e3\u3002 1.1 AssignToContext 1 2 3 4 5 6 7 8 inline void Environment::AssignToContext ( v8 :: Local < v8 :: Context > context , const ContextInfo & info ) { // \u5728context\u4e2d\u4fdd\u5b58env\u5bf9\u8c61 context -> SetAlignedPointerInEmbedderData ( ContextEmbedderIndex :: kEnvironment , this ); // Used by Environment::GetCurrent to know that we are on a node context. context -> SetAlignedPointerInEmbedderData ( ContextEmbedderIndex :: kContextTag , Environment :: kNodeContextTagPtr ); } AssignToContext\u7528\u4e8e\u4fdd\u5b58context\u548cenv\u7684\u5173\u7cfb\u3002\u8fd9\u4e2a\u903b\u8f91\u975e\u5e38\u91cd\u8981\uff0c\u56e0\u4e3a\u540e\u7eed\u6267\u884c\u4ee3\u7801\u65f6\uff0c\u6211\u4eec\u4f1a\u8fdb\u5165V8\u7684\u9886\u57df\uff0c\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u53ea\u77e5\u9053Isolate\u548ccontext\u3002\u5982\u679c\u4e0d\u4fdd\u5b58context\u548cenv\u7684\u5173\u7cfb\uff0c\u6211\u4eec\u5c31\u4e0d\u77e5\u9053\u5f53\u524d\u6240\u5c5e\u7684env\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u83b7\u53d6\u5bf9\u5e94\u7684env\u3002 1 2 3 4 5 6 7 8 9 inline Environment * Environment::GetCurrent ( v8 :: Isolate * isolate ) { v8 :: HandleScope handle_scope ( isolate ); return GetCurrent ( isolate -> GetCurrentContext ()); } inline Environment * Environment::GetCurrent ( v8 :: Local < v8 :: Context > context ) { return static_cast < Environment *> ( context -> GetAlignedPointerFromEmbedderData ( ContextEmbedderIndex :: kEnvironment )); } 1.2 CreateProperties \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bCreateProperties\u4e2d\u521b\u5efaprocess\u5bf9\u8c61\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 Isolate * isolate = env -> isolate (); EscapableHandleScope scope ( isolate ); Local < Context > context = env -> context (); // \u7533\u8bf7\u4e00\u4e2a\u51fd\u6570\u6a21\u677f Local < FunctionTemplate > process_template = FunctionTemplate :: New ( isolate ); process_template -> SetClassName ( env -> process_string ()); // \u4fdd\u5b58\u51fd\u6570\u6a21\u677f\u751f\u6210\u7684\u51fd\u6570 Local < Function > process_ctor ; // \u4fdd\u5b58\u51fd\u6570\u6a21\u5757\u751f\u6210\u7684\u51fd\u6570\u6240\u65b0\u5efa\u51fa\u6765\u7684\u5bf9\u8c61 Local < Object > process ; if ( ! process_template -> GetFunction ( context ). ToLocal ( & process_ctor ) || ! process_ctor -> NewInstance ( context ). ToLocal ( & process )) { return MaybeLocal < Object > (); } process\u6240\u4fdd\u5b58\u7684\u5bf9\u8c61\u5c31\u662f\u6211\u4eec\u5728JS\u5c42\u7528\u4f7f\u7528\u7684process\u5bf9\u8c61\u3002Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u8fd8\u6302\u8f7d\u4e86\u4e00\u4e9b\u5c5e\u6027\u3002 1 2 3 4 5 READONLY_PROPERTY ( process , \"version\" , FIXED_ONE_BYTE_STRING ( env -> isolate (), NODE_VERSION )); READONLY_STRING_PROPERTY ( process , \"arch\" , per_process :: metadata . arch );...... \u521b\u5efa\u5b8cprocess\u5bf9\u8c61\u540e\uff0cNode.js\u628aprocess\u4fdd\u5b58\u5230env\u4e2d\u3002 1 2 Local < Object > process_object = node :: CreateProcessObject ( this ). FromMaybe ( Local < Object > ()); set_process_object ( process_object )","title":"1.3.2 \u521b\u5efaEnvironment\u5bf9\u8c61"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#133-libuv","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 InitializeLibuv\u51fd\u6570\u4e2d\u7684\u903b\u8f91\u662f\u5f80Libuv\u4e2d\u63d0\u4ea4\u4efb\u52a1 \u3002 void Environment :: InitializeLibuv ( bool start_profiler_idle_notifier ) { HandleScope handle_scope ( isolate ()); Context :: Scope context_scope ( context ()); CHECK_EQ ( 0 , uv_timer_init ( event_loop (), timer_handle ())); uv_unref ( reinterpret_cast < uv_handle_t *> ( timer_handle ())); uv_check_init ( event_loop (), immediate_check_handle ()); uv_unref ( reinterpret_cast < uv_handle_t *> ( immediate_check_handle ())); uv_idle_init ( event_loop (), immediate_idle_handle ()); uv_check_start ( immediate_check_handle (), CheckImmediate ); uv_prepare_init ( event_loop (), & idle_prepare_handle_ ); uv_check_init ( event_loop (), & idle_check_handle_ ); uv_async_init ( event_loop (), & task_queues_async_ , []( uv_async_t * async ) { Environment * env = ContainerOf ( & Environment :: task_queues_async_ , async ); env -> CleanupFinalizationGroups (); env -> RunAndClearNativeImmediates (); }); uv_unref ( reinterpret_cast < uv_handle_t *> ( & idle_prepare_handle_ )); uv_unref ( reinterpret_cast < uv_handle_t *> ( & idle_check_handle_ )); uv_unref ( reinterpret_cast < uv_handle_t *> ( & task_queues_async_ )); // \u2026 } \u8fd9\u4e9b\u51fd\u6570\u90fd\u662fLibuv\u63d0\u4f9b\u7684\uff0c\u5206\u522b\u662f\u5f80Libuv\u4e0d\u540c\u9636\u6bb5\u63d2\u5165\u4efb\u52a1\u8282\u70b9\uff0cuv_unref\u662f\u4fee\u6539\u72b6\u6001\u3002 1 timer_handle\u662f\u5b9e\u73b0Node.js\u4e2d\u5b9a\u65f6\u5668\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5bf9\u5e94Libuv\u7684time\u9636\u6bb5 2 immediate_check_handle\u662f\u5b9e\u73b0Node.js\u4e2dsetImmediate\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5bf9\u5e94Libuv\u7684check\u9636\u6bb5\u3002 3 task_queues_async_\u7528\u4e8e\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u3002","title":"1.3.3 \u521d\u59cb\u5316Libuv\u4efb\u52a1"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#134-loader","text":"RunBootstrapping\u91cc\u8c03\u7528\u4e86BootstrapInternalLoaders\u548cBootstrapNode\u51fd\u6570\uff0c\u6211\u4eec\u4e00\u4e2a\u4e2a\u5206\u6790\u3002 1 \u521d\u59cb\u5316loader BootstrapInternalLoaders\u7528\u4e8e\u6267\u884cinternal/bootstrap/loaders.js\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u903b\u8f91\u3002\u9996\u5148\u5b9a\u4e49\u4e00\u4e2a\u53d8\u91cf\uff0c\u8be5\u53d8\u91cf\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\u6570\u7ec4\uff0c\u7528\u4e8e\u5b9a\u4e49\u51fd\u6570\u7684\u5f62\u53c2\u5217\u8868\uff0c\u4e00\u4f1a\u6211\u4eec\u4f1a\u770b\u5230\u5b83\u7684\u4f5c\u7528\u3002 1 2 3 4 5 std :: vector < Local < String >> loaders_params = { process_string (), FIXED_ONE_BYTE_STRING ( isolate_ , \"getLinkedBinding\" ), FIXED_ONE_BYTE_STRING ( isolate_ , \"getInternalBinding\" ), primordials_string ()}; \u7136\u540e\u518d\u5b9a\u4e49\u4e00\u4e2a\u53d8\u91cf\uff0c\u662f\u4e00\u4e2a\u5bf9\u8c61\u6570\u7ec4\uff0c\u7528\u4f5c\u6267\u884c\u51fd\u6570\u65f6\u7684\u5b9e\u53c2\u3002 1 2 3 4 5 6 7 8 9 std :: vector < Local < Value >> loaders_args = { process_object (), NewFunctionTemplate ( binding :: GetLinkedBinding ) -> GetFunction ( context ()) . ToLocalChecked (), NewFunctionTemplate ( binding :: GetInternalBinding ) -> GetFunction ( context ()) . ToLocalChecked (), primordials ()}; \u63a5\u7740Node.js\u7f16\u8bd1\u6267\u884cinternal/bootstrap/loaders.js\uff0c\u8fd9\u4e2a\u8fc7\u7a0b\u94fe\u8def\u975e\u5e38\u957f\uff0c\u6700\u540e\u5230V8\u5c42\uff0c\u5c31\u4e0d\u8d34\u51fa\u5177\u4f53\u7684\u4ee3\u7801\uff0c\u5177\u4f53\u7684\u903b\u8f91\u8f6c\u6210JS\u5982\u4e0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function demo ( process , getLinkedBinding , getInternalBinding , primordials ) { // internal/bootstrap/loaders.js \u7684\u4ee3\u7801 } const process = {}; function getLinkedBinding (){} function getInternalBinding () {} const primordials = {}; const export = demo ( process , getLinkedBinding , getInternalBinding , primordials ); V8\u628ainternal/bootstrap/loaders.js\u7528\u4e00\u4e2a\u51fd\u6570\u5305\u88f9\u8d77\u6765\uff0c\u5f62\u53c2\u5c31\u662floaders_params\u53d8\u91cf\u5bf9\u5e94\u7684\u56db\u4e2a\u5b57\u7b26\u4e32\u3002\u7136\u540e\u6267\u884c\u8fd9\u4e2a\u51fd\u6570\uff0c\u5e76\u4e14\u4f20\u5165loaders_args\u91cc\u7684\u90a3\u56db\u4e2a\u5bf9\u8c61\u3002internal/bootstrap/loaders.js\u4f1a\u5bfc\u51fa\u4e00\u4e2a\u5bf9\u8c61\u3002\u5728\u770binternal/bootstrap/loaders.js\u4ee3\u7801\u4e4b\u524d\uff0c\u6211\u4eec\u5148\u770b\u4e00\u4e0bgetLinkedBinding, getInternalBinding\u8fd9\u4e24\u4e2a\u51fd\u6570\uff0cNode.js\u5728C++\u5c42\u5bf9\u5916\u66b4\u9732\u4e86AddLinkedBinding\u65b9\u6cd5\u6ce8\u518c\u6a21\u5757\uff0cNode.js\u9488\u5bf9\u8fd9\u79cd\u7c7b\u578b\u7684\u6a21\u5757\uff0c\u7ef4\u62a4\u4e86\u4e00\u4e2a\u5355\u72ec\u7684\u94fe\u8868\u3002getLinkedBinding\u5c31\u662f\u6839\u636e\u6a21\u5757\u540d\u4ece\u8fd9\u4e2a\u94fe\u8868\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u6a21\u5757\uff0c\u4f46\u662f\u6211\u4eec\u4e00\u822c\u7528\u4e0d\u5230\u8fd9\u4e2a\uff0c\u6240\u4ee5\u5c31\u4e0d\u6df1\u5165\u5206\u6790\u3002\u524d\u9762\u6211\u4eec\u770b\u5230\u5bf9\u4e8eC++\u5185\u7f6e\u6a21\u5757\uff0cNode.js\u540c\u6837\u7ef4\u62a4\u4e86\u4e00\u4e2a\u94fe\u8868\uff0cgetInternalBinding\u5c31\u662f\u6839\u636e\u6a21\u5757\u540d\u4ece\u8fd9\u4e2a\u94fe\u8868\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u6a21\u5757\u3002\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u5177\u4f53\u770b\u4e00\u4e0binternal/bootstrap/loaders.js\u7684\u4ee3\u7801\u4e86\u3002 1 2 3 4 5 6 7 8 9 10 11 12 let internalBinding ; { const bindingObj = ObjectCreate ( null ); internalBinding = function internalBinding ( module ) { let mod = bindingObj [ module ]; if ( typeof mod !== 'object' ) { mod = bindingObj [ module ] = getInternalBinding ( module ); moduleLoadList . push ( `Internal Binding ${ module } ` ); } return mod ; }; } Node.js\u5728JS\u5bf9getInternalBinding\u8fdb\u884c\u4e86\u4e00\u4e2a\u5c01\u88c5\uff0c\u4e3b\u8981\u662f\u52a0\u4e86\u7f13\u5b58\u5904\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const internalBindingWhitelist = new SafeSet ([, 'tcp_wrap' , // \u4e00\u7cfb\u5217C++\u5185\u7f6e\u6a21\u5757\u540d ]); { const bindingObj = ObjectCreate ( null ); process . binding = function binding ( module ) { module = String ( module ); if ( internalBindingWhitelist . has ( module )) { return internalBinding ( module ); } throw new Error ( `No such module: ${ module } ` ); }; } \u5728process\u5bf9\u8c61\uff08\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u4f7f\u7528\u7684process\u5bf9\u8c61\uff09\u4e2d\u6302\u8f7dbinding\u51fd\u6570\uff0c\u8fd9\u4e2a\u51fd\u6570\u4e3b\u8981\u7528\u4e8e\u5185\u7f6e\u7684JS\u6a21\u5757\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u7ecf\u5e38\u770b\u5230\u3002binding\u7684\u903b\u8f91\u5c31\u662f\u6839\u636e\u6a21\u5757\u540d\u67e5\u627e\u5bf9\u5e94\u7684C++\u6a21\u5757\u3002\u4e0a\u9762\u7684\u5904\u7406\u662f\u4e3a\u4e86Node.js\u80fd\u5728JS\u5c42\u901a\u8fc7binding\u51fd\u6570\u52a0\u8f7dC++\u6a21\u5757\uff0c\u6211\u4eec\u77e5\u9053Node.js\u4e2d\u8fd8\u6709\u539f\u751f\u7684JS\u6a21\u5757\uff08lib\u6587\u4ef6\u5939\u4e0b\u7684JS\u6587\u4ef6\uff09\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0b\uff0c\u5bf9\u4e8e\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u7684\u5904\u7406\u3002Node.js\u5b9a\u4e49\u4e86\u4e00\u4e2aNativeModule\u7c7b\u8d1f\u8d23\u539f\u751fJS\u6a21\u5757\u7684\u52a0\u8f7d\u3002\u8fd8\u5b9a\u4e49\u4e86\u4e00\u4e2a\u53d8\u91cf\u4fdd\u5b58\u4e86\u539f\u751fJS\u6a21\u5757\u7684\u540d\u79f0\u5217\u8868\u3002 1 static map = new Map ( moduleIds . map (( id ) => [ id , new NativeModule ( id )])); NativeModule\u4e3b\u8981\u7684\u903b\u8f91\u5982\u4e0b 1 \u539f\u751fJS\u6a21\u5757\u7684\u4ee3\u7801\u662f\u8f6c\u6210\u5b57\u7b26\u5b58\u5728node_javascript.cc\u6587\u4ef6\u7684\uff0cNativeModule\u8d1f\u8d23\u539f\u751fJS\u6a21\u5757\u7684\u52a0\u8f7d\uff0c\u5373\u7f16\u8bd1\u548c\u6267\u884c\u3002 2 \u63d0\u4f9b\u4e00\u4e2arequire\u51fd\u6570\uff0c\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\uff0c\u5bf9\u4e8e\u6587\u4ef6\u8def\u5f84\u4ee5internal\u5f00\u5934\u7684\u6a21\u5757\uff0c\u662f\u4e0d\u80fd\u88ab\u7528\u6237require\u4f7f\u7528\u7684\u3002 \u8fd9\u662f\u539f\u751fJS\u6a21\u5757\u52a0\u8f7d\u7684\u5927\u6982\u903b\u8f91\uff0c\u5177\u4f53\u7684\u6211\u4eec\u5728Node.js\u6a21\u5757\u52a0\u8f7d\u7ae0\u8282\u5177\u4f53\u5206\u6790\u3002\u6267\u884c\u5b8cinternal/bootstrap/loaders.js\uff0c\u6700\u540e\u8fd4\u56de\u4e09\u4e2a\u53d8\u91cf\u7ed9C++\u5c42\u3002 1 2 3 4 5 return { internalBinding , NativeModule , require : nativeModuleRequire }; C++\u5c42\u4fdd\u5b58\u5176\u4e2d\u4e24\u4e2a\u51fd\u6570\uff0c\u5206\u522b\u7528\u4e8e\u52a0\u8f7d\u5185\u7f6eC++\u6a21\u5757\u548c\u539f\u751fJS\u6a21\u5757\u7684\u51fd\u6570\u3002 1 2 set_internal_binding_loader ( internal_binding_loader . As < Function > ()); set_native_module_require ( require . As < Function > ()); \u81f3\u6b64\uff0cinternal/bootstrap/loaders.js\u5206\u6790\u5b8c\u4e86\u3002 2 \u521d\u59cb\u5316\u6267\u884c\u4e0a\u4e0b\u6587 BootstrapNode\u8d1f\u8d23\u521d\u59cb\u5316\u6267\u884c\u4e0a\u4e0b\u6587\uff0c\u4ee3\u7801\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 EscapableHandleScope scope ( isolate_ ); // \u83b7\u53d6\u5168\u5c40\u53d8\u91cf\u5e76\u8bbe\u7f6eglobal\u5c5e\u6027 Local < Object > global = context () -> Global (); global -> Set ( context (), FIXED_ONE_BYTE_STRING ( isolate_ , \"global\" ), global ). Check (); /* \u6267\u884cinternal/bootstrap/node.js\u65f6\u7684\u53c2\u6570 process, require, internalBinding, primordials */ std :: vector < Local < String >> node_params = { process_string (), require_string (), internal_binding_string (), primordials_string ()}; std :: vector < Local < Value >> node_args = { process_object (), // \u539f\u751f\u6a21\u5757\u52a0\u8f7d\u5668 native_module_require (), // C++\u6a21\u5757\u52a0\u8f7d\u5668 internal_binding_loader (), primordials ()}; MaybeLocal < Value > result = ExecuteBootstrapper ( this , \"internal/bootstrap/node\" , & node_params , & node_args ); \u5728\u5168\u5c40\u5bf9\u8c61\u4e0a\u8bbe\u7f6e\u4e00\u4e2aglobal\u5c5e\u6027\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u5728Node.js\u4e2d\u4f7f\u7528\u7684global\u5bf9\u8c61\u3002\u63a5\u7740\u6267\u884cinternal/bootstrap/node.js\u8bbe\u7f6e\u4e00\u4e9b\u53d8\u91cf\uff08\u5177\u4f53\u53ef\u4ee5\u53c2\u8003nternal/bootstrap/node.js\uff09\u3002 1 2 3 4 5 process . cpuUsage = wrapped . cpuUsage ; process . resourceUsage = wrapped . resourceUsage ; process . memoryUsage = wrapped . memoryUsage ; process . kill = wrapped . kill ; process . exit = wrapped . exit ; \u8bbe\u7f6e\u5168\u5c40\u53d8\u91cf 1 2 3 4 5 6 7 8 9 10 defineOperation ( global , ' clearInterval ' , timers . clearInterval ); defineOperation ( global , ' clearTimeout ' , timers . clearTimeout ); defineOperation ( global , ' setInterval ' , timers . setInterval ); defineOperation ( global , ' setTimeout ' , timers . setTimeout ); ObjectDefineProperty ( global , ' process ' , { value : process , enumerable : false , writable : true , configurable : true });","title":"1.3.4 \u521d\u59cb\u5316Loader\u548c\u6267\u884c\u4e0a\u4e0b\u6587"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#135-js","text":"StartMainThreadExecution\u8fdb\u884c\u4e00\u4e9b\u521d\u59cb\u5316\u5de5\u4f5c\uff0c\u7136\u540e\u6267\u884c\u7528\u6237JS\u4ee3\u7801\u3002 1 \u7ed9process\u5bf9\u8c61\u6302\u8f7d\u5c5e\u6027 \u6267\u884cpatchProcessObject\u51fd\u6570\uff08\u5728node_process_methods.cc\u4e2d\u5bfc\u51fa\uff09\u7ed9process\u5bf9\u8c61\u6302\u8f7d\u4e00\u4e9b\u5217\u5c5e\u6027\uff0c\u4e0d\u4e00\u4e00\u5217\u4e3e\u3002 1 2 3 4 5 6 7 8 // process.argv process -> Set ( context , FIXED_ONE_BYTE_STRING ( isolate , \"argv\" ), ToV8Value ( context , env -> argv ()). ToLocalChecked ()). Check (); READONLY_PROPERTY ( process , \"pid\" , Integer :: New ( isolate , uv_os_getpid ())); \u56e0\u4e3aNode.js\u589e\u52a0\u4e86\u5bf9\u7ebf\u7a0b\u7684\u652f\u6301\uff0c\u6709\u4e9b\u5c5e\u6027\u9700\u8981hack\u4e00\u4e0b\uff0c\u6bd4\u5982\u5728\u7ebf\u7a0b\u91cc\u4f7f\u7528process.exit\u7684\u65f6\u5019\uff0c\u9000\u51fa\u7684\u662f\u5355\u4e2a\u7ebf\u7a0b\uff0c\u800c\u4e0d\u662f\u6574\u4e2a\u8fdb\u7a0b\uff0cexit\u7b49\u51fd\u6570\u9700\u8981\u7279\u6b8a\u5904\u7406\u3002\u540e\u9762\u7ae0\u8282\u4f1a\u8be6\u7ec6\u8bb2\u89e3\u3002 2 \u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1 1 2 3 4 5 6 7 8 9 10 function setupChildProcessIpcChannel () { if ( process . env . NODE_CHANNEL_FD ) { const fd = parseInt ( process . env . NODE_CHANNEL_FD , 10 ); delete process . env . NODE_CHANNEL_FD ; const serializationMode = process . env . NODE_CHANNEL_SERIALIZATION_MODE || 'json' ; delete process . env . NODE_CHANNEL_SERIALIZATION_MODE ; require ( 'child_process' ). _forkChild ( fd , serializationMode ); } } \u73af\u5883\u53d8\u91cfNODE_CHANNEL_FD\u662f\u5728\u521b\u5efa\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\u8bbe\u7f6e\u7684\uff0c\u5982\u679c\u6709\u8bf4\u660e\u5f53\u524d\u542f\u52a8\u7684\u8fdb\u7a0b\u662f\u5b50\u8fdb\u7a0b\uff0c\u5219\u9700\u8981\u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1\u3002 3 \u5904\u7406cluster\u6a21\u5757\u7684\u8fdb\u7a0b\u95f4\u901a\u4fe1 1 2 3 4 5 6 7 function initializeclusterIPC () { if ( process . argv [ 1 ] && process . env . NODE_UNIQUE_ID ) { const cluster = require ( 'cluster' ); cluster . _setupWorker (); delete process . env . NODE_UNIQUE_ID ; } } 4 \u6267\u884c\u7528\u6237JS\u4ee3\u7801 1 require ( 'internal/modules/cjs/loader' ). Module . runMain ( process . argv [ 1 ]); internal/modules/cjs/loader.js\u662f\u8d1f\u8d23\u52a0\u8f7d\u7528\u6237JS\u7684\u6a21\u5757\uff0crunMain\u51fd\u6570\u5728pre_execution.js\u88ab\u6302\u8f7d\uff0crunMain\u505a\u7684\u4e8b\u60c5\u662f\u52a0\u8f7d\u7528\u6237\u7684JS\uff0c\u7136\u540e\u6267\u884c\u3002\u5177\u4f53\u7684\u8fc7\u7a0b\u5728\u540e\u9762\u7ae0\u8282\u8be6\u7ec6\u5206\u6790\u3002","title":"1.3.5 \u6267\u884c\u7528\u6237JS\u6587\u4ef6"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#136-libuv","text":"\u6267\u884c\u5b8c\u6240\u6709\u7684\u521d\u59cb\u5316\u540e\uff0cNode.js\u6267\u884c\u4e86\u7528\u6237\u7684JS\u4ee3\u7801\uff0c\u7528\u6237\u7684JS\u4ee3\u7801\u4f1a\u5f80Libuv\u6ce8\u518c\u4e00\u4e9b\u4efb\u52a1\uff0c\u6bd4\u5982\u521b\u5efa\u4e00\u4e2a\u670d\u52a1\u5668\uff0c\u6700\u540eNode.js\u8fdb\u5165Libuv\u7684\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u5f00\u59cb\u4e00\u8f6e\u53c8\u4e00\u8f6e\u7684\u4e8b\u4ef6\u5faa\u73af\u5904\u7406\u3002\u5982\u679c\u6ca1\u6709\u9700\u8981\u5904\u7406\u7684\u4efb\u52a1\uff0cLibuv\u4f1a\u9000\u51fa\uff0c\u4ece\u800cNode.js\u9000\u51fa\u3002 1 2 3 4 5 6 7 8 9 10 do { uv_run ( env -> event_loop (), UV_RUN_DEFAULT ); per_process :: v8_platform . DrainVMTasks ( isolate_ ); more = uv_loop_alive ( env -> event_loop ()); if ( more && ! env -> is_stopping ()) continue ; if ( ! uv_loop_alive ( env -> event_loop ())) { EmitBeforeExit ( env . get ()); } more = uv_loop_alive ( env -> event_loop ()); } while ( more == true && ! env -> is_stopping ());","title":"1.3.6 \u8fdb\u5165Libuv\u4e8b\u4ef6\u5faa\u73af"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#14-nodejs","text":"\u670d\u52a1\u5668\u662f\u73b0\u4ee3\u8f6f\u4ef6\u4e2d\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2a\u7ec4\u6210\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u670d\u52a1\u5668\u53d1\u5c55\u7684\u8fc7\u7a0b\u4e2d\uff0c\u90fd\u6709\u54ea\u4e9b\u8bbe\u8ba1\u67b6\u6784\u3002\u4e00\u4e2a\u57fa\u4e8eTCP\u534f\u8bae\u7684\u670d\u52a1\u5668\uff0c\u57fa\u672c\u7684\u6d41\u7a0b\u5982\u4e0b\uff08\u4f2a\u4ee3\u7801\uff09\u3002 1 2 3 4 5 6 // \u62ff\u5230\u4e00\u4e2asocket\u7528\u4e8e\u76d1\u542c const socketfd = socket ( \u534f\u8bae\u7c7b\u578b\u7b49\u914d\u7f6e ); // \u76d1\u542c\u672c\u673a\u7684\u5730\u5740\uff08ip+\u7aef\u53e3\uff09 bind ( socketfd \uff0c \u76d1\u542c\u5730\u5740 ) // \u6807\u8bb0\u8be5socket\u662f\u76d1\u542c\u578bsocket listen ( socketfd ) \u6267\u884c\u5b8c\u4ee5\u4e0a\u6b65\u9aa4\uff0c\u4e00\u4e2a\u670d\u52a1\u5668\u6b63\u5f0f\u5f00\u59cb\u670d\u52a1\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u57fa\u4e8e\u4e0a\u9762\u7684\u6a21\u578b\uff0c\u5206\u6790\u5404\u79cd\u5404\u6837\u7684\u5904\u7406\u65b9\u6cd5\u3002","title":"1.4 Node.js\u548c\u5176\u5b83\u670d\u52a1\u5668\u7684\u6bd4\u8f83"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#141","text":"1 2 3 4 5 6 while ( 1 ) { const socketForCommunication = accept ( socket ); const data = read ( socketForCommunication ); handle ( data ); write ( socketForCommunication , data ); } \u6211\u4eec\u770b\u770b\u8fd9\u79cd\u6a21\u5f0f\u7684\u5904\u7406\u8fc7\u7a0b\uff0c\u5047\u8bbe\u6709n\u4e2a\u8bf7\u6c42\u5230\u6765\u3002\u90a3\u4e48socket\u7684\u7ed3\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u8fd9\u65f6\u5019\u8fdb\u7a0b\u4eceaccept\u4e2d\u88ab\u5524\u9192\u3002\u7136\u540e\u62ff\u5230\u4e00\u4e2a\u65b0\u7684socket\u7528\u4e8e\u901a\u4fe1\u3002\u7ed3\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 accept\u5c31\u662f\u4ece\u5df2\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u7684\u8fde\u63a5\u961f\u5217\u91cc\uff0c\u6458\u4e0b\u4e00\u4e2a\u8282\u70b9\u3002\u5f88\u591a\u540c\u5b66\u90fd\u4e86\u89e3\u4e09\u6b21\u63e1\u624b\u662f\u4ec0\u4e48\uff0c\u4f46\u662f\u53ef\u80fd\u5f88\u5c11\u540c\u5b66\u4f1a\u6df1\u5165\u601d\u8003\u6216\u8005\u770b\u5b83\u7684\u5b9e\u73b0\uff0c\u4f17\u6240\u5468\u77e5\uff0c\u4e00\u4e2a\u670d\u52a1\u5668\u542f\u52a8\u7684\u65f6\u5019\uff0c\u4f1a\u76d1\u542c\u4e00\u4e2a\u7aef\u53e3\uff0c\u5176\u5b9e\u5c31\u662f\u65b0\u5efa\u4e86\u4e00\u4e2asocket\u3002\u90a3\u4e48\u5982\u679c\u6709\u4e00\u4e2a\u8fde\u63a5\u5230\u6765\u7684\u65f6\u5019\uff0c\u6211\u4eec\u901a\u8fc7accept\u5c31\u80fd\u62ff\u5230\u8fd9\u4e2a\u65b0\u8fde\u63a5\u5bf9\u5e94\u7684socket\uff0c\u90a3\u8fd9\u4e2asocket\u548c\u76d1\u542c\u7684socket\u662f\u4e0d\u662f\u540c\u4e00\u4e2a\u5462\uff1f\u5176\u5b9esocket\u5206\u4e3a\u76d1\u542c\u578b\u548c\u901a\u4fe1\u578b\u7684\uff0c\u8868\u9762\u4e0a\uff0c\u670d\u52a1\u5668\u7528\u4e00\u4e2a\u7aef\u53e3\u5b9e\u73b0\u4e86\u591a\u4e2a\u8fde\u63a5\uff0c\u4f46\u662f\u8fd9\u4e2a\u7aef\u53e3\u662f\u7528\u4e8e\u76d1\u542c\u7684\uff0c\u5e95\u5c42\u7528\u4e8e\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5176\u5b9e\u662f\u53e6\u4e00\u4e2asocket\u3002\u6240\u4ee5\u6bcf\u4e00\u4e2a\u8fde\u63a5\u8fc7\u6765\uff0c\u8d1f\u8d23\u76d1\u542c\u7684socket\u53d1\u73b0\u662f\u4e00\u4e2a\u5efa\u7acb\u8fde\u63a5\u7684\u5305\uff08syn\u5305\uff09\uff0c\u5b83\u5c31\u4f1a\u751f\u6210\u4e00\u4e2a\u65b0\u7684socket\u4e0e\u4e4b\u901a\u4fe1\uff08accept\u7684\u65f6\u5019\u8fd4\u56de\u7684\u90a3\u4e2a\uff09\u3002\u76d1\u542csocket\u91cc\u53ea\u4fdd\u5b58\u4e86\u5b83\u76d1\u542c\u7684IP\u548c\u7aef\u53e3\uff0c\u901a\u4fe1socket\u9996\u5148\u4ece\u76d1\u542csocket\u4e2d\u590d\u5236IP\u548c\u7aef\u53e3\uff0c\u7136\u540e\u628a\u5ba2\u6237\u7aef\u7684IP\u548c\u7aef\u53e3\u4e5f\u8bb0\u5f55\u4e0b\u6765\uff0c\u5f53\u4e0b\u6b21\u6536\u5230\u4e00\u4e2a\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u6839\u636e\u56db\u5143\u7ec4\u4ecesocket\u6c60\u5b50\u91cc\u627e\u5230\u8be5socket\uff0c\u4ece\u800c\u5b8c\u6210\u6570\u636e\u7684\u5904\u7406\u3002 \u4e32\u884c\u8fd9\u79cd\u6a21\u5f0f\u5c31\u662f\u4ece\u5df2\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u7684\u961f\u5217\u91cc\u6458\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u7136\u540e\u5904\u7406\u3002\u518d\u6458\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u518d\u5904\u7406\u3002\u5982\u679c\u5904\u7406\u7684\u8fc7\u7a0b\u4e2d\u6709\u963b\u585e\u5f0fIO\uff0c\u53ef\u60f3\u800c\u77e5\uff0c\u6548\u7387\u662f\u6709\u591a\u4f4e\u3002\u800c\u4e14\u5e76\u53d1\u91cf\u6bd4\u8f83\u5927\u7684\u65f6\u5019\uff0c\u76d1\u542csocket\u5bf9\u5e94\u7684\u961f\u5217\u5f88\u5feb\u5c31\u4f1a\u88ab\u5360\u6ee1\uff08\u5df2\u5b8c\u6210\u8fde\u63a5\u961f\u5217\u6709\u4e00\u4e2a\u6700\u5927\u957f\u5ea6\uff09\u3002\u8fd9\u662f\u6700\u7b80\u5355\u7684\u6a21\u5f0f\uff0c\u867d\u7136\u670d\u52a1\u5668\u7684\u8bbe\u8ba1\u4e2d\u80af\u5b9a\u4e0d\u4f1a\u4f7f\u7528\u8fd9\u79cd\u6a21\u5f0f\uff0c\u4f46\u662f\u5b83\u8ba9\u6211\u4eec\u4e86\u89e3\u4e86\u4e00\u4e2a\u670d\u52a1\u5668\u5904\u7406\u8bf7\u6c42\u7684\u6574\u4f53\u8fc7\u7a0b\u3002","title":"1.4.1 \u4e32\u884c\u5904\u7406\u8bf7\u6c42"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#142","text":"\u4e32\u884c\u6a21\u5f0f\u4e2d\uff0c\u6240\u6709\u8bf7\u6c42\u90fd\u5728\u4e00\u4e2a\u8fdb\u7a0b\u4e2d\u6392\u961f\u88ab\u5904\u7406\uff0c\u8fd9\u662f\u6548\u7387\u4f4e\u4e0b\u7684\u539f\u56e0\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u628a\u8bf7\u6c42\u5206\u7ed9\u591a\u4e2a\u8fdb\u7a0b\u5904\u7406\u6765\u63d0\u4f9b\u6548\u7387\uff0c\u56e0\u4e3a\u5728\u4e32\u884c\u5904\u7406\u7684\u6a21\u5f0f\u4e2d\uff0c\u5982\u679c\u6709\u963b\u585e\u5f0fIO\u64cd\u4f5c\uff0c\u5b83\u5c31\u4f1a\u963b\u585e\u4e3b\u8fdb\u7a0b\uff0c\u4ece\u800c\u963b\u585e\u540e\u7eed\u8bf7\u6c42\u7684\u5904\u7406\u3002\u5728\u591a\u8fdb\u7a0b\u7684\u6a21\u5f0f\u4e0b\uff0c\u4e00\u4e2a\u8bf7\u6c42\u5982\u679c\u963b\u585e\u4e86\u8fdb\u7a0b\uff0c\u90a3\u4e48\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6302\u8d77\u8be5\u8fdb\u7a0b\uff0c\u63a5\u7740\u8c03\u5ea6\u5176\u5b83\u8fdb\u7a0b\u6267\u884c\uff0c\u90a3\u4e48\u5176\u5b83\u8fdb\u7a0b\u5c31\u53ef\u4ee5\u6267\u884c\u65b0\u7684\u4efb\u52a1\u3002\u591a\u8fdb\u7a0b\u6a21\u5f0f\u4e0b\u5206\u4e3a\u51e0\u79cd\u3002 1 \u4e3b\u8fdb\u7a0baccept\uff0c\u5b50\u8fdb\u7a0b\u5904\u7406\u8bf7\u6c42 \u8fd9\u79cd\u6a21\u5f0f\u4e0b\uff0c\u4e3b\u8fdb\u7a0b\u8d1f\u8d23\u6458\u53d6\u5df2\u5b8c\u6210\u8fde\u63a5\u7684\u8282\u70b9\uff0c\u7136\u540e\u628a\u8fd9\u4e2a\u8282\u70b9\u5bf9\u5e94\u7684\u8bf7\u6c42\u4ea4\u7ed9\u5b50\u8fdb\u7a0b\u5904\u7406\uff0c\u903b\u8f91\u5982\u4e0b\u3002 1 2 3 4 5 6 7 8 9 10 while ( 1 ) { const socketForCommunication = accept ( socket ); if ( fork () > 0 ) { continue ; // \u7236\u8fdb\u7a0b } else { // \u5b50\u8fdb\u7a0b handle ( socketForCommunication ); } } \u8fd9\u79cd\u6a21\u5f0f\u4e0b\uff0c\u6bcf\u6b21\u6765\u4e00\u4e2a\u8bf7\u6c42\uff0c\u5c31\u4f1a\u65b0\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u53bb\u5904\u7406\u3002\u8fd9\u79cd\u6a21\u5f0f\u6bd4\u4e32\u884c\u7684\u7a0d\u5fae\u597d\u4e86\u4e00\u70b9\uff0c\u6bcf\u4e2a\u8bf7\u6c42\u72ec\u7acb\u5904\u7406\uff0c\u5047\u8bbea\u8bf7\u6c42\u963b\u585e\u5728\u6587\u4ef6IO\uff0c\u90a3\u4e48\u4e0d\u4f1a\u5f71\u54cdb\u8bf7\u6c42\u7684\u5904\u7406\uff0c\u5c3d\u53ef\u80fd\u5730\u505a\u5230\u4e86\u5e76\u53d1\u3002\u5b83\u7684\u74f6\u9888\u5c31\u662f\u7cfb\u7edf\u7684\u8fdb\u7a0b\u6570\u6709\u9650\uff0c\u5982\u679c\u6709\u5927\u91cf\u7684\u8bf7\u6c42\uff0c\u7cfb\u7edf\u65e0\u6cd5\u625b\u5f97\u4f4f\uff0c\u518d\u8005\uff0c\u8fdb\u7a0b\u7684\u5f00\u9500\u5f88\u5927\uff0c\u5bf9\u4e8e\u7cfb\u7edf\u6765\u8bf4\u662f\u4e00\u4e2a\u6c89\u91cd\u7684\u8d1f\u62c5\u3002 2 \u8fdb\u7a0b\u6c60\u6a21\u5f0f \u5b9e\u65f6\u521b\u5efa\u548c\u9500\u6bc1\u8fdb\u7a0b\u5f00\u9500\u5927\uff0c\u6548\u7387\u4f4e\uff0c\u6240\u4ee5\u884d\u751f\u4e86\u8fdb\u7a0b\u6c60\u6a21\u5f0f\uff0c\u8fdb\u7a0b\u6c60\u6a21\u5f0f\u5c31\u662f\u670d\u52a1\u5668\u542f\u52a8\u7684\u65f6\u5019\uff0c\u9884\u5148\u521b\u5efa\u4e00\u5b9a\u6570\u91cf\u7684\u8fdb\u7a0b\uff0c\u4f46\u662f\u8fd9\u4e9b\u8fdb\u7a0b\u662fworker\u8fdb\u7a0b\u3002\u5b83\u4e0d\u8d1f\u8d23accept\u8bf7\u6c42\u3002\u5b83\u53ea\u8d1f\u8d23\u5904\u7406\u8bf7\u6c42\u3002\u4e3b\u8fdb\u7a0b\u8d1f\u8d23accept\uff0c\u5b83\u628aaccept\u8fd4\u56de\u7684socket\u4ea4\u7ed9worker\u8fdb\u7a0b\u5904\u7406\uff0c\u6a21\u5f0f\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u4f46\u662f\u548c1\u4e2d\u7684\u6a21\u5f0f\u76f8\u6bd4\uff0c\u8fdb\u7a0b\u6c60\u6a21\u5f0f\u76f8\u5bf9\u6bd4\u8f83\u590d\u6742\uff0c\u56e0\u4e3a\u5728\u6a21\u5f0f1\u4e2d\uff0c\u5f53\u4e3b\u8fdb\u7a0b\u6536\u5230\u4e00\u4e2a\u8bf7\u6c42\u7684\u65f6\u5019\uff0c\u5b9e\u65f6fork\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u8fd9\u65f6\u5019\uff0c\u8fd9\u4e2a\u5b50\u8fdb\u7a0b\u4f1a\u7ee7\u627f\u4e3b\u8fdb\u7a0b\u4e2d\u65b0\u8bf7\u6c42\u5bf9\u5e94\u7684fd\uff0c\u6240\u4ee5\u5b83\u53ef\u4ee5\u76f4\u63a5\u5904\u7406\u8be5fd\u5bf9\u5e94\u7684\u8bf7\u6c42\uff0c\u5728\u8fdb\u7a0b\u6c60\u7684\u6a21\u5f0f\u4e2d\uff0c\u5b50\u8fdb\u7a0b\u662f\u9884\u5148\u521b\u5efa\u7684\uff0c\u5f53\u4e3b\u8fdb\u7a0b\u6536\u5230\u4e00\u4e2a\u8bf7\u6c42\u7684\u65f6\u5019\uff0c\u5b50\u8fdb\u7a0b\u4e2d\u662f\u65e0\u6cd5\u62ff\u5f97\u5230\u8be5\u8bf7\u6c42\u5bf9\u5e94\u7684fd\u7684\u3002\u8fd9\u65f6\u5019\uff0c\u9700\u8981\u4e3b\u8fdb\u7a0b\u4f7f\u7528\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u6280\u672f\u628a\u8fd9\u4e2a\u8bf7\u6c42\u5bf9\u5e94\u7684fd\u4f20\u7ed9\u5b50\u8fdb\u7a0b\u3002\u4e00\u4e2a\u8fdb\u7a0b\u5176\u5b9e\u5c31\u662f\u4e00\u4e2a\u7ed3\u6784\u4f53task_struct\uff0c\u5728JS\u91cc\u6211\u4eec\u53ef\u4ee5\u8bf4\u662f\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5b83\u6709\u4e00\u4e2a\u5b57\u6bb5\u8bb0\u5f55\u4e86\u6253\u5f00\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5f53\u6211\u4eec\u8bbf\u95ee\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u6839\u636efd\u7684\u503c\uff0c\u4ecetask_struct\u4e2d\u627e\u5230fd\u5bf9\u5e94\u7684\u5e95\u5c42\u8d44\u6e90\uff0c\u6240\u4ee5\u4e3b\u8fdb\u7a0b\u7ed9\u5b50\u8fdb\u7a0b\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u65f6\u5019\uff0c\u4f20\u9012\u7684\u4e0d\u4ec5\u4ec5\u662f\u4e00\u4e2a\u6570\u5b57fd\uff0c\u56e0\u4e3a\u5982\u679c\u4ec5\u4ec5\u8fd9\u6837\u505a\uff0c\u5728\u5b50\u8fdb\u7a0b\u4e2d\u8be5fd\u53ef\u80fd\u6ca1\u6709\u5bf9\u5e94\u4efb\u4f55\u8d44\u6e90\uff0c\u6216\u8005\u5bf9\u5e94\u7684\u8d44\u6e90\u548c\u4e3b\u8fdb\u7a0b\u4e2d\u7684\u662f\u4e0d\u4e00\u81f4\u7684\u3002\u8fd9\u5176\u4e2d\u64cd\u4f5c\u7cfb\u7edf\u5e2e\u6211\u4eec\u505a\u4e86\u5f88\u591a\u4e8b\u60c5\u3002\u8ba9\u6211\u4eec\u5728\u5b50\u8fdb\u7a0b\u4e2d\u53ef\u4ee5\u901a\u8fc7fd\u8bbf\u95ee\u5230\u6b63\u786e\u7684\u8d44\u6e90\uff0c\u5373\u4e3b\u8fdb\u7a0b\u4e2d\u6536\u5230\u7684\u8bf7\u6c42\u3002 3 \u5b50\u8fdb\u7a0baccept \u8fd9\u79cd\u6a21\u5f0f\u4e0d\u662f\u7b49\u5230\u8bf7\u6c42\u6765\u7684\u65f6\u5019\u518d\u521b\u5efa\u8fdb\u7a0b\u3002\u800c\u662f\u5728\u670d\u52a1\u5668\u542f\u52a8\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u521b\u5efa\u591a\u4e2a\u8fdb\u7a0b\u3002\u7136\u540e\u591a\u4e2a\u8fdb\u7a0b\u5206\u522b\u8c03\u7528accept\u3002\u8fd9\u79cd\u6a21\u5f0f\u7684\u67b6\u6784\u5982\u56fe1-8\u6240\u793a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const socketfd = socket ( \u534f\u8bae\u7c7b\u578b\u7b49\u914d\u7f6e ); bind ( socketfd \uff0c \u76d1\u542c\u5730\u5740 ) for ( let i = 0 ; i < \u8fdb\u7a0b\u4e2a\u6570 ; i ++ ) { if ( fork () > 0 ) { // \u7236\u8fdb\u7a0b\u8d1f\u8d23\u76d1\u63a7\u5b50\u8fdb\u7a0b } else { // \u5b50\u8fdb\u7a0b\u5904\u7406\u8bf7\u6c42 listen ( socketfd ); while ( 1 ) { const socketForCommunication = accept ( socketfd ); handle ( socketForCommunication ); } } } \u8fd9\u79cd\u6a21\u5f0f\u4e0b\u591a\u4e2a\u5b50\u8fdb\u7a0b\u90fd\u963b\u585e\u5728accept\u3002\u5982\u679c\u8fd9\u65f6\u5019\u6709\u4e00\u4e2a\u8bf7\u6c42\u5230\u6765\uff0c\u90a3\u4e48\u6240\u6709\u7684\u5b50\u8fdb\u7a0b\u90fd\u4f1a\u88ab\u5524\u9192\uff0c\u4f46\u662f\u9996\u5148\u88ab\u8c03\u5ea6\u7684\u5b50\u8fdb\u7a0b\u4f1a\u9996\u5148\u6458\u4e0b\u8fd9\u4e2a\u8bf7\u6c42\u8282\u70b9\uff0c\u540e\u7eed\u7684\u8fdb\u7a0b\u88ab\u5524\u9192\u540e\u53ef\u80fd\u4f1a\u9047\u5230\u5df2\u7ecf\u6ca1\u6709\u8bf7\u6c42\u53ef\u4ee5\u5904\u7406\uff0c\u53c8\u8fdb\u5165\u7761\u7720\uff0c\u8fdb\u7a0b\u88ab\u65e0\u6548\u5524\u9192\uff0c\u8fd9\u662f\u8457\u540d\u7684\u60ca\u7fa4\u73b0\u8c61\u3002\u6539\u8fdb\u65b9\u5f0f\u5c31\u662f\u5728accpet\u4e4b\u524d\u52a0\u9501\uff0c\u62ff\u5230\u9501\u7684\u8fdb\u7a0b\u624d\u80fd\u8fdb\u884caccept\uff0c\u8fd9\u6837\u5c31\u4fdd\u8bc1\u4e86\u53ea\u6709\u4e00\u4e2a\u8fdb\u7a0b\u4f1a\u963b\u585e\u5728accept\uff0cNginx\u89e3\u51b3\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0c\u4f46\u662f\u65b0\u7248\u64cd\u4f5c\u7cfb\u7edf\u5df2\u7ecf\u5728\u5185\u6838\u5c42\u9762\u89e3\u51b3\u4e86\u8fd9\u4e2a\u95ee\u9898\u3002\u6bcf\u6b21\u53ea\u4f1a\u5524\u9192\u4e00\u4e2a\u8fdb\u7a0b\u3002\u901a\u5e38\u8fd9\u79cd\u6a21\u5f0f\u548c\u4e8b\u4ef6\u9a71\u52a8\u914d\u5408\u4f7f\u7528\u3002","title":"1.4.2 \u591a\u8fdb\u7a0b\u6a21\u5f0f"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#143","text":"\u591a\u7ebf\u7a0b\u6a21\u5f0f\u548c\u591a\u8fdb\u7a0b\u6a21\u5f0f\u662f\u7c7b\u4f3c\u7684\uff0c\u4e5f\u662f\u5206\u4e3a\u4e0b\u9762\u51e0\u79cd 1 \u4e3b\u8fdb\u7a0baccept\uff0c\u521b\u5efa\u5b50\u7ebf\u7a0b\u5904\u7406 2 \u5b50\u7ebf\u7a0baccept 3 \u7ebf\u7a0b\u6c60 \u524d\u9762\u4e24\u79cd\u548c\u591a\u8fdb\u7a0b\u6a21\u5f0f\u4e2d\u662f\u4e00\u6837\u7684\uff0c\u4f46\u662f\u7b2c\u4e09\u79cd\u6bd4\u8f83\u7279\u522b\uff0c\u6211\u4eec\u4e3b\u8981\u4ecb\u7ecd\u7b2c\u4e09\u79cd\u3002\u5728\u5b50\u8fdb\u7a0b\u6a21\u5f0f\u65f6\uff0c\u6bcf\u4e2a\u5b50\u8fdb\u7a0b\u90fd\u6709\u81ea\u5df1\u7684task_struct\uff0c\u8fd9\u5c31\u610f\u5473\u7740\u5728fork\u4e4b\u540e\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u8d1f\u8d23\u7ef4\u62a4\u81ea\u5df1\u7684\u6570\u636e\uff0c\u800c\u7ebf\u7a0b\u5219\u4e0d\u4e00\u6837\uff0c\u7ebf\u7a0b\u662f\u5171\u4eab\u4e3b\u7ebf\u7a0b\uff08\u4e3b\u8fdb\u7a0b\uff09\u7684\u6570\u636e\u7684\uff0c\u5f53\u4e3b\u8fdb\u7a0b\u4eceaccept\u4e2d\u62ff\u5230\u4e00\u4e2afd\u7684\u65f6\u5019\uff0c\u4f20\u7ed9\u7ebf\u7a0b\u7684\u8bdd\uff0c\u7ebf\u7a0b\u662f\u53ef\u4ee5\u76f4\u63a5\u64cd\u4f5c\u7684\u3002\u6240\u4ee5\u5728\u7ebf\u7a0b\u6c60\u6a21\u5f0f\u65f6\uff0c\u67b6\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u4e3b\u8fdb\u7a0b\u8d1f\u8d23accept\u8bf7\u6c42\uff0c\u7136\u540e\u901a\u8fc7\u4e92\u65a5\u7684\u65b9\u5f0f\u63d2\u5165\u4e00\u4e2a\u4efb\u52a1\u5230\u5171\u4eab\u961f\u5217\u4e2d\uff0c\u7ebf\u7a0b\u6c60\u4e2d\u7684\u5b50\u7ebf\u7a0b\u540c\u6837\u662f\u901a\u8fc7\u4e92\u65a5\u7684\u65b9\u5f0f\uff0c\u4ece\u5171\u4eab\u961f\u5217\u4e2d\u6458\u53d6\u8282\u70b9\u8fdb\u884c\u5904\u7406\u3002","title":"1.4.3 \u591a\u7ebf\u7a0b\u6a21\u5f0f"},{"location":"chapter01-Node.js%E7%BB%84%E6%88%90%E5%92%8C%E5%8E%9F%E7%90%86/#144","text":"\u73b0\u5728\u5f88\u591a\u670d\u52a1\u5668\uff08Nginx\uff0cNode.js\uff0cRedis\uff09\u90fd\u5f00\u59cb\u4f7f\u7528\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5f0f\u53bb\u8bbe\u8ba1\u3002\u4ece\u4e4b\u524d\u7684\u8bbe\u8ba1\u6a21\u5f0f\u4e2d\u6211\u4eec\u77e5\u9053\uff0c\u4e3a\u4e86\u5e94\u5bf9\u5927\u91cf\u7684\u8bf7\u6c42\uff0c\u670d\u52a1\u5668\u9700\u8981\u5927\u91cf\u7684\u8fdb\u7a0b/\u7ebf\u7a0b\u3002\u8fd9\u4e2a\u662f\u4e2a\u975e\u5e38\u5927\u7684\u5f00\u9500\u3002\u800c\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5f0f\uff0c\u4e00\u822c\u662f\u914d\u5408\u5355\u8fdb\u7a0b\uff08\u5355\u7ebf\u7a0b\uff09\uff0c\u518d\u591a\u7684\u8bf7\u6c42\uff0c\u4e5f\u662f\u5728\u4e00\u4e2a\u8fdb\u7a0b\u91cc\u5904\u7406\u7684\u3002\u4f46\u662f\u56e0\u4e3a\u662f\u5355\u8fdb\u7a0b\uff0c\u6240\u4ee5\u4e0d\u9002\u5408CPU\u5bc6\u96c6\u578b\uff0c\u56e0\u4e3a\u4e00\u4e2a\u4efb\u52a1\u4e00\u76f4\u5728\u5360\u636eCPU\u7684\u8bdd\uff0c\u540e\u7eed\u7684\u4efb\u52a1\u5c31\u65e0\u6cd5\u6267\u884c\u4e86\u3002\u5b83\u66f4\u9002\u5408IO\u5bc6\u96c6\u7684\uff08\u4e00\u822c\u90fd\u4f1a\u63d0\u4f9b\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u8d1f\u8d23\u5904\u7406CPU\u6216\u8005\u963b\u585e\u578b\u7684\u4efb\u52a1\uff09\u3002\u800c\u4f7f\u7528\u591a\u8fdb\u7a0b/\u7ebf\u7a0b\u6a21\u5f0f\u7684\u65f6\u5019\uff0c\u4e00\u4e2a\u8fdb\u7a0b/\u7ebf\u7a0b\u662f\u65e0\u6cd5\u4e00\u76f4\u5360\u636eCPU\u7684\uff0c\u6267\u884c\u4e00\u5b9a\u65f6\u95f4\u540e\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6267\u884c\u4efb\u52a1\u8c03\u5ea6\u3002\u8ba9\u5176\u5b83\u7ebf\u7a0b\u4e5f\u6709\u673a\u4f1a\u6267\u884c\uff0c\u8fd9\u6837\u5c31\u4e0d\u4f1a\u524d\u9762\u7684\u4efb\u52a1\u963b\u585e\u540e\u9762\u7684\u4efb\u52a1\uff0c\u51fa\u73b0\u9965\u997f\u60c5\u51b5\u3002\u5927\u90e8\u5206\u64cd\u4f5c\u7cfb\u7edf\u90fd\u63d0\u4f9b\u4e86\u4e8b\u4ef6\u9a71\u52a8\u7684API\u3002\u4f46\u662f\u4e8b\u4ef6\u9a71\u52a8\u5728\u4e0d\u540c\u7cfb\u7edf\u4e2d\u5b9e\u73b0\u4e0d\u4e00\u6837\u3002\u6240\u4ee5\u4e00\u822c\u90fd\u4f1a\u6709\u4e00\u5c42\u62bd\u8c61\u5c42\u62b9\u5e73\u8fd9\u4e2a\u5dee\u5f02\u3002\u8fd9\u91cc\u4ee5Linux\u7684epoll\u4e3a\u4f8b\u5b50\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // \u521b\u5efa\u4e00\u4e2aepoll var epollFD = epoll_create (); /* \u5728epoll\u7ed9\u67d0\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u6ce8\u518c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u8fd9\u91cc\u662f\u76d1\u542c\u7684socket\uff0c\u6ce8\u518c\u53ef \u8bfb\u4e8b\u4ef6\uff0c\u5373\u8fde\u63a5\u5230\u6765 event = { event: \u53ef\u8bfb fd\uff1a \u76d1\u542csocket // \u4e00\u4e9b\u4e0a\u4e0b\u6587 } */ epoll_ctl ( epollFD , EPOLL_CTL_ADD , socket , event ); while ( 1 ) { // \u963b\u585e\u7b49\u5f85\u4e8b\u4ef6\u5c31\u7eea\uff0cevents\u4fdd\u5b58\u5c31\u7eea\u4e8b\u4ef6\u7684\u4fe1\u606f\uff0ctotal\u662f\u4e2a\u6570 var total = epoll_wait ( epollFD , \u4fdd\u5b58\u5c31\u7eea\u4e8b\u4ef6\u7684\u7ed3\u6784 events , \u4e8b\u4ef6\u4e2a\u6570 , timeout ); for ( let i = 0 ; i < total ; i ++ ) { if ( events [ i ]. fd === \u76d1\u542c socket ) { var newSocket = accpet ( socket ); /* \u628a\u65b0\u7684socket\u4e5f\u6ce8\u518c\u5230epoll\uff0c\u7b49\u5f85\u53ef\u8bfb\uff0c \u5373\u53ef\u8bfb\u53d6\u5ba2\u6237\u7aef\u6570\u636e */ epoll_ctl ( epollFD , EPOLL_CTL_ADD , newSocket , \u53ef\u8bfb\u4e8b\u4ef6 ); } else { // \u4eceevents[i]\u4e2d\u62ff\u5230\u4e00\u4e9b\u4e0a\u4e0b\u6587\uff0c\u6267\u884c\u76f8\u5e94\u7684\u56de\u8c03 } } } \u8fd9\u5c31\u662f\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5f0f\u7684\u5927\u81f4\u8fc7\u7a0b\uff0c\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u8ba2\u9605/\u53d1\u5e03\u6a21\u5f0f\u3002\u670d\u52a1\u5668\u901a\u8fc7\u6ce8\u518c\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u4e8b\u4ef6\u5230epoll\u4e2d\uff0cepoll\u5f00\u59cb\u963b\u585e\uff0c\u7b49\u5230epoll\u8fd4\u56de\u7684\u65f6\u5019\uff0c\u5b83\u4f1a\u544a\u8bc9\u670d\u52a1\u5668\u54ea\u4e9bfd\u7684\u54ea\u4e9b\u4e8b\u4ef6\u89e6\u53d1\u4e86\uff0c\u8fd9\u65f6\u5019\u670d\u52a1\u5668\u904d\u5386\u5c31\u7eea\u4e8b\u4ef6\uff0c\u7136\u540e\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\uff0c\u5728\u56de\u8c03\u91cc\u53ef\u4ee5\u518d\u6b21\u6ce8\u518c\u65b0\u7684\u4e8b\u4ef6\uff0c\u5c31\u662f\u8fd9\u6837\u4e0d\u65ad\u9a71\u52a8\u7740\u3002epoll\u7684\u539f\u7406\u5176\u5b9e\u4e5f\u7c7b\u4f3c\u4e8b\u4ef6\u9a71\u52a8\uff0cepoll\u5e95\u5c42\u7ef4\u62a4\u7528\u6237\u6ce8\u518c\u7684\u4e8b\u4ef6\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cepoll\u672c\u8eab\u4e5f\u4f1a\u5728\u6587\u4ef6\u63cf\u8ff0\u7b26\u5bf9\u5e94\u7684\u6587\u4ef6/socket/\u7ba1\u9053\u5904\u6ce8\u518c\u4e00\u4e2a\u56de\u8c03\uff0c\u7136\u540e\u81ea\u8eab\u8fdb\u5165\u963b\u585e\uff0c\u7b49\u5230\u522b\u4eba\u901a\u77e5epoll\u6709\u4e8b\u4ef6\u53d1\u751f\u7684\u65f6\u5019\uff0cepoll\u5c31\u4f1a\u628afd\u548c\u4e8b\u4ef6\u8fd4\u56de\u7ed9\u7528\u6237\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 function epoll_wait () { for \u4e8b\u4ef6\u4e2a\u6570 // \u8c03\u7528\u6587\u4ef6\u7cfb\u7edf\u7684\u51fd\u6570\u5224\u65ad if ( \u4e8b\u4ef6 [ i ] \u4e2d\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e2d\u6709\u67d0\u4e2a\u7528\u6237\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u53d1\u751f ? ) { \u63d2\u5165\u5c31\u7eea\u4e8b\u4ef6\u961f\u5217 } else { /* \u5728\u4e8b\u4ef6[i]\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u6240\u5bf9\u5e94\u7684\u6587\u4ef6/socket/\u7ba1\u9053\u7b49indeo\u8282 \u70b9\u6ce8\u518c\u56de\u8c03\u3002\u5373\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u89e6\u53d1\u540e\u56de\u8c03epoll\uff0c\u56de\u8c03epoll\u540e\uff0c epoll\u628a\u8be5event[i]\u63d2\u5165\u5c31\u7eea\u4e8b\u4ef6\u961f\u5217\u8fd4\u56de\u7ed9\u7528\u6237 */ } } \u4ee5\u4e0a\u5c31\u662f\u670d\u52a1\u5668\u8bbe\u8ba1\u7684\u4e00\u4e9b\u57fa\u672c\u4ecb\u7ecd\u3002\u73b0\u5728\u7684\u670d\u52a1\u5668\u7684\u8bbe\u8ba1\u4e2d\u8fd8\u4f1a\u6d89\u53ca\u5230\u534f\u7a0b\u3002\u4e0d\u8fc7\u76ee\u524d\u8fd8\u6ca1\u6709\u770b\u8fc7\u5177\u4f53\u7684\u5b9e\u73b0\uff0c\u6240\u4ee5\u6682\u4e0d\u5c55\u5f00\u4ecb\u7ecd\uff0c\u6709\u5174\u8da3\u7684\u901a\u4fe1\u53ef\u4ee5\u770b\u4e00\u4e0b\u534f\u7a0b\u5e93libtask\u4e86\u89e3\u4e00\u4e0b\u5982\u4f55\u4f7f\u7528\u534f\u7a0b\u5b9e\u73b0\u4e00\u4e2a\u670d\u52a1\u5668\u3002 Node.js\u662f\u57fa\u4e8e\u5355\u8fdb\u7a0b\uff08\u5355\u7ebf\u7a0b\uff09\u7684\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5f0f\u3002\u8fd9\u4e5f\u662f\u4e3a\u4ec0\u4e48Node.js\u64c5\u957f\u5904\u7406\u9ad8\u5e76\u53d1IO\u578b\u4efb\u52a1\u800c\u4e0d\u64c5\u957f\u5904\u7406CPU\u578b\u4efb\u52a1\u7684\u539f\u56e0\uff0cNginx\u3001Redis\u4e5f\u662f\u8fd9\u79cd\u6a21\u5f0f\u3002\u53e6\u5916Node.js\u662f\u4e00\u4e2a\u53caweb\u670d\u52a1\u5668\u548c\u5e94\u7528\u670d\u52a1\u5668\u4e8e\u4e00\u8eab\u7684\u670d\u52a1\u5668\uff0c\u50cfNginx\u8fd9\u79cd\u5c5e\u4e8eweb\u670d\u52a1\u5668\uff0c\u5b83\u4eec\u53ea\u5904\u7406HTTP\u534f\u8bae\uff0c\u4e0d\u5177\u5907\u811a\u672c\u8bed\u8a00\u6765\u5904\u7406\u5177\u4f53\u7684\u4e1a\u52a1\u903b\u8f91\u3002\u5b83\u9700\u8981\u628a\u8bf7\u6c42\u8f6c\u53d1\u5230\u771f\u6b63\u7684web\u670d\u52a1\u5668\u4e2d\u53bb\u5904\u7406\uff0c\u6bd4\u5982PHP\u3002\u800cNode.js\u4e0d\u4ec5\u53ef\u4ee5\u89e3\u6790HTTP\u534f\u8bae\uff0c\u8fd8\u53ef\u4ee5\u5904\u7406\u5177\u4f53\u7684\u4e1a\u52a1\u903b\u8f91\u3002","title":"1.4.4 \u4e8b\u4ef6\u9a71\u52a8"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/","text":"\u7b2c\u4e8c\u7ae0Libuv\u6570\u636e\u7ed3\u6784\u548c\u901a\u7528\u903b\u8f91 \u00b6 2.1 \u6838\u5fc3\u7ed3\u6784\u4f53uv_loop_s \u00b6 uv_loop_s\u662fLibuv\u7684\u6838\u5fc3\u6570\u636e\u7ed3\u6784\uff0c\u6bcf\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af\u5bf9\u5e94\u4e00\u4e2auv_loop_s\u7ed3\u6784\u4f53\u3002\u5b83\u8bb0\u5f55\u4e86\u6574\u4e2a\u4e8b\u4ef6\u5faa\u73af\u4e2d\u7684\u6838\u5fc3\u6570\u636e\u3002\u6211\u4eec\u6765\u5206\u6790\u6bcf\u4e00\u4e2a\u5b57\u6bb5\u7684\u610f\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 1 \u7528\u6237\u81ea\u5b9a\u4e49\u6570\u636e\u7684\u5b57\u6bb5 void * data ; 2 \u6d3b\u8dc3\u7684 handle\u4e2a\u6570 \uff0c\u4f1a\u5f71\u54cd\u4f7f\u7528\u5faa\u73af\u7684\u9000\u51fa unsigned int active_handles ; 3 handle\u961f\u5217 \uff0c\u5305\u62ec\u6d3b\u8dc3\u548c\u975e\u6d3b\u8dc3\u7684 void * handle_queue [ 2 ]; 4 request\u4e2a\u6570 \uff0c\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa union { void * unused [ 2 ]; unsigned int count ; } active_reqs ; 5 \u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u7ed3\u675f\u7684\u6807\u8bb0 unsigned int stop_flag ; 6 Libuv\u8fd0\u884c\u7684\u4e00\u4e9b\u6807\u8bb0 \uff0c\u76ee\u524d\u53ea\u6709 UV_LOOP_BLOCK_SIGPROF \uff0c\u4e3b\u8981\u662f\u7528\u4e8e epoll_wait\u7684\u65f6\u5019\u5c4f\u853dSIGPROF\u4fe1\u53f7 \uff0c\u63d0\u9ad8\u6027\u80fd\uff0c SIGPROF\u662f\u8c03\u64cd\u4f5c\u7cfb\u7edfsettimer\u51fd\u6570\u8bbe\u7f6e\u4ece\u800c\u89e6\u53d1\u7684\u4fe1\u53f7 unsigned long flags ; 7 epoll\u7684fd int backend_fd ; 8 pending\u9636\u6bb5\u7684\u961f\u5217 void * pending_queue [ 2 ]; 9 \u6307\u5411\u9700\u8981\u5728 epoll\u4e2d\u6ce8\u518c\u4e8b\u4ef6\u7684uv__io_t\u7ed3\u6784\u4f53\u961f\u5217 void * watcher_queue [ 2 ]; 10 watcher_queue\u961f\u5217\u7684\u8282\u70b9\u4e2d\u6709\u4e00\u4e2afd\u5b57\u6bb5 \uff0c watchers\u4ee5fd\u4e3a\u7d22\u5f15 \uff0c\u8bb0\u5f55 fd\u6240\u5728\u7684uv__io_t\u7ed3\u6784\u4f53 uv__io_t ** watchers ; 11 watchers\u76f8\u5173\u7684\u6570\u91cf \uff0c\u5728 maybe_resize\u51fd\u6570\u91cc\u8bbe\u7f6e unsigned int nwatchers ; 12 watchers\u91ccfd\u4e2a\u6570 \uff0c\u4e00\u822c\u4e3a watcher_queue\u961f\u5217\u7684\u8282\u70b9\u6570 unsigned int nfds ; 13 \u7ebf\u7a0b\u6c60\u7684\u5b50\u7ebf\u7a0b\u5904\u7406\u5b8c\u4efb\u52a1\u540e\u628a\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53\u63d2\u5165\u5230 wq\u961f\u5217 void * wq [ 2 ]; 14 \u63a7\u5236 wq\u961f\u5217\u4e92\u65a5\u8bbf\u95ee \uff0c\u5426\u5219\u591a\u4e2a\u5b50\u7ebf\u7a0b\u540c\u65f6\u8bbf\u95ee\u4f1a\u6709\u95ee\u9898 uv_mutex_t wq_mutex ; 15 \u7528\u4e8e\u7ebf\u7a0b\u6c60\u7684\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1 uv_async_t wq_async ; 16 \u7528\u4e8e\u8bfb\u5199\u9501\u7684\u4e92\u65a5\u53d8\u91cf uv_rwlock_t cloexec_lock ; 17 \u4e8b\u4ef6\u5faa\u73af close\u9636\u6bb5\u7684\u961f\u5217 \uff0c\u7531 uv_close\u4ea7\u751f uv_handle_t * closing_handles ; 18 fork\u51fa\u6765\u7684\u8fdb\u7a0b\u961f\u5217 void * process_handles [ 2 ]; 19 \u4e8b\u4ef6\u5faa\u73af\u7684 prepare\u9636\u6bb5\u5bf9\u5e94\u7684\u4efb\u52a1\u961f\u5217 void * prepare_handles [ 2 ]; 20 \u4e8b\u4ef6\u5faa\u73af\u7684 check\u9636\u6bb5\u5bf9\u5e94\u7684\u4efb\u52a1\u961f\u5217 void * check_handles [ 2 ]; 21 \u4e8b\u4ef6\u5faa\u73af\u7684 idle\u9636\u6bb5\u5bf9\u5e94\u7684\u4efb\u52a1\u961f\u5217 void * idle_handles [ 2 ]; 21 async_handles\u961f\u5217 \uff0c Poll IO\u9636\u6bb5\u6267\u884cuv__async_io\u4e2d\u904d\u5386async_handles\u961f\u5217\u5904\u7406\u91cc\u9762pending\u4e3a1\u7684\u8282\u70b9 void * async_handles [ 2 ]; 22 \u7528\u4e8e\u76d1\u542c\u662f\u5426\u6709 async handle\u4efb\u52a1\u9700\u8981\u5904\u7406 uv__io_t async_io_watcher ; 23 \u7528\u4e8e\u4fdd\u5b58\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u7684\u5199\u7aef fd int async_wfd ; 24 \u4fdd\u5b58\u5b9a\u65f6\u5668\u4e8c\u53c9\u5806\u7ed3\u6784 struct { void * min ; unsigned int nelts ; } timer_heap ; 25 \u7ba1\u7406\u5b9a\u65f6\u5668\u8282\u70b9\u7684 id \uff0c\u4e0d\u65ad\u53e0\u52a0 uint64_t timer_counter ; 26 \u5f53\u524d\u65f6\u95f4\uff0c Libuv\u4f1a\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u7684\u5f00\u59cb\u548cPoll IO\u9636\u6bb5\u66f4\u65b0\u5f53\u524d\u65f6\u95f4 \uff0c\u7136\u540e\u5728\u540e\u7eed\u7684\u5404\u4e2a\u9636\u6bb5\u4f7f\u7528\uff0c\u51cf\u5c11\u5bf9\u7cfb\u7edf\u8c03\u7528 uint64_t time ; 27 \u7528\u4e8e fork\u51fa\u6765\u7684\u8fdb\u7a0b\u548c\u4e3b\u8fdb\u7a0b\u901a\u4fe1\u7684\u7ba1\u9053 \uff0c\u7528\u4e8e\u5b50\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\u901a\u77e5\u4e3b\u8fdb\u7a0b\uff0c\u7136\u540e\u4e3b\u8fdb\u7a0b\u6267\u884c\u5b50\u8fdb\u7a0b\u8282\u70b9\u6ce8\u518c\u7684\u56de\u8c03 int signal_pipefd [ 2 ]; 28 \u7c7b\u4f3c async_io_watcher \uff0c signal_io_watcher\u4fdd\u5b58\u4e86\u7ba1\u9053\u8bfb\u7aeffd\u548c\u56de\u8c03 \uff0c\u7136\u540e\u6ce8\u518c\u5230 epoll\u4e2d \uff0c\u5728\u5b50\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\uff0c\u901a\u8fc7 write\u5199\u5230\u7ba1\u9053 \uff0c\u6700\u540e\u5728 Poll IO\u9636\u6bb5\u6267\u884c\u56de\u8c03 uv__io_t signal_io_watcher ; 29 \u7528\u4e8e\u7ba1\u7406\u5b50\u8fdb\u7a0b\u9000\u51fa\u4fe1\u53f7\u7684 handle uv_signal_t child_watcher ; 30 \u5907\u7528\u7684 fd int emfile_fd ; 2.2 uv_handle_t \u00b6 \u5728Libuv\u4e2d\uff0cuv_handle_t\u7c7b\u4f3cC++\u4e2d\u7684\u57fa\u7c7b\uff0c\u6709\u5f88\u591a\u5b50\u7c7b\u7ee7\u627f\u4e8e\u5b83\uff0cLibuv\u4e3b\u8981\u901a\u8fc7\u63a7\u5236\u5185\u5b58\u7684\u5e03\u5c40\u5f97\u5230\u7ee7\u627f\u7684\u6548\u679c\u3002handle\u4ee3\u8868\u751f\u547d\u5468\u671f\u6bd4\u8f83\u957f\u7684\u5bf9\u8c61\u3002\u4f8b\u5982 1 \u4e00\u4e2a\u5904\u4e8eactive\u72b6\u6001\u7684prepare handle\uff0c\u5b83\u7684\u56de\u8c03\u4f1a\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u5316\u7684\u65f6\u5019\u88ab\u6267\u884c\u3002 2 \u4e00\u4e2aTCP handle\u5728\u6bcf\u6b21\u6709\u8fde\u63a5\u5230\u6765\u65f6\uff0c\u6267\u884c\u5b83\u7684\u56de\u8c03\u3002 \u6211\u4eec\u770b\u4e00\u4e0buv_handle_t\u7684\u5b9a\u4e49 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 1 \u81ea\u5b9a\u4e49\u6570\u636e\uff0c\u7528\u4e8e\u5173\u8054\u4e00\u4e9b\u4e0a\u4e0b\u6587 , Node . js\u4e2d\u7528\u4e8e\u5173\u8054handle\u6240\u5c5e\u7684C ++ \u5bf9\u8c61 void * data ; 2 \u6240\u5c5e\u7684\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 3 handle\u7c7b\u578b uv_handle_type type ; 4 handle\u8c03\u7528uv_close\u540e \uff0c\u5728 closing\u9636\u6bb5\u88ab\u6267\u884c\u7684\u56de\u8c03 uv_close_cb close_cb ; 5 \u7528\u4e8e\u7ec4\u7ec7 handle\u961f\u5217\u7684\u524d\u7f6e\u540e\u7f6e\u6307\u9488 void * handle_queue [ 2 ]; 6 \u6587\u4ef6\u63cf\u8ff0\u7b26 union { int fd ; void * reserved [ 4 ]; } u ; 7 \u5f53 handle\u5728close\u961f\u5217\u65f6 \uff0c\u8be5\u5b57\u6bb5\u6307\u5411\u4e0b\u4e00\u4e2a close\u8282\u70b9 uv_handle_t * next_closing ; 8 handle\u7684\u72b6\u6001\u548c\u6807\u8bb0 unsigned int flags ; 2.2.1 uv_stream_s \u00b6 uv_stream_s\u662f\u8868\u793a\u6d41\u7684\u7ed3\u6784\u4f53\u3002\u9664\u4e86\u7ee7\u627fuv_handle_t\u7684\u5b57\u6bb5\u5916\uff0c\u5b83\u989d\u5916\u5b9a\u4e49\u4e0b\u9762\u5b57\u6bb5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 1 \u7b49\u5f85\u53d1\u9001\u7684\u5b57\u8282\u6570 size_t write_queue_size ; 2 \u5206\u914d\u5185\u5b58\u7684\u51fd\u6570 uv_alloc_cb alloc_cb ; 3 \u8bfb\u53d6\u6570\u636e\u6210\u529f\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_read_cb read_cb ; 4 \u53d1\u8d77\u8fde\u63a5\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53 uv_connect_t * connect_req ; 5 \u5173\u95ed\u5199\u7aef\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53 uv_shutdown_t * shutdown_req ; 6 \u7528\u4e8e\u63d2\u5165 epoll \uff0c\u6ce8\u518c\u8bfb\u5199\u4e8b\u4ef6 uv__io_t io_watcher ; 7 \u5f85\u53d1\u9001\u961f\u5217 void * write_queue [ 2 ]; 8 \u53d1\u9001\u5b8c\u6210\u7684\u961f\u5217 void * write_completed_queue [ 2 ]; 9 \u6536\u5230\u8fde\u63a5\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_connection_cb connection_cb ; 10 socket\u64cd\u4f5c\u5931\u8d25\u7684\u9519\u8bef\u7801 int delayed_error ; 11 accept\u8fd4\u56de\u7684fd int accepted_fd ; 12 \u5df2\u7ecf accept\u4e86\u4e00\u4e2afd \uff0c\u53c8\u6709\u65b0\u7684 fd \uff0c\u6682\u5b58\u8d77\u6765 void * queued_fds ; 2.2.2 uv_async_s \u00b6 uv_async_s\u662fLibuv\u4e2d\u5b9e\u73b0\u5f02\u6b65\u901a\u4fe1\u7684\u7ed3\u6784\u4f53\u3002\u7ee7\u627f\u4e8euv_handle_t\uff0c\u5e76\u989d\u5916\u5b9a\u4e49\u4e86\u4ee5\u4e0b\u5b57\u6bb5\u3002 1 2 3 4 5 6 7 8 1 \u5f02\u6b65\u4e8b\u4ef6\u89e6\u53d1\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_async_cb async_cb ; 2 \u7528\u4e8e\u63d2\u5165 async - handles\u961f\u5217 void * queue [ 2 ]; 3 async_handles\u961f\u5217\u4e2d\u7684\u8282\u70b9pending\u5b57\u6bb5\u4e3a1\u8bf4\u660e\u5bf9\u5e94\u7684\u4e8b\u4ef6\u89e6\u53d1\u4e86 int pending ; 2.2.3 uv_tcp_s \u00b6 uv_tcp_s\u7ee7\u627fuv_handle_s\u548cuv_stream_s\u3002 2.2.4 uv_udp_s \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 1 \u53d1\u9001\u5b57\u8282\u6570 size_t send_queue_size ; 2 \u5199\u961f\u5217\u8282\u70b9\u7684\u4e2a\u6570 size_t send_queue_count ; 3 \u5206\u914d\u63a5\u6536\u6570\u636e\u7684\u5185\u5b58 uv_alloc_cb alloc_cb ; 4 \u63a5\u6536\u5b8c\u6570\u636e\u540e\u6267\u884c\u7684\u56de\u8c03 uv_udp_recv_cb recv_cb ; 5 \u63d2\u5165 epoll\u91cc\u7684IO\u89c2\u5bdf\u8005 \uff0c\u5b9e\u73b0\u6570\u636e\u8bfb\u5199 uv__io_t io_watcher ; 6 \u5f85\u53d1\u9001\u961f\u5217 void * write_queue [ 2 ]; 7 \u53d1\u9001\u5b8c\u6210\u7684\u961f\u5217\uff08\u53d1\u9001\u6210\u529f\u6216\u5931\u8d25\uff09\uff0c\u548c\u5f85\u53d1\u9001\u961f\u5217\u76f8\u5173 void * write_completed_queue [ 2 ]; 2.2.5 uv_tty_s \u00b6 uv_tty_s\u7ee7\u627f\u4e8euv_handle_t\u548cuv_stream_t\u3002\u989d\u5916\u5b9a\u4e49\u4e86\u4e0b\u9762\u5b57\u6bb5\u3002 1 2 3 4 5 1 \u7ec8\u7aef\u7684\u53c2\u6570 struct termios orig_termios ; 2 \u7ec8\u7aef\u7684\u5de5\u4f5c\u6a21\u5f0f int mode ; 2.2.6 uv_pipe_s \u00b6 uv_pipe_s\u7ee7\u627f\u4e8euv_handle_t\u548cuv_stream_t\u3002\u989d\u5916\u5b9a\u4e49\u4e86\u4e0b\u9762\u5b57\u6bb5\u3002 1 2 3 4 5 1 \u6807\u8bb0\u7ba1\u9053\u662f\u5426\u53ef\u7528\u4e8e\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 int ipc ; 2 \u7528\u4e8e Unix\u57df\u901a\u4fe1\u7684\u6587\u4ef6\u8def\u5f84 const char * pipe_fname ; 2.2.7 uv_prepare_s\u3001uv_check_s\u3001uv_idle_s \u00b6 \u4e0a\u9762\u4e09\u4e2a\u7ed3\u6784\u4f53\u5b9a\u4e49\u662f\u7c7b\u4f3c\u7684\uff0c\u5b83\u4eec\u90fd\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86\u4e24\u4e2a\u5b57\u6bb5\u3002 1 2 3 4 5 1 prepare \u3001 check \u3001 idle\u9636\u6bb5\u56de\u8c03 uv_xxx_cb xxx_cb ; 2 \u7528\u4e8e\u63d2\u5165 prepare \u3001 check \u3001 idle\u961f\u5217 void * queue [ 2 ]; 2.2.8 uv_timer_s \u00b6 uv_timer_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86\u4e0b\u9762\u51e0\u4e2a\u5b57\u6bb5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 1 \u8d85\u65f6\u56de\u8c03 uv_timer_cb timer_cb ; 2 \u63d2\u5165\u4e8c\u53c9\u5806\u7684\u5b57\u6bb5 void * heap_node [ 3 ]; 3 \u8d85\u65f6\u65f6\u95f4 uint64_t timeout ; 4 \u8d85\u65f6\u540e\u662f\u5426\u7ee7\u7eed\u5f00\u59cb\u91cd\u65b0\u8ba1\u65f6\uff0c\u662f\u7684\u8bdd\u91cd\u65b0\u63d2\u5165\u4e8c\u53c9\u5806 uint64_t repeat ; 5 id\u6807\u8bb0 \uff0c\u7528\u4e8e\u63d2\u5165\u4e8c\u53c9\u5806\u7684\u65f6\u5019\u5bf9\u6bd4 uint64_t start_id 2.2.9 uv_process_s \u00b6 uv_process_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86 1 2 3 4 5 6 7 8 9 10 11 1 \u8fdb\u7a0b\u9000\u51fa\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_exit_cb exit_cb ; 2 \u8fdb\u7a0b id int pid ; 3 \u7528\u4e8e\u63d2\u5165\u961f\u5217\uff0c\u8fdb\u7a0b\u961f\u5217\u6216\u8005 pending\u961f\u5217 void * queue [ 2 ]; 4 \u9000\u51fa\u7801\uff0c\u8fdb\u7a0b\u9000\u51fa\u65f6\u8bbe\u7f6e int status ; 2.2.10 uv_fs_event_s \u00b6 uv_fs_event_s\u7528\u4e8e\u76d1\u542c\u6587\u4ef6\u6539\u52a8\u3002uv_fs_event_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86 1 2 3 4 5 1 \u76d1\u542c\u7684\u6587\u4ef6\u8def\u5f84 ( \u6587\u4ef6\u6216\u76ee\u5f55 ) char * path ; 2 \u6587\u4ef6\u6539\u53d8\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_fs_event_cb cb ; 2.2.11 uv_fs_poll_s \u00b6 uv_fs_poll_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 1 poll_ctx\u6307\u5411poll_ctx\u7ed3\u6784\u4f53 void * poll_ctx ; struct poll_ctx { // \u5bf9\u5e94\u7684handle uv_fs_poll_t * parent_handle ; // \u6807\u8bb0\u662f\u5426\u5f00\u59cb\u8f6e\u8be2\u548c\u8f6e\u8be2\u65f6\u7684\u5931\u8d25\u539f\u56e0 int busy_polling ; // \u591a\u4e45\u68c0\u6d4b\u4e00\u6b21\u6587\u4ef6\u5185\u5bb9\u662f\u5426\u6539\u53d8 unsigned int interval ; // \u6bcf\u4e00\u8f6e\u8f6e\u8be2\u65f6\u7684\u5f00\u59cb\u65f6\u95f4 uint64_t start_time ; // \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; // \u6587\u4ef6\u6539\u53d8\u65f6\u56de\u8c03 uv_fs_poll_cb poll_cb ; // \u5b9a\u65f6\u5668\uff0c\u7528\u4e8e\u5b9a\u65f6\u8d85\u65f6\u540e\u8f6e\u8be2 uv_timer_t timer_handle ; // \u8bb0\u5f55\u8f6e\u8be2\u7684\u4e00\u4e0b\u4e0a\u4e0b\u6587\u4fe1\u606f\uff0c\u6587\u4ef6\u8def\u5f84\u3001\u56de\u8c03\u7b49 uv_fs_t fs_req ; // \u8f6e\u8be2\u65f6\u4fdd\u5b58\u64cd\u4f5c\u7cfb\u7edf\u8fd4\u56de\u7684\u6587\u4ef6\u4fe1\u606f uv_stat_t statbuf ; // \u76d1\u542c\u7684\u6587\u4ef6\u8def\u5f84\uff0c\u5b57\u7b26\u4e32\u7684\u503c\u8ffd\u52a0\u5728\u7ed3\u6784\u4f53\u540e\u9762 char path [ 1 ]; /* variable length */ }; 2.2.12 uv_poll_s \u00b6 uv_poll_s\u7ee7\u627f\u4e8euv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86\u4e0b\u9762\u5b57\u6bb5\u3002 1 2 3 4 5 1 \u76d1\u542c\u7684 fd\u6709\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_poll_cb poll_cb ; 2 \u4fdd\u5b58\u4e86 fd\u548c\u56de\u8c03\u7684IO\u89c2\u5bdf\u8005 \uff0c\u6ce8\u518c\u5230 epoll\u4e2d uv__io_t io_watcher ; 2.1.13 uv_signal_s \u00b6 uv_signal_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86\u4ee5\u4e0b\u5b57\u6bb5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 1 \u6536\u5230\u4fe1\u53f7\u65f6\u7684\u56de\u8c03 uv_signal_cb signal_cb ; 2 \u6ce8\u518c\u7684\u4fe1\u53f7 int signum ; 3 \u7528\u4e8e\u63d2\u5165\u7ea2\u9ed1\u6811\uff0c\u8fdb\u7a0b\u628a\u611f\u5174\u8da3\u7684\u4fe1\u53f7\u548c\u56de\u8c03\u5c01\u88c5\u6210 uv_signal_s \uff0c\u7136\u540e\u63d2\u5165\u5230\u7ea2\u9ed1\u6811\uff0c\u4fe1\u53f7\u5230\u6765\u65f6\uff0c\u8fdb\u7a0b\u5728\u4fe1\u53f7\u5904\u7406\u53f7\u4e2d\u628a\u901a\u77e5\u5199\u5165\u7ba1\u9053\uff0c\u901a\u77e5 Libuv \u3002 Libuv\u5728Poll IO\u9636\u6bb5\u4f1a\u6267\u884c\u8fdb\u7a0b\u5bf9\u5e94\u7684\u56de\u8c03 \u3002\u7ea2\u9ed1\u6811\u8282\u70b9\u7684\u5b9a\u4e49\u5982\u4e0b struct { struct uv_signal_s * rbe_left ; struct uv_signal_s * rbe_right ; struct uv_signal_s * rbe_parent ; int rbe_color ; } tree_entry ; 4 \u6536\u5230\u7684\u4fe1\u53f7\u4e2a\u6570 unsigned int caught_signals ; 5 \u5df2\u7ecf\u5904\u7406\u7684\u4fe1\u53f7\u4e2a\u6570 unsigned int dispatched_signals ; 2.3 uv_req_s \u00b6 \u5728Libuv\u4e2d\uff0cuv_req_s\u4e5f\u7c7b\u4f3cC++\u57fa\u7c7b\u7684\u4f5c\u7528\uff0c\u6709\u5f88\u591a\u5b50\u7c7b\u7ee7\u627f\u4e8e\u5b83\uff0crequest\u4ee3\u8868\u4e00\u6b21\u8bf7\u6c42\uff0c\u6bd4\u5982\u8bfb\u5199\u4e00\u4e2a\u6587\u4ef6\uff0c\u8bfb\u5199socket\uff0c\u67e5\u8be2DNS\u3002\u4efb\u52a1\u5b8c\u6210\u540e\u8fd9\u4e2arequest\u5c31\u7ed3\u675f\u4e86\u3002request\u53ef\u4ee5\u548chandle\u7ed3\u5408\u4f7f\u7528\uff0c\u6bd4\u5982\u5728\u4e00\u4e2aTCP\u670d\u52a1\u5668\u4e0a\uff08handle\uff09\u5199\u4e00\u4e2a\u6570\u636e\uff08request\uff09\uff0c\u4e5f\u53ef\u4ee5\u5355\u72ec\u4f7f\u7528\u4e00\u4e2arequest\uff0c\u6bd4\u5982DNS\u67e5\u8be2\u6216\u8005\u6587\u4ef6\u8bfb\u5199\u3002\u6211\u4eec\u770b\u4e00\u4e0buv_req_s\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 1 \u81ea\u5b9a\u4e49\u6570\u636e void * data ; 2 request\u7c7b\u578b uv_req_type type ; 3 \u4fdd\u7559\u5b57\u6bb5 void * reserved [ 6 ]; 2.3.1 uv_shutdown_s \u00b6 uv_shutdown_s\u7528\u4e8e\u5173\u95ed\u6d41\u7684\u5199\u7aef\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 2 3 4 5 1 \u8981\u5173\u95ed\u7684\u6d41\uff0c\u6bd4\u5982 TCP uv_stream_t * handle ; 2 \u5173\u95ed\u6d41\u7684\u5199\u7aef\u540e\u6267\u884c\u7684\u56de\u8c03 uv_shutdown_cb cb ; 2.3.2 uv_write_s \u00b6 uv_write_s\u8868\u793a\u4e00\u6b21\u5199\u8bf7\u6c42\uff0c\u6bd4\u5982\u5728TCP\u6d41\u4e0a\u53d1\u9001\u6570\u636e\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 1 \u5199\u5b8c\u540e\u7684\u56de\u8c03 uv_write_cb cb ; 2 \u9700\u8981\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5728 send_handle\u4e2d uv_stream_t * send_handle ; 3 \u5173\u8054\u7684 handle uv_stream_t * handle ; 4 \u7528\u4e8e\u63d2\u5165\u961f\u5217 void * queue [ 2 ]; 5 \u4fdd\u5b58\u9700\u8981\u5199\u7684\u6570\u636e\u76f8\u5173\u7684\u5b57\u6bb5\uff08\u5199\u5165\u7684 buffer\u4e2a\u6570 \uff0c\u5f53\u524d\u5199\u6210\u529f\u7684\u4f4d\u7f6e\u7b49\uff09 unsigned int write_index ; uv_buf_t * bufs ; unsigned int nbufs ; uv_buf_t bufsml [ 4 ]; 6 \u5199\u51fa\u9519\u7684\u9519\u8bef\u7801 int error ; 2.3.3 uv_connect_s \u00b6 uv_connect_s\u8868\u793a\u53d1\u8d77\u8fde\u63a5\u8bf7\u6c42\uff0c\u6bd4\u5982TCP\u8fde\u63a5\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 2 3 4 5 6 7 8 1 \u8fde\u63a5\u6210\u529f\u540e\u6267\u884c\u7684\u56de\u8c03 uv_connect_cb cb ; 2 \u5bf9\u5e94\u7684\u6d41\uff0c\u6bd4\u5982 tcp uv_stream_t * handle ; 3 \u7528\u4e8e\u63d2\u5165\u961f\u5217 void * queue [ 2 ]; 2.3.4 uv_udp_send_s \u00b6 uv_udp_send_s\u8868\u793a\u4e00\u6b21\u53d1\u9001UDP\u6570\u636e\u7684\u8bf7\u6c42 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 1 \u6240\u5c5e udp\u7684handle \uff0c udp_send_s\u4ee3\u8868\u4e00\u6b21\u53d1\u9001 uv_udp_t * handle ; 2 \u56de\u8c03 uv_udp_send_cb cb ; 3 \u7528\u4e8e\u63d2\u5165\u5f85\u53d1\u9001\u961f\u5217 void * queue [ 2 ]; 4 \u53d1\u9001\u7684\u76ee\u7684\u5730\u5740 struct sockaddr_storage addr ; 5 \u4fdd\u5b58\u4e86\u53d1\u9001\u6570\u636e\u7684\u7f13\u51b2\u533a\u548c\u4e2a\u6570 unsigned int nbufs ; uv_buf_t * bufs ; uv_buf_t bufsml [ 4 ]; 6 \u53d1\u9001\u72b6\u6001\u6216\u6210\u529f\u53d1\u9001\u7684\u5b57\u8282\u6570 ssize_t status ; 7 \u53d1\u9001\u5b8c\u6267\u884c\u7684\u56de\u8c03\uff08\u53d1\u9001\u6210\u529f\u6216\u5931\u8d25\uff09 uv_udp_send_cb send_cb ; 2.3.5 uv_getaddrinfo_s \u00b6 uv_getaddrinfo_s\u8868\u793a\u4e00\u6b21\u901a\u8fc7\u57df\u540d\u67e5\u8be2IP\u7684DNS\u8bf7\u6c42\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 1 \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 2 \u7528\u4e8e\u5f02\u6b65 DNS\u89e3\u6790\u65f6\u63d2\u5165\u7ebf\u7a0b\u6c60\u4efb\u52a1\u961f\u5217\u7684\u8282\u70b9 struct uv__work work_req ; 3 DNS\u89e3\u6790\u5b8c\u540e\u6267\u884c\u7684\u56de\u8c03 uv_getaddrinfo_cb cb ; 4 DNS\u67e5\u8be2\u7684\u914d\u7f6e struct addrinfo * hints ; char * hostname ; char * service ; 5 DNS\u89e3\u6790\u7ed3\u679c struct addrinfo * addrinfo ; 6 DNS\u89e3\u6790\u7684\u8fd4\u56de\u7801 int retcode ; 2.3.6 uv_getnameinfo_s \u00b6 uv_getnameinfo_s\u8868\u793a\u4e00\u6b21\u901a\u8fc7IP\u67e5\u8be2\u57df\u540d\u7684DNS\u67e5\u8be2\u8bf7\u6c42\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 1 \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 2 \u7528\u4e8e\u5f02\u6b65 DNS\u89e3\u6790\u65f6\u63d2\u5165\u7ebf\u7a0b\u6c60\u4efb\u52a1\u961f\u5217\u7684\u8282\u70b9 struct uv__work work_req ; 3 socket\u8f6c\u57df\u540d\u5b8c\u6210\u7684\u56de\u8c03 uv_getnameinfo_cb getnameinfo_cb ; 4 \u9700\u8981\u8f6c\u57df\u540d\u7684 socket\u7ed3\u6784\u4f53 struct sockaddr_storage storage ; 5 \u6307\u793a\u67e5\u8be2\u8fd4\u56de\u7684\u4fe1\u606f int flags ; 6 \u67e5\u8be2\u8fd4\u56de\u7684\u4fe1\u606f char host [ NI_MAXHOST ]; char service [ NI_MAXSERV ]; 7 \u67e5\u8be2\u8fd4\u56de\u7801 int retcode ; 2.3.7 uv_work_s \u00b6 uv_work_s\u7528\u4e8e\u5f80\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4efb\u52a1\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 2 3 4 5 6 7 8 9 10 11 1 \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 2 \u5904\u7406\u4efb\u52a1\u7684\u51fd\u6570 uv_work_cb work_cb ; 3 \u5904\u7406\u5b8c\u4efb\u52a1\u540e\u6267\u884c\u7684\u51fd\u6570 uv_after_work_cb after_work_cb ; 4 \u5c01\u88c5\u4e00\u4e2a work\u63d2\u5165\u5230\u7ebf\u7a0b\u6c60\u961f\u5217 \uff0c work_req\u7684work\u548cdone\u51fd\u6570\u662f\u5bf9\u4e0a\u9762work_cb\u548cafter_work_cb\u7684\u5c01\u88c5 struct uv__work work_req ; uv_fs_s \u00b6 uv_fs_s\u8868\u793a\u4e00\u6b21\u6587\u4ef6\u64cd\u4f5c\u8bf7\u6c42\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 1 \u6587\u4ef6\u64cd\u4f5c\u7c7b\u578b uv_fs_type fs_type ; 2 \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 3 \u6587\u4ef6\u64cd\u4f5c\u5b8c\u6210\u7684\u56de\u8c03 uv_fs_cb cb ; 4 \u6587\u4ef6\u64cd\u4f5c\u7684\u8fd4\u56de\u7801 ssize_t result ; 5 \u6587\u4ef6\u64cd\u4f5c\u8fd4\u56de\u7684\u6570\u636e void * ptr ; 6 \u6587\u4ef6\u64cd\u4f5c\u8def\u5f84 const char * path ; 7 \u6587\u4ef6\u7684 stat\u4fe1\u606f uv_stat_t statbuf ; 8 \u6587\u4ef6\u64cd\u4f5c\u6d89\u53ca\u5230\u4e24\u4e2a\u8def\u5f84\u65f6\uff0c\u4fdd\u5b58\u76ee\u7684\u8def\u5f84 const char * new_path ; 9 \u6587\u4ef6\u63cf\u8ff0\u7b26 uv_file file ; 10 \u6587\u4ef6\u6807\u8bb0 int flags ; 11 \u64cd\u4f5c\u6a21\u5f0f mode_t mode ; 12 \u5199\u6587\u4ef6\u65f6\u4f20\u5165\u7684\u6570\u636e\u548c\u4e2a\u6570 unsigned int nbufs ; uv_buf_t * bufs ; 13 \u6587\u4ef6\u504f\u79fb off_t off ; 14 \u4fdd\u5b58\u9700\u8981\u8bbe\u7f6e\u7684 uid\u548cgid \uff0c\u4f8b\u5982 chmod\u7684\u65f6\u5019 uv_uid_t uid ; uv_gid_t gid ; 15 \u4fdd\u5b58\u9700\u8981\u8bbe\u7f6e\u7684\u6587\u4ef6\u4fee\u6539\u3001\u8bbf\u95ee\u65f6\u95f4\uff0c\u4f8b\u5982 fs . utimes\u7684\u65f6\u5019 double atime ; double mtime ; 16 \u5f02\u6b65\u7684\u65f6\u5019\u7528\u4e8e\u63d2\u5165\u4efb\u52a1\u961f\u5217\uff0c\u4fdd\u5b58\u5de5\u4f5c\u51fd\u6570\uff0c\u56de\u8c03\u51fd\u6570 struct uv__work work_req ; 17 \u4fdd\u5b58\u8bfb\u53d6\u6570\u636e\u6216\u8005\u957f\u5ea6\u3002\u4f8b\u5982 read\u548csendfile uv_buf_t bufsml [ 4 ]; 2.4 IO\u89c2\u5bdf\u8005 \u00b6 IO\u89c2\u5bdf\u8005\u662fLibuv\u4e2d\u7684\u6838\u5fc3\u6982\u5ff5\u548c\u6570\u636e\u7ed3\u6784\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u7684\u5b9a\u4e49 1 2 3 4 5 6 7 8 9 10 11 12 1. struct uv__io_s { 2. // \u4e8b\u4ef6\u89e6\u53d1\u540e\u7684\u56de\u8c03 3. uv__io_cb cb ; 4. // \u7528\u4e8e\u63d2\u5165\u961f\u5217 5. void * pending_queue [ 2 ]; 6. void * watcher_queue [ 2 ]; 7. // \u4fdd\u5b58\u672c\u6b21\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u5728\u63d2\u5165IO\u89c2\u5bdf\u8005\u961f\u5217\u65f6\u8bbe\u7f6e 8. unsigned int pevents ; 9. // \u4fdd\u5b58\u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6 10. unsigned int events ; 11. int fd ; 12. }; IO\u89c2\u5bdf\u8005\u5c01\u88c5\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u4e8b\u4ef6\u548c\u56de\u8c03\uff0c\u7136\u540e\u63d2\u5165\u5230loop\u7ef4\u62a4\u7684IO\u89c2\u5bdf\u8005\u961f\u5217\uff0c\u5728Poll IO\u9636\u6bb5\uff0cLibuv\u4f1a\u6839\u636eIO\u89c2\u5bdf\u8005\u63cf\u8ff0\u7684\u4fe1\u606f\uff0c\u5f80\u5e95\u5c42\u7684\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u6ce8\u518c\u6587\u4ef6\u63cf\u8ff0\u7b26\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u3002\u5f53\u6ce8\u518c\u7684\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0cIO\u89c2\u5bdf\u8005\u7684\u56de\u8c03\u5c31\u4f1a\u88ab\u6267\u884c\u3002\u6211\u4eec\u770b\u5982\u4f55\u521dIO\u89c2\u5bdf\u8005\u7684\u4e00\u4e9b\u903b\u8f91\u3002 2.4.1 \u521d\u59cb\u5316IO\u89c2\u5bdf\u8005 \u00b6 1 2 3 4 5 6 7 8 9 10 11 1. void uv__io_init ( uv__io_t * w , uv__io_cb cb , int fd ) { 2. // \u521d\u59cb\u5316\u961f\u5217\uff0c\u56de\u8c03\uff0c\u9700\u8981\u76d1\u542c\u7684fd 3. QUEUE_INIT ( & w -> pending_queue ); 4. QUEUE_INIT ( & w -> watcher_queue ); 5. w -> cb = cb ; 6. w -> fd = fd ; 7. // \u4e0a\u6b21\u52a0\u5165epoll\u65f6\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u5728\u6267\u884c\u5b8cepoll\u64cd\u4f5c\u51fd\u6570\u540e\u8bbe\u7f6e 8. w -> events = 0 ; 9. // \u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u5728\u518d\u6b21\u6267\u884cepoll\u51fd\u6570\u4e4b\u524d\u8bbe\u7f6e 10. w -> pevents = 0 ; 11. } 2.4.2\u6ce8\u518c\u4e00\u4e2aIO\u89c2\u5bdf\u8005\u5230Libuv\u3002 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1. void uv__io_start ( uv_loop_t * loop , uv__io_t * w , unsigned int events ) { 2. // \u8bbe\u7f6e\u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6 3. w -> pevents |= events ; 4. // \u53ef\u80fd\u9700\u8981\u6269\u5bb9 5. maybe_resize ( loop , w -> fd + 1 ); 6. // \u4e8b\u4ef6\u6ca1\u6709\u53d8\u5316\u5219\u76f4\u63a5\u8fd4\u56de 7. if ( w -> events == w -> pevents ) 8. return ; 9. // IO\u89c2\u5bdf\u8005\u6ca1\u6709\u6302\u8f7d\u5728\u5176\u5b83\u5730\u65b9\u5219\u63d2\u5165Libuv\u7684IO\u89c2\u5bdf\u8005\u961f\u5217 10. if ( QUEUE_EMPTY ( & w -> watcher_queue )) 11. QUEUE_INSERT_TAIL ( & loop -> watcher_queue , & w -> watcher_queue ); 12. // \u4fdd\u5b58\u6620\u5c04\u5173\u7cfb 13. if ( loop -> watchers [ w -> fd ] == NULL ) { 14. loop -> watchers [ w -> fd ] = w ; 15. loop -> nfds ++ ; 16. } 17. } uv__io_start\u51fd\u6570\u5c31\u662f\u628a\u4e00\u4e2aIO\u89c2\u5bdf\u8005\u63d2\u5165\u5230Libuv\u7684\u89c2\u5bdf\u8005\u961f\u5217\u4e2d\uff0c\u5e76\u4e14\u5728watchers\u6570\u7ec4\u4e2d\u4fdd\u5b58\u4e00\u4e2a\u6620\u5c04\u5173\u7cfb\u3002Libuv\u5728Poll IO\u9636\u6bb5\u4f1a\u5904\u7406IO\u89c2\u5bdf\u8005\u961f\u5217\u3002 2.4.3 \u64a4\u9500IO\u89c2\u5bdf\u8005\u6216\u8005\u4e8b\u4ef6 \u00b6 uv__io_stop\u4fee\u6539IO\u89c2\u5bdf\u8005\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u5982\u679c\u8fd8\u6709\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u7684\u8bdd\uff0cIO\u89c2\u5bdf\u8005\u8fd8\u4f1a\u5728\u961f\u5217\u91cc\uff0c\u5426\u5219\u79fb\u51fa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 1. void uv__io_stop ( uv_loop_t * loop , 2. uv__io_t * w , 3. unsigned int events ) { 4. if ( w -> fd == -1 ) 5. return ; 6. assert ( w -> fd >= 0 ); 7. if (( unsigned ) w -> fd >= loop -> nwatchers ) 8. return ; 9. // \u6e05\u9664\u4e4b\u524d\u6ce8\u518c\u7684\u4e8b\u4ef6\uff0c\u4fdd\u5b58\u5728pevents\u91cc\uff0c\u8868\u793a\u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6 10. w -> pevents &= ~ events ; 11. // \u5bf9\u6240\u6709\u4e8b\u4ef6\u90fd\u4e0d\u611f\u5174\u8da3\u4e86 12. if ( w -> pevents == 0 ) { 13. // \u79fb\u51faIO\u89c2\u5bdf\u8005\u961f\u5217 14. QUEUE_REMOVE ( & w -> watcher_queue ); 15. // \u91cd\u7f6e 16. QUEUE_INIT ( & w -> watcher_queue ); 17. // \u91cd\u7f6e 18. if ( loop -> watchers [ w -> fd ] != NULL ) { 19. assert ( loop -> watchers [ w -> fd ] == w ); 20. assert ( loop -> nfds > 0 ); 21. loop -> watchers [ w -> fd ] = NULL ; 22. loop -> nfds -- ; 23. w -> events = 0 ; 24. } 25. } 26. /* 27. \u4e4b\u524d\u8fd8\u6ca1\u6709\u63d2\u5165IO\u89c2\u5bdf\u8005\u961f\u5217\uff0c\u5219\u63d2\u5165\uff0c 28. \u7b49\u5230Poll IO\u65f6\u5904\u7406\uff0c\u5426\u5219\u4e0d\u9700\u8981\u5904\u7406 29. */ 30. else if ( QUEUE_EMPTY ( & w -> watcher_queue )) 31. QUEUE_INSERT_TAIL ( & loop -> watcher_queue , & w -> watcher_queue ); 32. } 2.5 Libuv\u901a\u7528\u903b\u8f91 \u00b6 2.5.1 uv__handle_init \u00b6 uv__handle_init\u521d\u59cb\u5316handle\u7684\u7c7b\u578b\uff0c\u8bbe\u7f6eREF\u6807\u8bb0\uff0c\u63d2\u5165handle\u961f\u5217\u3002 1 2 3 4 5 6 7 8 9 1. # define uv__handle_init ( loop_ , h , type_ ) 2. do { 3. ( h ) -> loop = ( loop_ ); 4. ( h ) -> type = ( type_ ); 5. ( h ) -> flags = UV_HANDLE_REF ; 6. QUEUE_INSERT_TAIL ( & ( loop_ ) -> handle_queue , & ( h ) -> handle_queue ); 7. ( h ) -> next_closing = NULL 8. } 9. while ( 0 ) 2.5.2. uv__handle_start \u00b6 uv__handle_start\u8bbe\u7f6e\u6807\u8bb0handle\u4e3aACTIVE\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86REF\u6807\u8bb0\uff0c\u5219active handle\u7684\u4e2a\u6570\u52a0\u4e00\uff0cactive handle\u6570\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002 1 2 3 4 5 6 7 8 1. # define uv__handle_start ( h ) 2. do { 3. if ((( h ) -> flags & UV_HANDLE_ACTIVE ) != 0 ) break ; 4. ( h ) -> flags |= UV_HANDLE_ACTIVE ; 5. if ((( h ) -> flags & UV_HANDLE_REF ) != 0 ) 6. ( h ) -> loop -> active_handles ++ ; 7. } 8. while ( 0 ) 2.5.3. uv__handle_stop \u00b6 uv__handle_stop\u548cuv__handle_start\u76f8\u53cd\u3002 1 2 3 4 5 6 7 1. # define uv__handle_stop ( h ) 2. do { 3. if ((( h ) -> flags & UV_HANDLE_ACTIVE ) == 0 ) break ; 4. ( h ) -> flags &= ~ UV_HANDLE_ACTIVE ; 5. if ((( h ) -> flags & UV_HANDLE_REF ) != 0 ) uv__active_handle_rm ( h ); 6. } 7. while ( 0 ) Libuv\u4e2dhandle\u6709REF\u548cACTIVE\u4e24\u4e2a\u72b6\u6001\u3002\u5f53\u4e00\u4e2ahandle\u8c03\u7528xxx_init\u51fd\u6570\u7684\u65f6\u5019\uff0c\u5b83\u9996\u5148\u88ab\u6253\u4e0aREF\u6807\u8bb0\uff0c\u5e76\u4e14\u63d2\u5165loop->handle\u961f\u5217\u3002\u5f53handle\u8c03\u7528xxx_start\u51fd\u6570\u7684\u65f6\u5019\uff0c\u5b83\u88ab\u6253\u4e0aACTIVE\u6807\u8bb0\uff0c\u5e76\u4e14\u8bb0\u5f55active handle\u7684\u4e2a\u6570\u52a0\u4e00\u3002\u53ea\u6709REF\u5e76\u4e14ACTIVE\u72b6\u6001\u7684handle\u624d\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002 2.5.4. uv__req_init \u00b6 uv__req_init\u521d\u59cb\u5316\u8bf7\u6c42\u7684\u7c7b\u578b\uff0c\u8bb0\u5f55\u8bf7\u6c42\u7684\u4e2a\u6570\uff0c\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002 1 2 3 4 5 6 1. # define uv__req_init ( loop , req , typ ) 2. do { 3. ( req ) -> type = ( typ ); 4. ( loop ) -> active_reqs . count ++ ; 5. } 6. while ( 0 ) 2.5.5. uv__req_register \u00b6 \u8bf7\u6c42\u7684\u4e2a\u6570\u52a0\u4e00 1 2 3 4 5 1. # define uv__req_register ( loop , req ) 2. do { 3. ( loop ) -> active_reqs . count ++ ; 4. } 5. while ( 0 ) 2.5.6. uv__req_unregister \u00b6 \u8bf7\u6c42\u4e2a\u6570\u51cf\u4e00 1 2 3 4 5 6 1. # define uv__req_unregister ( loop , req ) 2. do { 3. assert ( uv__has_active_reqs ( loop )); 4. ( loop ) -> active_reqs . count -- ; 5. } 6. while ( 0 ) 2.5.7. uv__handle_ref \u00b6 uv__handle_ref\u6807\u8bb0handle\u4e3aREF\u72b6\u6001\uff0c\u5982\u679chandle\u662fACTIVE\u72b6\u6001\uff0c\u5219active handle\u6570\u52a0\u4e00 1 2 3 4 5 6 7 8 9 1. # define uv__handle_ref ( h ) 2. do { 3. if ((( h ) -> flags & UV_HANDLE_REF ) != 0 ) break ; 4. ( h ) -> flags |= UV_HANDLE_REF ; 5. if ((( h ) -> flags & UV_HANDLE_CLOSING ) != 0 ) break ; 6. if ((( h ) -> flags & UV_HANDLE_ACTIVE ) != 0 ) uv__active_handle_add ( h ); 7. } 8. while ( 0 ) 9. uv__handle_unref uv__handle_unref\u53bb\u6389handle\u7684REF\u72b6\u6001\uff0c\u5982\u679chandle\u662fACTIVE\u72b6\u6001\uff0c\u5219active handle\u6570\u51cf\u4e00 1 2 3 4 5 6 7 8 1. # define uv__handle_unref ( h ) 2. do { 3. if ((( h ) -> flags & UV_HANDLE_REF ) == 0 ) break ; 4. ( h ) -> flags &= ~ UV_HANDLE_REF ; 5. if ((( h ) -> flags & UV_HANDLE_CLOSING ) != 0 ) break ; 6. if ((( h ) -> flags & UV_HANDLE_ACTIVE ) != 0 ) uv__active_handle_rm ( h ); 7. } 8. while ( 0 )","title":"02-Libuv\u6570\u636e\u7ed3\u6784\u548c\u901a\u7528\u903b\u8f91"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#libuv","text":"","title":"\u7b2c\u4e8c\u7ae0Libuv\u6570\u636e\u7ed3\u6784\u548c\u901a\u7528\u903b\u8f91"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#21-uv_loop_s","text":"uv_loop_s\u662fLibuv\u7684\u6838\u5fc3\u6570\u636e\u7ed3\u6784\uff0c\u6bcf\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af\u5bf9\u5e94\u4e00\u4e2auv_loop_s\u7ed3\u6784\u4f53\u3002\u5b83\u8bb0\u5f55\u4e86\u6574\u4e2a\u4e8b\u4ef6\u5faa\u73af\u4e2d\u7684\u6838\u5fc3\u6570\u636e\u3002\u6211\u4eec\u6765\u5206\u6790\u6bcf\u4e00\u4e2a\u5b57\u6bb5\u7684\u610f\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 1 \u7528\u6237\u81ea\u5b9a\u4e49\u6570\u636e\u7684\u5b57\u6bb5 void * data ; 2 \u6d3b\u8dc3\u7684 handle\u4e2a\u6570 \uff0c\u4f1a\u5f71\u54cd\u4f7f\u7528\u5faa\u73af\u7684\u9000\u51fa unsigned int active_handles ; 3 handle\u961f\u5217 \uff0c\u5305\u62ec\u6d3b\u8dc3\u548c\u975e\u6d3b\u8dc3\u7684 void * handle_queue [ 2 ]; 4 request\u4e2a\u6570 \uff0c\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa union { void * unused [ 2 ]; unsigned int count ; } active_reqs ; 5 \u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u7ed3\u675f\u7684\u6807\u8bb0 unsigned int stop_flag ; 6 Libuv\u8fd0\u884c\u7684\u4e00\u4e9b\u6807\u8bb0 \uff0c\u76ee\u524d\u53ea\u6709 UV_LOOP_BLOCK_SIGPROF \uff0c\u4e3b\u8981\u662f\u7528\u4e8e epoll_wait\u7684\u65f6\u5019\u5c4f\u853dSIGPROF\u4fe1\u53f7 \uff0c\u63d0\u9ad8\u6027\u80fd\uff0c SIGPROF\u662f\u8c03\u64cd\u4f5c\u7cfb\u7edfsettimer\u51fd\u6570\u8bbe\u7f6e\u4ece\u800c\u89e6\u53d1\u7684\u4fe1\u53f7 unsigned long flags ; 7 epoll\u7684fd int backend_fd ; 8 pending\u9636\u6bb5\u7684\u961f\u5217 void * pending_queue [ 2 ]; 9 \u6307\u5411\u9700\u8981\u5728 epoll\u4e2d\u6ce8\u518c\u4e8b\u4ef6\u7684uv__io_t\u7ed3\u6784\u4f53\u961f\u5217 void * watcher_queue [ 2 ]; 10 watcher_queue\u961f\u5217\u7684\u8282\u70b9\u4e2d\u6709\u4e00\u4e2afd\u5b57\u6bb5 \uff0c watchers\u4ee5fd\u4e3a\u7d22\u5f15 \uff0c\u8bb0\u5f55 fd\u6240\u5728\u7684uv__io_t\u7ed3\u6784\u4f53 uv__io_t ** watchers ; 11 watchers\u76f8\u5173\u7684\u6570\u91cf \uff0c\u5728 maybe_resize\u51fd\u6570\u91cc\u8bbe\u7f6e unsigned int nwatchers ; 12 watchers\u91ccfd\u4e2a\u6570 \uff0c\u4e00\u822c\u4e3a watcher_queue\u961f\u5217\u7684\u8282\u70b9\u6570 unsigned int nfds ; 13 \u7ebf\u7a0b\u6c60\u7684\u5b50\u7ebf\u7a0b\u5904\u7406\u5b8c\u4efb\u52a1\u540e\u628a\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53\u63d2\u5165\u5230 wq\u961f\u5217 void * wq [ 2 ]; 14 \u63a7\u5236 wq\u961f\u5217\u4e92\u65a5\u8bbf\u95ee \uff0c\u5426\u5219\u591a\u4e2a\u5b50\u7ebf\u7a0b\u540c\u65f6\u8bbf\u95ee\u4f1a\u6709\u95ee\u9898 uv_mutex_t wq_mutex ; 15 \u7528\u4e8e\u7ebf\u7a0b\u6c60\u7684\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1 uv_async_t wq_async ; 16 \u7528\u4e8e\u8bfb\u5199\u9501\u7684\u4e92\u65a5\u53d8\u91cf uv_rwlock_t cloexec_lock ; 17 \u4e8b\u4ef6\u5faa\u73af close\u9636\u6bb5\u7684\u961f\u5217 \uff0c\u7531 uv_close\u4ea7\u751f uv_handle_t * closing_handles ; 18 fork\u51fa\u6765\u7684\u8fdb\u7a0b\u961f\u5217 void * process_handles [ 2 ]; 19 \u4e8b\u4ef6\u5faa\u73af\u7684 prepare\u9636\u6bb5\u5bf9\u5e94\u7684\u4efb\u52a1\u961f\u5217 void * prepare_handles [ 2 ]; 20 \u4e8b\u4ef6\u5faa\u73af\u7684 check\u9636\u6bb5\u5bf9\u5e94\u7684\u4efb\u52a1\u961f\u5217 void * check_handles [ 2 ]; 21 \u4e8b\u4ef6\u5faa\u73af\u7684 idle\u9636\u6bb5\u5bf9\u5e94\u7684\u4efb\u52a1\u961f\u5217 void * idle_handles [ 2 ]; 21 async_handles\u961f\u5217 \uff0c Poll IO\u9636\u6bb5\u6267\u884cuv__async_io\u4e2d\u904d\u5386async_handles\u961f\u5217\u5904\u7406\u91cc\u9762pending\u4e3a1\u7684\u8282\u70b9 void * async_handles [ 2 ]; 22 \u7528\u4e8e\u76d1\u542c\u662f\u5426\u6709 async handle\u4efb\u52a1\u9700\u8981\u5904\u7406 uv__io_t async_io_watcher ; 23 \u7528\u4e8e\u4fdd\u5b58\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u7684\u5199\u7aef fd int async_wfd ; 24 \u4fdd\u5b58\u5b9a\u65f6\u5668\u4e8c\u53c9\u5806\u7ed3\u6784 struct { void * min ; unsigned int nelts ; } timer_heap ; 25 \u7ba1\u7406\u5b9a\u65f6\u5668\u8282\u70b9\u7684 id \uff0c\u4e0d\u65ad\u53e0\u52a0 uint64_t timer_counter ; 26 \u5f53\u524d\u65f6\u95f4\uff0c Libuv\u4f1a\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u7684\u5f00\u59cb\u548cPoll IO\u9636\u6bb5\u66f4\u65b0\u5f53\u524d\u65f6\u95f4 \uff0c\u7136\u540e\u5728\u540e\u7eed\u7684\u5404\u4e2a\u9636\u6bb5\u4f7f\u7528\uff0c\u51cf\u5c11\u5bf9\u7cfb\u7edf\u8c03\u7528 uint64_t time ; 27 \u7528\u4e8e fork\u51fa\u6765\u7684\u8fdb\u7a0b\u548c\u4e3b\u8fdb\u7a0b\u901a\u4fe1\u7684\u7ba1\u9053 \uff0c\u7528\u4e8e\u5b50\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\u901a\u77e5\u4e3b\u8fdb\u7a0b\uff0c\u7136\u540e\u4e3b\u8fdb\u7a0b\u6267\u884c\u5b50\u8fdb\u7a0b\u8282\u70b9\u6ce8\u518c\u7684\u56de\u8c03 int signal_pipefd [ 2 ]; 28 \u7c7b\u4f3c async_io_watcher \uff0c signal_io_watcher\u4fdd\u5b58\u4e86\u7ba1\u9053\u8bfb\u7aeffd\u548c\u56de\u8c03 \uff0c\u7136\u540e\u6ce8\u518c\u5230 epoll\u4e2d \uff0c\u5728\u5b50\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\uff0c\u901a\u8fc7 write\u5199\u5230\u7ba1\u9053 \uff0c\u6700\u540e\u5728 Poll IO\u9636\u6bb5\u6267\u884c\u56de\u8c03 uv__io_t signal_io_watcher ; 29 \u7528\u4e8e\u7ba1\u7406\u5b50\u8fdb\u7a0b\u9000\u51fa\u4fe1\u53f7\u7684 handle uv_signal_t child_watcher ; 30 \u5907\u7528\u7684 fd int emfile_fd ;","title":"2.1 \u6838\u5fc3\u7ed3\u6784\u4f53uv_loop_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#22-uv_handle_t","text":"\u5728Libuv\u4e2d\uff0cuv_handle_t\u7c7b\u4f3cC++\u4e2d\u7684\u57fa\u7c7b\uff0c\u6709\u5f88\u591a\u5b50\u7c7b\u7ee7\u627f\u4e8e\u5b83\uff0cLibuv\u4e3b\u8981\u901a\u8fc7\u63a7\u5236\u5185\u5b58\u7684\u5e03\u5c40\u5f97\u5230\u7ee7\u627f\u7684\u6548\u679c\u3002handle\u4ee3\u8868\u751f\u547d\u5468\u671f\u6bd4\u8f83\u957f\u7684\u5bf9\u8c61\u3002\u4f8b\u5982 1 \u4e00\u4e2a\u5904\u4e8eactive\u72b6\u6001\u7684prepare handle\uff0c\u5b83\u7684\u56de\u8c03\u4f1a\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u5316\u7684\u65f6\u5019\u88ab\u6267\u884c\u3002 2 \u4e00\u4e2aTCP handle\u5728\u6bcf\u6b21\u6709\u8fde\u63a5\u5230\u6765\u65f6\uff0c\u6267\u884c\u5b83\u7684\u56de\u8c03\u3002 \u6211\u4eec\u770b\u4e00\u4e0buv_handle_t\u7684\u5b9a\u4e49 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 1 \u81ea\u5b9a\u4e49\u6570\u636e\uff0c\u7528\u4e8e\u5173\u8054\u4e00\u4e9b\u4e0a\u4e0b\u6587 , Node . js\u4e2d\u7528\u4e8e\u5173\u8054handle\u6240\u5c5e\u7684C ++ \u5bf9\u8c61 void * data ; 2 \u6240\u5c5e\u7684\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 3 handle\u7c7b\u578b uv_handle_type type ; 4 handle\u8c03\u7528uv_close\u540e \uff0c\u5728 closing\u9636\u6bb5\u88ab\u6267\u884c\u7684\u56de\u8c03 uv_close_cb close_cb ; 5 \u7528\u4e8e\u7ec4\u7ec7 handle\u961f\u5217\u7684\u524d\u7f6e\u540e\u7f6e\u6307\u9488 void * handle_queue [ 2 ]; 6 \u6587\u4ef6\u63cf\u8ff0\u7b26 union { int fd ; void * reserved [ 4 ]; } u ; 7 \u5f53 handle\u5728close\u961f\u5217\u65f6 \uff0c\u8be5\u5b57\u6bb5\u6307\u5411\u4e0b\u4e00\u4e2a close\u8282\u70b9 uv_handle_t * next_closing ; 8 handle\u7684\u72b6\u6001\u548c\u6807\u8bb0 unsigned int flags ;","title":"2.2 uv_handle_t"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#221-uv_stream_s","text":"uv_stream_s\u662f\u8868\u793a\u6d41\u7684\u7ed3\u6784\u4f53\u3002\u9664\u4e86\u7ee7\u627fuv_handle_t\u7684\u5b57\u6bb5\u5916\uff0c\u5b83\u989d\u5916\u5b9a\u4e49\u4e0b\u9762\u5b57\u6bb5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 1 \u7b49\u5f85\u53d1\u9001\u7684\u5b57\u8282\u6570 size_t write_queue_size ; 2 \u5206\u914d\u5185\u5b58\u7684\u51fd\u6570 uv_alloc_cb alloc_cb ; 3 \u8bfb\u53d6\u6570\u636e\u6210\u529f\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_read_cb read_cb ; 4 \u53d1\u8d77\u8fde\u63a5\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53 uv_connect_t * connect_req ; 5 \u5173\u95ed\u5199\u7aef\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53 uv_shutdown_t * shutdown_req ; 6 \u7528\u4e8e\u63d2\u5165 epoll \uff0c\u6ce8\u518c\u8bfb\u5199\u4e8b\u4ef6 uv__io_t io_watcher ; 7 \u5f85\u53d1\u9001\u961f\u5217 void * write_queue [ 2 ]; 8 \u53d1\u9001\u5b8c\u6210\u7684\u961f\u5217 void * write_completed_queue [ 2 ]; 9 \u6536\u5230\u8fde\u63a5\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_connection_cb connection_cb ; 10 socket\u64cd\u4f5c\u5931\u8d25\u7684\u9519\u8bef\u7801 int delayed_error ; 11 accept\u8fd4\u56de\u7684fd int accepted_fd ; 12 \u5df2\u7ecf accept\u4e86\u4e00\u4e2afd \uff0c\u53c8\u6709\u65b0\u7684 fd \uff0c\u6682\u5b58\u8d77\u6765 void * queued_fds ;","title":"2.2.1 uv_stream_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#222-uv_async_s","text":"uv_async_s\u662fLibuv\u4e2d\u5b9e\u73b0\u5f02\u6b65\u901a\u4fe1\u7684\u7ed3\u6784\u4f53\u3002\u7ee7\u627f\u4e8euv_handle_t\uff0c\u5e76\u989d\u5916\u5b9a\u4e49\u4e86\u4ee5\u4e0b\u5b57\u6bb5\u3002 1 2 3 4 5 6 7 8 1 \u5f02\u6b65\u4e8b\u4ef6\u89e6\u53d1\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_async_cb async_cb ; 2 \u7528\u4e8e\u63d2\u5165 async - handles\u961f\u5217 void * queue [ 2 ]; 3 async_handles\u961f\u5217\u4e2d\u7684\u8282\u70b9pending\u5b57\u6bb5\u4e3a1\u8bf4\u660e\u5bf9\u5e94\u7684\u4e8b\u4ef6\u89e6\u53d1\u4e86 int pending ;","title":"2.2.2 uv_async_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#223-uv_tcp_s","text":"uv_tcp_s\u7ee7\u627fuv_handle_s\u548cuv_stream_s\u3002","title":"2.2.3 uv_tcp_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#224-uv_udp_s","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 1 \u53d1\u9001\u5b57\u8282\u6570 size_t send_queue_size ; 2 \u5199\u961f\u5217\u8282\u70b9\u7684\u4e2a\u6570 size_t send_queue_count ; 3 \u5206\u914d\u63a5\u6536\u6570\u636e\u7684\u5185\u5b58 uv_alloc_cb alloc_cb ; 4 \u63a5\u6536\u5b8c\u6570\u636e\u540e\u6267\u884c\u7684\u56de\u8c03 uv_udp_recv_cb recv_cb ; 5 \u63d2\u5165 epoll\u91cc\u7684IO\u89c2\u5bdf\u8005 \uff0c\u5b9e\u73b0\u6570\u636e\u8bfb\u5199 uv__io_t io_watcher ; 6 \u5f85\u53d1\u9001\u961f\u5217 void * write_queue [ 2 ]; 7 \u53d1\u9001\u5b8c\u6210\u7684\u961f\u5217\uff08\u53d1\u9001\u6210\u529f\u6216\u5931\u8d25\uff09\uff0c\u548c\u5f85\u53d1\u9001\u961f\u5217\u76f8\u5173 void * write_completed_queue [ 2 ];","title":"2.2.4 uv_udp_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#225-uv_tty_s","text":"uv_tty_s\u7ee7\u627f\u4e8euv_handle_t\u548cuv_stream_t\u3002\u989d\u5916\u5b9a\u4e49\u4e86\u4e0b\u9762\u5b57\u6bb5\u3002 1 2 3 4 5 1 \u7ec8\u7aef\u7684\u53c2\u6570 struct termios orig_termios ; 2 \u7ec8\u7aef\u7684\u5de5\u4f5c\u6a21\u5f0f int mode ;","title":"2.2.5 uv_tty_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#226-uv_pipe_s","text":"uv_pipe_s\u7ee7\u627f\u4e8euv_handle_t\u548cuv_stream_t\u3002\u989d\u5916\u5b9a\u4e49\u4e86\u4e0b\u9762\u5b57\u6bb5\u3002 1 2 3 4 5 1 \u6807\u8bb0\u7ba1\u9053\u662f\u5426\u53ef\u7528\u4e8e\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 int ipc ; 2 \u7528\u4e8e Unix\u57df\u901a\u4fe1\u7684\u6587\u4ef6\u8def\u5f84 const char * pipe_fname ;","title":"2.2.6 uv_pipe_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#227-uv_prepare_suv_check_suv_idle_s","text":"\u4e0a\u9762\u4e09\u4e2a\u7ed3\u6784\u4f53\u5b9a\u4e49\u662f\u7c7b\u4f3c\u7684\uff0c\u5b83\u4eec\u90fd\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86\u4e24\u4e2a\u5b57\u6bb5\u3002 1 2 3 4 5 1 prepare \u3001 check \u3001 idle\u9636\u6bb5\u56de\u8c03 uv_xxx_cb xxx_cb ; 2 \u7528\u4e8e\u63d2\u5165 prepare \u3001 check \u3001 idle\u961f\u5217 void * queue [ 2 ];","title":"2.2.7 uv_prepare_s\u3001uv_check_s\u3001uv_idle_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#228-uv_timer_s","text":"uv_timer_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86\u4e0b\u9762\u51e0\u4e2a\u5b57\u6bb5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 1 \u8d85\u65f6\u56de\u8c03 uv_timer_cb timer_cb ; 2 \u63d2\u5165\u4e8c\u53c9\u5806\u7684\u5b57\u6bb5 void * heap_node [ 3 ]; 3 \u8d85\u65f6\u65f6\u95f4 uint64_t timeout ; 4 \u8d85\u65f6\u540e\u662f\u5426\u7ee7\u7eed\u5f00\u59cb\u91cd\u65b0\u8ba1\u65f6\uff0c\u662f\u7684\u8bdd\u91cd\u65b0\u63d2\u5165\u4e8c\u53c9\u5806 uint64_t repeat ; 5 id\u6807\u8bb0 \uff0c\u7528\u4e8e\u63d2\u5165\u4e8c\u53c9\u5806\u7684\u65f6\u5019\u5bf9\u6bd4 uint64_t start_id","title":"2.2.8 uv_timer_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#229-uv_process_s","text":"uv_process_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86 1 2 3 4 5 6 7 8 9 10 11 1 \u8fdb\u7a0b\u9000\u51fa\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_exit_cb exit_cb ; 2 \u8fdb\u7a0b id int pid ; 3 \u7528\u4e8e\u63d2\u5165\u961f\u5217\uff0c\u8fdb\u7a0b\u961f\u5217\u6216\u8005 pending\u961f\u5217 void * queue [ 2 ]; 4 \u9000\u51fa\u7801\uff0c\u8fdb\u7a0b\u9000\u51fa\u65f6\u8bbe\u7f6e int status ;","title":"2.2.9 uv_process_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#2210-uv_fs_event_s","text":"uv_fs_event_s\u7528\u4e8e\u76d1\u542c\u6587\u4ef6\u6539\u52a8\u3002uv_fs_event_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86 1 2 3 4 5 1 \u76d1\u542c\u7684\u6587\u4ef6\u8def\u5f84 ( \u6587\u4ef6\u6216\u76ee\u5f55 ) char * path ; 2 \u6587\u4ef6\u6539\u53d8\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_fs_event_cb cb ;","title":"2.2.10 uv_fs_event_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#2211-uv_fs_poll_s","text":"uv_fs_poll_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 1 poll_ctx\u6307\u5411poll_ctx\u7ed3\u6784\u4f53 void * poll_ctx ; struct poll_ctx { // \u5bf9\u5e94\u7684handle uv_fs_poll_t * parent_handle ; // \u6807\u8bb0\u662f\u5426\u5f00\u59cb\u8f6e\u8be2\u548c\u8f6e\u8be2\u65f6\u7684\u5931\u8d25\u539f\u56e0 int busy_polling ; // \u591a\u4e45\u68c0\u6d4b\u4e00\u6b21\u6587\u4ef6\u5185\u5bb9\u662f\u5426\u6539\u53d8 unsigned int interval ; // \u6bcf\u4e00\u8f6e\u8f6e\u8be2\u65f6\u7684\u5f00\u59cb\u65f6\u95f4 uint64_t start_time ; // \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; // \u6587\u4ef6\u6539\u53d8\u65f6\u56de\u8c03 uv_fs_poll_cb poll_cb ; // \u5b9a\u65f6\u5668\uff0c\u7528\u4e8e\u5b9a\u65f6\u8d85\u65f6\u540e\u8f6e\u8be2 uv_timer_t timer_handle ; // \u8bb0\u5f55\u8f6e\u8be2\u7684\u4e00\u4e0b\u4e0a\u4e0b\u6587\u4fe1\u606f\uff0c\u6587\u4ef6\u8def\u5f84\u3001\u56de\u8c03\u7b49 uv_fs_t fs_req ; // \u8f6e\u8be2\u65f6\u4fdd\u5b58\u64cd\u4f5c\u7cfb\u7edf\u8fd4\u56de\u7684\u6587\u4ef6\u4fe1\u606f uv_stat_t statbuf ; // \u76d1\u542c\u7684\u6587\u4ef6\u8def\u5f84\uff0c\u5b57\u7b26\u4e32\u7684\u503c\u8ffd\u52a0\u5728\u7ed3\u6784\u4f53\u540e\u9762 char path [ 1 ]; /* variable length */ };","title":"2.2.11 uv_fs_poll_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#2212-uv_poll_s","text":"uv_poll_s\u7ee7\u627f\u4e8euv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86\u4e0b\u9762\u5b57\u6bb5\u3002 1 2 3 4 5 1 \u76d1\u542c\u7684 fd\u6709\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u65f6\u6267\u884c\u7684\u56de\u8c03 uv_poll_cb poll_cb ; 2 \u4fdd\u5b58\u4e86 fd\u548c\u56de\u8c03\u7684IO\u89c2\u5bdf\u8005 \uff0c\u6ce8\u518c\u5230 epoll\u4e2d uv__io_t io_watcher ;","title":"2.2.12 uv_poll_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#2113-uv_signal_s","text":"uv_signal_s\u7ee7\u627fuv_handle_t\uff0c\u989d\u5916\u5b9a\u4e49\u4e86\u4ee5\u4e0b\u5b57\u6bb5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 1 \u6536\u5230\u4fe1\u53f7\u65f6\u7684\u56de\u8c03 uv_signal_cb signal_cb ; 2 \u6ce8\u518c\u7684\u4fe1\u53f7 int signum ; 3 \u7528\u4e8e\u63d2\u5165\u7ea2\u9ed1\u6811\uff0c\u8fdb\u7a0b\u628a\u611f\u5174\u8da3\u7684\u4fe1\u53f7\u548c\u56de\u8c03\u5c01\u88c5\u6210 uv_signal_s \uff0c\u7136\u540e\u63d2\u5165\u5230\u7ea2\u9ed1\u6811\uff0c\u4fe1\u53f7\u5230\u6765\u65f6\uff0c\u8fdb\u7a0b\u5728\u4fe1\u53f7\u5904\u7406\u53f7\u4e2d\u628a\u901a\u77e5\u5199\u5165\u7ba1\u9053\uff0c\u901a\u77e5 Libuv \u3002 Libuv\u5728Poll IO\u9636\u6bb5\u4f1a\u6267\u884c\u8fdb\u7a0b\u5bf9\u5e94\u7684\u56de\u8c03 \u3002\u7ea2\u9ed1\u6811\u8282\u70b9\u7684\u5b9a\u4e49\u5982\u4e0b struct { struct uv_signal_s * rbe_left ; struct uv_signal_s * rbe_right ; struct uv_signal_s * rbe_parent ; int rbe_color ; } tree_entry ; 4 \u6536\u5230\u7684\u4fe1\u53f7\u4e2a\u6570 unsigned int caught_signals ; 5 \u5df2\u7ecf\u5904\u7406\u7684\u4fe1\u53f7\u4e2a\u6570 unsigned int dispatched_signals ;","title":"2.1.13 uv_signal_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#23-uv_req_s","text":"\u5728Libuv\u4e2d\uff0cuv_req_s\u4e5f\u7c7b\u4f3cC++\u57fa\u7c7b\u7684\u4f5c\u7528\uff0c\u6709\u5f88\u591a\u5b50\u7c7b\u7ee7\u627f\u4e8e\u5b83\uff0crequest\u4ee3\u8868\u4e00\u6b21\u8bf7\u6c42\uff0c\u6bd4\u5982\u8bfb\u5199\u4e00\u4e2a\u6587\u4ef6\uff0c\u8bfb\u5199socket\uff0c\u67e5\u8be2DNS\u3002\u4efb\u52a1\u5b8c\u6210\u540e\u8fd9\u4e2arequest\u5c31\u7ed3\u675f\u4e86\u3002request\u53ef\u4ee5\u548chandle\u7ed3\u5408\u4f7f\u7528\uff0c\u6bd4\u5982\u5728\u4e00\u4e2aTCP\u670d\u52a1\u5668\u4e0a\uff08handle\uff09\u5199\u4e00\u4e2a\u6570\u636e\uff08request\uff09\uff0c\u4e5f\u53ef\u4ee5\u5355\u72ec\u4f7f\u7528\u4e00\u4e2arequest\uff0c\u6bd4\u5982DNS\u67e5\u8be2\u6216\u8005\u6587\u4ef6\u8bfb\u5199\u3002\u6211\u4eec\u770b\u4e00\u4e0buv_req_s\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 1 \u81ea\u5b9a\u4e49\u6570\u636e void * data ; 2 request\u7c7b\u578b uv_req_type type ; 3 \u4fdd\u7559\u5b57\u6bb5 void * reserved [ 6 ];","title":"2.3 uv_req_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#231-uv_shutdown_s","text":"uv_shutdown_s\u7528\u4e8e\u5173\u95ed\u6d41\u7684\u5199\u7aef\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 2 3 4 5 1 \u8981\u5173\u95ed\u7684\u6d41\uff0c\u6bd4\u5982 TCP uv_stream_t * handle ; 2 \u5173\u95ed\u6d41\u7684\u5199\u7aef\u540e\u6267\u884c\u7684\u56de\u8c03 uv_shutdown_cb cb ;","title":"2.3.1 uv_shutdown_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#232-uv_write_s","text":"uv_write_s\u8868\u793a\u4e00\u6b21\u5199\u8bf7\u6c42\uff0c\u6bd4\u5982\u5728TCP\u6d41\u4e0a\u53d1\u9001\u6570\u636e\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 1 \u5199\u5b8c\u540e\u7684\u56de\u8c03 uv_write_cb cb ; 2 \u9700\u8981\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5728 send_handle\u4e2d uv_stream_t * send_handle ; 3 \u5173\u8054\u7684 handle uv_stream_t * handle ; 4 \u7528\u4e8e\u63d2\u5165\u961f\u5217 void * queue [ 2 ]; 5 \u4fdd\u5b58\u9700\u8981\u5199\u7684\u6570\u636e\u76f8\u5173\u7684\u5b57\u6bb5\uff08\u5199\u5165\u7684 buffer\u4e2a\u6570 \uff0c\u5f53\u524d\u5199\u6210\u529f\u7684\u4f4d\u7f6e\u7b49\uff09 unsigned int write_index ; uv_buf_t * bufs ; unsigned int nbufs ; uv_buf_t bufsml [ 4 ]; 6 \u5199\u51fa\u9519\u7684\u9519\u8bef\u7801 int error ;","title":"2.3.2 uv_write_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#233-uv_connect_s","text":"uv_connect_s\u8868\u793a\u53d1\u8d77\u8fde\u63a5\u8bf7\u6c42\uff0c\u6bd4\u5982TCP\u8fde\u63a5\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 2 3 4 5 6 7 8 1 \u8fde\u63a5\u6210\u529f\u540e\u6267\u884c\u7684\u56de\u8c03 uv_connect_cb cb ; 2 \u5bf9\u5e94\u7684\u6d41\uff0c\u6bd4\u5982 tcp uv_stream_t * handle ; 3 \u7528\u4e8e\u63d2\u5165\u961f\u5217 void * queue [ 2 ];","title":"2.3.3 uv_connect_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#234-uv_udp_send_s","text":"uv_udp_send_s\u8868\u793a\u4e00\u6b21\u53d1\u9001UDP\u6570\u636e\u7684\u8bf7\u6c42 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 1 \u6240\u5c5e udp\u7684handle \uff0c udp_send_s\u4ee3\u8868\u4e00\u6b21\u53d1\u9001 uv_udp_t * handle ; 2 \u56de\u8c03 uv_udp_send_cb cb ; 3 \u7528\u4e8e\u63d2\u5165\u5f85\u53d1\u9001\u961f\u5217 void * queue [ 2 ]; 4 \u53d1\u9001\u7684\u76ee\u7684\u5730\u5740 struct sockaddr_storage addr ; 5 \u4fdd\u5b58\u4e86\u53d1\u9001\u6570\u636e\u7684\u7f13\u51b2\u533a\u548c\u4e2a\u6570 unsigned int nbufs ; uv_buf_t * bufs ; uv_buf_t bufsml [ 4 ]; 6 \u53d1\u9001\u72b6\u6001\u6216\u6210\u529f\u53d1\u9001\u7684\u5b57\u8282\u6570 ssize_t status ; 7 \u53d1\u9001\u5b8c\u6267\u884c\u7684\u56de\u8c03\uff08\u53d1\u9001\u6210\u529f\u6216\u5931\u8d25\uff09 uv_udp_send_cb send_cb ;","title":"2.3.4 uv_udp_send_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#235-uv_getaddrinfo_s","text":"uv_getaddrinfo_s\u8868\u793a\u4e00\u6b21\u901a\u8fc7\u57df\u540d\u67e5\u8be2IP\u7684DNS\u8bf7\u6c42\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 1 \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 2 \u7528\u4e8e\u5f02\u6b65 DNS\u89e3\u6790\u65f6\u63d2\u5165\u7ebf\u7a0b\u6c60\u4efb\u52a1\u961f\u5217\u7684\u8282\u70b9 struct uv__work work_req ; 3 DNS\u89e3\u6790\u5b8c\u540e\u6267\u884c\u7684\u56de\u8c03 uv_getaddrinfo_cb cb ; 4 DNS\u67e5\u8be2\u7684\u914d\u7f6e struct addrinfo * hints ; char * hostname ; char * service ; 5 DNS\u89e3\u6790\u7ed3\u679c struct addrinfo * addrinfo ; 6 DNS\u89e3\u6790\u7684\u8fd4\u56de\u7801 int retcode ;","title":"2.3.5 uv_getaddrinfo_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#236-uv_getnameinfo_s","text":"uv_getnameinfo_s\u8868\u793a\u4e00\u6b21\u901a\u8fc7IP\u67e5\u8be2\u57df\u540d\u7684DNS\u67e5\u8be2\u8bf7\u6c42\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 1 \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 2 \u7528\u4e8e\u5f02\u6b65 DNS\u89e3\u6790\u65f6\u63d2\u5165\u7ebf\u7a0b\u6c60\u4efb\u52a1\u961f\u5217\u7684\u8282\u70b9 struct uv__work work_req ; 3 socket\u8f6c\u57df\u540d\u5b8c\u6210\u7684\u56de\u8c03 uv_getnameinfo_cb getnameinfo_cb ; 4 \u9700\u8981\u8f6c\u57df\u540d\u7684 socket\u7ed3\u6784\u4f53 struct sockaddr_storage storage ; 5 \u6307\u793a\u67e5\u8be2\u8fd4\u56de\u7684\u4fe1\u606f int flags ; 6 \u67e5\u8be2\u8fd4\u56de\u7684\u4fe1\u606f char host [ NI_MAXHOST ]; char service [ NI_MAXSERV ]; 7 \u67e5\u8be2\u8fd4\u56de\u7801 int retcode ;","title":"2.3.6 uv_getnameinfo_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#237-uv_work_s","text":"uv_work_s\u7528\u4e8e\u5f80\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4efb\u52a1\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 2 3 4 5 6 7 8 9 10 11 1 \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 2 \u5904\u7406\u4efb\u52a1\u7684\u51fd\u6570 uv_work_cb work_cb ; 3 \u5904\u7406\u5b8c\u4efb\u52a1\u540e\u6267\u884c\u7684\u51fd\u6570 uv_after_work_cb after_work_cb ; 4 \u5c01\u88c5\u4e00\u4e2a work\u63d2\u5165\u5230\u7ebf\u7a0b\u6c60\u961f\u5217 \uff0c work_req\u7684work\u548cdone\u51fd\u6570\u662f\u5bf9\u4e0a\u9762work_cb\u548cafter_work_cb\u7684\u5c01\u88c5 struct uv__work work_req ;","title":"2.3.7 uv_work_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#uv_fs_s","text":"uv_fs_s\u8868\u793a\u4e00\u6b21\u6587\u4ef6\u64cd\u4f5c\u8bf7\u6c42\uff0c\u989d\u5916\u5b9a\u4e49\u7684\u5b57\u6bb5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 1 \u6587\u4ef6\u64cd\u4f5c\u7c7b\u578b uv_fs_type fs_type ; 2 \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; 3 \u6587\u4ef6\u64cd\u4f5c\u5b8c\u6210\u7684\u56de\u8c03 uv_fs_cb cb ; 4 \u6587\u4ef6\u64cd\u4f5c\u7684\u8fd4\u56de\u7801 ssize_t result ; 5 \u6587\u4ef6\u64cd\u4f5c\u8fd4\u56de\u7684\u6570\u636e void * ptr ; 6 \u6587\u4ef6\u64cd\u4f5c\u8def\u5f84 const char * path ; 7 \u6587\u4ef6\u7684 stat\u4fe1\u606f uv_stat_t statbuf ; 8 \u6587\u4ef6\u64cd\u4f5c\u6d89\u53ca\u5230\u4e24\u4e2a\u8def\u5f84\u65f6\uff0c\u4fdd\u5b58\u76ee\u7684\u8def\u5f84 const char * new_path ; 9 \u6587\u4ef6\u63cf\u8ff0\u7b26 uv_file file ; 10 \u6587\u4ef6\u6807\u8bb0 int flags ; 11 \u64cd\u4f5c\u6a21\u5f0f mode_t mode ; 12 \u5199\u6587\u4ef6\u65f6\u4f20\u5165\u7684\u6570\u636e\u548c\u4e2a\u6570 unsigned int nbufs ; uv_buf_t * bufs ; 13 \u6587\u4ef6\u504f\u79fb off_t off ; 14 \u4fdd\u5b58\u9700\u8981\u8bbe\u7f6e\u7684 uid\u548cgid \uff0c\u4f8b\u5982 chmod\u7684\u65f6\u5019 uv_uid_t uid ; uv_gid_t gid ; 15 \u4fdd\u5b58\u9700\u8981\u8bbe\u7f6e\u7684\u6587\u4ef6\u4fee\u6539\u3001\u8bbf\u95ee\u65f6\u95f4\uff0c\u4f8b\u5982 fs . utimes\u7684\u65f6\u5019 double atime ; double mtime ; 16 \u5f02\u6b65\u7684\u65f6\u5019\u7528\u4e8e\u63d2\u5165\u4efb\u52a1\u961f\u5217\uff0c\u4fdd\u5b58\u5de5\u4f5c\u51fd\u6570\uff0c\u56de\u8c03\u51fd\u6570 struct uv__work work_req ; 17 \u4fdd\u5b58\u8bfb\u53d6\u6570\u636e\u6216\u8005\u957f\u5ea6\u3002\u4f8b\u5982 read\u548csendfile uv_buf_t bufsml [ 4 ];","title":"uv_fs_s"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#24-io","text":"IO\u89c2\u5bdf\u8005\u662fLibuv\u4e2d\u7684\u6838\u5fc3\u6982\u5ff5\u548c\u6570\u636e\u7ed3\u6784\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u7684\u5b9a\u4e49 1 2 3 4 5 6 7 8 9 10 11 12 1. struct uv__io_s { 2. // \u4e8b\u4ef6\u89e6\u53d1\u540e\u7684\u56de\u8c03 3. uv__io_cb cb ; 4. // \u7528\u4e8e\u63d2\u5165\u961f\u5217 5. void * pending_queue [ 2 ]; 6. void * watcher_queue [ 2 ]; 7. // \u4fdd\u5b58\u672c\u6b21\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u5728\u63d2\u5165IO\u89c2\u5bdf\u8005\u961f\u5217\u65f6\u8bbe\u7f6e 8. unsigned int pevents ; 9. // \u4fdd\u5b58\u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6 10. unsigned int events ; 11. int fd ; 12. }; IO\u89c2\u5bdf\u8005\u5c01\u88c5\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u4e8b\u4ef6\u548c\u56de\u8c03\uff0c\u7136\u540e\u63d2\u5165\u5230loop\u7ef4\u62a4\u7684IO\u89c2\u5bdf\u8005\u961f\u5217\uff0c\u5728Poll IO\u9636\u6bb5\uff0cLibuv\u4f1a\u6839\u636eIO\u89c2\u5bdf\u8005\u63cf\u8ff0\u7684\u4fe1\u606f\uff0c\u5f80\u5e95\u5c42\u7684\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u6ce8\u518c\u6587\u4ef6\u63cf\u8ff0\u7b26\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u3002\u5f53\u6ce8\u518c\u7684\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0cIO\u89c2\u5bdf\u8005\u7684\u56de\u8c03\u5c31\u4f1a\u88ab\u6267\u884c\u3002\u6211\u4eec\u770b\u5982\u4f55\u521dIO\u89c2\u5bdf\u8005\u7684\u4e00\u4e9b\u903b\u8f91\u3002","title":"2.4 IO\u89c2\u5bdf\u8005"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#241-io","text":"1 2 3 4 5 6 7 8 9 10 11 1. void uv__io_init ( uv__io_t * w , uv__io_cb cb , int fd ) { 2. // \u521d\u59cb\u5316\u961f\u5217\uff0c\u56de\u8c03\uff0c\u9700\u8981\u76d1\u542c\u7684fd 3. QUEUE_INIT ( & w -> pending_queue ); 4. QUEUE_INIT ( & w -> watcher_queue ); 5. w -> cb = cb ; 6. w -> fd = fd ; 7. // \u4e0a\u6b21\u52a0\u5165epoll\u65f6\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u5728\u6267\u884c\u5b8cepoll\u64cd\u4f5c\u51fd\u6570\u540e\u8bbe\u7f6e 8. w -> events = 0 ; 9. // \u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u5728\u518d\u6b21\u6267\u884cepoll\u51fd\u6570\u4e4b\u524d\u8bbe\u7f6e 10. w -> pevents = 0 ; 11. }","title":"2.4.1 \u521d\u59cb\u5316IO\u89c2\u5bdf\u8005"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#242iolibuv","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 1. void uv__io_start ( uv_loop_t * loop , uv__io_t * w , unsigned int events ) { 2. // \u8bbe\u7f6e\u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6 3. w -> pevents |= events ; 4. // \u53ef\u80fd\u9700\u8981\u6269\u5bb9 5. maybe_resize ( loop , w -> fd + 1 ); 6. // \u4e8b\u4ef6\u6ca1\u6709\u53d8\u5316\u5219\u76f4\u63a5\u8fd4\u56de 7. if ( w -> events == w -> pevents ) 8. return ; 9. // IO\u89c2\u5bdf\u8005\u6ca1\u6709\u6302\u8f7d\u5728\u5176\u5b83\u5730\u65b9\u5219\u63d2\u5165Libuv\u7684IO\u89c2\u5bdf\u8005\u961f\u5217 10. if ( QUEUE_EMPTY ( & w -> watcher_queue )) 11. QUEUE_INSERT_TAIL ( & loop -> watcher_queue , & w -> watcher_queue ); 12. // \u4fdd\u5b58\u6620\u5c04\u5173\u7cfb 13. if ( loop -> watchers [ w -> fd ] == NULL ) { 14. loop -> watchers [ w -> fd ] = w ; 15. loop -> nfds ++ ; 16. } 17. } uv__io_start\u51fd\u6570\u5c31\u662f\u628a\u4e00\u4e2aIO\u89c2\u5bdf\u8005\u63d2\u5165\u5230Libuv\u7684\u89c2\u5bdf\u8005\u961f\u5217\u4e2d\uff0c\u5e76\u4e14\u5728watchers\u6570\u7ec4\u4e2d\u4fdd\u5b58\u4e00\u4e2a\u6620\u5c04\u5173\u7cfb\u3002Libuv\u5728Poll IO\u9636\u6bb5\u4f1a\u5904\u7406IO\u89c2\u5bdf\u8005\u961f\u5217\u3002","title":"2.4.2\u6ce8\u518c\u4e00\u4e2aIO\u89c2\u5bdf\u8005\u5230Libuv\u3002"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#243-io","text":"uv__io_stop\u4fee\u6539IO\u89c2\u5bdf\u8005\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff0c\u5982\u679c\u8fd8\u6709\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u7684\u8bdd\uff0cIO\u89c2\u5bdf\u8005\u8fd8\u4f1a\u5728\u961f\u5217\u91cc\uff0c\u5426\u5219\u79fb\u51fa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 1. void uv__io_stop ( uv_loop_t * loop , 2. uv__io_t * w , 3. unsigned int events ) { 4. if ( w -> fd == -1 ) 5. return ; 6. assert ( w -> fd >= 0 ); 7. if (( unsigned ) w -> fd >= loop -> nwatchers ) 8. return ; 9. // \u6e05\u9664\u4e4b\u524d\u6ce8\u518c\u7684\u4e8b\u4ef6\uff0c\u4fdd\u5b58\u5728pevents\u91cc\uff0c\u8868\u793a\u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6 10. w -> pevents &= ~ events ; 11. // \u5bf9\u6240\u6709\u4e8b\u4ef6\u90fd\u4e0d\u611f\u5174\u8da3\u4e86 12. if ( w -> pevents == 0 ) { 13. // \u79fb\u51faIO\u89c2\u5bdf\u8005\u961f\u5217 14. QUEUE_REMOVE ( & w -> watcher_queue ); 15. // \u91cd\u7f6e 16. QUEUE_INIT ( & w -> watcher_queue ); 17. // \u91cd\u7f6e 18. if ( loop -> watchers [ w -> fd ] != NULL ) { 19. assert ( loop -> watchers [ w -> fd ] == w ); 20. assert ( loop -> nfds > 0 ); 21. loop -> watchers [ w -> fd ] = NULL ; 22. loop -> nfds -- ; 23. w -> events = 0 ; 24. } 25. } 26. /* 27. \u4e4b\u524d\u8fd8\u6ca1\u6709\u63d2\u5165IO\u89c2\u5bdf\u8005\u961f\u5217\uff0c\u5219\u63d2\u5165\uff0c 28. \u7b49\u5230Poll IO\u65f6\u5904\u7406\uff0c\u5426\u5219\u4e0d\u9700\u8981\u5904\u7406 29. */ 30. else if ( QUEUE_EMPTY ( & w -> watcher_queue )) 31. QUEUE_INSERT_TAIL ( & loop -> watcher_queue , & w -> watcher_queue ); 32. }","title":"2.4.3 \u64a4\u9500IO\u89c2\u5bdf\u8005\u6216\u8005\u4e8b\u4ef6"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#25-libuv","text":"","title":"2.5 Libuv\u901a\u7528\u903b\u8f91"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#251-uv__handle_init","text":"uv__handle_init\u521d\u59cb\u5316handle\u7684\u7c7b\u578b\uff0c\u8bbe\u7f6eREF\u6807\u8bb0\uff0c\u63d2\u5165handle\u961f\u5217\u3002 1 2 3 4 5 6 7 8 9 1. # define uv__handle_init ( loop_ , h , type_ ) 2. do { 3. ( h ) -> loop = ( loop_ ); 4. ( h ) -> type = ( type_ ); 5. ( h ) -> flags = UV_HANDLE_REF ; 6. QUEUE_INSERT_TAIL ( & ( loop_ ) -> handle_queue , & ( h ) -> handle_queue ); 7. ( h ) -> next_closing = NULL 8. } 9. while ( 0 )","title":"2.5.1   uv__handle_init"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#252-uv__handle_start","text":"uv__handle_start\u8bbe\u7f6e\u6807\u8bb0handle\u4e3aACTIVE\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86REF\u6807\u8bb0\uff0c\u5219active handle\u7684\u4e2a\u6570\u52a0\u4e00\uff0cactive handle\u6570\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002 1 2 3 4 5 6 7 8 1. # define uv__handle_start ( h ) 2. do { 3. if ((( h ) -> flags & UV_HANDLE_ACTIVE ) != 0 ) break ; 4. ( h ) -> flags |= UV_HANDLE_ACTIVE ; 5. if ((( h ) -> flags & UV_HANDLE_REF ) != 0 ) 6. ( h ) -> loop -> active_handles ++ ; 7. } 8. while ( 0 )","title":"2.5.2.  uv__handle_start"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#253-uv__handle_stop","text":"uv__handle_stop\u548cuv__handle_start\u76f8\u53cd\u3002 1 2 3 4 5 6 7 1. # define uv__handle_stop ( h ) 2. do { 3. if ((( h ) -> flags & UV_HANDLE_ACTIVE ) == 0 ) break ; 4. ( h ) -> flags &= ~ UV_HANDLE_ACTIVE ; 5. if ((( h ) -> flags & UV_HANDLE_REF ) != 0 ) uv__active_handle_rm ( h ); 6. } 7. while ( 0 ) Libuv\u4e2dhandle\u6709REF\u548cACTIVE\u4e24\u4e2a\u72b6\u6001\u3002\u5f53\u4e00\u4e2ahandle\u8c03\u7528xxx_init\u51fd\u6570\u7684\u65f6\u5019\uff0c\u5b83\u9996\u5148\u88ab\u6253\u4e0aREF\u6807\u8bb0\uff0c\u5e76\u4e14\u63d2\u5165loop->handle\u961f\u5217\u3002\u5f53handle\u8c03\u7528xxx_start\u51fd\u6570\u7684\u65f6\u5019\uff0c\u5b83\u88ab\u6253\u4e0aACTIVE\u6807\u8bb0\uff0c\u5e76\u4e14\u8bb0\u5f55active handle\u7684\u4e2a\u6570\u52a0\u4e00\u3002\u53ea\u6709REF\u5e76\u4e14ACTIVE\u72b6\u6001\u7684handle\u624d\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002","title":"2.5.3.  uv__handle_stop"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#254-uv__req_init","text":"uv__req_init\u521d\u59cb\u5316\u8bf7\u6c42\u7684\u7c7b\u578b\uff0c\u8bb0\u5f55\u8bf7\u6c42\u7684\u4e2a\u6570\uff0c\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002 1 2 3 4 5 6 1. # define uv__req_init ( loop , req , typ ) 2. do { 3. ( req ) -> type = ( typ ); 4. ( loop ) -> active_reqs . count ++ ; 5. } 6. while ( 0 )","title":"2.5.4.  uv__req_init"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#255-uv__req_register","text":"\u8bf7\u6c42\u7684\u4e2a\u6570\u52a0\u4e00 1 2 3 4 5 1. # define uv__req_register ( loop , req ) 2. do { 3. ( loop ) -> active_reqs . count ++ ; 4. } 5. while ( 0 )","title":"2.5.5.  uv__req_register"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#256-uv__req_unregister","text":"\u8bf7\u6c42\u4e2a\u6570\u51cf\u4e00 1 2 3 4 5 6 1. # define uv__req_unregister ( loop , req ) 2. do { 3. assert ( uv__has_active_reqs ( loop )); 4. ( loop ) -> active_reqs . count -- ; 5. } 6. while ( 0 )","title":"2.5.6.  uv__req_unregister"},{"location":"chapter02-Libuv%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%9A%E7%94%A8%E9%80%BB%E8%BE%91/#257-uv__handle_ref","text":"uv__handle_ref\u6807\u8bb0handle\u4e3aREF\u72b6\u6001\uff0c\u5982\u679chandle\u662fACTIVE\u72b6\u6001\uff0c\u5219active handle\u6570\u52a0\u4e00 1 2 3 4 5 6 7 8 9 1. # define uv__handle_ref ( h ) 2. do { 3. if ((( h ) -> flags & UV_HANDLE_REF ) != 0 ) break ; 4. ( h ) -> flags |= UV_HANDLE_REF ; 5. if ((( h ) -> flags & UV_HANDLE_CLOSING ) != 0 ) break ; 6. if ((( h ) -> flags & UV_HANDLE_ACTIVE ) != 0 ) uv__active_handle_add ( h ); 7. } 8. while ( 0 ) 9. uv__handle_unref uv__handle_unref\u53bb\u6389handle\u7684REF\u72b6\u6001\uff0c\u5982\u679chandle\u662fACTIVE\u72b6\u6001\uff0c\u5219active handle\u6570\u51cf\u4e00 1 2 3 4 5 6 7 8 1. # define uv__handle_unref ( h ) 2. do { 3. if ((( h ) -> flags & UV_HANDLE_REF ) == 0 ) break ; 4. ( h ) -> flags &= ~ UV_HANDLE_REF ; 5. if ((( h ) -> flags & UV_HANDLE_CLOSING ) != 0 ) break ; 6. if ((( h ) -> flags & UV_HANDLE_ACTIVE ) != 0 ) uv__active_handle_rm ( h ); 7. } 8. while ( 0 )","title":"2.5.7.  uv__handle_ref"},{"location":"chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/","text":"\u7b2c\u4e09\u7ae0 \u4e8b\u4ef6\u5faa\u73af \u00b6 Node.js\u5c5e\u4e8e\u5355\u7ebf\u7a0b\u4e8b\u4ef6\u5faa\u73af\u67b6\u6784\uff0c\u8be5\u4e8b\u4ef6\u5faa\u73af\u7531Libuv\u7684uv_run\u51fd\u6570\u5b9e\u73b0\uff0c\u5728\u8be5\u51fd\u6570\u4e2d\u6267\u884cwhile\u5faa\u73af\uff0c\u7136\u540e\u4e0d\u65ad\u5730\u5904\u7406\u5404\u4e2a\u9636\u6bb5\uff08phase\uff09\u7684\u4e8b\u4ef6\u56de\u8c03\u3002\u4e8b\u4ef6\u5faa\u73af\u7684\u5904\u7406\u76f8\u5f53\u4e8e\u4e00\u4e2a\u6d88\u8d39\u8005\uff0c\u6d88\u8d39\u7531\u5404\u79cd\u4ee3\u7801\u4ea7\u751f\u7684\u4efb\u52a1\u3002Node.js\u521d\u59cb\u5316\u5b8c\u6210\u540e\u5c31\u5f00\u59cb\u9677\u5165\u8be5\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u4e8b\u4ef6\u5faa\u73af\u7684\u7ed3\u675f\u4e5f\u5c31\u610f\u5473\u7740Node.js\u7684\u7ed3\u675f\u3002\u4e0b\u9762\u770b\u4e00\u4e0b\u4e8b\u4ef6\u5faa\u73af\u7684\u6838\u5fc3\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 int uv_run ( uv_loop_t * loop , uv_run_mode mode ) { int timeout ; int r ; int ran_pending ; // \u5728uv_run\u4e4b\u524d\u8981\u5148\u63d0\u4ea4\u4efb\u52a1\u5230loop r = uv__loop_alive ( loop ); // \u4e8b\u4ef6\u5faa\u73af\u6ca1\u6709\u4efb\u52a1\u6267\u884c\uff0c\u5373\u5c06\u9000\u51fa\uff0c\u8bbe\u7f6e\u4e00\u4e0b\u5f53\u524d\u5faa\u73af\u7684\u65f6\u95f4 if ( ! r ) uv__update_time ( loop ); // \u6ca1\u6709\u4efb\u52a1\u9700\u8981\u5904\u7406\u6216\u8005\u8c03\u7528\u4e86uv_stop\u5219\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af while ( r != 0 && loop -> stop_flag == 0 ) { // \u66f4\u65b0loop\u7684time\u5b57\u6bb5 uv__update_time ( loop ); // \u6267\u884c\u8d85\u65f6\u56de\u8c03 uv__run_timers ( loop ); /* \u6267\u884cpending\u56de\u8c03\uff0cran_pending\u4ee3\u8868pending\u961f\u5217\u662f\u5426\u4e3a\u7a7a\uff0c \u5373\u6ca1\u6709\u8282\u70b9\u53ef\u4ee5\u6267\u884c */ ran_pending = uv__run_pending ( loop ); // \u7ee7\u7eed\u6267\u884c\u5404\u79cd\u961f\u5217 uv__run_idle ( loop ); uv__run_prepare ( loop ); timeout = 0 ; /* \u6267\u884c\u6a21\u5f0f\u662fUV_RUN_ONCE\u65f6\uff0c\u5982\u679c\u6ca1\u6709pending\u8282\u70b9\uff0c \u624d\u4f1a\u963b\u585e\u5f0fPoll IO\uff0c\u9ed8\u8ba4\u6a21\u5f0f\u4e5f\u662f */ if (( mode == UV_RUN_ONCE && ! ran_pending ) || mode == UV_RUN_DEFAULT ) timeout = uv_backend_timeout ( loop ); // Poll IO timeout\u662fepoll_wait\u7684\u8d85\u65f6\u65f6\u95f4 uv__io_poll ( loop , timeout ); // \u5904\u7406check\u9636\u6bb5 uv__run_check ( loop ); // \u5904\u7406close\u9636\u6bb5 uv__run_closing_handles ( loop ); /* \u8fd8\u6709\u4e00\u6b21\u6267\u884c\u8d85\u65f6\u56de\u8c03\u7684\u673a\u4f1a\uff0c\u56e0\u4e3auv__io_poll\u53ef\u80fd\u662f\u56e0\u4e3a \u5b9a\u65f6\u5668\u8d85\u65f6\u8fd4\u56de\u7684\u3002 */ if ( mode == UV_RUN_ONCE ) { uv__update_time ( loop ); uv__run_timers ( loop ); } r = uv__loop_alive ( loop ); /* \u53ea\u6267\u884c\u4e00\u6b21\uff0c\u9000\u51fa\u5faa\u73af,UV_RUN_NOWAIT\u8868\u793a\u5728Poll IO\u9636\u6bb5 \u4e0d\u4f1a\u963b\u585e\u5e76\u4e14\u5faa\u73af\u53ea\u6267\u884c\u4e00\u6b21 */ if ( mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT ) break ; } // \u662f\u56e0\u4e3a\u8c03\u7528\u4e86uv_stop\u9000\u51fa\u7684\uff0c\u91cd\u7f6eflag if ( loop -> stop_flag != 0 ) loop -> stop_flag = 0 ; /* \u8fd4\u56de\u662f\u5426\u8fd8\u6709\u6d3b\u8dc3\u7684\u4efb\u52a1\uff08handle\u6216request\uff09\uff0c \u4e1a\u52a1\u4ee3\u8868\u53ef\u4ee5\u518d\u6b21\u6267\u884cuv_run */ return r ; } Libuv\u5206\u4e3a\u51e0\u4e2a\u9636\u6bb5\uff0c\u4e0b\u9762\u4ece\u5148\u5230\u540e\uff0c\u5206\u522b\u5206\u6790\u5404\u4e2a\u9636\u6bb5\u7684\u76f8\u5173\u4ee3\u7801\u3002 3.1 \u4e8b\u4ef6\u5faa\u73af\u4e4b\u5b9a\u65f6\u5668 \u00b6 Libuv\u4e2d\uff0c\u5b9a\u65f6\u5668\u9636\u6bb5\u662f\u7b2c\u4e00\u4e2a\u88ab\u5904\u7406\u7684\u9636\u6bb5\u3002\u5b9a\u65f6\u5668\u662f\u4ee5\u6700\u5c0f\u5806\u5b9e\u73b0\u7684\uff0c\u6700\u5feb\u8fc7\u671f\u7684\u8282\u70b9\u662f\u6839\u8282\u70b9\u3002Libuv\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\u90fd\u4f1a\u7f13\u5b58\u5f53\u524d\u7684\u65f6\u95f4\uff0c\u5728\u6bcf\u4e00\u8f6e\u7684\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u4f7f\u7528\u7684\u90fd\u662f\u8fd9\u4e2a\u7f13\u5b58\u7684\u65f6\u95f4\uff0c\u5fc5\u8981\u7684\u65f6\u5019Libuv\u4f1a\u663e\u5f0f\u66f4\u65b0\u8fd9\u4e2a\u65f6\u95f4\uff0c\u56e0\u4e3a\u83b7\u53d6\u65f6\u95f4\u9700\u8981\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\u63a5\u53e3\uff0c\u800c\u9891\u7e41\u8c03\u7528\u7cfb\u7edf\u8c03\u7528\u4f1a\u5e26\u6765\u4e00\u5b9a\u7684\u8017\u65f6\uff0c\u7f13\u5b58\u65f6\u95f4\u53ef\u4ee5\u51cf\u5c11\u64cd\u4f5c\u7cfb\u7edf\u7684\u8c03\u7528\uff0c\u63d0\u9ad8\u6027\u80fd\u3002Libuv\u7f13\u5b58\u4e86\u5f53\u524d\u6700\u65b0\u7684\u65f6\u95f4\u540e\uff0c\u5c31\u6267\u884cuv__run_timers\uff0c\u8be5\u51fd\u6570\u5c31\u662f\u904d\u5386\u6700\u5c0f\u5806\uff0c\u627e\u51fa\u5f53\u524d\u8d85\u65f6\u7684\u8282\u70b9\u3002\u56e0\u4e3a\u5806\u7684\u6027\u8d28\u662f\u7236\u8282\u70b9\u80af\u5b9a\u6bd4\u5b69\u5b50\u5c0f\u3002\u5e76\u4e14\u6839\u8282\u70b9\u662f\u6700\u5c0f\u7684\uff0c\u6240\u4ee5\u5982\u679c\u4e00\u4e2a\u6839\u8282\u70b9\uff0c\u5b83\u6ca1\u6709\u8d85\u65f6\uff0c\u5219\u540e\u9762\u7684\u8282\u70b9\u4e5f\u4e0d\u4f1a\u8d85\u65f6\u3002\u5bf9\u4e8e\u8d85\u65f6\u7684\u8282\u70b9\u5c31\u6267\u884c\u5b83\u7684\u56de\u8c03\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void uv__run_timers ( uv_loop_t * loop ) { struct heap_node * heap_node ; uv_timer_t * handle ; // \u904d\u5386\u4e8c\u53c9\u5806 for (;;) { // \u627e\u51fa\u6700\u5c0f\u7684\u8282\u70b9 heap_node = heap_min ( timer_heap ( loop )); // \u6ca1\u6709\u5219\u9000\u51fa if ( heap_node == NULL ) break ; // \u901a\u8fc7\u7ed3\u6784\u4f53\u5b57\u6bb5\u627e\u5230\u7ed3\u6784\u4f53\u9996\u5730\u5740 handle = container_of ( heap_node , uv_timer_t , heap_node ); // \u6700\u5c0f\u7684\u8282\u70b9\u90fd\u6ca1\u6709\u8d85\u5e02\uff0c\u5219\u540e\u9762\u7684\u8282\u70b9\u4e5f\u4e0d\u4f1a\u8d85\u65f6 if ( handle -> timeout > loop -> time ) break ; // \u5220\u9664\u8be5\u8282\u70b9 uv_timer_stop ( handle ); /* \u91cd\u8bd5\u63d2\u5165\u4e8c\u53c9\u5806\uff0c\u5982\u679c\u9700\u8981\u7684\u8bdd\uff08\u8bbe\u7f6e\u4e86repeat\uff0c\u6bd4\u5982 setInterval\uff09 */ uv_timer_again ( handle ); // \u6267\u884c\u56de\u8c03 handle -> timer_cb ( handle ); } } \u6267\u884c\u5b8c\u56de\u8c03\u540e\uff0c\u8fd8\u6709\u4e24\u4e2a\u5173\u952e\u7684\u64cd\u4f5c\uff0c\u7b2c\u4e00\u5c31\u662fstop\uff0c\u7b2c\u4e8c\u5c31\u662fagain\u3002stop\u7684\u903b\u8f91\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u628ahandle\u4ece\u4e8c\u53c9\u5806\u4e2d\u5220\u9664\uff0c\u5e76\u4e14\u4fee\u6539handle\u7684\u72b6\u6001\u3002\u90a3\u4e48again\u53c8\u662f\u4ec0\u4e48\u5462\uff1fagain\u662f\u4e3a\u4e86\u652f\u6301setInterval\u8fd9\u79cd\u573a\u666f\uff0c\u5982\u679chandle\u8bbe\u7f6e\u4e86repeat\u6807\u8bb0\uff0c\u5219\u8be5handle\u5728\u8d85\u65f6\u540e\uff0c\u6bcfrepeat\u7684\u65f6\u95f4\u540e\uff0c\u5c31\u4f1a\u7ee7\u7eed\u6267\u884c\u8d85\u65f6\u56de\u8c03\u3002\u5bf9\u4e8esetInterval\uff0c\u5c31\u662f\u8d85\u65f6\u65f6\u95f4\u662fx\uff0c\u6bcfx\u7684\u65f6\u95f4\u540e\uff0c\u6267\u884c\u56de\u8c03\u3002\u8fd9\u5c31\u662fNode.js\u91cc\u5b9a\u65f6\u5668\u7684\u5e95\u5c42\u539f\u7406\u3002\u4f46Node.js\u4e0d\u662f\u6bcf\u6b21\u8c03setTimeout/setInterval\u7684\u65f6\u5019\u90fd\u5f80\u6700\u5c0f\u5806\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0cNode.js\u91cc\uff0c\u53ea\u6709\u4e00\u4e2a\u5173\u4e8euv_timer_s\u7684handle\uff0c\u5b83\u5728JS\u5c42\u7ef4\u62a4\u4e86\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\uff0c\u6bcf\u6b21\u8ba1\u7b97\u51fa\u6700\u65e9\u5230\u671f\u7684\u8282\u70b9\uff0c\u7136\u540e\u4fee\u6539handle\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u5177\u4f53\u5728\u5b9a\u65f6\u5668\u7ae0\u8282\u8bb2\u89e3\u3002 \u53e6\u5916timer\u9636\u6bb5\u548cPoll IO\u9636\u6bb5\u4e5f\u6709\u4e00\u4e9b\u8054\u7cfb\uff0c\u56e0\u4e3aPoll IO\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4e3b\u7ebf\u7a0b\u963b\u585e\uff0c\u4e3a\u4e86\u4fdd\u8bc1\u4e3b\u7ebf\u7a0b\u53ef\u4ee5\u5c3d\u5feb\u6267\u884c\u5b9a\u65f6\u5668\u7684\u56de\u8c03\uff0cPoll IO\u4e0d\u80fd\u4e00\u76f4\u963b\u585e\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\uff0c\u963b\u585e\u7684\u65f6\u957f\u5c31\u662f\u6700\u5feb\u5230\u671f\u7684\u5b9a\u65f6\u5668\u8282\u70b9\u7684\u65f6\u957f\uff08\u5177\u4f53\u53ef\u53c2\u8003libuv core.c\u4e2d\u7684uv_backend_timeout\u51fd\u6570\uff09\u3002 3.2 pending\u9636\u6bb5 \u00b6 \u5b98\u7f51\u5bf9pending\u9636\u6bb5\u7684\u89e3\u91ca\u662f\u5728\u4e0a\u4e00\u8f6e\u7684Poll IO\u9636\u6bb5\u6ca1\u6709\u6267\u884c\u7684IO\u56de\u8c03\uff0c\u4f1a\u5728\u4e0b\u4e00\u8f6e\u5faa\u73af\u7684pending\u9636\u6bb5\u88ab\u6267\u884c\u3002\u4ece\u6e90\u7801\u6765\u770b\uff0cPoll IO\u9636\u6bb5\u5904\u7406\u4efb\u52a1\u65f6\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u5f53\u524d\u6267\u884c\u7684\u64cd\u4f5c\u5931\u8d25\u9700\u8981\u6267\u884c\u56de\u8c03\u901a\u77e5\u8c03\u7528\u65b9\u4e00\u4e9b\u4fe1\u606f\uff0c\u8be5\u56de\u8c03\u51fd\u6570\u4e0d\u4f1a\u7acb\u523b\u6267\u884c\uff0c\u800c\u662f\u5728\u4e0b\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u7684pending\u9636\u6bb5\u6267\u884c\uff08\u6bd4\u5982\u5199\u5165\u6570\u636e\u6210\u529f\uff0c\u6216\u8005TCP\u8fde\u63a5\u5931\u8d25\u65f6\u56de\u8c03C++\u5c42\uff09\uff0c\u6211\u4eec\u5148\u770bpending\u9636\u6bb5\u7684\u5904\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 static int uv__run_pending ( uv_loop_t * loop ) { QUEUE * q ; QUEUE pq ; uv__io_t * w ; if ( QUEUE_EMPTY ( & loop -> pending_queue )) return 0 ; // \u628apending_queue\u961f\u5217\u7684\u8282\u70b9\u79fb\u5230pq\uff0c\u5373\u6e05\u7a7a\u4e86pending_queue QUEUE_MOVE ( & loop -> pending_queue , & pq ); // \u904d\u5386pq\u961f\u5217 while ( ! QUEUE_EMPTY ( & pq )) { // \u53d6\u51fa\u5f53\u524d\u7b2c\u4e00\u4e2a\u9700\u8981\u5904\u7406\u7684\u8282\u70b9\uff0c\u5373pq.next q = QUEUE_HEAD ( & pq ); // \u628a\u5f53\u524d\u9700\u8981\u5904\u7406\u7684\u8282\u70b9\u79fb\u51fa\u961f\u5217 QUEUE_REMOVE ( q ); /* \u91cd\u7f6e\u4e00\u4e0bprev\u548cnext\u6307\u9488\uff0c\u56e0\u4e3a\u8fd9\u65f6\u5019\u8fd9\u4e24\u4e2a\u6307\u9488\u662f \u6307\u5411\u961f\u5217\u4e2d\u7684\u4e24\u4e2a\u8282\u70b9 */ QUEUE_INIT ( q ); w = QUEUE_DATA ( q , uv__io_t , pending_queue ); w -> cb ( loop , w , POLLOUT ); } return 1 ; } pending\u9636\u6bb5\u7684\u5904\u7406\u903b\u8f91\u5c31\u662f\u628apending\u961f\u5217\u91cc\u7684\u8282\u70b9\u9010\u4e2a\u6267\u884c\u3002\u6211\u4eec\u770b\u4e00\u4e0bpending\u961f\u5217\u7684\u8282\u70b9\u662f\u5982\u4f55\u751f\u4ea7\u51fa\u6765\u7684\u3002 1 2 3 4 void uv__io_feed ( uv_loop_t * loop , uv__io_t * w ) { if ( QUEUE_EMPTY ( & w -> pending_queue )) QUEUE_INSERT_TAIL ( & loop -> pending_queue , & w -> pending_queue ); } Libuv\u901a\u8fc7uv__io_feed\u51fd\u6570\u751f\u4ea7pending\u4efb\u52a1\uff0c\u4eceLibuv\u7684\u4ee3\u7801\u4e2d\u6211\u4eec\u770b\u5230IO\u9519\u8bef\u7684\u65f6\u5019\u4f1a\u8c03\u8fd9\u4e2a\u51fd\u6570\uff08\u5982tcp.c\u7684uv__tcp_connect\u51fd\u6570\uff09\u3002 1 2 if ( handle -> delayed_error ) uv__io_feed ( handle -> loop , & handle -> io_watcher ); \u5728\u5199\u5165\u6570\u636e\u6210\u529f\u540e\uff08\u6bd4\u5982TCP\u3001UDP\uff09\uff0c\u4e5f\u4f1a\u5f80pending\u961f\u5217\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u7b49\u5f85\u56de\u8c03\u3002\u6bd4\u5982\u53d1\u9001\u6570\u636e\u6210\u529f\u540e\u6267\u884c\u7684\u4ee3\u7801\uff08udp.c\u7684uv__udp_sendmsg\u51fd\u6570\uff09 1 2 3 4 5 6 7 8 9 // \u53d1\u9001\u5b8c\u79fb\u51fa\u5199\u961f\u5217 QUEUE_REMOVE ( & req -> queue ); // \u52a0\u5165\u5199\u5b8c\u6210\u961f\u5217 QUEUE_INSERT_TAIL ( & handle -> write_completed_queue , & req -> queue ); /* \u6709\u8282\u70b9\u6570\u636e\u5199\u5b8c\u4e86\uff0c\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0c pending\u9636\u6bb5\u6267\u884c\u56de\u8c03 */ uv__io_feed ( handle -> loop , & handle -> io_watcher ); \u6700\u540e\u5173\u95edIO\u7684\u65f6\u5019\uff08\u5982\u5173\u95ed\u4e00\u4e2aTCP\u8fde\u63a5\uff09\u4f1a\u4ecepending\u961f\u5217\u79fb\u9664\u5bf9\u5e94\u7684\u8282\u70b9\uff0c\u56e0\u4e3a\u5df2\u7ecf\u5173\u95ed\u4e86\uff0c\u81ea\u7136\u5c31\u4e0d\u9700\u8981\u6267\u884c\u56de\u8c03\u3002 1 2 3 4 5 6 void uv__io_close ( uv_loop_t * loop , uv__io_t * w ) { uv__io_stop ( loop , w , POLLIN | POLLOUT | UV__POLLRDHUP | UV__POLLPRI ); QUEUE_REMOVE ( & w -> pending_queue ); } 3.3 \u4e8b\u4ef6\u5faa\u73af\u4e4bprepare,check,idle \u00b6 prepare,check,idle\u662fLibuv\u4e8b\u4ef6\u5faa\u73af\u4e2d\u5c5e\u4e8e\u6bd4\u8f83\u7b80\u5355\u7684\u4e00\u4e2a\u9636\u6bb5\uff0c\u5b83\u4eec\u7684\u5b9e\u73b0\u662f\u4e00\u6837\u7684\uff08\u89c1loop-watcher.c\uff09\u3002\u672c\u8282\u53ea\u8bb2\u89e3prepare\u9636\u6bb5\uff0c\u6211\u4eec\u77e5\u9053Libuv\u4e2d\u5206\u4e3ahandle\u548crequest\uff0c\u800cprepare\u9636\u6bb5\u7684\u4efb\u52a1\u662f\u5c5e\u4e8ehandle\u7c7b\u578b\u3002\u8fd9\u610f\u5473\u7740\u9664\u975e\u6211\u4eec\u663e\u5f0f\u79fb\u9664\uff0c\u5426\u5219prepare\u9636\u6bb5\u7684\u8282\u70b9\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u4e2d\u90fd\u4f1a\u88ab\u6267\u884c\u3002\u4e0b\u9762\u6211\u4eec\u5148\u770b\u770b\u600e\u4e48\u4f7f\u7528\u5b83\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void prep_cb ( uv_prepare_t * handle ) { printf ( \"Prep callback \\n \" ); } int main () { uv_prepare_t prep ; // \u521d\u59cb\u5316\u4e00\u4e2ahandle\uff0cuv_default_loop\u662f\u4e8b\u4ef6\u5faa\u73af\u7684\u6838\u5fc3\u7ed3\u6784\u4f53 uv_prepare_init ( uv_default_loop (), & prep ); // \u6ce8\u518chandle\u7684\u56de\u8c03 uv_prepare_start ( & prep , prep_cb ); // \u5f00\u59cb\u4e8b\u4ef6\u5faa\u73af uv_run ( uv_default_loop (), UV_RUN_DEFAULT ); return 0 ; } \u6267\u884cmain\u51fd\u6570\uff0cLibuv\u5c31\u4f1a\u5728prepare\u9636\u6bb5\u6267\u884c\u56de\u8c03prep_cb\u3002\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u8fd9\u4e2a\u8fc7\u7a0b\u3002 1 2 3 4 5 int uv_prepare_init ( uv_loop_t * loop , uv_prepare_t * handle ) { uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_PREPARE ); handle -> prepare_cb = NULL ; return 0 ; } init\u51fd\u6570\u4e3b\u8981\u662f\u505a\u4e00\u4e9b\u521d\u59cb\u5316\u64cd\u4f5c\u3002\u6211\u4eec\u7ee7\u7eed\u8981\u770bstart\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 int uv_prepare_start ( uv_prepare_t * handle , uv_prepare_cb cb ) { // \u5982\u679c\u5df2\u7ecf\u6267\u884c\u8fc7start\u51fd\u6570\u5219\u76f4\u63a5\u8fd4\u56de if ( uv__is_active ( handle )) return 0 ; if ( cb == NULL ) return UV_EINVAL ; QUEUE_INSERT_HEAD ( & handle -> loop -> prepare_handles , & handle -> queue ); handle -> prepare_cb = cb ; uv__handle_start ( handle ); return 0 ; } uv_prepare_start\u51fd\u6570\u4e3b\u8981\u7684\u903b\u8f91\u4e3b\u8981\u662f\u8bbe\u7f6e\u56de\u8c03\uff0c\u628ahandle\u63d2\u5165loop\u7684prepare_handles\u961f\u5217\uff0cprepare_handles\u961f\u5217\u4fdd\u5b58\u4e86prepare\u9636\u6bb5\u7684\u4efb\u52a1\u3002\u5728\u4e8b\u4ef6\u5faa\u73af\u7684prepare\u9636\u6bb5\u4f1a\u9010\u4e2a\u6267\u884c\u91cc\u9762\u7684\u8282\u70b9\u7684\u56de\u8c03\u3002\u7136\u540e\u6211\u4eec\u770b\u770bLibuv\u5728\u4e8b\u4ef6\u5faa\u73af\u7684prepare\u9636\u6bb5\u662f\u5982\u4f55\u5904\u7406\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void uv__run_prepare ( uv_loop_t * loop ) { uv_prepare_t * h ; QUEUE queue ; QUEUE * q ; /* \u628a\u8be5\u7c7b\u578b\u5bf9\u5e94\u7684\u961f\u5217\u4e2d\u6240\u6709\u8282\u70b9\u6458\u4e0b\u6765\u6302\u8f7d\u5230queue\u53d8\u91cf\uff0c \u76f8\u5f53\u4e8e\u6e05\u7a7aprepare_handles\u961f\u5217\uff0c\u56e0\u4e3a\u5982\u679c\u76f4\u63a5\u904d\u5386 prepare_handles\u961f\u5217\uff0c\u5728\u6267\u884c\u56de\u8c03\u7684\u65f6\u5019\u4e00\u76f4\u5f80prepare_handles \u961f\u5217\u52a0\u8282\u70b9\uff0c\u4f1a\u5bfc\u81f4\u4e0b\u9762\u7684while\u5faa\u73af\u65e0\u6cd5\u9000\u51fa\u3002 \u5148\u79fb\u9664\u7684\u8bdd\uff0c\u65b0\u63d2\u5165\u7684\u8282\u70b9\u5728\u4e0b\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u624d\u4f1a\u88ab\u5904\u7406\u3002 */ QUEUE_MOVE ( & loop -> prepare_handles , & queue ); // \u904d\u5386\u961f\u5217\uff0c\u6267\u884c\u6bcf\u4e2a\u8282\u70b9\u91cc\u9762\u7684\u51fd\u6570 while ( ! QUEUE_EMPTY ( & queue )) { // \u53d6\u4e0b\u5f53\u524d\u5f85\u5904\u7406\u7684\u8282\u70b9\uff0c\u5373\u961f\u5217\u7684\u5934 q = QUEUE_HEAD ( & queue ); /* \u53d6\u5f97\u8be5\u8282\u70b9\u5bf9\u5e94\u7684\u6574\u4e2a\u7ed3\u6784\u4f53\u7684\u57fa\u5730\u5740\uff0c \u5373\u901a\u8fc7\u7ed3\u6784\u4f53\u6210\u5458\u53d6\u5f97\u7ed3\u6784\u4f53\u9996\u5730\u5740 */ h = QUEUE_DATA ( q , uv_prepare_t , queue ); // \u628a\u8be5\u8282\u70b9\u79fb\u51fa\u5f53\u524d\u961f\u5217 QUEUE_REMOVE ( q ); // \u91cd\u65b0\u63d2\u5165\u539f\u6765\u7684\u961f\u5217 QUEUE_INSERT_TAIL ( & loop -> prepare_handles , q ); // \u6267\u884c\u56de\u8c03\u51fd\u6570 h -> prepare_cb ( h ); } } uv__run_prepare\u51fd\u6570\u7684\u903b\u8f91\u5f88\u7b80\u5355\uff0c\u4f46\u662f\u6709\u4e00\u4e2a\u91cd\u70b9\u7684\u5730\u65b9\u5c31\u662f\u6267\u884c\u5b8c\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0cLibuv\u4f1a\u628a\u8be5\u8282\u70b9\u91cd\u65b0\u63d2\u5165\u961f\u5217\u4e2d\uff0c\u6240\u4ee5prepare\uff08\u5305\u62ecidle\u3001check\uff09\u9636\u6bb5\u7684\u8282\u70b9\u5728\u6bcf\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e2d\u90fd\u4f1a\u88ab\u6267\u884c\u3002\u800c\u50cf\u5b9a\u65f6\u5668\u3001pending\u3001closing\u9636\u6bb5\u7684\u8282\u70b9\u662f\u4e00\u6b21\u6027\u7684\uff0c\u88ab\u6267\u884c\u540e\u5c31\u4f1a\u4ece\u961f\u5217\u91cc\u5220\u9664\u3002 \u6211\u4eec\u56de\u987e\u4e00\u5f00\u59cb\u7684\u6d4b\u8bd5\u4ee3\u7801\u3002\u56e0\u4e3a\u5b83\u8bbe\u7f6e\u4e86Libuv\u7684\u8fd0\u884c\u6a21\u5f0f\u662f\u9ed8\u8ba4\u6a21\u5f0f\u3002\u800cprepare\u961f\u5217\u53c8\u4e00\u76f4\u6709\u4e00\u4e2ahandle\u8282\u70b9\uff0c\u6240\u4ee5\u5b83\u662f\u4e0d\u4f1a\u9000\u51fa\u7684\u3002\u5b83\u4f1a\u4e00\u76f4\u6267\u884c\u56de\u8c03\u3002\u90a3\u5982\u679c\u6211\u4eec\u8981\u9000\u51fa\u600e\u4e48\u529e\u5462\uff1f\u6216\u8005\u8bf4\u4e0d\u8981\u6267\u884cprepare\u961f\u5217\u7684\u67d0\u4e2a\u8282\u70b9\u4e86\u3002\u6211\u4eec\u53ea\u9700\u8981stop\u4e00\u4e0b\u5c31\u53ef\u4ee5\u4e86\u3002 1 2 3 4 5 6 7 8 int uv_prepare_stop ( uv_prepare_t * handle ) { if ( ! uv__is_active ( handle )) return 0 ; // \u628ahandle\u4eceprepare\u961f\u5217\u4e2d\u79fb\u9664\uff0c\u4f46\u8fd8\u6302\u8f7d\u5230handle_queue\u4e2d QUEUE_REMOVE ( & handle -> queue ); // \u6e05\u9664active\u6807\u8bb0\u4f4d\u5e76\u4e14\u51cf\u53bbloop\u4e2dhandle\u7684active\u6570 uv__handle_stop ( handle ); return 0 ; } stop\u51fd\u6570\u548cstart\u51fd\u6570\u662f\u76f8\u53cd\u7684\u4f5c\u7528\uff0c\u8fd9\u5c31\u662fNode.js\u4e2dprepare\u3001check\u3001idle\u9636\u6bb5\u7684\u539f\u7406\u3002 3.4 \u4e8b\u4ef6\u5faa\u73af\u4e4bPoll IO \u00b6 Poll IO\u662fLibuv\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2a\u9636\u6bb5\uff0c\u6587\u4ef6IO\u3001\u7f51\u7edcIO\u3001\u4fe1\u53f7\u5904\u7406\u7b49\u90fd\u5728\u8fd9\u4e2a\u9636\u6bb5\u5904\u7406\uff0c\u8fd9\u4e5f\u662f\u6700\u590d\u6742\u7684\u4e00\u4e2a\u9636\u6bb5\u3002\u5904\u7406\u903b\u8f91\u5728core.c\u7684uv__io_poll\u8fd9\u4e2a\u51fd\u6570\uff0c\u8fd9\u4e2a\u51fd\u6570\u6bd4\u8f83\u590d\u6742\uff0c\u6211\u4eec\u5206\u5f00\u5206\u6790\u3002\u5728\u5f00\u59cb\u5206\u6790Poll IO\u4e4b\u524d\uff0c\u5148\u4e86\u89e3\u4e00\u4e0b\u5b83\u76f8\u5173\u7684\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u3002 1 IO\u89c2\u5bdf\u8005uv__io_t\u3002\u8fd9\u4e2a\u7ed3\u6784\u4f53\u662fPoll IO\u9636\u6bb5\u6838\u5fc3\u7ed3\u6784\u4f53\u3002\u5b83\u4e3b\u8981\u662f\u4fdd\u5b58\u4e86IO\u76f8\u5173\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u56de \u8c03\u3001\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u7b49\u4fe1\u606f\u3002 2 watcher_queue\u89c2\u5bdf\u8005\u961f\u5217\u3002\u6240\u6709\u9700\u8981Libuv\u5904\u7406\u7684IO\u89c2\u5bdf\u8005\u90fd\u6302\u8f7d\u5728\u8fd9\u4e2a\u961f\u5217\u91cc\uff0cLibuv\u5728Poll IO\u9636\u6bb5\u4f1a\u9010\u4e2a\u5904\u7406\u3002 \u4e0b\u9762\u6211\u4eec\u5f00\u59cb\u5206\u6790Poll IO\u9636\u6bb5\u3002\u5148\u770b\u7b2c\u4e00\u6bb5\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // \u6ca1\u6709IO\u89c2\u5bdf\u8005\uff0c\u5219\u76f4\u63a5\u8fd4\u56de if ( loop -> nfds == 0 ) { assert ( QUEUE_EMPTY ( & loop -> watcher_queue )); return ; } // \u904d\u5386IO\u89c2\u5bdf\u8005\u961f\u5217 while ( ! QUEUE_EMPTY ( & loop -> watcher_queue )) { // \u53d6\u51fa\u5f53\u524d\u5934\u8282\u70b9 q = QUEUE_HEAD ( & loop -> watcher_queue ); // \u8131\u79bb\u961f\u5217 QUEUE_REMOVE ( q ); // \u521d\u59cb\u5316\uff08\u91cd\u7f6e\uff09\u8282\u70b9\u7684\u524d\u540e\u6307\u9488 QUEUE_INIT ( q ); // \u901a\u8fc7\u7ed3\u6784\u4f53\u6210\u529f\u83b7\u53d6\u7ed3\u6784\u4f53\u9996\u5730\u5740 w = QUEUE_DATA ( q , uv__io_t , watcher_queue ); // \u8bbe\u7f6e\u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6 e . events = w -> pevents ; /* \u8fd9\u91cc\u4f7f\u7528\u4e86fd\u5b57\u6bb5\uff0c\u4e8b\u4ef6\u89e6\u53d1\u540e\u518d\u901a\u8fc7fd\u4ecewatchs \u5b57\u6bb5\u91cc\u627e\u5230\u5bf9\u5e94\u7684IO\u89c2\u5bdf\u8005\uff0c\u6ca1\u6709\u4f7f\u7528ptr\u6307\u5411IO\u89c2\u5bdf\u8005\u7684\u65b9\u6848 */ e . data . fd = w -> fd ; // \u5982\u679cw->events\u521d\u59cb\u5316\u7684\u65f6\u5019\u4e3a0\uff0c\u5219\u65b0\u589e\uff0c\u5426\u5219\u4fee\u6539 if ( w -> events == 0 ) op = EPOLL_CTL_ADD ; else op = EPOLL_CTL_MOD ; // \u4fee\u6539epoll\u7684\u6570\u636e epoll_ctl ( loop -> backend_fd , op , w -> fd , & e ) // \u8bb0\u5f55\u5f53\u524d\u52a0\u5230epoll\u65f6\u7684\u72b6\u6001 w -> events = w -> pevents ; } \u7b2c\u4e00\u6b65\u9996\u5148\u904d\u5386IO\u89c2\u5bdf\u8005\uff0c\u4fee\u6539epoll\u7684\u6570\u636e\u3002\u7136\u540e\u51c6\u5907\u8fdb\u5165\u7b49\u5f85\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 psigset = NULL ; if ( loop -> flags & UV_LOOP_BLOCK_SIGPROF ) { sigemptyset ( & sigset ); sigaddset ( & sigset , SIGPROF ); psigset = & sigset ; } /* http://man7.org/Linux/man-pages/man2/epoll_wait.2.html pthread_sigmask(SIG_SETMASK, &sigmask, &origmask); ready = epoll_wait(epfd, &events, maxevents, timeout); pthread_sigmask(SIG_SETMASK, &origmask, NULL); \u5373\u5c4f\u853dSIGPROF\u4fe1\u53f7\uff0c\u907f\u514dSIGPROF\u4fe1\u53f7\u5524\u9192epoll_wait\uff0c\u4f46\u662f\u5374\u6ca1 \u6709\u5c31\u7eea\u7684\u4e8b\u4ef6 */ nfds = epoll_pwait ( loop -> backend_fd , events , ARRAY_SIZE ( events ), timeout , psigset ); // epoll\u53ef\u80fd\u963b\u585e\uff0c\u8fd9\u91cc\u9700\u8981\u66f4\u65b0\u4e8b\u4ef6\u5faa\u73af\u7684\u65f6\u95f4 uv__update_time ( loop ) ``` epoll_wait\u53ef\u80fd\u4f1a\u5f15\u8d77\u4e3b\u7ebf\u7a0b\u963b\u585e\uff0c\u6240\u4ee5wait\u8fd4\u56de\u540e\u9700\u8981\u66f4\u65b0\u5f53\u524d\u7684\u65f6\u95f4\uff0c\u5426\u5219\u5728\u4f7f\u7528\u7684\u65f6\u5019\u65f6\u95f4\u5dee\u4f1a\u6bd4\u8f83\u5927\uff0c\u56e0\u4e3aLibuv\u4f1a\u5728\u6bcf\u8f6e\u65f6\u95f4\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\u7f13\u5b58\u5f53\u524d\u65f6\u95f4\u8fd9\u4e2a\u503c\u3002\u5176\u5b83\u5730\u65b9\u76f4\u63a5\u4f7f\u7528\uff0c\u800c\u4e0d\u662f\u6bcf\u6b21\u90fd\u53bb\u83b7\u53d6\u3002\u4e0b\u9762\u6211\u4eec\u63a5\u7740\u770bepoll\u8fd4\u56de\u540e\u7684\u5904\u7406\uff08\u5047\u8bbe\u6709\u4e8b\u4ef6\u89e6\u53d1\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // \u4fdd\u5b58epoll_wait\u8fd4\u56de\u7684\u4e00\u4e9b\u6570\u636e\uff0cmaybe_resize\u7533\u8bf7\u7a7a\u95f4\u7684\u65f6\u5019+2\u4e86 loop -> watchers [ loop -> nwatchers ] = ( void * ) events ; loop -> watchers [ loop -> nwatchers + 1 ] = ( void * ) ( uintptr_t ) nfds ; for ( i = 0 ; i < nfds ; i ++ ) { // \u89e6\u53d1\u7684\u4e8b\u4ef6\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26 pe = events + i ; fd = pe -> data . fd ; // \u6839\u636efd\u83b7\u53d6IO\u89c2\u5bdf\u8005\uff0c\u89c1\u4e0a\u9762\u7684\u56fe w = loop -> watchers [ fd ]; // \u4f1a\u5176\u5b83\u56de\u8c03\u91cc\u88ab\u5220\u9664\u4e86\uff0c\u5219\u4eceepoll\u4e2d\u5220\u9664 if ( w == NULL ) { epoll_ctl ( loop -> backend_fd , EPOLL_CTL_DEL , fd , pe ); continue ; } if ( pe -> events != 0 ) { /* \u7528\u4e8e\u4fe1\u53f7\u5904\u7406\u7684IO\u89c2\u5bdf\u8005\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u89e6\u53d1\u4e86\uff0c \u5373\u6709\u4fe1\u53f7\u53d1\u751f\u3002 */ if ( w == & loop -> signal_io_watcher ) have_signals = 1 ; else // \u4e00\u822c\u7684IO\u89c2\u5bdf\u8005\u5219\u6267\u884c\u56de\u8c03 w -> cb ( loop , w , pe -> events ); nevents ++ ; } } // \u6709\u4fe1\u53f7\u53d1\u751f\uff0c\u89e6\u53d1\u56de\u8c03 if ( have_signals != 0 ) loop -> signal_io_watcher . cb ( loop , & loop -> signal_io_watcher , POLLIN ); \u4e0a\u9762\u7684\u4ee3\u7801\u5904\u7406IO\u4e8b\u4ef6\u5e76\u6267\u884cIO\u89c2\u5bdf\u8005\u91cc\u7684\u56de\u8c03\uff0c\u4f46\u662f\u6709\u4e00\u4e2a\u7279\u6b8a\u7684\u5730\u65b9\u5c31\u662f\u4fe1\u53f7\u5904\u7406\u7684IO\u89c2\u5bdf\u8005\u9700\u8981\u5355\u72ec\u5224\u65ad\uff0c\u5b83\u662f\u4e00\u4e2a\u5168\u5c40\u7684IO\u89c2\u5bdf\u8005\uff0c\u548c\u4e00\u822c\u52a8\u6001\u7533\u8bf7\u548c\u9500\u6bc1\u7684IO\u89c2\u5bdf\u8005\u4e0d\u4e00\u6837\uff0c\u5b83\u662f\u5b58\u5728\u4e8eLibuv\u8fd0\u884c\u7684\u6574\u4e2a\u751f\u547d\u5468\u671f\u3002\u8fd9\u5c31\u662fPoll IO\u7684\u6574\u4e2a\u8fc7\u7a0b\u3002 3.5 \u4e8b\u4ef6\u5faa\u73af\u4e4bclose \u00b6 close\u662fLibuv\u6bcf\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e2d\u6700\u540e\u7684\u4e00\u4e2a\u9636\u6bb5\u3002uv_close\u7528\u4e8e\u5173\u95ed\u4e00\u4e2ahandle\uff0c\u5e76\u4e14\u6267\u884c\u4e00\u4e2a\u56de\u8c03\u3002uv_close\u4ea7\u751f\u7684\u4efb\u52a1\u4f1a\u63d2\u5165\u5230close\u9636\u6bb5\u7684\u961f\u5217\uff0c\u7136\u540e\u5728close\u9636\u6bb5\u88ab\u5904\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0buv_close\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void uv_close ( uv_handle_t * handle , uv_close_cb close_cb ) { // \u6b63\u5728\u5173\u95ed\uff0c\u4f46\u662f\u8fd8\u6ca1\u6267\u884c\u56de\u8c03\u7b49\u540e\u7f6e\u64cd\u4f5c handle -> flags |= UV_HANDLE_CLOSING ; handle -> close_cb = close_cb ; switch ( handle -> type ) { case UV_PREPARE : uv__prepare_close (( uv_prepare_t * ) handle ); break ; case UV_CHECK : uv__check_close (( uv_check_t * ) handle ); break ; ... default : assert ( 0 ); } uv__make_close_pending ( handle ); } uv_close\u8bbe\u7f6e\u56de\u8c03\u548c\u72b6\u6001\uff0c\u7136\u540e\u6839\u636ehandle\u7c7b\u578b\u8c03\u5bf9\u5e94\u7684close\u51fd\u6570\uff0c\u4e00\u822c\u5c31\u662fstop\u8fd9\u4e2ahandle\uff0c\u89e3\u9664IO\u89c2\u5bdf\u8005\u6ce8\u518c\u7684\u4e8b\u4ef6\uff0c\u4ece\u4e8b\u4ef6\u5faa\u73af\u7684handle\u961f\u5217\u79fb\u9664\u8be5handle\u7b49\u7b49\uff0c\u6bd4\u5982prepare\u7684close\u51fd\u6570\u53ea\u662f\u628ahandle\u4ece\u961f\u5217\u4e2d\u79fb\u9664\u3002 1 2 3 4 5 6 7 8 void uv__prepare_close ( uv_prepare_t * handle ) { uv_prepare_stop ( handle ); } int uv_prepare_stop ( uv_prepare__t * handle ) { QUEUE_REMOVE ( & handle -> queue ); uv__handle_stop ( handle ); return 0 ; } \u6839\u636e\u4e0d\u540c\u7684handle\u505a\u4e0d\u540c\u7684\u5904\u7406\u540e\uff0c\u63a5\u7740\u6267\u884cuv__make_close_pending\u5f80close\u961f\u5217\u8ffd\u52a0\u8282\u70b9\u3002 1 2 3 4 5 // \u5934\u63d2\u6cd5\u63d2\u5165closing\u961f\u5217\uff0c\u5728closing\u9636\u6bb5\u88ab\u6267\u884c void uv__make_close_pending ( uv_handle_t * handle ) { handle -> next_closing = handle -> loop -> closing_handles ; handle -> loop -> closing_handles = handle ; } \u7136\u540e\u5728close\u9636\u6bb5\u9010\u4e2a\u5904\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0bclose\u9636\u6bb5\u7684\u5904\u7406\u903b\u8f91 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // \u6267\u884cclosing\u9636\u6bb5\u7684\u7684\u56de\u8c03 static void uv__run_closing_handles ( uv_loop_t * loop ) { uv_handle_t * p ; uv_handle_t * q ; p = loop -> closing_handles ; loop -> closing_handles = NULL ; while ( p ) { q = p -> next_closing ; uv__finish_close ( p ); p = q ; } } // \u6267\u884cclosing\u9636\u6bb5\u7684\u56de\u8c03 static void uv__finish_close ( uv_handle_t * handle ) { handle -> flags |= UV_HANDLE_CLOSED ; ... uv__handle_unref ( handle ); // \u4ecehandle\u961f\u5217\u91cc\u79fb\u9664 QUEUE_REMOVE ( & handle -> handle_queue ); if ( handle -> close_cb ) { handle -> close_cb ( handle ); } } uv__run_closing_handles\u4f1a\u9010\u4e2a\u6267\u884c\u6bcf\u4e2a\u4efb\u52a1\u8282\u70b9\u7684\u56de\u8c03\u3002 3.6 \u63a7\u5236\u4e8b\u4ef6\u5faa\u73af \u00b6 Libuv\u901a\u8fc7uv__loop_alive\u51fd\u6570\u5224\u65ad\u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u8fd8\u9700\u8981\u7ee7\u7eed\u6267\u884c\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 static int uv__loop_alive ( const uv_loop_t * loop ) { return uv__has_active_handles ( loop ) || uv__has_active_reqs ( loop ) || loop -> closing_handles != NULL ; } \u4e3a\u4ec0\u4e48\u4f1a\u6709\u4e00\u4e2aclosing_handle\u7684\u5224\u65ad\u5462\uff1f\u4eceuv_run\u7684\u4ee3\u7801\u6765\u770b\uff0c\u6267\u884c\u5b8cclose\u9636\u6bb5\u540e\uff0c\u4f1a\u7acb\u523b\u6267\u884cuv__loop_alive\uff0c\u6b63\u5e38\u6765\u8bf4\uff0cclose\u9636\u6bb5\u7684\u961f\u5217\u662f\u7a7a\u7684\uff0c\u4f46\u662f\u5982\u679c\u6211\u4eec\u5728close\u56de\u8c03\u91cc\u53c8\u5f80close\u961f\u5217\u65b0\u589e\u4e86\u4e00\u4e2a\u8282\u70b9\uff0c\u800c\u8be5\u8282\u70b9\u4e0d\u4f1a\u5728\u672c\u8f6e\u7684close\u9636\u6bb5\u88ab\u6267\u884c\uff0c\u8fd9\u6837\u4f1a\u5bfc\u81f4\u6267\u884c\u5b8cclose\u9636\u6bb5\uff0c\u4f46\u662fclose\u961f\u5217\u4f9d\u7136\u6709\u8282\u70b9\uff0c\u5982\u679c\u76f4\u63a5\u9000\u51fa\uff0c\u5219\u65e0\u6cd5\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u3002 \u6211\u4eec\u770b\u5230\u6709\u4e09\u79cd\u60c5\u51b5\uff0cLibuv\u8ba4\u4e3a\u4e8b\u4ef6\u5faa\u73af\u662f\u5b58\u6d3b\u7684\u3002\u5982\u679c\u6211\u4eec\u63a7\u5236\u8fd9\u4e09\u79cd\u6761\u4ef6\u5c31\u53ef\u4ee5\u63a7\u5236\u4e8b\u4ef6\u5faa\u73af\u7684\u7684\u9000\u51fa\u3002\u6211\u4eec\u901a\u8fc7\u4e00\u4e2a\u4f8b\u5b50\u7406\u89e3\u4e00\u4e0b\u8fd9\u4e2a\u8fc7\u7a0b\u3002 1 2 3 4 const timeout = setTimeout (() => { console . log ( 'never console' ) }, 5000 ); timeout . unref (); \u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0csetTimeout\u7684\u56de\u8c03\u662f\u4e0d\u4f1a\u6267\u884c\u7684\u3002\u9664\u975e\u8d85\u65f6\u65f6\u95f4\u975e\u5e38\u77ed\uff0c\u77ed\u5230\u7b2c\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u7684\u65f6\u5019\u5c31\u5230\u671f\u4e86\uff0c\u5426\u5219\u5728\u7b2c\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e4b\u540e\uff0c\u7531\u4e8eunref\u7684\u5f71\u54cd\uff0c\u4e8b\u4ef6\u5faa\u73af\u76f4\u63a5\u9000\u51fa\u4e86\u3002unref\u5f71\u54cd\u7684\u5c31\u662fhandle\u8fd9\u4e2a\u6761\u4ef6\u3002\u8fd9\u65f6\u5019\u4e8b\u4ef6\u5faa\u73af\u4ee3\u7801\u5982\u4e0b\u3002 1 2 3 4 5 6 7 while ( r != 0 && loop -> stop_flag == 0 ) { uv__update_time ( loop ); uv__run_timers ( loop ); // ... // uv__loop_alive\u8fd4\u56defalse\uff0c\u76f4\u63a5\u8df3\u51fawhile\uff0c\u4ece\u800c\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af r = uv__loop_alive ( loop ); }","title":"03-\u4e8b\u4ef6\u5faa\u73af"},{"location":"chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/#_1","text":"Node.js\u5c5e\u4e8e\u5355\u7ebf\u7a0b\u4e8b\u4ef6\u5faa\u73af\u67b6\u6784\uff0c\u8be5\u4e8b\u4ef6\u5faa\u73af\u7531Libuv\u7684uv_run\u51fd\u6570\u5b9e\u73b0\uff0c\u5728\u8be5\u51fd\u6570\u4e2d\u6267\u884cwhile\u5faa\u73af\uff0c\u7136\u540e\u4e0d\u65ad\u5730\u5904\u7406\u5404\u4e2a\u9636\u6bb5\uff08phase\uff09\u7684\u4e8b\u4ef6\u56de\u8c03\u3002\u4e8b\u4ef6\u5faa\u73af\u7684\u5904\u7406\u76f8\u5f53\u4e8e\u4e00\u4e2a\u6d88\u8d39\u8005\uff0c\u6d88\u8d39\u7531\u5404\u79cd\u4ee3\u7801\u4ea7\u751f\u7684\u4efb\u52a1\u3002Node.js\u521d\u59cb\u5316\u5b8c\u6210\u540e\u5c31\u5f00\u59cb\u9677\u5165\u8be5\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u4e8b\u4ef6\u5faa\u73af\u7684\u7ed3\u675f\u4e5f\u5c31\u610f\u5473\u7740Node.js\u7684\u7ed3\u675f\u3002\u4e0b\u9762\u770b\u4e00\u4e0b\u4e8b\u4ef6\u5faa\u73af\u7684\u6838\u5fc3\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 int uv_run ( uv_loop_t * loop , uv_run_mode mode ) { int timeout ; int r ; int ran_pending ; // \u5728uv_run\u4e4b\u524d\u8981\u5148\u63d0\u4ea4\u4efb\u52a1\u5230loop r = uv__loop_alive ( loop ); // \u4e8b\u4ef6\u5faa\u73af\u6ca1\u6709\u4efb\u52a1\u6267\u884c\uff0c\u5373\u5c06\u9000\u51fa\uff0c\u8bbe\u7f6e\u4e00\u4e0b\u5f53\u524d\u5faa\u73af\u7684\u65f6\u95f4 if ( ! r ) uv__update_time ( loop ); // \u6ca1\u6709\u4efb\u52a1\u9700\u8981\u5904\u7406\u6216\u8005\u8c03\u7528\u4e86uv_stop\u5219\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af while ( r != 0 && loop -> stop_flag == 0 ) { // \u66f4\u65b0loop\u7684time\u5b57\u6bb5 uv__update_time ( loop ); // \u6267\u884c\u8d85\u65f6\u56de\u8c03 uv__run_timers ( loop ); /* \u6267\u884cpending\u56de\u8c03\uff0cran_pending\u4ee3\u8868pending\u961f\u5217\u662f\u5426\u4e3a\u7a7a\uff0c \u5373\u6ca1\u6709\u8282\u70b9\u53ef\u4ee5\u6267\u884c */ ran_pending = uv__run_pending ( loop ); // \u7ee7\u7eed\u6267\u884c\u5404\u79cd\u961f\u5217 uv__run_idle ( loop ); uv__run_prepare ( loop ); timeout = 0 ; /* \u6267\u884c\u6a21\u5f0f\u662fUV_RUN_ONCE\u65f6\uff0c\u5982\u679c\u6ca1\u6709pending\u8282\u70b9\uff0c \u624d\u4f1a\u963b\u585e\u5f0fPoll IO\uff0c\u9ed8\u8ba4\u6a21\u5f0f\u4e5f\u662f */ if (( mode == UV_RUN_ONCE && ! ran_pending ) || mode == UV_RUN_DEFAULT ) timeout = uv_backend_timeout ( loop ); // Poll IO timeout\u662fepoll_wait\u7684\u8d85\u65f6\u65f6\u95f4 uv__io_poll ( loop , timeout ); // \u5904\u7406check\u9636\u6bb5 uv__run_check ( loop ); // \u5904\u7406close\u9636\u6bb5 uv__run_closing_handles ( loop ); /* \u8fd8\u6709\u4e00\u6b21\u6267\u884c\u8d85\u65f6\u56de\u8c03\u7684\u673a\u4f1a\uff0c\u56e0\u4e3auv__io_poll\u53ef\u80fd\u662f\u56e0\u4e3a \u5b9a\u65f6\u5668\u8d85\u65f6\u8fd4\u56de\u7684\u3002 */ if ( mode == UV_RUN_ONCE ) { uv__update_time ( loop ); uv__run_timers ( loop ); } r = uv__loop_alive ( loop ); /* \u53ea\u6267\u884c\u4e00\u6b21\uff0c\u9000\u51fa\u5faa\u73af,UV_RUN_NOWAIT\u8868\u793a\u5728Poll IO\u9636\u6bb5 \u4e0d\u4f1a\u963b\u585e\u5e76\u4e14\u5faa\u73af\u53ea\u6267\u884c\u4e00\u6b21 */ if ( mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT ) break ; } // \u662f\u56e0\u4e3a\u8c03\u7528\u4e86uv_stop\u9000\u51fa\u7684\uff0c\u91cd\u7f6eflag if ( loop -> stop_flag != 0 ) loop -> stop_flag = 0 ; /* \u8fd4\u56de\u662f\u5426\u8fd8\u6709\u6d3b\u8dc3\u7684\u4efb\u52a1\uff08handle\u6216request\uff09\uff0c \u4e1a\u52a1\u4ee3\u8868\u53ef\u4ee5\u518d\u6b21\u6267\u884cuv_run */ return r ; } Libuv\u5206\u4e3a\u51e0\u4e2a\u9636\u6bb5\uff0c\u4e0b\u9762\u4ece\u5148\u5230\u540e\uff0c\u5206\u522b\u5206\u6790\u5404\u4e2a\u9636\u6bb5\u7684\u76f8\u5173\u4ee3\u7801\u3002","title":"\u7b2c\u4e09\u7ae0 \u4e8b\u4ef6\u5faa\u73af"},{"location":"chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/#31","text":"Libuv\u4e2d\uff0c\u5b9a\u65f6\u5668\u9636\u6bb5\u662f\u7b2c\u4e00\u4e2a\u88ab\u5904\u7406\u7684\u9636\u6bb5\u3002\u5b9a\u65f6\u5668\u662f\u4ee5\u6700\u5c0f\u5806\u5b9e\u73b0\u7684\uff0c\u6700\u5feb\u8fc7\u671f\u7684\u8282\u70b9\u662f\u6839\u8282\u70b9\u3002Libuv\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\u90fd\u4f1a\u7f13\u5b58\u5f53\u524d\u7684\u65f6\u95f4\uff0c\u5728\u6bcf\u4e00\u8f6e\u7684\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u4f7f\u7528\u7684\u90fd\u662f\u8fd9\u4e2a\u7f13\u5b58\u7684\u65f6\u95f4\uff0c\u5fc5\u8981\u7684\u65f6\u5019Libuv\u4f1a\u663e\u5f0f\u66f4\u65b0\u8fd9\u4e2a\u65f6\u95f4\uff0c\u56e0\u4e3a\u83b7\u53d6\u65f6\u95f4\u9700\u8981\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\u63a5\u53e3\uff0c\u800c\u9891\u7e41\u8c03\u7528\u7cfb\u7edf\u8c03\u7528\u4f1a\u5e26\u6765\u4e00\u5b9a\u7684\u8017\u65f6\uff0c\u7f13\u5b58\u65f6\u95f4\u53ef\u4ee5\u51cf\u5c11\u64cd\u4f5c\u7cfb\u7edf\u7684\u8c03\u7528\uff0c\u63d0\u9ad8\u6027\u80fd\u3002Libuv\u7f13\u5b58\u4e86\u5f53\u524d\u6700\u65b0\u7684\u65f6\u95f4\u540e\uff0c\u5c31\u6267\u884cuv__run_timers\uff0c\u8be5\u51fd\u6570\u5c31\u662f\u904d\u5386\u6700\u5c0f\u5806\uff0c\u627e\u51fa\u5f53\u524d\u8d85\u65f6\u7684\u8282\u70b9\u3002\u56e0\u4e3a\u5806\u7684\u6027\u8d28\u662f\u7236\u8282\u70b9\u80af\u5b9a\u6bd4\u5b69\u5b50\u5c0f\u3002\u5e76\u4e14\u6839\u8282\u70b9\u662f\u6700\u5c0f\u7684\uff0c\u6240\u4ee5\u5982\u679c\u4e00\u4e2a\u6839\u8282\u70b9\uff0c\u5b83\u6ca1\u6709\u8d85\u65f6\uff0c\u5219\u540e\u9762\u7684\u8282\u70b9\u4e5f\u4e0d\u4f1a\u8d85\u65f6\u3002\u5bf9\u4e8e\u8d85\u65f6\u7684\u8282\u70b9\u5c31\u6267\u884c\u5b83\u7684\u56de\u8c03\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void uv__run_timers ( uv_loop_t * loop ) { struct heap_node * heap_node ; uv_timer_t * handle ; // \u904d\u5386\u4e8c\u53c9\u5806 for (;;) { // \u627e\u51fa\u6700\u5c0f\u7684\u8282\u70b9 heap_node = heap_min ( timer_heap ( loop )); // \u6ca1\u6709\u5219\u9000\u51fa if ( heap_node == NULL ) break ; // \u901a\u8fc7\u7ed3\u6784\u4f53\u5b57\u6bb5\u627e\u5230\u7ed3\u6784\u4f53\u9996\u5730\u5740 handle = container_of ( heap_node , uv_timer_t , heap_node ); // \u6700\u5c0f\u7684\u8282\u70b9\u90fd\u6ca1\u6709\u8d85\u5e02\uff0c\u5219\u540e\u9762\u7684\u8282\u70b9\u4e5f\u4e0d\u4f1a\u8d85\u65f6 if ( handle -> timeout > loop -> time ) break ; // \u5220\u9664\u8be5\u8282\u70b9 uv_timer_stop ( handle ); /* \u91cd\u8bd5\u63d2\u5165\u4e8c\u53c9\u5806\uff0c\u5982\u679c\u9700\u8981\u7684\u8bdd\uff08\u8bbe\u7f6e\u4e86repeat\uff0c\u6bd4\u5982 setInterval\uff09 */ uv_timer_again ( handle ); // \u6267\u884c\u56de\u8c03 handle -> timer_cb ( handle ); } } \u6267\u884c\u5b8c\u56de\u8c03\u540e\uff0c\u8fd8\u6709\u4e24\u4e2a\u5173\u952e\u7684\u64cd\u4f5c\uff0c\u7b2c\u4e00\u5c31\u662fstop\uff0c\u7b2c\u4e8c\u5c31\u662fagain\u3002stop\u7684\u903b\u8f91\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u628ahandle\u4ece\u4e8c\u53c9\u5806\u4e2d\u5220\u9664\uff0c\u5e76\u4e14\u4fee\u6539handle\u7684\u72b6\u6001\u3002\u90a3\u4e48again\u53c8\u662f\u4ec0\u4e48\u5462\uff1fagain\u662f\u4e3a\u4e86\u652f\u6301setInterval\u8fd9\u79cd\u573a\u666f\uff0c\u5982\u679chandle\u8bbe\u7f6e\u4e86repeat\u6807\u8bb0\uff0c\u5219\u8be5handle\u5728\u8d85\u65f6\u540e\uff0c\u6bcfrepeat\u7684\u65f6\u95f4\u540e\uff0c\u5c31\u4f1a\u7ee7\u7eed\u6267\u884c\u8d85\u65f6\u56de\u8c03\u3002\u5bf9\u4e8esetInterval\uff0c\u5c31\u662f\u8d85\u65f6\u65f6\u95f4\u662fx\uff0c\u6bcfx\u7684\u65f6\u95f4\u540e\uff0c\u6267\u884c\u56de\u8c03\u3002\u8fd9\u5c31\u662fNode.js\u91cc\u5b9a\u65f6\u5668\u7684\u5e95\u5c42\u539f\u7406\u3002\u4f46Node.js\u4e0d\u662f\u6bcf\u6b21\u8c03setTimeout/setInterval\u7684\u65f6\u5019\u90fd\u5f80\u6700\u5c0f\u5806\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0cNode.js\u91cc\uff0c\u53ea\u6709\u4e00\u4e2a\u5173\u4e8euv_timer_s\u7684handle\uff0c\u5b83\u5728JS\u5c42\u7ef4\u62a4\u4e86\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\uff0c\u6bcf\u6b21\u8ba1\u7b97\u51fa\u6700\u65e9\u5230\u671f\u7684\u8282\u70b9\uff0c\u7136\u540e\u4fee\u6539handle\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u5177\u4f53\u5728\u5b9a\u65f6\u5668\u7ae0\u8282\u8bb2\u89e3\u3002 \u53e6\u5916timer\u9636\u6bb5\u548cPoll IO\u9636\u6bb5\u4e5f\u6709\u4e00\u4e9b\u8054\u7cfb\uff0c\u56e0\u4e3aPoll IO\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4e3b\u7ebf\u7a0b\u963b\u585e\uff0c\u4e3a\u4e86\u4fdd\u8bc1\u4e3b\u7ebf\u7a0b\u53ef\u4ee5\u5c3d\u5feb\u6267\u884c\u5b9a\u65f6\u5668\u7684\u56de\u8c03\uff0cPoll IO\u4e0d\u80fd\u4e00\u76f4\u963b\u585e\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\uff0c\u963b\u585e\u7684\u65f6\u957f\u5c31\u662f\u6700\u5feb\u5230\u671f\u7684\u5b9a\u65f6\u5668\u8282\u70b9\u7684\u65f6\u957f\uff08\u5177\u4f53\u53ef\u53c2\u8003libuv core.c\u4e2d\u7684uv_backend_timeout\u51fd\u6570\uff09\u3002","title":"3.1 \u4e8b\u4ef6\u5faa\u73af\u4e4b\u5b9a\u65f6\u5668"},{"location":"chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/#32-pending","text":"\u5b98\u7f51\u5bf9pending\u9636\u6bb5\u7684\u89e3\u91ca\u662f\u5728\u4e0a\u4e00\u8f6e\u7684Poll IO\u9636\u6bb5\u6ca1\u6709\u6267\u884c\u7684IO\u56de\u8c03\uff0c\u4f1a\u5728\u4e0b\u4e00\u8f6e\u5faa\u73af\u7684pending\u9636\u6bb5\u88ab\u6267\u884c\u3002\u4ece\u6e90\u7801\u6765\u770b\uff0cPoll IO\u9636\u6bb5\u5904\u7406\u4efb\u52a1\u65f6\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u5f53\u524d\u6267\u884c\u7684\u64cd\u4f5c\u5931\u8d25\u9700\u8981\u6267\u884c\u56de\u8c03\u901a\u77e5\u8c03\u7528\u65b9\u4e00\u4e9b\u4fe1\u606f\uff0c\u8be5\u56de\u8c03\u51fd\u6570\u4e0d\u4f1a\u7acb\u523b\u6267\u884c\uff0c\u800c\u662f\u5728\u4e0b\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u7684pending\u9636\u6bb5\u6267\u884c\uff08\u6bd4\u5982\u5199\u5165\u6570\u636e\u6210\u529f\uff0c\u6216\u8005TCP\u8fde\u63a5\u5931\u8d25\u65f6\u56de\u8c03C++\u5c42\uff09\uff0c\u6211\u4eec\u5148\u770bpending\u9636\u6bb5\u7684\u5904\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 static int uv__run_pending ( uv_loop_t * loop ) { QUEUE * q ; QUEUE pq ; uv__io_t * w ; if ( QUEUE_EMPTY ( & loop -> pending_queue )) return 0 ; // \u628apending_queue\u961f\u5217\u7684\u8282\u70b9\u79fb\u5230pq\uff0c\u5373\u6e05\u7a7a\u4e86pending_queue QUEUE_MOVE ( & loop -> pending_queue , & pq ); // \u904d\u5386pq\u961f\u5217 while ( ! QUEUE_EMPTY ( & pq )) { // \u53d6\u51fa\u5f53\u524d\u7b2c\u4e00\u4e2a\u9700\u8981\u5904\u7406\u7684\u8282\u70b9\uff0c\u5373pq.next q = QUEUE_HEAD ( & pq ); // \u628a\u5f53\u524d\u9700\u8981\u5904\u7406\u7684\u8282\u70b9\u79fb\u51fa\u961f\u5217 QUEUE_REMOVE ( q ); /* \u91cd\u7f6e\u4e00\u4e0bprev\u548cnext\u6307\u9488\uff0c\u56e0\u4e3a\u8fd9\u65f6\u5019\u8fd9\u4e24\u4e2a\u6307\u9488\u662f \u6307\u5411\u961f\u5217\u4e2d\u7684\u4e24\u4e2a\u8282\u70b9 */ QUEUE_INIT ( q ); w = QUEUE_DATA ( q , uv__io_t , pending_queue ); w -> cb ( loop , w , POLLOUT ); } return 1 ; } pending\u9636\u6bb5\u7684\u5904\u7406\u903b\u8f91\u5c31\u662f\u628apending\u961f\u5217\u91cc\u7684\u8282\u70b9\u9010\u4e2a\u6267\u884c\u3002\u6211\u4eec\u770b\u4e00\u4e0bpending\u961f\u5217\u7684\u8282\u70b9\u662f\u5982\u4f55\u751f\u4ea7\u51fa\u6765\u7684\u3002 1 2 3 4 void uv__io_feed ( uv_loop_t * loop , uv__io_t * w ) { if ( QUEUE_EMPTY ( & w -> pending_queue )) QUEUE_INSERT_TAIL ( & loop -> pending_queue , & w -> pending_queue ); } Libuv\u901a\u8fc7uv__io_feed\u51fd\u6570\u751f\u4ea7pending\u4efb\u52a1\uff0c\u4eceLibuv\u7684\u4ee3\u7801\u4e2d\u6211\u4eec\u770b\u5230IO\u9519\u8bef\u7684\u65f6\u5019\u4f1a\u8c03\u8fd9\u4e2a\u51fd\u6570\uff08\u5982tcp.c\u7684uv__tcp_connect\u51fd\u6570\uff09\u3002 1 2 if ( handle -> delayed_error ) uv__io_feed ( handle -> loop , & handle -> io_watcher ); \u5728\u5199\u5165\u6570\u636e\u6210\u529f\u540e\uff08\u6bd4\u5982TCP\u3001UDP\uff09\uff0c\u4e5f\u4f1a\u5f80pending\u961f\u5217\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u7b49\u5f85\u56de\u8c03\u3002\u6bd4\u5982\u53d1\u9001\u6570\u636e\u6210\u529f\u540e\u6267\u884c\u7684\u4ee3\u7801\uff08udp.c\u7684uv__udp_sendmsg\u51fd\u6570\uff09 1 2 3 4 5 6 7 8 9 // \u53d1\u9001\u5b8c\u79fb\u51fa\u5199\u961f\u5217 QUEUE_REMOVE ( & req -> queue ); // \u52a0\u5165\u5199\u5b8c\u6210\u961f\u5217 QUEUE_INSERT_TAIL ( & handle -> write_completed_queue , & req -> queue ); /* \u6709\u8282\u70b9\u6570\u636e\u5199\u5b8c\u4e86\uff0c\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0c pending\u9636\u6bb5\u6267\u884c\u56de\u8c03 */ uv__io_feed ( handle -> loop , & handle -> io_watcher ); \u6700\u540e\u5173\u95edIO\u7684\u65f6\u5019\uff08\u5982\u5173\u95ed\u4e00\u4e2aTCP\u8fde\u63a5\uff09\u4f1a\u4ecepending\u961f\u5217\u79fb\u9664\u5bf9\u5e94\u7684\u8282\u70b9\uff0c\u56e0\u4e3a\u5df2\u7ecf\u5173\u95ed\u4e86\uff0c\u81ea\u7136\u5c31\u4e0d\u9700\u8981\u6267\u884c\u56de\u8c03\u3002 1 2 3 4 5 6 void uv__io_close ( uv_loop_t * loop , uv__io_t * w ) { uv__io_stop ( loop , w , POLLIN | POLLOUT | UV__POLLRDHUP | UV__POLLPRI ); QUEUE_REMOVE ( & w -> pending_queue ); }","title":"3.2 pending\u9636\u6bb5"},{"location":"chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/#33-preparecheckidle","text":"prepare,check,idle\u662fLibuv\u4e8b\u4ef6\u5faa\u73af\u4e2d\u5c5e\u4e8e\u6bd4\u8f83\u7b80\u5355\u7684\u4e00\u4e2a\u9636\u6bb5\uff0c\u5b83\u4eec\u7684\u5b9e\u73b0\u662f\u4e00\u6837\u7684\uff08\u89c1loop-watcher.c\uff09\u3002\u672c\u8282\u53ea\u8bb2\u89e3prepare\u9636\u6bb5\uff0c\u6211\u4eec\u77e5\u9053Libuv\u4e2d\u5206\u4e3ahandle\u548crequest\uff0c\u800cprepare\u9636\u6bb5\u7684\u4efb\u52a1\u662f\u5c5e\u4e8ehandle\u7c7b\u578b\u3002\u8fd9\u610f\u5473\u7740\u9664\u975e\u6211\u4eec\u663e\u5f0f\u79fb\u9664\uff0c\u5426\u5219prepare\u9636\u6bb5\u7684\u8282\u70b9\u5728\u6bcf\u6b21\u4e8b\u4ef6\u5faa\u73af\u4e2d\u90fd\u4f1a\u88ab\u6267\u884c\u3002\u4e0b\u9762\u6211\u4eec\u5148\u770b\u770b\u600e\u4e48\u4f7f\u7528\u5b83\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void prep_cb ( uv_prepare_t * handle ) { printf ( \"Prep callback \\n \" ); } int main () { uv_prepare_t prep ; // \u521d\u59cb\u5316\u4e00\u4e2ahandle\uff0cuv_default_loop\u662f\u4e8b\u4ef6\u5faa\u73af\u7684\u6838\u5fc3\u7ed3\u6784\u4f53 uv_prepare_init ( uv_default_loop (), & prep ); // \u6ce8\u518chandle\u7684\u56de\u8c03 uv_prepare_start ( & prep , prep_cb ); // \u5f00\u59cb\u4e8b\u4ef6\u5faa\u73af uv_run ( uv_default_loop (), UV_RUN_DEFAULT ); return 0 ; } \u6267\u884cmain\u51fd\u6570\uff0cLibuv\u5c31\u4f1a\u5728prepare\u9636\u6bb5\u6267\u884c\u56de\u8c03prep_cb\u3002\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u8fd9\u4e2a\u8fc7\u7a0b\u3002 1 2 3 4 5 int uv_prepare_init ( uv_loop_t * loop , uv_prepare_t * handle ) { uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_PREPARE ); handle -> prepare_cb = NULL ; return 0 ; } init\u51fd\u6570\u4e3b\u8981\u662f\u505a\u4e00\u4e9b\u521d\u59cb\u5316\u64cd\u4f5c\u3002\u6211\u4eec\u7ee7\u7eed\u8981\u770bstart\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 int uv_prepare_start ( uv_prepare_t * handle , uv_prepare_cb cb ) { // \u5982\u679c\u5df2\u7ecf\u6267\u884c\u8fc7start\u51fd\u6570\u5219\u76f4\u63a5\u8fd4\u56de if ( uv__is_active ( handle )) return 0 ; if ( cb == NULL ) return UV_EINVAL ; QUEUE_INSERT_HEAD ( & handle -> loop -> prepare_handles , & handle -> queue ); handle -> prepare_cb = cb ; uv__handle_start ( handle ); return 0 ; } uv_prepare_start\u51fd\u6570\u4e3b\u8981\u7684\u903b\u8f91\u4e3b\u8981\u662f\u8bbe\u7f6e\u56de\u8c03\uff0c\u628ahandle\u63d2\u5165loop\u7684prepare_handles\u961f\u5217\uff0cprepare_handles\u961f\u5217\u4fdd\u5b58\u4e86prepare\u9636\u6bb5\u7684\u4efb\u52a1\u3002\u5728\u4e8b\u4ef6\u5faa\u73af\u7684prepare\u9636\u6bb5\u4f1a\u9010\u4e2a\u6267\u884c\u91cc\u9762\u7684\u8282\u70b9\u7684\u56de\u8c03\u3002\u7136\u540e\u6211\u4eec\u770b\u770bLibuv\u5728\u4e8b\u4ef6\u5faa\u73af\u7684prepare\u9636\u6bb5\u662f\u5982\u4f55\u5904\u7406\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void uv__run_prepare ( uv_loop_t * loop ) { uv_prepare_t * h ; QUEUE queue ; QUEUE * q ; /* \u628a\u8be5\u7c7b\u578b\u5bf9\u5e94\u7684\u961f\u5217\u4e2d\u6240\u6709\u8282\u70b9\u6458\u4e0b\u6765\u6302\u8f7d\u5230queue\u53d8\u91cf\uff0c \u76f8\u5f53\u4e8e\u6e05\u7a7aprepare_handles\u961f\u5217\uff0c\u56e0\u4e3a\u5982\u679c\u76f4\u63a5\u904d\u5386 prepare_handles\u961f\u5217\uff0c\u5728\u6267\u884c\u56de\u8c03\u7684\u65f6\u5019\u4e00\u76f4\u5f80prepare_handles \u961f\u5217\u52a0\u8282\u70b9\uff0c\u4f1a\u5bfc\u81f4\u4e0b\u9762\u7684while\u5faa\u73af\u65e0\u6cd5\u9000\u51fa\u3002 \u5148\u79fb\u9664\u7684\u8bdd\uff0c\u65b0\u63d2\u5165\u7684\u8282\u70b9\u5728\u4e0b\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u624d\u4f1a\u88ab\u5904\u7406\u3002 */ QUEUE_MOVE ( & loop -> prepare_handles , & queue ); // \u904d\u5386\u961f\u5217\uff0c\u6267\u884c\u6bcf\u4e2a\u8282\u70b9\u91cc\u9762\u7684\u51fd\u6570 while ( ! QUEUE_EMPTY ( & queue )) { // \u53d6\u4e0b\u5f53\u524d\u5f85\u5904\u7406\u7684\u8282\u70b9\uff0c\u5373\u961f\u5217\u7684\u5934 q = QUEUE_HEAD ( & queue ); /* \u53d6\u5f97\u8be5\u8282\u70b9\u5bf9\u5e94\u7684\u6574\u4e2a\u7ed3\u6784\u4f53\u7684\u57fa\u5730\u5740\uff0c \u5373\u901a\u8fc7\u7ed3\u6784\u4f53\u6210\u5458\u53d6\u5f97\u7ed3\u6784\u4f53\u9996\u5730\u5740 */ h = QUEUE_DATA ( q , uv_prepare_t , queue ); // \u628a\u8be5\u8282\u70b9\u79fb\u51fa\u5f53\u524d\u961f\u5217 QUEUE_REMOVE ( q ); // \u91cd\u65b0\u63d2\u5165\u539f\u6765\u7684\u961f\u5217 QUEUE_INSERT_TAIL ( & loop -> prepare_handles , q ); // \u6267\u884c\u56de\u8c03\u51fd\u6570 h -> prepare_cb ( h ); } } uv__run_prepare\u51fd\u6570\u7684\u903b\u8f91\u5f88\u7b80\u5355\uff0c\u4f46\u662f\u6709\u4e00\u4e2a\u91cd\u70b9\u7684\u5730\u65b9\u5c31\u662f\u6267\u884c\u5b8c\u6bcf\u4e00\u4e2a\u8282\u70b9\uff0cLibuv\u4f1a\u628a\u8be5\u8282\u70b9\u91cd\u65b0\u63d2\u5165\u961f\u5217\u4e2d\uff0c\u6240\u4ee5prepare\uff08\u5305\u62ecidle\u3001check\uff09\u9636\u6bb5\u7684\u8282\u70b9\u5728\u6bcf\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e2d\u90fd\u4f1a\u88ab\u6267\u884c\u3002\u800c\u50cf\u5b9a\u65f6\u5668\u3001pending\u3001closing\u9636\u6bb5\u7684\u8282\u70b9\u662f\u4e00\u6b21\u6027\u7684\uff0c\u88ab\u6267\u884c\u540e\u5c31\u4f1a\u4ece\u961f\u5217\u91cc\u5220\u9664\u3002 \u6211\u4eec\u56de\u987e\u4e00\u5f00\u59cb\u7684\u6d4b\u8bd5\u4ee3\u7801\u3002\u56e0\u4e3a\u5b83\u8bbe\u7f6e\u4e86Libuv\u7684\u8fd0\u884c\u6a21\u5f0f\u662f\u9ed8\u8ba4\u6a21\u5f0f\u3002\u800cprepare\u961f\u5217\u53c8\u4e00\u76f4\u6709\u4e00\u4e2ahandle\u8282\u70b9\uff0c\u6240\u4ee5\u5b83\u662f\u4e0d\u4f1a\u9000\u51fa\u7684\u3002\u5b83\u4f1a\u4e00\u76f4\u6267\u884c\u56de\u8c03\u3002\u90a3\u5982\u679c\u6211\u4eec\u8981\u9000\u51fa\u600e\u4e48\u529e\u5462\uff1f\u6216\u8005\u8bf4\u4e0d\u8981\u6267\u884cprepare\u961f\u5217\u7684\u67d0\u4e2a\u8282\u70b9\u4e86\u3002\u6211\u4eec\u53ea\u9700\u8981stop\u4e00\u4e0b\u5c31\u53ef\u4ee5\u4e86\u3002 1 2 3 4 5 6 7 8 int uv_prepare_stop ( uv_prepare_t * handle ) { if ( ! uv__is_active ( handle )) return 0 ; // \u628ahandle\u4eceprepare\u961f\u5217\u4e2d\u79fb\u9664\uff0c\u4f46\u8fd8\u6302\u8f7d\u5230handle_queue\u4e2d QUEUE_REMOVE ( & handle -> queue ); // \u6e05\u9664active\u6807\u8bb0\u4f4d\u5e76\u4e14\u51cf\u53bbloop\u4e2dhandle\u7684active\u6570 uv__handle_stop ( handle ); return 0 ; } stop\u51fd\u6570\u548cstart\u51fd\u6570\u662f\u76f8\u53cd\u7684\u4f5c\u7528\uff0c\u8fd9\u5c31\u662fNode.js\u4e2dprepare\u3001check\u3001idle\u9636\u6bb5\u7684\u539f\u7406\u3002","title":"3.3 \u4e8b\u4ef6\u5faa\u73af\u4e4bprepare,check,idle"},{"location":"chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/#34-poll-io","text":"Poll IO\u662fLibuv\u975e\u5e38\u91cd\u8981\u7684\u4e00\u4e2a\u9636\u6bb5\uff0c\u6587\u4ef6IO\u3001\u7f51\u7edcIO\u3001\u4fe1\u53f7\u5904\u7406\u7b49\u90fd\u5728\u8fd9\u4e2a\u9636\u6bb5\u5904\u7406\uff0c\u8fd9\u4e5f\u662f\u6700\u590d\u6742\u7684\u4e00\u4e2a\u9636\u6bb5\u3002\u5904\u7406\u903b\u8f91\u5728core.c\u7684uv__io_poll\u8fd9\u4e2a\u51fd\u6570\uff0c\u8fd9\u4e2a\u51fd\u6570\u6bd4\u8f83\u590d\u6742\uff0c\u6211\u4eec\u5206\u5f00\u5206\u6790\u3002\u5728\u5f00\u59cb\u5206\u6790Poll IO\u4e4b\u524d\uff0c\u5148\u4e86\u89e3\u4e00\u4e0b\u5b83\u76f8\u5173\u7684\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u3002 1 IO\u89c2\u5bdf\u8005uv__io_t\u3002\u8fd9\u4e2a\u7ed3\u6784\u4f53\u662fPoll IO\u9636\u6bb5\u6838\u5fc3\u7ed3\u6784\u4f53\u3002\u5b83\u4e3b\u8981\u662f\u4fdd\u5b58\u4e86IO\u76f8\u5173\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u56de \u8c03\u3001\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u7b49\u4fe1\u606f\u3002 2 watcher_queue\u89c2\u5bdf\u8005\u961f\u5217\u3002\u6240\u6709\u9700\u8981Libuv\u5904\u7406\u7684IO\u89c2\u5bdf\u8005\u90fd\u6302\u8f7d\u5728\u8fd9\u4e2a\u961f\u5217\u91cc\uff0cLibuv\u5728Poll IO\u9636\u6bb5\u4f1a\u9010\u4e2a\u5904\u7406\u3002 \u4e0b\u9762\u6211\u4eec\u5f00\u59cb\u5206\u6790Poll IO\u9636\u6bb5\u3002\u5148\u770b\u7b2c\u4e00\u6bb5\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // \u6ca1\u6709IO\u89c2\u5bdf\u8005\uff0c\u5219\u76f4\u63a5\u8fd4\u56de if ( loop -> nfds == 0 ) { assert ( QUEUE_EMPTY ( & loop -> watcher_queue )); return ; } // \u904d\u5386IO\u89c2\u5bdf\u8005\u961f\u5217 while ( ! QUEUE_EMPTY ( & loop -> watcher_queue )) { // \u53d6\u51fa\u5f53\u524d\u5934\u8282\u70b9 q = QUEUE_HEAD ( & loop -> watcher_queue ); // \u8131\u79bb\u961f\u5217 QUEUE_REMOVE ( q ); // \u521d\u59cb\u5316\uff08\u91cd\u7f6e\uff09\u8282\u70b9\u7684\u524d\u540e\u6307\u9488 QUEUE_INIT ( q ); // \u901a\u8fc7\u7ed3\u6784\u4f53\u6210\u529f\u83b7\u53d6\u7ed3\u6784\u4f53\u9996\u5730\u5740 w = QUEUE_DATA ( q , uv__io_t , watcher_queue ); // \u8bbe\u7f6e\u5f53\u524d\u611f\u5174\u8da3\u7684\u4e8b\u4ef6 e . events = w -> pevents ; /* \u8fd9\u91cc\u4f7f\u7528\u4e86fd\u5b57\u6bb5\uff0c\u4e8b\u4ef6\u89e6\u53d1\u540e\u518d\u901a\u8fc7fd\u4ecewatchs \u5b57\u6bb5\u91cc\u627e\u5230\u5bf9\u5e94\u7684IO\u89c2\u5bdf\u8005\uff0c\u6ca1\u6709\u4f7f\u7528ptr\u6307\u5411IO\u89c2\u5bdf\u8005\u7684\u65b9\u6848 */ e . data . fd = w -> fd ; // \u5982\u679cw->events\u521d\u59cb\u5316\u7684\u65f6\u5019\u4e3a0\uff0c\u5219\u65b0\u589e\uff0c\u5426\u5219\u4fee\u6539 if ( w -> events == 0 ) op = EPOLL_CTL_ADD ; else op = EPOLL_CTL_MOD ; // \u4fee\u6539epoll\u7684\u6570\u636e epoll_ctl ( loop -> backend_fd , op , w -> fd , & e ) // \u8bb0\u5f55\u5f53\u524d\u52a0\u5230epoll\u65f6\u7684\u72b6\u6001 w -> events = w -> pevents ; } \u7b2c\u4e00\u6b65\u9996\u5148\u904d\u5386IO\u89c2\u5bdf\u8005\uff0c\u4fee\u6539epoll\u7684\u6570\u636e\u3002\u7136\u540e\u51c6\u5907\u8fdb\u5165\u7b49\u5f85\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 psigset = NULL ; if ( loop -> flags & UV_LOOP_BLOCK_SIGPROF ) { sigemptyset ( & sigset ); sigaddset ( & sigset , SIGPROF ); psigset = & sigset ; } /* http://man7.org/Linux/man-pages/man2/epoll_wait.2.html pthread_sigmask(SIG_SETMASK, &sigmask, &origmask); ready = epoll_wait(epfd, &events, maxevents, timeout); pthread_sigmask(SIG_SETMASK, &origmask, NULL); \u5373\u5c4f\u853dSIGPROF\u4fe1\u53f7\uff0c\u907f\u514dSIGPROF\u4fe1\u53f7\u5524\u9192epoll_wait\uff0c\u4f46\u662f\u5374\u6ca1 \u6709\u5c31\u7eea\u7684\u4e8b\u4ef6 */ nfds = epoll_pwait ( loop -> backend_fd , events , ARRAY_SIZE ( events ), timeout , psigset ); // epoll\u53ef\u80fd\u963b\u585e\uff0c\u8fd9\u91cc\u9700\u8981\u66f4\u65b0\u4e8b\u4ef6\u5faa\u73af\u7684\u65f6\u95f4 uv__update_time ( loop ) ``` epoll_wait\u53ef\u80fd\u4f1a\u5f15\u8d77\u4e3b\u7ebf\u7a0b\u963b\u585e\uff0c\u6240\u4ee5wait\u8fd4\u56de\u540e\u9700\u8981\u66f4\u65b0\u5f53\u524d\u7684\u65f6\u95f4\uff0c\u5426\u5219\u5728\u4f7f\u7528\u7684\u65f6\u5019\u65f6\u95f4\u5dee\u4f1a\u6bd4\u8f83\u5927\uff0c\u56e0\u4e3aLibuv\u4f1a\u5728\u6bcf\u8f6e\u65f6\u95f4\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\u7f13\u5b58\u5f53\u524d\u65f6\u95f4\u8fd9\u4e2a\u503c\u3002\u5176\u5b83\u5730\u65b9\u76f4\u63a5\u4f7f\u7528\uff0c\u800c\u4e0d\u662f\u6bcf\u6b21\u90fd\u53bb\u83b7\u53d6\u3002\u4e0b\u9762\u6211\u4eec\u63a5\u7740\u770bepoll\u8fd4\u56de\u540e\u7684\u5904\u7406\uff08\u5047\u8bbe\u6709\u4e8b\u4ef6\u89e6\u53d1\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // \u4fdd\u5b58epoll_wait\u8fd4\u56de\u7684\u4e00\u4e9b\u6570\u636e\uff0cmaybe_resize\u7533\u8bf7\u7a7a\u95f4\u7684\u65f6\u5019+2\u4e86 loop -> watchers [ loop -> nwatchers ] = ( void * ) events ; loop -> watchers [ loop -> nwatchers + 1 ] = ( void * ) ( uintptr_t ) nfds ; for ( i = 0 ; i < nfds ; i ++ ) { // \u89e6\u53d1\u7684\u4e8b\u4ef6\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26 pe = events + i ; fd = pe -> data . fd ; // \u6839\u636efd\u83b7\u53d6IO\u89c2\u5bdf\u8005\uff0c\u89c1\u4e0a\u9762\u7684\u56fe w = loop -> watchers [ fd ]; // \u4f1a\u5176\u5b83\u56de\u8c03\u91cc\u88ab\u5220\u9664\u4e86\uff0c\u5219\u4eceepoll\u4e2d\u5220\u9664 if ( w == NULL ) { epoll_ctl ( loop -> backend_fd , EPOLL_CTL_DEL , fd , pe ); continue ; } if ( pe -> events != 0 ) { /* \u7528\u4e8e\u4fe1\u53f7\u5904\u7406\u7684IO\u89c2\u5bdf\u8005\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u89e6\u53d1\u4e86\uff0c \u5373\u6709\u4fe1\u53f7\u53d1\u751f\u3002 */ if ( w == & loop -> signal_io_watcher ) have_signals = 1 ; else // \u4e00\u822c\u7684IO\u89c2\u5bdf\u8005\u5219\u6267\u884c\u56de\u8c03 w -> cb ( loop , w , pe -> events ); nevents ++ ; } } // \u6709\u4fe1\u53f7\u53d1\u751f\uff0c\u89e6\u53d1\u56de\u8c03 if ( have_signals != 0 ) loop -> signal_io_watcher . cb ( loop , & loop -> signal_io_watcher , POLLIN ); \u4e0a\u9762\u7684\u4ee3\u7801\u5904\u7406IO\u4e8b\u4ef6\u5e76\u6267\u884cIO\u89c2\u5bdf\u8005\u91cc\u7684\u56de\u8c03\uff0c\u4f46\u662f\u6709\u4e00\u4e2a\u7279\u6b8a\u7684\u5730\u65b9\u5c31\u662f\u4fe1\u53f7\u5904\u7406\u7684IO\u89c2\u5bdf\u8005\u9700\u8981\u5355\u72ec\u5224\u65ad\uff0c\u5b83\u662f\u4e00\u4e2a\u5168\u5c40\u7684IO\u89c2\u5bdf\u8005\uff0c\u548c\u4e00\u822c\u52a8\u6001\u7533\u8bf7\u548c\u9500\u6bc1\u7684IO\u89c2\u5bdf\u8005\u4e0d\u4e00\u6837\uff0c\u5b83\u662f\u5b58\u5728\u4e8eLibuv\u8fd0\u884c\u7684\u6574\u4e2a\u751f\u547d\u5468\u671f\u3002\u8fd9\u5c31\u662fPoll IO\u7684\u6574\u4e2a\u8fc7\u7a0b\u3002","title":"3.4 \u4e8b\u4ef6\u5faa\u73af\u4e4bPoll IO"},{"location":"chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/#35-close","text":"close\u662fLibuv\u6bcf\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e2d\u6700\u540e\u7684\u4e00\u4e2a\u9636\u6bb5\u3002uv_close\u7528\u4e8e\u5173\u95ed\u4e00\u4e2ahandle\uff0c\u5e76\u4e14\u6267\u884c\u4e00\u4e2a\u56de\u8c03\u3002uv_close\u4ea7\u751f\u7684\u4efb\u52a1\u4f1a\u63d2\u5165\u5230close\u9636\u6bb5\u7684\u961f\u5217\uff0c\u7136\u540e\u5728close\u9636\u6bb5\u88ab\u5904\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0buv_close\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void uv_close ( uv_handle_t * handle , uv_close_cb close_cb ) { // \u6b63\u5728\u5173\u95ed\uff0c\u4f46\u662f\u8fd8\u6ca1\u6267\u884c\u56de\u8c03\u7b49\u540e\u7f6e\u64cd\u4f5c handle -> flags |= UV_HANDLE_CLOSING ; handle -> close_cb = close_cb ; switch ( handle -> type ) { case UV_PREPARE : uv__prepare_close (( uv_prepare_t * ) handle ); break ; case UV_CHECK : uv__check_close (( uv_check_t * ) handle ); break ; ... default : assert ( 0 ); } uv__make_close_pending ( handle ); } uv_close\u8bbe\u7f6e\u56de\u8c03\u548c\u72b6\u6001\uff0c\u7136\u540e\u6839\u636ehandle\u7c7b\u578b\u8c03\u5bf9\u5e94\u7684close\u51fd\u6570\uff0c\u4e00\u822c\u5c31\u662fstop\u8fd9\u4e2ahandle\uff0c\u89e3\u9664IO\u89c2\u5bdf\u8005\u6ce8\u518c\u7684\u4e8b\u4ef6\uff0c\u4ece\u4e8b\u4ef6\u5faa\u73af\u7684handle\u961f\u5217\u79fb\u9664\u8be5handle\u7b49\u7b49\uff0c\u6bd4\u5982prepare\u7684close\u51fd\u6570\u53ea\u662f\u628ahandle\u4ece\u961f\u5217\u4e2d\u79fb\u9664\u3002 1 2 3 4 5 6 7 8 void uv__prepare_close ( uv_prepare_t * handle ) { uv_prepare_stop ( handle ); } int uv_prepare_stop ( uv_prepare__t * handle ) { QUEUE_REMOVE ( & handle -> queue ); uv__handle_stop ( handle ); return 0 ; } \u6839\u636e\u4e0d\u540c\u7684handle\u505a\u4e0d\u540c\u7684\u5904\u7406\u540e\uff0c\u63a5\u7740\u6267\u884cuv__make_close_pending\u5f80close\u961f\u5217\u8ffd\u52a0\u8282\u70b9\u3002 1 2 3 4 5 // \u5934\u63d2\u6cd5\u63d2\u5165closing\u961f\u5217\uff0c\u5728closing\u9636\u6bb5\u88ab\u6267\u884c void uv__make_close_pending ( uv_handle_t * handle ) { handle -> next_closing = handle -> loop -> closing_handles ; handle -> loop -> closing_handles = handle ; } \u7136\u540e\u5728close\u9636\u6bb5\u9010\u4e2a\u5904\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0bclose\u9636\u6bb5\u7684\u5904\u7406\u903b\u8f91 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // \u6267\u884cclosing\u9636\u6bb5\u7684\u7684\u56de\u8c03 static void uv__run_closing_handles ( uv_loop_t * loop ) { uv_handle_t * p ; uv_handle_t * q ; p = loop -> closing_handles ; loop -> closing_handles = NULL ; while ( p ) { q = p -> next_closing ; uv__finish_close ( p ); p = q ; } } // \u6267\u884cclosing\u9636\u6bb5\u7684\u56de\u8c03 static void uv__finish_close ( uv_handle_t * handle ) { handle -> flags |= UV_HANDLE_CLOSED ; ... uv__handle_unref ( handle ); // \u4ecehandle\u961f\u5217\u91cc\u79fb\u9664 QUEUE_REMOVE ( & handle -> handle_queue ); if ( handle -> close_cb ) { handle -> close_cb ( handle ); } } uv__run_closing_handles\u4f1a\u9010\u4e2a\u6267\u884c\u6bcf\u4e2a\u4efb\u52a1\u8282\u70b9\u7684\u56de\u8c03\u3002","title":"3.5 \u4e8b\u4ef6\u5faa\u73af\u4e4bclose"},{"location":"chapter03-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/#36","text":"Libuv\u901a\u8fc7uv__loop_alive\u51fd\u6570\u5224\u65ad\u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u8fd8\u9700\u8981\u7ee7\u7eed\u6267\u884c\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 static int uv__loop_alive ( const uv_loop_t * loop ) { return uv__has_active_handles ( loop ) || uv__has_active_reqs ( loop ) || loop -> closing_handles != NULL ; } \u4e3a\u4ec0\u4e48\u4f1a\u6709\u4e00\u4e2aclosing_handle\u7684\u5224\u65ad\u5462\uff1f\u4eceuv_run\u7684\u4ee3\u7801\u6765\u770b\uff0c\u6267\u884c\u5b8cclose\u9636\u6bb5\u540e\uff0c\u4f1a\u7acb\u523b\u6267\u884cuv__loop_alive\uff0c\u6b63\u5e38\u6765\u8bf4\uff0cclose\u9636\u6bb5\u7684\u961f\u5217\u662f\u7a7a\u7684\uff0c\u4f46\u662f\u5982\u679c\u6211\u4eec\u5728close\u56de\u8c03\u91cc\u53c8\u5f80close\u961f\u5217\u65b0\u589e\u4e86\u4e00\u4e2a\u8282\u70b9\uff0c\u800c\u8be5\u8282\u70b9\u4e0d\u4f1a\u5728\u672c\u8f6e\u7684close\u9636\u6bb5\u88ab\u6267\u884c\uff0c\u8fd9\u6837\u4f1a\u5bfc\u81f4\u6267\u884c\u5b8cclose\u9636\u6bb5\uff0c\u4f46\u662fclose\u961f\u5217\u4f9d\u7136\u6709\u8282\u70b9\uff0c\u5982\u679c\u76f4\u63a5\u9000\u51fa\uff0c\u5219\u65e0\u6cd5\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u3002 \u6211\u4eec\u770b\u5230\u6709\u4e09\u79cd\u60c5\u51b5\uff0cLibuv\u8ba4\u4e3a\u4e8b\u4ef6\u5faa\u73af\u662f\u5b58\u6d3b\u7684\u3002\u5982\u679c\u6211\u4eec\u63a7\u5236\u8fd9\u4e09\u79cd\u6761\u4ef6\u5c31\u53ef\u4ee5\u63a7\u5236\u4e8b\u4ef6\u5faa\u73af\u7684\u7684\u9000\u51fa\u3002\u6211\u4eec\u901a\u8fc7\u4e00\u4e2a\u4f8b\u5b50\u7406\u89e3\u4e00\u4e0b\u8fd9\u4e2a\u8fc7\u7a0b\u3002 1 2 3 4 const timeout = setTimeout (() => { console . log ( 'never console' ) }, 5000 ); timeout . unref (); \u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0csetTimeout\u7684\u56de\u8c03\u662f\u4e0d\u4f1a\u6267\u884c\u7684\u3002\u9664\u975e\u8d85\u65f6\u65f6\u95f4\u975e\u5e38\u77ed\uff0c\u77ed\u5230\u7b2c\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u7684\u65f6\u5019\u5c31\u5230\u671f\u4e86\uff0c\u5426\u5219\u5728\u7b2c\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e4b\u540e\uff0c\u7531\u4e8eunref\u7684\u5f71\u54cd\uff0c\u4e8b\u4ef6\u5faa\u73af\u76f4\u63a5\u9000\u51fa\u4e86\u3002unref\u5f71\u54cd\u7684\u5c31\u662fhandle\u8fd9\u4e2a\u6761\u4ef6\u3002\u8fd9\u65f6\u5019\u4e8b\u4ef6\u5faa\u73af\u4ee3\u7801\u5982\u4e0b\u3002 1 2 3 4 5 6 7 while ( r != 0 && loop -> stop_flag == 0 ) { uv__update_time ( loop ); uv__run_timers ( loop ); // ... // uv__loop_alive\u8fd4\u56defalse\uff0c\u76f4\u63a5\u8df3\u51fawhile\uff0c\u4ece\u800c\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af r = uv__loop_alive ( loop ); }","title":"3.6 \u63a7\u5236\u4e8b\u4ef6\u5faa\u73af"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/","text":"\u7b2c\u56db\u7ae0 \u7ebf\u7a0b\u6c60 \u00b6 Libuv\u662f\u5355\u7ebf\u7a0b\u4e8b\u4ef6\u9a71\u52a8\u7684\u5f02\u6b65IO\u5e93\uff0c\u5bf9\u4e8e\u963b\u585e\u5f0f\u6216\u8017\u65f6\u7684\u64cd\u4f5c\uff0c\u5982\u679c\u5728Libuv\u7684\u4e3b\u5faa\u73af\u91cc\u6267\u884c\u7684\u8bdd\uff0c\u5c31\u4f1a\u963b\u585e\u540e\u9762\u7684\u4efb\u52a1\u6267\u884c\uff0c\u6240\u4ee5Libuv\u91cc\u7ef4\u62a4\u4e86\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u5b83\u8d1f\u8d23\u5904\u7406Libuv\u4e2d\u8017\u65f6\u6216\u8005\u5bfc\u81f4\u963b\u585e\u7684\u64cd\u4f5c\uff0c\u6bd4\u5982\u6587\u4ef6IO\u3001DNS\u3001\u81ea\u5b9a\u4e49\u7684\u8017\u65f6\u4efb\u52a1\u3002\u7ebf\u7a0b\u6c60\u5728Libuv\u67b6\u6784\u4e2d\u7684\u4f4d\u7f6e\u5982\u56fe4-1\u6240\u793a\u3002 Libuv\u4e3b\u7ebf\u7a0b\u901a\u8fc7\u7ebf\u7a0b\u6c60\u63d0\u4f9b\u7684\u63a5\u53e3\u628a\u4efb\u52a1\u63d0\u4ea4\u7ed9\u7ebf\u7a0b\u6c60\uff0c\u7136\u540e\u7acb\u523b\u8fd4\u56de\u5230\u4e8b\u4ef6\u5faa\u73af\u4e2d\u7ee7\u7eed\u6267\u884c\uff0c\u7ebf\u7a0b\u6c60\u7ef4\u62a4\u4e86\u4e00\u4e2a\u4efb\u52a1\u961f\u5217\uff0c\u591a\u4e2a\u5b50\u7ebf\u7a0b\u4f1a\u4e92\u65a5\u5730\u4ece\u4e2d\u6458\u4e0b\u4efb\u52a1\u8282\u70b9\u6267\u884c\uff0c\u5f53\u5b50\u7ebf\u7a0b\u6267\u884c\u4efb\u52a1\u5b8c\u6bd5\u540e\u4f1a\u901a\u77e5\u4e3b\u7ebf\u7a0b\uff0c\u4e3b\u7ebf\u7a0b\u5728\u4e8b\u4ef6\u5faa\u73af\u7684Poll IO\u9636\u6bb5\u5c31\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u7ebf\u7a0b\u6c60\u5728Libuv\u4e2d\u7684\u5b9e\u73b0\u3002 4.1\u4e3b\u7ebf\u7a0b\u548c\u5b50\u7ebf\u7a0b\u95f4\u901a\u4fe1 \u00b6 Libuv\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u7684\u901a\u4fe1\u662f\u4f7f\u7528uv_async_t\u7ed3\u6784\u4f53\u5b9e\u73b0\u7684\u3002Libuv\u4f7f\u7528loop->async_handles\u961f\u5217\u8bb0\u5f55\u6240\u6709\u7684uv_async_t\u7ed3\u6784\u4f53\uff0c\u4f7f\u7528loop->async_io_watcher\u4f5c\u4e3a\u6240\u6709uv_async_t\u7ed3\u6784\u4f53\u7684IO\u89c2\u5bdf\u8005\uff0c\u5373loop-> async_handles\u961f\u5217\u4e0a\u6240\u6709\u7684handle\u90fd\u662f\u5171\u4eabasync_io_watcher\u8fd9\u4e2aIO\u89c2\u5bdf\u8005\u7684\u3002\u7b2c\u4e00\u6b21\u63d2\u5165\u4e00\u4e2auv_async_t\u7ed3\u6784\u4f53\u5230async_handle\u961f\u5217\u65f6\uff0c\u4f1a\u521d\u59cb\u5316IO\u89c2\u5bdf\u8005\uff0c\u5982\u679c\u518d\u6b21\u6ce8\u518c\u4e00\u4e2aasync_handle\uff0c\u53ea\u4f1a\u5728loop->async_handle\u961f\u5217\u548chandle\u961f\u5217\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u800c\u4e0d\u4f1a\u65b0\u589e\u4e00\u4e2aIO\u89c2\u5bdf\u8005\u3002\u5f53uv_async_t\u7ed3\u6784\u4f53\u5bf9\u5e94\u7684\u4efb\u52a1\u5b8c\u6210\u65f6\uff0c\u5b50\u7ebf\u7a0b\u4f1a\u8bbe\u7f6eIO\u89c2\u5bdf\u8005\u4e3a\u53ef\u8bfb\u3002Libuv\u5728\u4e8b\u4ef6\u5faa\u73af\u7684Poll IO\u9636\u6bb5\u5c31\u4f1a\u5904\u7406IO\u89c2\u5bdf\u8005\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0buv_async_t\u5728Libuv\u4e2d\u7684\u4f7f\u7528\u3002 4.1.1 \u521d\u59cb\u5316 \u00b6 \u4f7f\u7528uv_async_t\u4e4b\u524d\u9996\u5148\u9700\u8981\u6267\u884cuv_async_init\u8fdb\u884c\u521d\u59cb\u5316\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int uv_async_init ( uv_loop_t * loop , uv_async_t * handle , uv_async_cb async_cb ) { int err ; // \u7ed9Libuv\u6ce8\u518c\u4e00\u4e2a\u89c2\u5bdf\u8005io err = uv__async_start ( loop ); if ( err ) return err ; // \u8bbe\u7f6e\u76f8\u5173\u5b57\u6bb5\uff0c\u7ed9Libuv\u63d2\u5165\u4e00\u4e2ahandle uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_ASYNC ); // \u8bbe\u7f6e\u56de\u8c03 handle -> async_cb = async_cb ; // \u521d\u59cb\u5316\u6807\u8bb0\u5b57\u6bb5\uff0c0\u8868\u793a\u6ca1\u6709\u4efb\u52a1\u5b8c\u6210 handle -> pending = 0 ; // \u628auv_async_t\u63d2\u5165async_handle\u961f\u5217 QUEUE_INSERT_TAIL ( & loop -> async_handles , & handle -> queue ); uv__handle_start ( handle ); return 0 ; } uv_async_init\u51fd\u6570\u4e3b\u8981\u521d\u59cb\u5316\u7ed3\u6784\u4f53uv_async_t\u7684\u4e00\u4e9b\u5b57\u6bb5\uff0c\u7136\u540e\u6267\u884cQUEUE_INSERT_TAIL\u7ed9Libuv\u7684async_handles\u961f\u5217\u8ffd\u52a0\u4e00\u4e2a\u8282\u70b9\u3002\u6211\u4eec\u770b\u5230\u8fd8\u6709\u4e00\u4e2auv__async_start\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0buv__async_start\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 static int uv__async_start ( uv_loop_t * loop ) { int pipefd [ 2 ]; int err ; // uv__async_start\u53ea\u6267\u884c\u4e00\u6b21\uff0c\u6709fd\u5219\u4e0d\u9700\u8981\u6267\u884c\u4e86 if ( loop -> async_io_watcher . fd != -1 ) return 0 ; // \u83b7\u53d6\u4e00\u4e2a\u7528\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684fd\uff08Linux\u7684eventfd\u673a\u5236\uff09 err = uv__async_eventfd (); /* \u6210\u529f\u5219\u4fdd\u5b58fd\uff0c\u5931\u8d25\u8bf4\u660e\u4e0d\u652f\u6301eventfd\uff0c \u5219\u4f7f\u7528\u7ba1\u9053\u901a\u4fe1\u4f5c\u4e3a\u8fdb\u7a0b\u95f4\u901a\u4fe1 */ if ( err >= 0 ) { pipefd [ 0 ] = err ; pipefd [ 1 ] = -1 ; } else if ( err == UV_ENOSYS ) { // \u4e0d\u652f\u6301eventfd\u5219\u4f7f\u7528\u533f\u540d\u7ba1\u9053 err = uv__make_pipe ( pipefd , UV__F_NONBLOCK ); #if defined(__Linux__) if ( err == 0 ) { char buf [ 32 ]; int fd ; snprintf ( buf , sizeof ( buf ), \"/proc/self/fd/%d\" , pipefd [ 0 ]); // \u901a\u8fc7\u4e00\u4e2afd\u5c31\u53ef\u4ee5\u5b9e\u73b0\u5bf9\u7ba1\u9053\u7684\u8bfb\u5199\uff0c\u9ad8\u7ea7\u7528\u6cd5 fd = uv__open_cloexec ( buf , O_RDWR ); if ( fd >= 0 ) { // \u5173\u6389\u65e7\u7684 uv__close ( pipefd [ 0 ]); uv__close ( pipefd [ 1 ]); // \u8d4b\u503c\u65b0\u7684 pipefd [ 0 ] = fd ; pipefd [ 1 ] = fd ; } } #endif } // err\u5927\u4e8e\u7b49\u4e8e0\u8bf4\u660e\u62ff\u5230\u4e86\u901a\u4fe1\u7684\u8bfb\u5199\u4e24\u7aef if ( err < 0 ) return err ; /* \u521d\u59cb\u5316IO\u89c2\u5bdf\u8005async_io_watcher\uff0c \u628a\u8bfb\u7aef\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5230IO\u89c2\u5bdf\u8005 */ uv__io_init ( & loop -> async_io_watcher , uv__async_io , pipefd [ 0 ]); // \u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230loop\u91cc\uff0c\u5e76\u6ce8\u518c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6POLLIN\uff0c\u7b49\u5f85\u53ef\u8bfb uv__io_start ( loop , & loop -> async_io_watcher , POLLIN ); // \u4fdd\u5b58\u5199\u7aef\u6587\u4ef6\u63cf\u8ff0\u7b26 loop -> async_wfd = pipefd [ 1 ]; return 0 ; } uv__async_start\u53ea\u4f1a\u6267\u884c\u4e00\u6b21\uff0c\u65f6\u673a\u5728\u7b2c\u4e00\u6b21\u6267\u884cuv_async_init\u7684\u65f6\u5019\u3002uv__async_start\u4e3b\u8981\u7684\u903b\u8f91\u5982\u4e0b 1 \u83b7\u53d6\u901a\u4fe1\u63cf\u8ff0\u7b26\uff08\u901a\u8fc7eventfd\u751f\u6210\u4e00\u4e2a\u901a\u4fe1\u7684fd\uff08\u5145\u5f53\u8bfb\u5199\u4e24\u7aef\uff09\u6216\u8005\u7ba1\u9053\u751f\u6210\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u4e24\u4e2afd\u8868\u793a\u8bfb\u7aef\u548c\u5199\u7aef\uff09\u3002 2 \u5c01\u88c5\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u548c\u56de\u8c03\u5230IO\u89c2\u5bdf\u8005\u7136\u540e\u8ffd\u52a0\u5230watcher_queue\u961f\u5217\uff0c\u5728Poll IO\u9636\u6bb5\uff0cLibuv\u4f1a\u6ce8\u518c\u5230epoll\u91cc\u9762\uff0c\u5982\u679c\u6709\u4efb\u52a1\u5b8c\u6210\uff0c\u4e5f\u4f1a\u5728Poll IO\u9636\u6bb5\u6267\u884c\u56de\u8c03\u3002 3 \u4fdd\u5b58\u5199\u7aef\u63cf\u8ff0\u7b26\u3002\u4efb\u52a1\u5b8c\u6210\u65f6\u901a\u8fc7\u5199\u7aeffd\u901a\u77e5\u4e3b\u7ebf\u7a0b\u3002 \u6211\u4eec\u770b\u5230uv__async_start\u51fd\u6570\u91cc\u6709\u5f88\u591a\u83b7\u53d6\u901a\u4fe1\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u903b\u8f91\uff0c\u603b\u7684\u6765\u8bf4\uff0c\u662f\u4e3a\u4e86\u5b8c\u6210\u4e24\u7aef\u901a\u4fe1\u7684\u529f\u80fd\u3002\u521d\u59cb\u5316async\u7ed3\u6784\u4f53\u540e\uff0cLibuv\u7ed3\u6784\u5982\u56fe4-2\u6240\u793a\u3002 4.1.2 \u901a\u77e5\u4e3b\u7ebf\u7a0b \u00b6 \u521d\u59cb\u5316async\u7ed3\u6784\u4f53\u540e\uff0c\u5982\u679casync\u7ed3\u6784\u4f53\u5bf9\u5e94\u7684\u4efb\u52a1\u5b8c\u6210\u540e\uff0c\u5c31\u4f1a\u901a\u77e5\u4e3b\u7ebf\u7a0b\uff0c\u5b50\u7ebf\u7a0b\u901a\u8fc7\u8bbe\u7f6e\u8fd9\u4e2ahandle\u7684pending\u4e3a1\u6807\u8bb0\u4efb\u52a1\u5b8c\u6210\uff0c\u7136\u540e\u518d\u5f80\u7ba1\u9053\u5199\u7aef\u5199\u5165\u6807\u8bb0\uff0c\u901a\u77e5\u4e3b\u7ebf\u7a0b\u6709\u4efb\u52a1\u5b8c\u6210\u4e86\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 int uv_async_send ( uv_async_t * handle ) { /* Do a cheap read first. */ if ( ACCESS_ONCE ( int , handle -> pending ) != 0 ) return 0 ; /* \u5982pending\u662f0\uff0c\u5219\u8bbe\u7f6e\u4e3a1\uff0c\u8fd4\u56de0\uff0c\u5982\u679c\u662f1\u5219\u8fd4\u56de1\uff0c \u6240\u4ee5\u5982\u679c\u591a\u6b21\u8c03\u7528\u8be5\u51fd\u6570\u662f\u4f1a\u88ab\u5408\u5e76\u7684 */ if ( cmpxchgi ( & handle -> pending , 0 , 1 ) == 0 ) uv__async_send ( handle -> loop ); return 0 ; } static void uv__async_send ( uv_loop_t * loop ) { const void * buf ; ssize_t len ; int fd ; int r ; buf = \"\" ; len = 1 ; fd = loop -> async_wfd ; #if defined(__Linux__) // \u8bf4\u660e\u7528\u7684\u662feventfd\u800c\u4e0d\u662f\u7ba1\u9053,eventfd\u65f6\u8bfb\u5199\u4e24\u7aef\u5bf9\u5e94\u540c\u4e00\u4e2afd if ( fd == -1 ) { static const uint64_t val = 1 ; buf = & val ; len = sizeof ( val ); // \u89c1uv__async_start fd = loop -> async_io_watcher . fd ; /* eventfd */ } #endif // \u901a\u77e5\u8bfb\u7aef do r = write ( fd , buf , len ); while ( r == -1 && errno == EINTR ); if ( r == len ) return ; if ( r == -1 ) if ( errno == EAGAIN || errno == EWOULDBLOCK ) return ; abort (); } uv_async_send\u9996\u5148\u62ff\u5230\u5199\u7aef\u5bf9\u5e94\u7684fd\uff0c\u7136\u540e\u8c03\u7528write\u51fd\u6570\uff0c\u6b64\u65f6\uff0c\u5f80\u7ba1\u9053\u7684\u5199\u7aef\u5199\u5165\u6570\u636e\uff0c\u6807\u8bb0\u6709\u4efb\u52a1\u5b8c\u6210\u3002\u6709\u5199\u5219\u5fc5\u7136\u6709\u8bfb\u3002\u8bfb\u7684\u903b\u8f91\u662f\u5728uv__io_poll\u4e2d\u5b9e\u73b0\u7684\u3002uv__io_poll\u51fd\u6570\u5373Libuv\u4e2dPoll IO\u9636\u6bb5\u6267\u884c\u7684\u51fd\u6570\u3002\u5728uv__io_poll\u4e2d\u4f1a\u53d1\u73b0\u7ba1\u9053\u53ef\u8bfb\uff0c\u7136\u540e\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03uv__async_io\u3002 4.1.3 \u4e3b\u7ebf\u7a0b\u5904\u7406\u56de\u8c03 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 static void uv__async_io ( uv_loop_t * loop , uv__io_t * w , unsigned int events ) { char buf [ 1024 ]; ssize_t r ; QUEUE queue ; QUEUE * q ; uv_async_t * h ; for (;;) { // \u6d88\u8d39\u6240\u6709\u7684\u6570\u636e r = read ( w -> fd , buf , sizeof ( buf )); // \u6570\u636e\u5927\u5c0f\u5927\u4e8ebuf\u957f\u5ea6\uff081024\uff09\uff0c\u5219\u7ee7\u7eed\u6d88\u8d39 if ( r == sizeof ( buf )) continue ; // \u6210\u529f\u6d88\u8d39\u5b8c\u6bd5\uff0c\u8df3\u51fa\u6d88\u8d39\u7684\u903b\u8f91 if ( r != -1 ) break ; // \u8bfb\u7e41\u5fd9 if ( errno == EAGAIN || errno == EWOULDBLOCK ) break ; // \u8bfb\u88ab\u4e2d\u65ad\uff0c\u7ee7\u7eed\u8bfb if ( errno == EINTR ) continue ; abort (); } // \u628aasync_handles\u961f\u5217\u91cc\u7684\u6240\u6709\u8282\u70b9\u90fd\u79fb\u5230queue\u53d8\u91cf\u4e2d QUEUE_MOVE ( & loop -> async_handles , & queue ); while ( ! QUEUE_EMPTY ( & queue )) { // \u9010\u4e2a\u53d6\u51fa\u8282\u70b9 q = QUEUE_HEAD ( & queue ); // \u6839\u636e\u7ed3\u6784\u4f53\u5b57\u6bb5\u83b7\u53d6\u7ed3\u6784\u4f53\u9996\u5730\u5740 h = QUEUE_DATA ( q , uv_async_t , queue ); // \u4ece\u961f\u5217\u4e2d\u79fb\u9664\u8be5\u8282\u70b9 QUEUE_REMOVE ( q ); // \u91cd\u65b0\u63d2\u5165async_handles\u961f\u5217\uff0c\u7b49\u5f85\u4e0b\u6b21\u4e8b\u4ef6 QUEUE_INSERT_TAIL ( & loop -> async_handles , q ); /* \u5c06\u7b2c\u4e00\u4e2a\u53c2\u6570\u548c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u8fdb\u884c\u6bd4\u8f83\uff0c\u5982\u679c\u76f8\u7b49\uff0c \u5219\u5c06\u7b2c\u4e09\u53c2\u6570\u5199\u5165\u7b2c\u4e00\u4e2a\u53c2\u6570\uff0c\u8fd4\u56de\u7b2c\u4e8c\u4e2a\u53c2\u6570\u7684\u503c\uff0c \u5982\u679c\u4e0d\u76f8\u7b49\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u53c2\u6570\u7684\u503c\u3002 */ /* \u5224\u65ad\u89e6\u53d1\u4e86\u54ea\u4e9basync\u3002pending\u5728uv_async_send\u91cc\u8bbe\u7f6e\u62101\uff0c \u5982\u679cpending\u7b49\u4e8e1\uff0c\u5219\u6e050\uff0c\u8fd4\u56de1.\u5982\u679cpending\u7b49\u4e8e0\uff0c\u5219\u8fd4\u56de0 */ if ( cmpxchgi ( & h -> pending , 1 , 0 ) == 0 ) continue ; if ( h -> async_cb == NULL ) continue ; // \u6267\u884c\u4e0a\u5c42\u56de\u8c03 h -> async_cb ( h ); } } uv__async_io\u4f1a\u904d\u5386async_handles\u961f\u5217\uff0cpending\u7b49\u4e8e1\u7684\u8bdd\u8bf4\u660e\u4efb\u52a1\u5b8c\u6210\uff0c\u7136\u540e\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u5e76\u6e05\u9664\u6807\u8bb0\u4f4d\u3002 4.2 \u7ebf\u7a0b\u6c60\u7684\u5b9e\u73b0 \u00b6 \u4e86\u89e3\u4e86Libuv\u4e2d\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u7684\u901a\u4fe1\u673a\u5236\u540e\uff0c\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u7ebf\u7a0b\u6c60\u7684\u5b9e\u73b0\u3002 4.2.1 \u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u5316 \u00b6 \u7ebf\u7a0b\u6c60\u662f\u61d2\u521d\u59cb\u5316\u7684\uff0cNode.js\u542f\u52a8\u7684\u65f6\u5019\uff0c\u5e76\u6ca1\u6709\u521b\u5efa\u5b50\u7ebf\u7a0b\uff0c\u800c\u662f\u5728\u63d0\u4ea4\u7b2c\u4e00\u4e2a\u4efb\u52a1\u7ed9\u7ebf\u7a0b\u6c60\u65f6\uff0c\u7ebf\u7a0b\u6c60\u624d\u5f00\u59cb\u521d\u59cb\u5316\u3002\u6211\u4eec\u5148\u770b\u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u5316\u903b\u8f91\uff0c\u7136\u540e\u518d\u770b\u5b83\u7684\u4f7f\u7528\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 static void init_threads ( void ) { unsigned int i ; const char * val ; // \u9ed8\u8ba4\u7ebf\u7a0b\u65704\u4e2a\uff0cstatic uv_thread_t default_threads[4]; nthreads = ARRAY_SIZE ( default_threads ); // \u5224\u65ad\u7528\u6237\u662f\u5426\u5728\u73af\u5883\u53d8\u91cf\u4e2d\u8bbe\u7f6e\u4e86\u7ebf\u7a0b\u6570\uff0c\u662f\u7684\u8bdd\u53d6\u7528\u6237\u5b9a\u4e49\u7684 val = getenv ( \"UV_THREADPOOL_SIZE\" ); if ( val != NULL ) nthreads = atoi ( val ); if ( nthreads == 0 ) nthreads = 1 ; // #define MAX_THREADPOOL_SIZE 128\u6700\u591a128\u4e2a\u7ebf\u7a0b if ( nthreads > MAX_THREADPOOL_SIZE ) nthreads = MAX_THREADPOOL_SIZE ; threads = default_threads ; // \u8d85\u8fc7\u9ed8\u8ba4\u5927\u5c0f\uff0c\u91cd\u65b0\u5206\u914d\u5185\u5b58 if ( nthreads > ARRAY_SIZE ( default_threads )) { threads = uv__malloc ( nthreads * sizeof ( threads [ 0 ])); } // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\uff0c\u7528\u4e8e\u6709\u4efb\u52a1\u65f6\u5524\u9192\u5b50\u7ebf\u7a0b\uff0c\u6ca1\u6709\u4efb\u52a1\u65f6\u6302\u8d77\u5b50\u7ebf\u7a0b if ( uv_cond_init ( & cond )) abort (); // \u521d\u59cb\u5316\u4e92\u65a5\u53d8\u91cf\uff0c\u7528\u4e8e\u591a\u4e2a\u5b50\u7ebf\u7a0b\u4e92\u65a5\u8bbf\u95ee\u4efb\u52a1\u961f\u5217 if ( uv_mutex_init ( & mutex )) abort (); // \u521d\u59cb\u5316\u4e09\u4e2a\u961f\u5217 QUEUE_INIT ( & wq ); QUEUE_INIT ( & slow_io_pending_wq ); QUEUE_INIT ( & run_slow_work_message ); // \u521b\u5efa\u591a\u4e2a\u7ebf\u7a0b\uff0c\u5de5\u4f5c\u51fd\u6570\u4e3aworker\uff0csem\u4e3aworker\u5165\u53c2 for ( i = 0 ; i < nthreads ; i ++ ) if ( uv_thread_create ( threads + i , worker , & sem )) abort (); } \u7ebf\u7a0b\u6c60\u521d\u59cb\u5316\u65f6\uff0c\u4f1a\u6839\u636e\u914d\u7f6e\u7684\u5b50\u7ebf\u7a0b\u6570\u521b\u5efa\u5bf9\u5e94\u6570\u91cf\u7684\u7ebf\u7a0b\u3002\u9ed8\u8ba4\u662f4\u4e2a\uff0c\u6700\u5927128\u4e2a\u5b50\u7ebf\u7a0b\uff08\u4e0d\u540c\u7248\u672c\u7684Libuv\u53ef\u80fd\u4f1a\u4e0d\u4e00\u6837\uff09\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u901a\u8fc7\u73af\u5883\u53d8\u91cf\u8bbe\u7f6e\u81ea\u5b9a\u4e49\u7684\u5927\u5c0f\u3002\u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u5316\u4e3b\u8981\u662f\u521d\u59cb\u5316\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\uff0c\u7136\u540e\u521b\u5efa\u591a\u4e2a\u7ebf\u7a0b\uff0c\u63a5\u7740\u5728\u6bcf\u4e2a\u7ebf\u7a0b\u91cc\u6267\u884cworker\u51fd\u6570\u5904\u7406\u4efb\u52a1\u3002\u540e\u9762\u6211\u4eec\u4f1a\u5206\u6790worker\u7684\u903b\u8f91\u3002 4.2.2 \u63d0\u4ea4\u4efb\u52a1\u5230\u7ebf\u7a0b\u6c60 \u00b6 \u4e86\u89e3\u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u5316\u4e4b\u540e\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4efb\u52a1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // \u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4e00\u4e2a\u4efb\u52a1 void uv__work_submit ( uv_loop_t * loop , struct uv__work * w , enum uv__work_kind kind , void ( * work )( struct uv__work * w ), void ( * done )( struct uv__work * w , int status )){ /* \u4fdd\u8bc1\u5df2\u7ecf\u521d\u59cb\u5316\u7ebf\u7a0b\uff0c\u5e76\u53ea\u6267\u884c\u4e00\u6b21\uff0c\u6240\u4ee5\u7ebf\u7a0b\u6c60\u662f\u5728\u63d0\u4ea4\u7b2c\u4e00\u4e2a \u4efb\u52a1\u7684\u65f6\u5019\u624d\u88ab\u521d\u59cb\u5316\uff0cinit_once -> init_threads */ uv_once ( & once , init_once ); w -> loop = loop ; w -> work = work ; w -> done = done ; post ( & w -> wq , kind ); } \u8fd9\u91cc\u628a\u4e1a\u52a1\u76f8\u5173\u7684\u51fd\u6570\u548c\u4efb\u52a1\u5b8c\u6210\u540e\u7684\u56de\u8c03\u51fd\u6570\u5c01\u88c5\u5230uv__work\u7ed3\u6784\u4f53\u4e2d\u3002uv__work\u7ed3\u6784\u5b9a\u4e49\u5982\u4e0b\u3002 1 2 3 4 5 6 struct uv__work { void ( * work )( struct uv__work * w ); void ( * done )( struct uv__work * w , int status ); struct uv_loop_s * loop ; void * wq [ 2 ]; }; \u7136\u540e\u8c03\u8c03\u7528post\u51fd\u6570\u5f80\u7ebf\u7a0b\u6c60\u7684\u961f\u5217\u4e2d\u52a0\u5165\u4e00\u4e2a\u65b0\u7684\u4efb\u52a1\u3002Libuv\u628a\u4efb\u52a1\u5206\u4e3a\u4e09\u79cd\u7c7b\u578b\uff0c\u6162IO\uff08DNS\u89e3\u6790\uff09\u3001\u5febIO\uff08\u6587\u4ef6\u64cd\u4f5c\uff09\u3001CPU\u5bc6\u96c6\u578b\u7b49\uff0ckind\u5c31\u662f\u8bf4\u660e\u4efb\u52a1\u7684\u7c7b\u578b\u7684\u3002\u6211\u4eec\u63a5\u7740\u770bpost\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 static void post ( QUEUE * q , enum uv__work_kind kind ) { // \u52a0\u9501\u8bbf\u95ee\u4efb\u52a1\u961f\u5217\uff0c\u56e0\u4e3a\u8fd9\u4e2a\u961f\u5217\u662f\u7ebf\u7a0b\u6c60\u5171\u4eab\u7684 uv_mutex_lock ( & mutex ); // \u7c7b\u578b\u662f\u6162IO if ( kind == UV__WORK_SLOW_IO ) { /* \u63d2\u5165\u6162IO\u5bf9\u5e94\u7684\u961f\u5217\uff0cLibuv\u8fd9\u4e2a\u7248\u672c\u628a\u4efb\u52a1\u5206\u4e3a\u51e0\u79cd\u7c7b\u578b\uff0c \u5bf9\u4e8e\u6162IO\u7c7b\u578b\u7684\u4efb\u52a1\uff0cLibuv\u662f\u5f80\u4efb\u52a1\u961f\u5217\u91cc\u9762\u63d2\u5165\u4e00\u4e2a\u7279\u6b8a\u7684\u8282\u70b9 run_slow_work_message\uff0c\u7136\u540e\u7528slow_io_pending_wq\u7ef4\u62a4\u4e86\u4e00\u4e2a\u6162IO \u4efb\u52a1\u7684\u961f\u5217\uff0c\u5f53\u5904\u7406\u5230run_slow_work_message\u8fd9\u4e2a\u8282\u70b9\u7684\u65f6\u5019\uff0c Libuv\u4f1a\u4eceslow_io_pending_wq\u961f\u5217\u91cc\u9010\u4e2a\u53d6\u51fa\u4efb\u52a1\u8282\u70b9\u6765\u6267\u884c\u3002 */ QUEUE_INSERT_TAIL ( & slow_io_pending_wq , q ); /* \u6709\u6162IO\u4efb\u52a1\u7684\u65f6\u5019\uff0c\u9700\u8981\u7ed9\u4e3b\u961f\u5217wq\u63d2\u5165\u4e00\u4e2a\u6d88\u606f\u8282\u70b9 run_slow_work_message,\u8bf4\u660e\u6709\u6162IO\u4efb\u52a1\uff0c\u6240\u4ee5\u5982\u679c run_slow_work_message\u662f\u7a7a\uff0c\u8bf4\u660e\u8fd8\u6ca1\u6709\u63d2\u5165\u4e3b\u961f\u5217\u3002\u9700\u8981\u8fdb\u884c q = &run_slow_work_message;\u8d4b\u503c\uff0c\u7136\u540e\u628a run_slow_work_message\u63d2\u5165\u4e3b\u961f\u5217\u3002\u5982\u679crun_slow_work_message \u975e\u7a7a\uff0c\u8bf4\u660e\u5df2\u7ecf\u63d2\u5165\u7ebf\u7a0b\u6c60\u7684\u4efb\u52a1\u961f\u5217\u4e86\u3002\u89e3\u9501\u7136\u540e\u76f4\u63a5\u8fd4\u56de\u3002 */ if ( ! QUEUE_EMPTY ( & run_slow_work_message )) { uv_mutex_unlock ( & mutex ); return ; } // \u8bf4\u660erun_slow_work_message\u8fd8\u6ca1\u6709\u63d2\u5165\u961f\u5217\uff0c\u51c6\u5907\u63d2\u5165\u961f\u5217 q = & run_slow_work_message ; } // \u628a\u8282\u70b9\u63d2\u5165\u4e3b\u961f\u5217\uff0c\u53ef\u80fd\u662f\u6162IO\u6d88\u606f\u8282\u70b9\u6216\u8005\u4e00\u822c\u4efb\u52a1 QUEUE_INSERT_TAIL ( & wq , q ); /* \u6709\u7a7a\u95f2\u7ebf\u7a0b\u5219\u5524\u9192\u5b83\uff0c\u5982\u679c\u5927\u5bb6\u90fd\u5728\u5fd9\uff0c \u5219\u7b49\u5230\u5b83\u5fd9\u5b8c\u540e\u5c31\u4f1a\u91cd\u65b0\u5224\u65ad\u662f\u5426\u8fd8\u6709\u65b0\u4efb\u52a1 */ if ( idle_threads > 0 ) uv_cond_signal ( & cond ); // \u64cd\u4f5c\u5b8c\u961f\u5217\uff0c\u89e3\u9501 uv_mutex_unlock ( & mutex ); } \u8fd9\u5c31\u662fLibuv\u4e2d\u7ebf\u7a0b\u6c60\u7684\u751f\u4ea7\u8005\u903b\u8f91\u3002\u4efb\u52a1\u961f\u5217\u7684\u67b6\u6784\u5982\u56fe4-3\u6240\u793a\u3002 \u9664\u4e86\u4e0a\u9762\u63d0\u5230\u7684\uff0cLibuv\u8fd8\u63d0\u4f9b\u4e86\u53e6\u5916\u4e00\u79cd\u751f\u4ea7\u4efb\u52a1\u7684\u65b9\u5f0f\uff0c\u5373uv_queue_work\u51fd\u6570\uff0c\u5b83\u53ea\u63d0\u4ea4CPU\u5bc6\u96c6\u578b\u7684\u4efb\u52a1\uff08\u5728Node.js\u7684crypto\u6a21\u5757\u4e2d\u4f7f\u7528\uff09\u3002\u4e0b\u9762\u6211\u4eec\u770buv_queue_work\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int uv_queue_work ( uv_loop_t * loop , uv_work_t * req , uv_work_cb work_cb , uv_after_work_cb after_work_cb ) { if ( work_cb == NULL ) return UV_EINVAL ; uv__req_init ( loop , req , UV_WORK ); req -> loop = loop ; req -> work_cb = work_cb ; req -> after_work_cb = after_work_cb ; uv__work_submit ( loop , & req -> work_req , UV__WORK_CPU , uv__queue_work , uv__queue_done ); return 0 ; } uv_queue_work\u51fd\u6570\u5176\u5b9e\u4e5f\u6ca1\u6709\u592a\u591a\u7684\u903b\u8f91\uff0c\u5b83\u4fdd\u5b58\u7528\u6237\u7684\u5de5\u4f5c\u51fd\u6570\u548c\u56de\u8c03\u5230request\u4e2d\u3002\u7136\u540e\u628auv__queue_work\u548cuv__queue_done\u5c01\u88c5\u5230uv__work\u4e2d\uff0c\u63a5\u7740\u63d0\u4ea4\u4efb\u52a1\u5230\u7ebf\u7a0b\u6c60\u4e2d\u3002\u6240\u4ee5\u5f53\u8fd9\u4e2a\u4efb\u52a1\u88ab\u6267\u884c\u7684\u65f6\u5019\u3002\u5b83\u4f1a\u6267\u884c\u5de5\u4f5c\u51fd\u6570uv__queue_work\u3002 1 2 3 4 5 static void uv__queue_work ( struct uv__work * w ) { // \u901a\u8fc7\u7ed3\u6784\u4f53\u67d0\u5b57\u6bb5\u62ff\u5230\u7ed3\u6784\u4f53\u5730\u5740 uv_work_t * req = container_of ( w , uv_work_t , work_req ); req -> work_cb ( req ); } \u6211\u4eec\u770b\u5230uv__queue_work\u5176\u5b9e\u5c31\u662f\u5bf9\u7528\u6237\u5b9a\u4e49\u7684\u4efb\u52a1\u51fd\u6570\u8fdb\u884c\u4e86\u5c01\u88c5\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u731c\u5230\uff0cuv__queue_done\u4e5f\u53ea\u662f\u5bf9\u7528\u6237\u56de\u8c03\u7684\u7b80\u5355\u5c01\u88c5\uff0c\u5373\u5b83\u4f1a\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 4.2.3 \u5904\u7406\u4efb\u52a1 \u00b6 \u6211\u4eec\u63d0\u4ea4\u4e86\u4efb\u52a1\u540e\uff0c\u7ebf\u7a0b\u81ea\u7136\u8981\u5904\u7406\uff0c\u521d\u59cb\u5316\u7ebf\u7a0b\u6c60\u7684\u65f6\u5019\u6211\u4eec\u5206\u6790\u8fc7\uff0cworker\u51fd\u6570\u662f\u8d1f\u8d23\u5904\u7406\u4efb\u52a1\u3002\u6211\u4eec\u770b\u4e00\u4e0bworker\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 static void worker ( void * arg ) { struct uv__work * w ; QUEUE * q ; int is_slow_work ; // \u7ebf\u7a0b\u542f\u52a8\u6210\u529f uv_sem_post (( uv_sem_t * ) arg ); arg = NULL ; // \u52a0\u9501\u4e92\u65a5\u8bbf\u95ee\u4efb\u52a1\u961f\u5217 uv_mutex_lock ( & mutex ); for (;;) { /* 1 \u961f\u5217\u4e3a\u7a7a 2 \u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u4f46\u662f\u961f\u5217\u4e2d\u53ea\u6709\u6162IO\u4efb\u52a1\u4e14\u6b63\u5728\u6267\u884c\u7684\u6162IO\u4efb\u52a1 \u4e2a\u6570\u8fbe\u5230\u9608\u503c\u5219\u7a7a\u95f2\u7ebf\u7a0b\u52a0\u4e00\uff0c\u9632\u6b62\u6162IO\u5360\u7528\u8fc7\u591a\u7ebf\u7a0b\uff0c\u5bfc\u81f4 \u5176\u5b83\u5feb\u7684\u4efb\u52a1\u65e0\u6cd5\u5f97\u5230\u6267\u884c */ while ( QUEUE_EMPTY ( & wq ) || ( QUEUE_HEAD ( & wq ) == & run_slow_work_message && QUEUE_NEXT ( & run_slow_work_message ) == & wq && slow_io_work_running >= slow_work_thread_threshold ())) { idle_threads += 1 ; // \u963b\u585e\uff0c\u7b49\u5f85\u5524\u9192 uv_cond_wait ( & cond , & mutex ); // \u88ab\u5524\u9192\uff0c\u5f00\u59cb\u5e72\u6d3b\uff0c\u7a7a\u95f2\u7ebf\u7a0b\u6570\u51cf\u4e00 idle_threads -= 1 ; } // \u53d6\u51fa\u5934\u7ed3\u70b9\uff0c\u5934\u6307\u70b9\u53ef\u80fd\u662f\u9000\u51fa\u6d88\u606f\u3001\u6162IO\uff0c\u4e00\u822c\u8bf7\u6c42 q = QUEUE_HEAD ( & wq ); // \u5982\u679c\u5934\u7ed3\u70b9\u662f\u9000\u51fa\u6d88\u606f\uff0c\u5219\u7ed3\u675f\u7ebf\u7a0b if ( q == & exit_message ) { /* \u5524\u9192\u5176\u5b83\u56e0\u4e3a\u6ca1\u6709\u4efb\u52a1\u6b63\u963b\u585e\u7b49\u5f85\u4efb\u52a1\u7684\u7ebf\u7a0b\uff0c \u544a\u8bc9\u5b83\u4eec\u51c6\u5907\u9000\u51fa */ uv_cond_signal ( & cond ); uv_mutex_unlock ( & mutex ); break ; } // \u79fb\u9664\u8282\u70b9 QUEUE_REMOVE ( q ); // \u91cd\u7f6e\u524d\u540e\u6307\u9488 QUEUE_INIT ( q ); is_slow_work = 0 ; /* \u5982\u679c\u5f53\u524d\u8282\u70b9\u7b49\u4e8e\u6162IO\u8282\u70b9\uff0c\u4e0a\u9762\u7684while\u53ea\u5224\u65ad\u4e86\u662f\u4e0d\u662f\u53ea\u6709\u6162 IO\u4efb\u52a1\u4e14\u8fbe\u5230\u9608\u503c\uff0c\u8fd9\u91cc\u662f\u4efb\u52a1\u961f\u5217\u91cc\u80af\u5b9a\u6709\u975e\u6162IO\u4efb\u52a1\uff0c\u53ef\u80fd\u6709 \u6162IO\uff0c\u5982\u679c\u6709\u6162IO\u5e76\u4e14\u6b63\u5728\u6267\u884c\u7684\u4e2a\u6570\u8fbe\u5230\u9608\u503c\uff0c\u5219\u5148\u4e0d\u5904\u7406\u8be5\u6162 IO\u4efb\u52a1\uff0c\u7ee7\u7eed\u5224\u65ad\u662f\u5426\u8fd8\u6709\u975e\u6162IO\u4efb\u52a1\u53ef\u6267\u884c\u3002 */ if ( q == & run_slow_work_message ) { // \u8fbe\u5230\u9608\u503c\uff0c\u8be5\u8282\u70b9\u91cd\u65b0\u5165\u961f\uff0c\u56e0\u4e3a\u521a\u624d\u88ab\u5220\u9664\u4e86 if ( slow_io_work_running >= slow_work_thread_threshold ()) { QUEUE_INSERT_TAIL ( & wq , q ); continue ; } /* \u6ca1\u6709\u6162IO\u4efb\u52a1\u5219\u7ee7\u7eed\uff0c\u8fd9\u65f6\u5019run_slow_work_message \u5df2\u7ecf\u4ece\u961f\u5217\u4e2d\u88ab\u5220\u9664\uff0c\u4e0b\u6b21\u6709\u6162IO\u7684\u65f6\u5019\u91cd\u65b0\u5165\u961f */ if ( QUEUE_EMPTY ( & slow_io_pending_wq )) continue ; // \u6709\u6162IO\uff0c\u5f00\u59cb\u5904\u7406\u6162IO\u4efb\u52a1 is_slow_work = 1 ; /* \u6b63\u5728\u5904\u7406\u6162IO\u4efb\u52a1\u7684\u4e2a\u6570\u7d2f\u52a0\uff0c\u7528\u4e8e\u5176\u5b83\u7ebf\u7a0b\u5224\u65ad\u6162IO\u4efb\u52a1\u4e2a \u6570\u662f\u5426\u8fbe\u5230\u9608\u503c, slow_io_work_running\u662f\u591a\u4e2a\u7ebf\u7a0b\u5171\u4eab\u7684\u53d8\u91cf */ slow_io_work_running ++ ; // \u6458\u4e0b\u4e00\u4e2a\u6162IO\u4efb\u52a1 q = QUEUE_HEAD ( & slow_io_pending_wq ); // \u4ece\u6162IO\u961f\u5217\u79fb\u9664 QUEUE_REMOVE ( q ); QUEUE_INIT ( q ); /* \u53d6\u51fa\u4e00\u4e2a\u4efb\u52a1\u540e\uff0c\u5982\u679c\u8fd8\u6709\u6162IO\u4efb\u52a1\u5219\u628a\u6162IO\u6807\u8bb0\u8282\u70b9\u91cd\u65b0\u5165 \u961f\uff0c\u8868\u793a\u8fd8\u6709\u6162IO\u4efb\u52a1\uff0c\u56e0\u4e3a\u4e0a\u9762\u628a\u8be5\u6807\u8bb0\u8282\u70b9\u51fa\u961f\u4e86 */ if ( ! QUEUE_EMPTY ( & slow_io_pending_wq )) { QUEUE_INSERT_TAIL ( & wq , & run_slow_work_message ); // \u6709\u7a7a\u95f2\u7ebf\u7a0b\u5219\u5524\u9192\u5b83\uff0c\u56e0\u4e3a\u8fd8\u6709\u4efb\u52a1\u5904\u7406 if ( idle_threads > 0 ) uv_cond_signal ( & cond ); } } // \u4e0d\u9700\u8981\u64cd\u4f5c\u961f\u5217\u4e86\uff0c\u5c3d\u5feb\u91ca\u653e\u9501 uv_mutex_unlock ( & mutex ); // q\u662f\u6162IO\u6216\u8005\u4e00\u822c\u4efb\u52a1 w = QUEUE_DATA ( q , struct uv__work , wq ); // \u6267\u884c\u4e1a\u52a1\u7684\u4efb\u52a1\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u4e00\u822c\u4f1a\u963b\u585e w -> work ( w ); // \u51c6\u5907\u64cd\u4f5cloop\u7684\u4efb\u52a1\u5b8c\u6210\u961f\u5217\uff0c\u52a0\u9501 uv_mutex_lock ( & w -> loop -> wq_mutex ); // \u7f6e\u7a7a\u8bf4\u660e\u6267\u884c\u5b8c\u4e86\uff0c\u89c1cancel\u903b\u8f91 w -> work = NULL ; /* \u6267\u884c\u5b8c\u4efb\u52a1,\u63d2\u5165\u5230loop\u7684wq\u961f\u5217,\u5728uv__work_done\u7684\u65f6\u5019\u4f1a \u6267\u884c\u8be5\u961f\u5217\u7684\u8282\u70b9 */ QUEUE_INSERT_TAIL ( & w -> loop -> wq , & w -> wq ); // \u901a\u77e5loop\u7684wq_async\u8282\u70b9 uv_async_send ( & w -> loop -> wq_async ); uv_mutex_unlock ( & w -> loop -> wq_mutex ); // \u4e3a\u4e0b\u4e00\u8f6e\u64cd\u4f5c\u4efb\u52a1\u961f\u5217\u52a0\u9501 uv_mutex_lock ( & mutex ); /* \u6267\u884c\u5b8c\u6162IO\u4efb\u52a1\uff0c\u8bb0\u5f55\u6b63\u5728\u6267\u884c\u7684\u6162IO\u4e2a\u6570\u53d8\u91cf\u51cf1\uff0c \u4e0a\u9762\u52a0\u9501\u4fdd\u8bc1\u4e86\u4e92\u65a5\u8bbf\u95ee\u8fd9\u4e2a\u53d8\u91cf */ if ( is_slow_work ) { slow_io_work_running -- ; } } } \u6211\u4eec\u770b\u5230\u6d88\u8d39\u8005\u7684\u903b\u8f91\u4f3c\u4e4e\u6bd4\u8f83\u590d\u6742\uff0c\u5bf9\u4e8e\u6162IO\u7c7b\u578b\u7684\u4efb\u52a1\uff0cLibuv\u9650\u5236\u4e86\u5904\u7406\u6162IO\u4efb\u52a1\u7684\u7ebf\u7a0b\u6570\uff0c\u907f\u514d\u8017\u65f6\u6bd4\u8f83\u5c11\u7684\u4efb\u52a1\u5f97\u4e0d\u5230\u5904\u7406\u3002\u5176\u4f59\u7684\u903b\u8f91\u548c\u4e00\u822c\u7684\u7ebf\u7a0b\u6c60\u7c7b\u4f3c\uff0c\u5c31\u662f\u4e92\u65a5\u8bbf\u95ee\u4efb\u52a1\u961f\u5217\uff0c\u7136\u540e\u53d6\u51fa\u8282\u70b9\u6267\u884c\uff0c\u6267\u884c\u5b8c\u540e\u901a\u77e5\u4e3b\u7ebf\u7a0b\u3002\u7ed3\u6784\u5982\u56fe4-4\u6240\u793a\u3002 4.2.4 \u901a\u77e5\u4e3b\u7ebf\u7a0b \u00b6 \u7ebf\u7a0b\u6267\u884c\u5b8c\u4efb\u52a1\u540e\uff0c\u5e76\u4e0d\u662f\u76f4\u63a5\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u800c\u662f\u901a\u77e5\u4e3b\u7ebf\u7a0b\uff0c\u7531\u4e3b\u7ebf\u7a0b\u7edf\u4e00\u5904\u7406\uff0c\u8fd9\u662fNode.js\u5355\u7ebf\u7a0b\u4e8b\u4ef6\u5faa\u73af\u7684\u8981\u6c42\uff0c\u4e5f\u907f\u514d\u4e86\u591a\u7ebf\u7a0b\u5e26\u6765\u7684\u590d\u6742\u95ee\u9898\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u5757\u7684\u903b\u8f91\u3002\u4e00\u5207\u8981\u4eceLibuv\u7684\u521d\u59cb\u5316\u5f00\u59cb 1 uv_default_loop (); -> uv_loop_init (); -> uv_async_init ( loop , & loop -> wq_async , uv__work_done ); \u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\u4e3b\u7ebf\u7a0b\u548c\u5b50\u7ebf\u7a0b\u7684\u901a\u4fe1\u673a\u5236\uff0cwq_async\u662f\u7528\u4e8e\u7ebf\u7a0b\u6c60\u4e2d\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u7684async handle\uff0c\u5b83\u5bf9\u5e94\u7684\u56de\u8c03\u662fuv__work_done\u3002\u6240\u4ee5\u5f53\u4e00\u4e2a\u7ebf\u7a0b\u6c60\u7684\u7ebf\u7a0b\u4efb\u52a1\u5b8c\u6210\u65f6\uff0c\u901a\u8fc7uv_async_send(&w->loop->wq_async)\u8bbe\u7f6eloop->wq_async.pending = 1\uff0c\u7136\u540e\u901a\u77e5IO\u89c2\u5bdf\u8005\uff0cLibuv\u5728Poll IO\u9636\u6bb5\u5c31\u4f1a\u6267\u884c\u8be5handle\u5bf9\u5e94\u7684\u56de\u8c03uv__work_done\u51fd\u6570\u3002\u90a3\u4e48\u6211\u4eec\u5c31\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void uv__work_done ( uv_async_t * handle ) { struct uv__work * w ; uv_loop_t * loop ; QUEUE * q ; QUEUE wq ; int err ; // \u901a\u8fc7\u7ed3\u6784\u4f53\u5b57\u6bb5\u83b7\u5f97\u7ed3\u6784\u4f53\u9996\u5730\u5740 loop = container_of ( handle , uv_loop_t , wq_async ); // \u51c6\u5907\u5904\u7406\u961f\u5217\uff0c\u52a0\u9501 uv_mutex_lock ( & loop -> wq_mutex ); /* loop->wq\u662f\u5df2\u5b8c\u6210\u7684\u4efb\u52a1\u961f\u5217\u3002\u628aloop->wq\u961f\u5217\u7684\u8282\u70b9\u5168\u90e8\u79fb\u5230 wp\u53d8\u91cf\u4e2d\uff0c\u8fd9\u6837\u4e00\u6765\u53ef\u4ee5\u5c3d\u5feb\u91ca\u653e\u9501 */ QUEUE_MOVE ( & loop -> wq , & wq ); // \u4e0d\u9700\u8981\u4f7f\u7528\u4e86\uff0c\u89e3\u9501 uv_mutex_unlock ( & loop -> wq_mutex ); // wq\u961f\u5217\u7684\u8282\u70b9\u6765\u81ea\u5b50\u7ebf\u7a0b\u63d2\u5165 while ( ! QUEUE_EMPTY ( & wq )) { q = QUEUE_HEAD ( & wq ); QUEUE_REMOVE ( q ); w = container_of ( q , struct uv__work , wq ); // \u7b49\u4e8euv__canceled\u8bf4\u660e\u8fd9\u4e2a\u4efb\u52a1\u88ab\u53d6\u6d88\u4e86 err = ( w -> work == uv__cancelled ) ? UV_ECANCELED : 0 ; // \u6267\u884c\u56de\u8c03 w -> done ( w , err ); } } \u8be5\u51fd\u6570\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u9010\u4e2a\u5904\u7406\u5df2\u5b8c\u6210\u7684\u4efb\u52a1\u8282\u70b9\uff0c\u6267\u884c\u56de\u8c03\uff0c\u5728Node.js\u4e2d\uff0c\u8fd9\u91cc\u7684\u56de\u8c03\u662fC++\u5c42\uff0c\u7136\u540e\u518d\u5230JS\u5c42\u3002\u7ed3\u6784\u56fe\u5982\u56fe4-5\u6240\u793a\u3002 4.2.5 \u53d6\u6d88\u4efb\u52a1 \u00b6 \u7ebf\u7a0b\u6c60\u7684\u8bbe\u8ba1\u4e2d\uff0c\u53d6\u6d88\u4efb\u52a1\u662f\u4e00\u4e2a\u6bd4\u8f83\u91cd\u8981\u7684\u80fd\u529b\uff0c\u56e0\u4e3a\u5728\u7ebf\u7a0b\u91cc\u6267\u884c\u7684\u90fd\u662f\u4e00\u4e9b\u8017\u65f6\u6216\u8005\u5f15\u8d77\u963b\u585e\u7684\u64cd\u4f5c\uff0c\u5982\u679c\u80fd\u53ca\u65f6\u53d6\u6d88\u4e00\u4e2a\u4efb\u52a1\uff0c\u5c06\u4f1a\u51cf\u8f7b\u5f88\u591a\u6ca1\u5fc5\u8981\u7684\u5904\u7406\u3002\u4e0d\u8fc7Libuv\u5b9e\u73b0\u4e2d\uff0c\u53ea\u6709\u5f53\u4efb\u52a1\u8fd8\u5728\u7b49\u5f85\u961f\u5217\u4e2d\u624d\u80fd\u88ab\u53d6\u6d88\uff0c\u5982\u679c\u4e00\u4e2a\u4efb\u52a1\u6b63\u5728\u88ab\u7ebf\u7a0b\u5904\u7406\uff0c\u5219\u65e0\u6cd5\u53d6\u6d88\u4e86\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bLibuv\u4e2d\u662f\u5982\u4f55\u5b9e\u73b0\u53d6\u6d88\u4efb\u52a1\u7684\u3002Libuv\u63d0\u4f9b\u4e86uv__work_cancel\u51fd\u6570\u652f\u6301\u7528\u6237\u53d6\u6d88\u63d0\u4ea4\u7684\u4efb\u52a1\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 static int uv__work_cancel ( uv_loop_t * loop , uv_req_t * req , struct uv__work * w ) { int cancelled ; // \u52a0\u9501\uff0c\u4e3a\u4e86\u628a\u8282\u70b9\u79fb\u51fa\u961f\u5217 uv_mutex_lock ( & mutex ); // \u52a0\u9501\uff0c\u4e3a\u4e86\u5224\u65adw->wq\u662f\u5426\u4e3a\u7a7a uv_mutex_lock ( & w -> loop -> wq_mutex ); /* cancelled\u4e3atrue\u8bf4\u660e\u4efb\u52a1\u8fd8\u5728\u7ebf\u7a0b\u6c60\u961f\u5217\u7b49\u5f85\u5904\u7406 1 \u5904\u7406\u5b8c\uff0cw->work == NULL 2 \u5904\u7406\u4e2d\uff0cQUEUE_EMPTY(&w->wq)\u4e3atrue\uff0c\u56e0 \u4e3aworker\u5728\u6458\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684\u65f6\u5019\uff0c\u91cd\u7f6eprev\u548cnext\u6307\u9488 3 \u672a\u5904\u7406\uff0c!QUEUE_EMPTY(&w->wq)\u662ftrue \u4e14w->work != NULL */ cancelled = ! QUEUE_EMPTY ( & w -> wq ) && w -> work != NULL ; // \u4ece\u7ebf\u7a0b\u6c60\u4efb\u52a1\u961f\u5217\u4e2d\u5220\u9664\u8be5\u8282\u70b9 if ( cancelled ) QUEUE_REMOVE ( & w -> wq ); uv_mutex_unlock ( & w -> loop -> wq_mutex ); uv_mutex_unlock ( & mutex ); // \u6b63\u5728\u6267\u884c\u6216\u8005\u5df2\u7ecf\u6267\u884c\u5b8c\u4e86\uff0c\u5219\u4e0d\u80fd\u53d6\u6d88 if ( ! cancelled ) return UV_EBUSY ; // \u6253\u53d6\u6d88\u6807\u8bb0\uff0cLibuv\u6267\u884c\u56de\u8c03\u7684\u65f6\u5019\u7528\u5230 w -> work = uv__cancelled ; uv_mutex_lock ( & loop -> wq_mutex ); /* \u63d2\u5165loop\u7684wq\u961f\u5217\uff0c\u5bf9\u4e8e\u53d6\u6d88\u7684\u52a8\u4f5c\uff0cLibuv\u8ba4\u4e3a\u662f\u4efb\u52a1\u6267\u884c\u5b8c\u4e86\u3002 \u6240\u4ee5\u63d2\u5165\u5df2\u5b8c\u6210\u7684\u961f\u5217\uff0c\u6267\u884c\u56de\u8c03\u7684\u65f6\u5019\u4f1a\u901a\u77e5\u7528\u6237\u8be5\u4efb\u52a1\u7684\u6267\u884c\u7ed3\u679c \u662f\u53d6\u6d88\uff0c\u9519\u8bef\u7801\u662fUV_ECANCELED */ QUEUE_INSERT_TAIL ( & loop -> wq , & w -> wq ); // \u901a\u77e5\u4e3b\u7ebf\u7a0b\u6709\u4efb\u52a1\u5b8c\u6210 uv_async_send ( & loop -> wq_async ); uv_mutex_unlock ( & loop -> wq_mutex ); return 0 ; } \u5728Libuv\u4e2d\uff0c\u53d6\u6d88\u4efb\u52a1\u7684\u65b9\u5f0f\u5c31\u662f\u628a\u8282\u70b9\u4ece\u7ebf\u7a0b\u6c60\u5f85\u5904\u7406\u961f\u5217\u4e2d\u5220\u9664\uff0c\u7136\u540e\u6253\u4e0a\u53d6\u6d88\u7684\u6807\u8bb0\uff08w->work = uv__cancelled\uff09\uff0c\u63a5\u7740\u628a\u8be5\u8282\u70b9\u63d2\u5165\u5df2\u5b8c\u6210\u961f\u5217\uff0cLibuv\u5728\u5904\u7406\u5df2\u5b8c\u6210\u961f\u5217\u7684\u8282\u70b9\u65f6\uff0c\u5224\u65ad\u5982\u679cw->work == uv__cancelled\u5219\u5728\u6267\u884c\u7528\u6237\u56de\u8c03\u65f6\uff0c\u4f20\u5165\u9519\u8bef\u7801UV_ECANCELED\uff0c\u6211\u4eec\u770b\u5230uv__work_cancel\u8fd9\u4e2a\u51fd\u6570\u5b9a\u4e49\u524d\u9762\u52a0\u4e86\u4e00\u4e2astatic\uff0c\u8bf4\u660e\u8fd9\u4e2a\u51fd\u6570\u662f\u53ea\u5728\u672c\u6587\u4ef6\u5185\u4f7f\u7528\u7684\uff0cLibuv\u5bf9\u5916\u63d0\u4f9b\u7684\u53d6\u6d88\u4efb\u52a1\u7684\u63a5\u53e3\u662fuv_cancel\u3002","title":"04-\u7ebf\u7a0b\u6c60"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#_1","text":"Libuv\u662f\u5355\u7ebf\u7a0b\u4e8b\u4ef6\u9a71\u52a8\u7684\u5f02\u6b65IO\u5e93\uff0c\u5bf9\u4e8e\u963b\u585e\u5f0f\u6216\u8017\u65f6\u7684\u64cd\u4f5c\uff0c\u5982\u679c\u5728Libuv\u7684\u4e3b\u5faa\u73af\u91cc\u6267\u884c\u7684\u8bdd\uff0c\u5c31\u4f1a\u963b\u585e\u540e\u9762\u7684\u4efb\u52a1\u6267\u884c\uff0c\u6240\u4ee5Libuv\u91cc\u7ef4\u62a4\u4e86\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u5b83\u8d1f\u8d23\u5904\u7406Libuv\u4e2d\u8017\u65f6\u6216\u8005\u5bfc\u81f4\u963b\u585e\u7684\u64cd\u4f5c\uff0c\u6bd4\u5982\u6587\u4ef6IO\u3001DNS\u3001\u81ea\u5b9a\u4e49\u7684\u8017\u65f6\u4efb\u52a1\u3002\u7ebf\u7a0b\u6c60\u5728Libuv\u67b6\u6784\u4e2d\u7684\u4f4d\u7f6e\u5982\u56fe4-1\u6240\u793a\u3002 Libuv\u4e3b\u7ebf\u7a0b\u901a\u8fc7\u7ebf\u7a0b\u6c60\u63d0\u4f9b\u7684\u63a5\u53e3\u628a\u4efb\u52a1\u63d0\u4ea4\u7ed9\u7ebf\u7a0b\u6c60\uff0c\u7136\u540e\u7acb\u523b\u8fd4\u56de\u5230\u4e8b\u4ef6\u5faa\u73af\u4e2d\u7ee7\u7eed\u6267\u884c\uff0c\u7ebf\u7a0b\u6c60\u7ef4\u62a4\u4e86\u4e00\u4e2a\u4efb\u52a1\u961f\u5217\uff0c\u591a\u4e2a\u5b50\u7ebf\u7a0b\u4f1a\u4e92\u65a5\u5730\u4ece\u4e2d\u6458\u4e0b\u4efb\u52a1\u8282\u70b9\u6267\u884c\uff0c\u5f53\u5b50\u7ebf\u7a0b\u6267\u884c\u4efb\u52a1\u5b8c\u6bd5\u540e\u4f1a\u901a\u77e5\u4e3b\u7ebf\u7a0b\uff0c\u4e3b\u7ebf\u7a0b\u5728\u4e8b\u4ef6\u5faa\u73af\u7684Poll IO\u9636\u6bb5\u5c31\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u7ebf\u7a0b\u6c60\u5728Libuv\u4e2d\u7684\u5b9e\u73b0\u3002","title":"\u7b2c\u56db\u7ae0 \u7ebf\u7a0b\u6c60"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#41","text":"Libuv\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u7684\u901a\u4fe1\u662f\u4f7f\u7528uv_async_t\u7ed3\u6784\u4f53\u5b9e\u73b0\u7684\u3002Libuv\u4f7f\u7528loop->async_handles\u961f\u5217\u8bb0\u5f55\u6240\u6709\u7684uv_async_t\u7ed3\u6784\u4f53\uff0c\u4f7f\u7528loop->async_io_watcher\u4f5c\u4e3a\u6240\u6709uv_async_t\u7ed3\u6784\u4f53\u7684IO\u89c2\u5bdf\u8005\uff0c\u5373loop-> async_handles\u961f\u5217\u4e0a\u6240\u6709\u7684handle\u90fd\u662f\u5171\u4eabasync_io_watcher\u8fd9\u4e2aIO\u89c2\u5bdf\u8005\u7684\u3002\u7b2c\u4e00\u6b21\u63d2\u5165\u4e00\u4e2auv_async_t\u7ed3\u6784\u4f53\u5230async_handle\u961f\u5217\u65f6\uff0c\u4f1a\u521d\u59cb\u5316IO\u89c2\u5bdf\u8005\uff0c\u5982\u679c\u518d\u6b21\u6ce8\u518c\u4e00\u4e2aasync_handle\uff0c\u53ea\u4f1a\u5728loop->async_handle\u961f\u5217\u548chandle\u961f\u5217\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u800c\u4e0d\u4f1a\u65b0\u589e\u4e00\u4e2aIO\u89c2\u5bdf\u8005\u3002\u5f53uv_async_t\u7ed3\u6784\u4f53\u5bf9\u5e94\u7684\u4efb\u52a1\u5b8c\u6210\u65f6\uff0c\u5b50\u7ebf\u7a0b\u4f1a\u8bbe\u7f6eIO\u89c2\u5bdf\u8005\u4e3a\u53ef\u8bfb\u3002Libuv\u5728\u4e8b\u4ef6\u5faa\u73af\u7684Poll IO\u9636\u6bb5\u5c31\u4f1a\u5904\u7406IO\u89c2\u5bdf\u8005\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0buv_async_t\u5728Libuv\u4e2d\u7684\u4f7f\u7528\u3002","title":"4.1\u4e3b\u7ebf\u7a0b\u548c\u5b50\u7ebf\u7a0b\u95f4\u901a\u4fe1"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#411","text":"\u4f7f\u7528uv_async_t\u4e4b\u524d\u9996\u5148\u9700\u8981\u6267\u884cuv_async_init\u8fdb\u884c\u521d\u59cb\u5316\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int uv_async_init ( uv_loop_t * loop , uv_async_t * handle , uv_async_cb async_cb ) { int err ; // \u7ed9Libuv\u6ce8\u518c\u4e00\u4e2a\u89c2\u5bdf\u8005io err = uv__async_start ( loop ); if ( err ) return err ; // \u8bbe\u7f6e\u76f8\u5173\u5b57\u6bb5\uff0c\u7ed9Libuv\u63d2\u5165\u4e00\u4e2ahandle uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_ASYNC ); // \u8bbe\u7f6e\u56de\u8c03 handle -> async_cb = async_cb ; // \u521d\u59cb\u5316\u6807\u8bb0\u5b57\u6bb5\uff0c0\u8868\u793a\u6ca1\u6709\u4efb\u52a1\u5b8c\u6210 handle -> pending = 0 ; // \u628auv_async_t\u63d2\u5165async_handle\u961f\u5217 QUEUE_INSERT_TAIL ( & loop -> async_handles , & handle -> queue ); uv__handle_start ( handle ); return 0 ; } uv_async_init\u51fd\u6570\u4e3b\u8981\u521d\u59cb\u5316\u7ed3\u6784\u4f53uv_async_t\u7684\u4e00\u4e9b\u5b57\u6bb5\uff0c\u7136\u540e\u6267\u884cQUEUE_INSERT_TAIL\u7ed9Libuv\u7684async_handles\u961f\u5217\u8ffd\u52a0\u4e00\u4e2a\u8282\u70b9\u3002\u6211\u4eec\u770b\u5230\u8fd8\u6709\u4e00\u4e2auv__async_start\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0buv__async_start\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 static int uv__async_start ( uv_loop_t * loop ) { int pipefd [ 2 ]; int err ; // uv__async_start\u53ea\u6267\u884c\u4e00\u6b21\uff0c\u6709fd\u5219\u4e0d\u9700\u8981\u6267\u884c\u4e86 if ( loop -> async_io_watcher . fd != -1 ) return 0 ; // \u83b7\u53d6\u4e00\u4e2a\u7528\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684fd\uff08Linux\u7684eventfd\u673a\u5236\uff09 err = uv__async_eventfd (); /* \u6210\u529f\u5219\u4fdd\u5b58fd\uff0c\u5931\u8d25\u8bf4\u660e\u4e0d\u652f\u6301eventfd\uff0c \u5219\u4f7f\u7528\u7ba1\u9053\u901a\u4fe1\u4f5c\u4e3a\u8fdb\u7a0b\u95f4\u901a\u4fe1 */ if ( err >= 0 ) { pipefd [ 0 ] = err ; pipefd [ 1 ] = -1 ; } else if ( err == UV_ENOSYS ) { // \u4e0d\u652f\u6301eventfd\u5219\u4f7f\u7528\u533f\u540d\u7ba1\u9053 err = uv__make_pipe ( pipefd , UV__F_NONBLOCK ); #if defined(__Linux__) if ( err == 0 ) { char buf [ 32 ]; int fd ; snprintf ( buf , sizeof ( buf ), \"/proc/self/fd/%d\" , pipefd [ 0 ]); // \u901a\u8fc7\u4e00\u4e2afd\u5c31\u53ef\u4ee5\u5b9e\u73b0\u5bf9\u7ba1\u9053\u7684\u8bfb\u5199\uff0c\u9ad8\u7ea7\u7528\u6cd5 fd = uv__open_cloexec ( buf , O_RDWR ); if ( fd >= 0 ) { // \u5173\u6389\u65e7\u7684 uv__close ( pipefd [ 0 ]); uv__close ( pipefd [ 1 ]); // \u8d4b\u503c\u65b0\u7684 pipefd [ 0 ] = fd ; pipefd [ 1 ] = fd ; } } #endif } // err\u5927\u4e8e\u7b49\u4e8e0\u8bf4\u660e\u62ff\u5230\u4e86\u901a\u4fe1\u7684\u8bfb\u5199\u4e24\u7aef if ( err < 0 ) return err ; /* \u521d\u59cb\u5316IO\u89c2\u5bdf\u8005async_io_watcher\uff0c \u628a\u8bfb\u7aef\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5230IO\u89c2\u5bdf\u8005 */ uv__io_init ( & loop -> async_io_watcher , uv__async_io , pipefd [ 0 ]); // \u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230loop\u91cc\uff0c\u5e76\u6ce8\u518c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6POLLIN\uff0c\u7b49\u5f85\u53ef\u8bfb uv__io_start ( loop , & loop -> async_io_watcher , POLLIN ); // \u4fdd\u5b58\u5199\u7aef\u6587\u4ef6\u63cf\u8ff0\u7b26 loop -> async_wfd = pipefd [ 1 ]; return 0 ; } uv__async_start\u53ea\u4f1a\u6267\u884c\u4e00\u6b21\uff0c\u65f6\u673a\u5728\u7b2c\u4e00\u6b21\u6267\u884cuv_async_init\u7684\u65f6\u5019\u3002uv__async_start\u4e3b\u8981\u7684\u903b\u8f91\u5982\u4e0b 1 \u83b7\u53d6\u901a\u4fe1\u63cf\u8ff0\u7b26\uff08\u901a\u8fc7eventfd\u751f\u6210\u4e00\u4e2a\u901a\u4fe1\u7684fd\uff08\u5145\u5f53\u8bfb\u5199\u4e24\u7aef\uff09\u6216\u8005\u7ba1\u9053\u751f\u6210\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u4e24\u4e2afd\u8868\u793a\u8bfb\u7aef\u548c\u5199\u7aef\uff09\u3002 2 \u5c01\u88c5\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u548c\u56de\u8c03\u5230IO\u89c2\u5bdf\u8005\u7136\u540e\u8ffd\u52a0\u5230watcher_queue\u961f\u5217\uff0c\u5728Poll IO\u9636\u6bb5\uff0cLibuv\u4f1a\u6ce8\u518c\u5230epoll\u91cc\u9762\uff0c\u5982\u679c\u6709\u4efb\u52a1\u5b8c\u6210\uff0c\u4e5f\u4f1a\u5728Poll IO\u9636\u6bb5\u6267\u884c\u56de\u8c03\u3002 3 \u4fdd\u5b58\u5199\u7aef\u63cf\u8ff0\u7b26\u3002\u4efb\u52a1\u5b8c\u6210\u65f6\u901a\u8fc7\u5199\u7aeffd\u901a\u77e5\u4e3b\u7ebf\u7a0b\u3002 \u6211\u4eec\u770b\u5230uv__async_start\u51fd\u6570\u91cc\u6709\u5f88\u591a\u83b7\u53d6\u901a\u4fe1\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u903b\u8f91\uff0c\u603b\u7684\u6765\u8bf4\uff0c\u662f\u4e3a\u4e86\u5b8c\u6210\u4e24\u7aef\u901a\u4fe1\u7684\u529f\u80fd\u3002\u521d\u59cb\u5316async\u7ed3\u6784\u4f53\u540e\uff0cLibuv\u7ed3\u6784\u5982\u56fe4-2\u6240\u793a\u3002","title":"4.1.1 \u521d\u59cb\u5316"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#412","text":"\u521d\u59cb\u5316async\u7ed3\u6784\u4f53\u540e\uff0c\u5982\u679casync\u7ed3\u6784\u4f53\u5bf9\u5e94\u7684\u4efb\u52a1\u5b8c\u6210\u540e\uff0c\u5c31\u4f1a\u901a\u77e5\u4e3b\u7ebf\u7a0b\uff0c\u5b50\u7ebf\u7a0b\u901a\u8fc7\u8bbe\u7f6e\u8fd9\u4e2ahandle\u7684pending\u4e3a1\u6807\u8bb0\u4efb\u52a1\u5b8c\u6210\uff0c\u7136\u540e\u518d\u5f80\u7ba1\u9053\u5199\u7aef\u5199\u5165\u6807\u8bb0\uff0c\u901a\u77e5\u4e3b\u7ebf\u7a0b\u6709\u4efb\u52a1\u5b8c\u6210\u4e86\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 int uv_async_send ( uv_async_t * handle ) { /* Do a cheap read first. */ if ( ACCESS_ONCE ( int , handle -> pending ) != 0 ) return 0 ; /* \u5982pending\u662f0\uff0c\u5219\u8bbe\u7f6e\u4e3a1\uff0c\u8fd4\u56de0\uff0c\u5982\u679c\u662f1\u5219\u8fd4\u56de1\uff0c \u6240\u4ee5\u5982\u679c\u591a\u6b21\u8c03\u7528\u8be5\u51fd\u6570\u662f\u4f1a\u88ab\u5408\u5e76\u7684 */ if ( cmpxchgi ( & handle -> pending , 0 , 1 ) == 0 ) uv__async_send ( handle -> loop ); return 0 ; } static void uv__async_send ( uv_loop_t * loop ) { const void * buf ; ssize_t len ; int fd ; int r ; buf = \"\" ; len = 1 ; fd = loop -> async_wfd ; #if defined(__Linux__) // \u8bf4\u660e\u7528\u7684\u662feventfd\u800c\u4e0d\u662f\u7ba1\u9053,eventfd\u65f6\u8bfb\u5199\u4e24\u7aef\u5bf9\u5e94\u540c\u4e00\u4e2afd if ( fd == -1 ) { static const uint64_t val = 1 ; buf = & val ; len = sizeof ( val ); // \u89c1uv__async_start fd = loop -> async_io_watcher . fd ; /* eventfd */ } #endif // \u901a\u77e5\u8bfb\u7aef do r = write ( fd , buf , len ); while ( r == -1 && errno == EINTR ); if ( r == len ) return ; if ( r == -1 ) if ( errno == EAGAIN || errno == EWOULDBLOCK ) return ; abort (); } uv_async_send\u9996\u5148\u62ff\u5230\u5199\u7aef\u5bf9\u5e94\u7684fd\uff0c\u7136\u540e\u8c03\u7528write\u51fd\u6570\uff0c\u6b64\u65f6\uff0c\u5f80\u7ba1\u9053\u7684\u5199\u7aef\u5199\u5165\u6570\u636e\uff0c\u6807\u8bb0\u6709\u4efb\u52a1\u5b8c\u6210\u3002\u6709\u5199\u5219\u5fc5\u7136\u6709\u8bfb\u3002\u8bfb\u7684\u903b\u8f91\u662f\u5728uv__io_poll\u4e2d\u5b9e\u73b0\u7684\u3002uv__io_poll\u51fd\u6570\u5373Libuv\u4e2dPoll IO\u9636\u6bb5\u6267\u884c\u7684\u51fd\u6570\u3002\u5728uv__io_poll\u4e2d\u4f1a\u53d1\u73b0\u7ba1\u9053\u53ef\u8bfb\uff0c\u7136\u540e\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03uv__async_io\u3002","title":"4.1.2 \u901a\u77e5\u4e3b\u7ebf\u7a0b"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#413","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 static void uv__async_io ( uv_loop_t * loop , uv__io_t * w , unsigned int events ) { char buf [ 1024 ]; ssize_t r ; QUEUE queue ; QUEUE * q ; uv_async_t * h ; for (;;) { // \u6d88\u8d39\u6240\u6709\u7684\u6570\u636e r = read ( w -> fd , buf , sizeof ( buf )); // \u6570\u636e\u5927\u5c0f\u5927\u4e8ebuf\u957f\u5ea6\uff081024\uff09\uff0c\u5219\u7ee7\u7eed\u6d88\u8d39 if ( r == sizeof ( buf )) continue ; // \u6210\u529f\u6d88\u8d39\u5b8c\u6bd5\uff0c\u8df3\u51fa\u6d88\u8d39\u7684\u903b\u8f91 if ( r != -1 ) break ; // \u8bfb\u7e41\u5fd9 if ( errno == EAGAIN || errno == EWOULDBLOCK ) break ; // \u8bfb\u88ab\u4e2d\u65ad\uff0c\u7ee7\u7eed\u8bfb if ( errno == EINTR ) continue ; abort (); } // \u628aasync_handles\u961f\u5217\u91cc\u7684\u6240\u6709\u8282\u70b9\u90fd\u79fb\u5230queue\u53d8\u91cf\u4e2d QUEUE_MOVE ( & loop -> async_handles , & queue ); while ( ! QUEUE_EMPTY ( & queue )) { // \u9010\u4e2a\u53d6\u51fa\u8282\u70b9 q = QUEUE_HEAD ( & queue ); // \u6839\u636e\u7ed3\u6784\u4f53\u5b57\u6bb5\u83b7\u53d6\u7ed3\u6784\u4f53\u9996\u5730\u5740 h = QUEUE_DATA ( q , uv_async_t , queue ); // \u4ece\u961f\u5217\u4e2d\u79fb\u9664\u8be5\u8282\u70b9 QUEUE_REMOVE ( q ); // \u91cd\u65b0\u63d2\u5165async_handles\u961f\u5217\uff0c\u7b49\u5f85\u4e0b\u6b21\u4e8b\u4ef6 QUEUE_INSERT_TAIL ( & loop -> async_handles , q ); /* \u5c06\u7b2c\u4e00\u4e2a\u53c2\u6570\u548c\u7b2c\u4e8c\u4e2a\u53c2\u6570\u8fdb\u884c\u6bd4\u8f83\uff0c\u5982\u679c\u76f8\u7b49\uff0c \u5219\u5c06\u7b2c\u4e09\u53c2\u6570\u5199\u5165\u7b2c\u4e00\u4e2a\u53c2\u6570\uff0c\u8fd4\u56de\u7b2c\u4e8c\u4e2a\u53c2\u6570\u7684\u503c\uff0c \u5982\u679c\u4e0d\u76f8\u7b49\uff0c\u5219\u8fd4\u56de\u7b2c\u4e00\u4e2a\u53c2\u6570\u7684\u503c\u3002 */ /* \u5224\u65ad\u89e6\u53d1\u4e86\u54ea\u4e9basync\u3002pending\u5728uv_async_send\u91cc\u8bbe\u7f6e\u62101\uff0c \u5982\u679cpending\u7b49\u4e8e1\uff0c\u5219\u6e050\uff0c\u8fd4\u56de1.\u5982\u679cpending\u7b49\u4e8e0\uff0c\u5219\u8fd4\u56de0 */ if ( cmpxchgi ( & h -> pending , 1 , 0 ) == 0 ) continue ; if ( h -> async_cb == NULL ) continue ; // \u6267\u884c\u4e0a\u5c42\u56de\u8c03 h -> async_cb ( h ); } } uv__async_io\u4f1a\u904d\u5386async_handles\u961f\u5217\uff0cpending\u7b49\u4e8e1\u7684\u8bdd\u8bf4\u660e\u4efb\u52a1\u5b8c\u6210\uff0c\u7136\u540e\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u5e76\u6e05\u9664\u6807\u8bb0\u4f4d\u3002","title":"4.1.3 \u4e3b\u7ebf\u7a0b\u5904\u7406\u56de\u8c03"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#42","text":"\u4e86\u89e3\u4e86Libuv\u4e2d\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u7684\u901a\u4fe1\u673a\u5236\u540e\uff0c\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u7ebf\u7a0b\u6c60\u7684\u5b9e\u73b0\u3002","title":"4.2 \u7ebf\u7a0b\u6c60\u7684\u5b9e\u73b0"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#421","text":"\u7ebf\u7a0b\u6c60\u662f\u61d2\u521d\u59cb\u5316\u7684\uff0cNode.js\u542f\u52a8\u7684\u65f6\u5019\uff0c\u5e76\u6ca1\u6709\u521b\u5efa\u5b50\u7ebf\u7a0b\uff0c\u800c\u662f\u5728\u63d0\u4ea4\u7b2c\u4e00\u4e2a\u4efb\u52a1\u7ed9\u7ebf\u7a0b\u6c60\u65f6\uff0c\u7ebf\u7a0b\u6c60\u624d\u5f00\u59cb\u521d\u59cb\u5316\u3002\u6211\u4eec\u5148\u770b\u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u5316\u903b\u8f91\uff0c\u7136\u540e\u518d\u770b\u5b83\u7684\u4f7f\u7528\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 static void init_threads ( void ) { unsigned int i ; const char * val ; // \u9ed8\u8ba4\u7ebf\u7a0b\u65704\u4e2a\uff0cstatic uv_thread_t default_threads[4]; nthreads = ARRAY_SIZE ( default_threads ); // \u5224\u65ad\u7528\u6237\u662f\u5426\u5728\u73af\u5883\u53d8\u91cf\u4e2d\u8bbe\u7f6e\u4e86\u7ebf\u7a0b\u6570\uff0c\u662f\u7684\u8bdd\u53d6\u7528\u6237\u5b9a\u4e49\u7684 val = getenv ( \"UV_THREADPOOL_SIZE\" ); if ( val != NULL ) nthreads = atoi ( val ); if ( nthreads == 0 ) nthreads = 1 ; // #define MAX_THREADPOOL_SIZE 128\u6700\u591a128\u4e2a\u7ebf\u7a0b if ( nthreads > MAX_THREADPOOL_SIZE ) nthreads = MAX_THREADPOOL_SIZE ; threads = default_threads ; // \u8d85\u8fc7\u9ed8\u8ba4\u5927\u5c0f\uff0c\u91cd\u65b0\u5206\u914d\u5185\u5b58 if ( nthreads > ARRAY_SIZE ( default_threads )) { threads = uv__malloc ( nthreads * sizeof ( threads [ 0 ])); } // \u521d\u59cb\u5316\u6761\u4ef6\u53d8\u91cf\uff0c\u7528\u4e8e\u6709\u4efb\u52a1\u65f6\u5524\u9192\u5b50\u7ebf\u7a0b\uff0c\u6ca1\u6709\u4efb\u52a1\u65f6\u6302\u8d77\u5b50\u7ebf\u7a0b if ( uv_cond_init ( & cond )) abort (); // \u521d\u59cb\u5316\u4e92\u65a5\u53d8\u91cf\uff0c\u7528\u4e8e\u591a\u4e2a\u5b50\u7ebf\u7a0b\u4e92\u65a5\u8bbf\u95ee\u4efb\u52a1\u961f\u5217 if ( uv_mutex_init ( & mutex )) abort (); // \u521d\u59cb\u5316\u4e09\u4e2a\u961f\u5217 QUEUE_INIT ( & wq ); QUEUE_INIT ( & slow_io_pending_wq ); QUEUE_INIT ( & run_slow_work_message ); // \u521b\u5efa\u591a\u4e2a\u7ebf\u7a0b\uff0c\u5de5\u4f5c\u51fd\u6570\u4e3aworker\uff0csem\u4e3aworker\u5165\u53c2 for ( i = 0 ; i < nthreads ; i ++ ) if ( uv_thread_create ( threads + i , worker , & sem )) abort (); } \u7ebf\u7a0b\u6c60\u521d\u59cb\u5316\u65f6\uff0c\u4f1a\u6839\u636e\u914d\u7f6e\u7684\u5b50\u7ebf\u7a0b\u6570\u521b\u5efa\u5bf9\u5e94\u6570\u91cf\u7684\u7ebf\u7a0b\u3002\u9ed8\u8ba4\u662f4\u4e2a\uff0c\u6700\u5927128\u4e2a\u5b50\u7ebf\u7a0b\uff08\u4e0d\u540c\u7248\u672c\u7684Libuv\u53ef\u80fd\u4f1a\u4e0d\u4e00\u6837\uff09\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u901a\u8fc7\u73af\u5883\u53d8\u91cf\u8bbe\u7f6e\u81ea\u5b9a\u4e49\u7684\u5927\u5c0f\u3002\u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u5316\u4e3b\u8981\u662f\u521d\u59cb\u5316\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\uff0c\u7136\u540e\u521b\u5efa\u591a\u4e2a\u7ebf\u7a0b\uff0c\u63a5\u7740\u5728\u6bcf\u4e2a\u7ebf\u7a0b\u91cc\u6267\u884cworker\u51fd\u6570\u5904\u7406\u4efb\u52a1\u3002\u540e\u9762\u6211\u4eec\u4f1a\u5206\u6790worker\u7684\u903b\u8f91\u3002","title":"4.2.1 \u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u5316"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#422","text":"\u4e86\u89e3\u7ebf\u7a0b\u6c60\u7684\u521d\u59cb\u5316\u4e4b\u540e\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4efb\u52a1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // \u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4e00\u4e2a\u4efb\u52a1 void uv__work_submit ( uv_loop_t * loop , struct uv__work * w , enum uv__work_kind kind , void ( * work )( struct uv__work * w ), void ( * done )( struct uv__work * w , int status )){ /* \u4fdd\u8bc1\u5df2\u7ecf\u521d\u59cb\u5316\u7ebf\u7a0b\uff0c\u5e76\u53ea\u6267\u884c\u4e00\u6b21\uff0c\u6240\u4ee5\u7ebf\u7a0b\u6c60\u662f\u5728\u63d0\u4ea4\u7b2c\u4e00\u4e2a \u4efb\u52a1\u7684\u65f6\u5019\u624d\u88ab\u521d\u59cb\u5316\uff0cinit_once -> init_threads */ uv_once ( & once , init_once ); w -> loop = loop ; w -> work = work ; w -> done = done ; post ( & w -> wq , kind ); } \u8fd9\u91cc\u628a\u4e1a\u52a1\u76f8\u5173\u7684\u51fd\u6570\u548c\u4efb\u52a1\u5b8c\u6210\u540e\u7684\u56de\u8c03\u51fd\u6570\u5c01\u88c5\u5230uv__work\u7ed3\u6784\u4f53\u4e2d\u3002uv__work\u7ed3\u6784\u5b9a\u4e49\u5982\u4e0b\u3002 1 2 3 4 5 6 struct uv__work { void ( * work )( struct uv__work * w ); void ( * done )( struct uv__work * w , int status ); struct uv_loop_s * loop ; void * wq [ 2 ]; }; \u7136\u540e\u8c03\u8c03\u7528post\u51fd\u6570\u5f80\u7ebf\u7a0b\u6c60\u7684\u961f\u5217\u4e2d\u52a0\u5165\u4e00\u4e2a\u65b0\u7684\u4efb\u52a1\u3002Libuv\u628a\u4efb\u52a1\u5206\u4e3a\u4e09\u79cd\u7c7b\u578b\uff0c\u6162IO\uff08DNS\u89e3\u6790\uff09\u3001\u5febIO\uff08\u6587\u4ef6\u64cd\u4f5c\uff09\u3001CPU\u5bc6\u96c6\u578b\u7b49\uff0ckind\u5c31\u662f\u8bf4\u660e\u4efb\u52a1\u7684\u7c7b\u578b\u7684\u3002\u6211\u4eec\u63a5\u7740\u770bpost\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 static void post ( QUEUE * q , enum uv__work_kind kind ) { // \u52a0\u9501\u8bbf\u95ee\u4efb\u52a1\u961f\u5217\uff0c\u56e0\u4e3a\u8fd9\u4e2a\u961f\u5217\u662f\u7ebf\u7a0b\u6c60\u5171\u4eab\u7684 uv_mutex_lock ( & mutex ); // \u7c7b\u578b\u662f\u6162IO if ( kind == UV__WORK_SLOW_IO ) { /* \u63d2\u5165\u6162IO\u5bf9\u5e94\u7684\u961f\u5217\uff0cLibuv\u8fd9\u4e2a\u7248\u672c\u628a\u4efb\u52a1\u5206\u4e3a\u51e0\u79cd\u7c7b\u578b\uff0c \u5bf9\u4e8e\u6162IO\u7c7b\u578b\u7684\u4efb\u52a1\uff0cLibuv\u662f\u5f80\u4efb\u52a1\u961f\u5217\u91cc\u9762\u63d2\u5165\u4e00\u4e2a\u7279\u6b8a\u7684\u8282\u70b9 run_slow_work_message\uff0c\u7136\u540e\u7528slow_io_pending_wq\u7ef4\u62a4\u4e86\u4e00\u4e2a\u6162IO \u4efb\u52a1\u7684\u961f\u5217\uff0c\u5f53\u5904\u7406\u5230run_slow_work_message\u8fd9\u4e2a\u8282\u70b9\u7684\u65f6\u5019\uff0c Libuv\u4f1a\u4eceslow_io_pending_wq\u961f\u5217\u91cc\u9010\u4e2a\u53d6\u51fa\u4efb\u52a1\u8282\u70b9\u6765\u6267\u884c\u3002 */ QUEUE_INSERT_TAIL ( & slow_io_pending_wq , q ); /* \u6709\u6162IO\u4efb\u52a1\u7684\u65f6\u5019\uff0c\u9700\u8981\u7ed9\u4e3b\u961f\u5217wq\u63d2\u5165\u4e00\u4e2a\u6d88\u606f\u8282\u70b9 run_slow_work_message,\u8bf4\u660e\u6709\u6162IO\u4efb\u52a1\uff0c\u6240\u4ee5\u5982\u679c run_slow_work_message\u662f\u7a7a\uff0c\u8bf4\u660e\u8fd8\u6ca1\u6709\u63d2\u5165\u4e3b\u961f\u5217\u3002\u9700\u8981\u8fdb\u884c q = &run_slow_work_message;\u8d4b\u503c\uff0c\u7136\u540e\u628a run_slow_work_message\u63d2\u5165\u4e3b\u961f\u5217\u3002\u5982\u679crun_slow_work_message \u975e\u7a7a\uff0c\u8bf4\u660e\u5df2\u7ecf\u63d2\u5165\u7ebf\u7a0b\u6c60\u7684\u4efb\u52a1\u961f\u5217\u4e86\u3002\u89e3\u9501\u7136\u540e\u76f4\u63a5\u8fd4\u56de\u3002 */ if ( ! QUEUE_EMPTY ( & run_slow_work_message )) { uv_mutex_unlock ( & mutex ); return ; } // \u8bf4\u660erun_slow_work_message\u8fd8\u6ca1\u6709\u63d2\u5165\u961f\u5217\uff0c\u51c6\u5907\u63d2\u5165\u961f\u5217 q = & run_slow_work_message ; } // \u628a\u8282\u70b9\u63d2\u5165\u4e3b\u961f\u5217\uff0c\u53ef\u80fd\u662f\u6162IO\u6d88\u606f\u8282\u70b9\u6216\u8005\u4e00\u822c\u4efb\u52a1 QUEUE_INSERT_TAIL ( & wq , q ); /* \u6709\u7a7a\u95f2\u7ebf\u7a0b\u5219\u5524\u9192\u5b83\uff0c\u5982\u679c\u5927\u5bb6\u90fd\u5728\u5fd9\uff0c \u5219\u7b49\u5230\u5b83\u5fd9\u5b8c\u540e\u5c31\u4f1a\u91cd\u65b0\u5224\u65ad\u662f\u5426\u8fd8\u6709\u65b0\u4efb\u52a1 */ if ( idle_threads > 0 ) uv_cond_signal ( & cond ); // \u64cd\u4f5c\u5b8c\u961f\u5217\uff0c\u89e3\u9501 uv_mutex_unlock ( & mutex ); } \u8fd9\u5c31\u662fLibuv\u4e2d\u7ebf\u7a0b\u6c60\u7684\u751f\u4ea7\u8005\u903b\u8f91\u3002\u4efb\u52a1\u961f\u5217\u7684\u67b6\u6784\u5982\u56fe4-3\u6240\u793a\u3002 \u9664\u4e86\u4e0a\u9762\u63d0\u5230\u7684\uff0cLibuv\u8fd8\u63d0\u4f9b\u4e86\u53e6\u5916\u4e00\u79cd\u751f\u4ea7\u4efb\u52a1\u7684\u65b9\u5f0f\uff0c\u5373uv_queue_work\u51fd\u6570\uff0c\u5b83\u53ea\u63d0\u4ea4CPU\u5bc6\u96c6\u578b\u7684\u4efb\u52a1\uff08\u5728Node.js\u7684crypto\u6a21\u5757\u4e2d\u4f7f\u7528\uff09\u3002\u4e0b\u9762\u6211\u4eec\u770buv_queue_work\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int uv_queue_work ( uv_loop_t * loop , uv_work_t * req , uv_work_cb work_cb , uv_after_work_cb after_work_cb ) { if ( work_cb == NULL ) return UV_EINVAL ; uv__req_init ( loop , req , UV_WORK ); req -> loop = loop ; req -> work_cb = work_cb ; req -> after_work_cb = after_work_cb ; uv__work_submit ( loop , & req -> work_req , UV__WORK_CPU , uv__queue_work , uv__queue_done ); return 0 ; } uv_queue_work\u51fd\u6570\u5176\u5b9e\u4e5f\u6ca1\u6709\u592a\u591a\u7684\u903b\u8f91\uff0c\u5b83\u4fdd\u5b58\u7528\u6237\u7684\u5de5\u4f5c\u51fd\u6570\u548c\u56de\u8c03\u5230request\u4e2d\u3002\u7136\u540e\u628auv__queue_work\u548cuv__queue_done\u5c01\u88c5\u5230uv__work\u4e2d\uff0c\u63a5\u7740\u63d0\u4ea4\u4efb\u52a1\u5230\u7ebf\u7a0b\u6c60\u4e2d\u3002\u6240\u4ee5\u5f53\u8fd9\u4e2a\u4efb\u52a1\u88ab\u6267\u884c\u7684\u65f6\u5019\u3002\u5b83\u4f1a\u6267\u884c\u5de5\u4f5c\u51fd\u6570uv__queue_work\u3002 1 2 3 4 5 static void uv__queue_work ( struct uv__work * w ) { // \u901a\u8fc7\u7ed3\u6784\u4f53\u67d0\u5b57\u6bb5\u62ff\u5230\u7ed3\u6784\u4f53\u5730\u5740 uv_work_t * req = container_of ( w , uv_work_t , work_req ); req -> work_cb ( req ); } \u6211\u4eec\u770b\u5230uv__queue_work\u5176\u5b9e\u5c31\u662f\u5bf9\u7528\u6237\u5b9a\u4e49\u7684\u4efb\u52a1\u51fd\u6570\u8fdb\u884c\u4e86\u5c01\u88c5\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u731c\u5230\uff0cuv__queue_done\u4e5f\u53ea\u662f\u5bf9\u7528\u6237\u56de\u8c03\u7684\u7b80\u5355\u5c01\u88c5\uff0c\u5373\u5b83\u4f1a\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002","title":"4.2.2 \u63d0\u4ea4\u4efb\u52a1\u5230\u7ebf\u7a0b\u6c60"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#423","text":"\u6211\u4eec\u63d0\u4ea4\u4e86\u4efb\u52a1\u540e\uff0c\u7ebf\u7a0b\u81ea\u7136\u8981\u5904\u7406\uff0c\u521d\u59cb\u5316\u7ebf\u7a0b\u6c60\u7684\u65f6\u5019\u6211\u4eec\u5206\u6790\u8fc7\uff0cworker\u51fd\u6570\u662f\u8d1f\u8d23\u5904\u7406\u4efb\u52a1\u3002\u6211\u4eec\u770b\u4e00\u4e0bworker\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 static void worker ( void * arg ) { struct uv__work * w ; QUEUE * q ; int is_slow_work ; // \u7ebf\u7a0b\u542f\u52a8\u6210\u529f uv_sem_post (( uv_sem_t * ) arg ); arg = NULL ; // \u52a0\u9501\u4e92\u65a5\u8bbf\u95ee\u4efb\u52a1\u961f\u5217 uv_mutex_lock ( & mutex ); for (;;) { /* 1 \u961f\u5217\u4e3a\u7a7a 2 \u961f\u5217\u4e0d\u4e3a\u7a7a\uff0c\u4f46\u662f\u961f\u5217\u4e2d\u53ea\u6709\u6162IO\u4efb\u52a1\u4e14\u6b63\u5728\u6267\u884c\u7684\u6162IO\u4efb\u52a1 \u4e2a\u6570\u8fbe\u5230\u9608\u503c\u5219\u7a7a\u95f2\u7ebf\u7a0b\u52a0\u4e00\uff0c\u9632\u6b62\u6162IO\u5360\u7528\u8fc7\u591a\u7ebf\u7a0b\uff0c\u5bfc\u81f4 \u5176\u5b83\u5feb\u7684\u4efb\u52a1\u65e0\u6cd5\u5f97\u5230\u6267\u884c */ while ( QUEUE_EMPTY ( & wq ) || ( QUEUE_HEAD ( & wq ) == & run_slow_work_message && QUEUE_NEXT ( & run_slow_work_message ) == & wq && slow_io_work_running >= slow_work_thread_threshold ())) { idle_threads += 1 ; // \u963b\u585e\uff0c\u7b49\u5f85\u5524\u9192 uv_cond_wait ( & cond , & mutex ); // \u88ab\u5524\u9192\uff0c\u5f00\u59cb\u5e72\u6d3b\uff0c\u7a7a\u95f2\u7ebf\u7a0b\u6570\u51cf\u4e00 idle_threads -= 1 ; } // \u53d6\u51fa\u5934\u7ed3\u70b9\uff0c\u5934\u6307\u70b9\u53ef\u80fd\u662f\u9000\u51fa\u6d88\u606f\u3001\u6162IO\uff0c\u4e00\u822c\u8bf7\u6c42 q = QUEUE_HEAD ( & wq ); // \u5982\u679c\u5934\u7ed3\u70b9\u662f\u9000\u51fa\u6d88\u606f\uff0c\u5219\u7ed3\u675f\u7ebf\u7a0b if ( q == & exit_message ) { /* \u5524\u9192\u5176\u5b83\u56e0\u4e3a\u6ca1\u6709\u4efb\u52a1\u6b63\u963b\u585e\u7b49\u5f85\u4efb\u52a1\u7684\u7ebf\u7a0b\uff0c \u544a\u8bc9\u5b83\u4eec\u51c6\u5907\u9000\u51fa */ uv_cond_signal ( & cond ); uv_mutex_unlock ( & mutex ); break ; } // \u79fb\u9664\u8282\u70b9 QUEUE_REMOVE ( q ); // \u91cd\u7f6e\u524d\u540e\u6307\u9488 QUEUE_INIT ( q ); is_slow_work = 0 ; /* \u5982\u679c\u5f53\u524d\u8282\u70b9\u7b49\u4e8e\u6162IO\u8282\u70b9\uff0c\u4e0a\u9762\u7684while\u53ea\u5224\u65ad\u4e86\u662f\u4e0d\u662f\u53ea\u6709\u6162 IO\u4efb\u52a1\u4e14\u8fbe\u5230\u9608\u503c\uff0c\u8fd9\u91cc\u662f\u4efb\u52a1\u961f\u5217\u91cc\u80af\u5b9a\u6709\u975e\u6162IO\u4efb\u52a1\uff0c\u53ef\u80fd\u6709 \u6162IO\uff0c\u5982\u679c\u6709\u6162IO\u5e76\u4e14\u6b63\u5728\u6267\u884c\u7684\u4e2a\u6570\u8fbe\u5230\u9608\u503c\uff0c\u5219\u5148\u4e0d\u5904\u7406\u8be5\u6162 IO\u4efb\u52a1\uff0c\u7ee7\u7eed\u5224\u65ad\u662f\u5426\u8fd8\u6709\u975e\u6162IO\u4efb\u52a1\u53ef\u6267\u884c\u3002 */ if ( q == & run_slow_work_message ) { // \u8fbe\u5230\u9608\u503c\uff0c\u8be5\u8282\u70b9\u91cd\u65b0\u5165\u961f\uff0c\u56e0\u4e3a\u521a\u624d\u88ab\u5220\u9664\u4e86 if ( slow_io_work_running >= slow_work_thread_threshold ()) { QUEUE_INSERT_TAIL ( & wq , q ); continue ; } /* \u6ca1\u6709\u6162IO\u4efb\u52a1\u5219\u7ee7\u7eed\uff0c\u8fd9\u65f6\u5019run_slow_work_message \u5df2\u7ecf\u4ece\u961f\u5217\u4e2d\u88ab\u5220\u9664\uff0c\u4e0b\u6b21\u6709\u6162IO\u7684\u65f6\u5019\u91cd\u65b0\u5165\u961f */ if ( QUEUE_EMPTY ( & slow_io_pending_wq )) continue ; // \u6709\u6162IO\uff0c\u5f00\u59cb\u5904\u7406\u6162IO\u4efb\u52a1 is_slow_work = 1 ; /* \u6b63\u5728\u5904\u7406\u6162IO\u4efb\u52a1\u7684\u4e2a\u6570\u7d2f\u52a0\uff0c\u7528\u4e8e\u5176\u5b83\u7ebf\u7a0b\u5224\u65ad\u6162IO\u4efb\u52a1\u4e2a \u6570\u662f\u5426\u8fbe\u5230\u9608\u503c, slow_io_work_running\u662f\u591a\u4e2a\u7ebf\u7a0b\u5171\u4eab\u7684\u53d8\u91cf */ slow_io_work_running ++ ; // \u6458\u4e0b\u4e00\u4e2a\u6162IO\u4efb\u52a1 q = QUEUE_HEAD ( & slow_io_pending_wq ); // \u4ece\u6162IO\u961f\u5217\u79fb\u9664 QUEUE_REMOVE ( q ); QUEUE_INIT ( q ); /* \u53d6\u51fa\u4e00\u4e2a\u4efb\u52a1\u540e\uff0c\u5982\u679c\u8fd8\u6709\u6162IO\u4efb\u52a1\u5219\u628a\u6162IO\u6807\u8bb0\u8282\u70b9\u91cd\u65b0\u5165 \u961f\uff0c\u8868\u793a\u8fd8\u6709\u6162IO\u4efb\u52a1\uff0c\u56e0\u4e3a\u4e0a\u9762\u628a\u8be5\u6807\u8bb0\u8282\u70b9\u51fa\u961f\u4e86 */ if ( ! QUEUE_EMPTY ( & slow_io_pending_wq )) { QUEUE_INSERT_TAIL ( & wq , & run_slow_work_message ); // \u6709\u7a7a\u95f2\u7ebf\u7a0b\u5219\u5524\u9192\u5b83\uff0c\u56e0\u4e3a\u8fd8\u6709\u4efb\u52a1\u5904\u7406 if ( idle_threads > 0 ) uv_cond_signal ( & cond ); } } // \u4e0d\u9700\u8981\u64cd\u4f5c\u961f\u5217\u4e86\uff0c\u5c3d\u5feb\u91ca\u653e\u9501 uv_mutex_unlock ( & mutex ); // q\u662f\u6162IO\u6216\u8005\u4e00\u822c\u4efb\u52a1 w = QUEUE_DATA ( q , struct uv__work , wq ); // \u6267\u884c\u4e1a\u52a1\u7684\u4efb\u52a1\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u4e00\u822c\u4f1a\u963b\u585e w -> work ( w ); // \u51c6\u5907\u64cd\u4f5cloop\u7684\u4efb\u52a1\u5b8c\u6210\u961f\u5217\uff0c\u52a0\u9501 uv_mutex_lock ( & w -> loop -> wq_mutex ); // \u7f6e\u7a7a\u8bf4\u660e\u6267\u884c\u5b8c\u4e86\uff0c\u89c1cancel\u903b\u8f91 w -> work = NULL ; /* \u6267\u884c\u5b8c\u4efb\u52a1,\u63d2\u5165\u5230loop\u7684wq\u961f\u5217,\u5728uv__work_done\u7684\u65f6\u5019\u4f1a \u6267\u884c\u8be5\u961f\u5217\u7684\u8282\u70b9 */ QUEUE_INSERT_TAIL ( & w -> loop -> wq , & w -> wq ); // \u901a\u77e5loop\u7684wq_async\u8282\u70b9 uv_async_send ( & w -> loop -> wq_async ); uv_mutex_unlock ( & w -> loop -> wq_mutex ); // \u4e3a\u4e0b\u4e00\u8f6e\u64cd\u4f5c\u4efb\u52a1\u961f\u5217\u52a0\u9501 uv_mutex_lock ( & mutex ); /* \u6267\u884c\u5b8c\u6162IO\u4efb\u52a1\uff0c\u8bb0\u5f55\u6b63\u5728\u6267\u884c\u7684\u6162IO\u4e2a\u6570\u53d8\u91cf\u51cf1\uff0c \u4e0a\u9762\u52a0\u9501\u4fdd\u8bc1\u4e86\u4e92\u65a5\u8bbf\u95ee\u8fd9\u4e2a\u53d8\u91cf */ if ( is_slow_work ) { slow_io_work_running -- ; } } } \u6211\u4eec\u770b\u5230\u6d88\u8d39\u8005\u7684\u903b\u8f91\u4f3c\u4e4e\u6bd4\u8f83\u590d\u6742\uff0c\u5bf9\u4e8e\u6162IO\u7c7b\u578b\u7684\u4efb\u52a1\uff0cLibuv\u9650\u5236\u4e86\u5904\u7406\u6162IO\u4efb\u52a1\u7684\u7ebf\u7a0b\u6570\uff0c\u907f\u514d\u8017\u65f6\u6bd4\u8f83\u5c11\u7684\u4efb\u52a1\u5f97\u4e0d\u5230\u5904\u7406\u3002\u5176\u4f59\u7684\u903b\u8f91\u548c\u4e00\u822c\u7684\u7ebf\u7a0b\u6c60\u7c7b\u4f3c\uff0c\u5c31\u662f\u4e92\u65a5\u8bbf\u95ee\u4efb\u52a1\u961f\u5217\uff0c\u7136\u540e\u53d6\u51fa\u8282\u70b9\u6267\u884c\uff0c\u6267\u884c\u5b8c\u540e\u901a\u77e5\u4e3b\u7ebf\u7a0b\u3002\u7ed3\u6784\u5982\u56fe4-4\u6240\u793a\u3002","title":"4.2.3 \u5904\u7406\u4efb\u52a1"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#424","text":"\u7ebf\u7a0b\u6267\u884c\u5b8c\u4efb\u52a1\u540e\uff0c\u5e76\u4e0d\u662f\u76f4\u63a5\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u800c\u662f\u901a\u77e5\u4e3b\u7ebf\u7a0b\uff0c\u7531\u4e3b\u7ebf\u7a0b\u7edf\u4e00\u5904\u7406\uff0c\u8fd9\u662fNode.js\u5355\u7ebf\u7a0b\u4e8b\u4ef6\u5faa\u73af\u7684\u8981\u6c42\uff0c\u4e5f\u907f\u514d\u4e86\u591a\u7ebf\u7a0b\u5e26\u6765\u7684\u590d\u6742\u95ee\u9898\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u5757\u7684\u903b\u8f91\u3002\u4e00\u5207\u8981\u4eceLibuv\u7684\u521d\u59cb\u5316\u5f00\u59cb 1 uv_default_loop (); -> uv_loop_init (); -> uv_async_init ( loop , & loop -> wq_async , uv__work_done ); \u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\u4e3b\u7ebf\u7a0b\u548c\u5b50\u7ebf\u7a0b\u7684\u901a\u4fe1\u673a\u5236\uff0cwq_async\u662f\u7528\u4e8e\u7ebf\u7a0b\u6c60\u4e2d\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u7684async handle\uff0c\u5b83\u5bf9\u5e94\u7684\u56de\u8c03\u662fuv__work_done\u3002\u6240\u4ee5\u5f53\u4e00\u4e2a\u7ebf\u7a0b\u6c60\u7684\u7ebf\u7a0b\u4efb\u52a1\u5b8c\u6210\u65f6\uff0c\u901a\u8fc7uv_async_send(&w->loop->wq_async)\u8bbe\u7f6eloop->wq_async.pending = 1\uff0c\u7136\u540e\u901a\u77e5IO\u89c2\u5bdf\u8005\uff0cLibuv\u5728Poll IO\u9636\u6bb5\u5c31\u4f1a\u6267\u884c\u8be5handle\u5bf9\u5e94\u7684\u56de\u8c03uv__work_done\u51fd\u6570\u3002\u90a3\u4e48\u6211\u4eec\u5c31\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void uv__work_done ( uv_async_t * handle ) { struct uv__work * w ; uv_loop_t * loop ; QUEUE * q ; QUEUE wq ; int err ; // \u901a\u8fc7\u7ed3\u6784\u4f53\u5b57\u6bb5\u83b7\u5f97\u7ed3\u6784\u4f53\u9996\u5730\u5740 loop = container_of ( handle , uv_loop_t , wq_async ); // \u51c6\u5907\u5904\u7406\u961f\u5217\uff0c\u52a0\u9501 uv_mutex_lock ( & loop -> wq_mutex ); /* loop->wq\u662f\u5df2\u5b8c\u6210\u7684\u4efb\u52a1\u961f\u5217\u3002\u628aloop->wq\u961f\u5217\u7684\u8282\u70b9\u5168\u90e8\u79fb\u5230 wp\u53d8\u91cf\u4e2d\uff0c\u8fd9\u6837\u4e00\u6765\u53ef\u4ee5\u5c3d\u5feb\u91ca\u653e\u9501 */ QUEUE_MOVE ( & loop -> wq , & wq ); // \u4e0d\u9700\u8981\u4f7f\u7528\u4e86\uff0c\u89e3\u9501 uv_mutex_unlock ( & loop -> wq_mutex ); // wq\u961f\u5217\u7684\u8282\u70b9\u6765\u81ea\u5b50\u7ebf\u7a0b\u63d2\u5165 while ( ! QUEUE_EMPTY ( & wq )) { q = QUEUE_HEAD ( & wq ); QUEUE_REMOVE ( q ); w = container_of ( q , struct uv__work , wq ); // \u7b49\u4e8euv__canceled\u8bf4\u660e\u8fd9\u4e2a\u4efb\u52a1\u88ab\u53d6\u6d88\u4e86 err = ( w -> work == uv__cancelled ) ? UV_ECANCELED : 0 ; // \u6267\u884c\u56de\u8c03 w -> done ( w , err ); } } \u8be5\u51fd\u6570\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u9010\u4e2a\u5904\u7406\u5df2\u5b8c\u6210\u7684\u4efb\u52a1\u8282\u70b9\uff0c\u6267\u884c\u56de\u8c03\uff0c\u5728Node.js\u4e2d\uff0c\u8fd9\u91cc\u7684\u56de\u8c03\u662fC++\u5c42\uff0c\u7136\u540e\u518d\u5230JS\u5c42\u3002\u7ed3\u6784\u56fe\u5982\u56fe4-5\u6240\u793a\u3002","title":"4.2.4 \u901a\u77e5\u4e3b\u7ebf\u7a0b"},{"location":"chapter04-%E7%BA%BF%E7%A8%8B%E6%B1%A0/#425","text":"\u7ebf\u7a0b\u6c60\u7684\u8bbe\u8ba1\u4e2d\uff0c\u53d6\u6d88\u4efb\u52a1\u662f\u4e00\u4e2a\u6bd4\u8f83\u91cd\u8981\u7684\u80fd\u529b\uff0c\u56e0\u4e3a\u5728\u7ebf\u7a0b\u91cc\u6267\u884c\u7684\u90fd\u662f\u4e00\u4e9b\u8017\u65f6\u6216\u8005\u5f15\u8d77\u963b\u585e\u7684\u64cd\u4f5c\uff0c\u5982\u679c\u80fd\u53ca\u65f6\u53d6\u6d88\u4e00\u4e2a\u4efb\u52a1\uff0c\u5c06\u4f1a\u51cf\u8f7b\u5f88\u591a\u6ca1\u5fc5\u8981\u7684\u5904\u7406\u3002\u4e0d\u8fc7Libuv\u5b9e\u73b0\u4e2d\uff0c\u53ea\u6709\u5f53\u4efb\u52a1\u8fd8\u5728\u7b49\u5f85\u961f\u5217\u4e2d\u624d\u80fd\u88ab\u53d6\u6d88\uff0c\u5982\u679c\u4e00\u4e2a\u4efb\u52a1\u6b63\u5728\u88ab\u7ebf\u7a0b\u5904\u7406\uff0c\u5219\u65e0\u6cd5\u53d6\u6d88\u4e86\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bLibuv\u4e2d\u662f\u5982\u4f55\u5b9e\u73b0\u53d6\u6d88\u4efb\u52a1\u7684\u3002Libuv\u63d0\u4f9b\u4e86uv__work_cancel\u51fd\u6570\u652f\u6301\u7528\u6237\u53d6\u6d88\u63d0\u4ea4\u7684\u4efb\u52a1\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 static int uv__work_cancel ( uv_loop_t * loop , uv_req_t * req , struct uv__work * w ) { int cancelled ; // \u52a0\u9501\uff0c\u4e3a\u4e86\u628a\u8282\u70b9\u79fb\u51fa\u961f\u5217 uv_mutex_lock ( & mutex ); // \u52a0\u9501\uff0c\u4e3a\u4e86\u5224\u65adw->wq\u662f\u5426\u4e3a\u7a7a uv_mutex_lock ( & w -> loop -> wq_mutex ); /* cancelled\u4e3atrue\u8bf4\u660e\u4efb\u52a1\u8fd8\u5728\u7ebf\u7a0b\u6c60\u961f\u5217\u7b49\u5f85\u5904\u7406 1 \u5904\u7406\u5b8c\uff0cw->work == NULL 2 \u5904\u7406\u4e2d\uff0cQUEUE_EMPTY(&w->wq)\u4e3atrue\uff0c\u56e0 \u4e3aworker\u5728\u6458\u4e0b\u4e00\u4e2a\u4efb\u52a1\u7684\u65f6\u5019\uff0c\u91cd\u7f6eprev\u548cnext\u6307\u9488 3 \u672a\u5904\u7406\uff0c!QUEUE_EMPTY(&w->wq)\u662ftrue \u4e14w->work != NULL */ cancelled = ! QUEUE_EMPTY ( & w -> wq ) && w -> work != NULL ; // \u4ece\u7ebf\u7a0b\u6c60\u4efb\u52a1\u961f\u5217\u4e2d\u5220\u9664\u8be5\u8282\u70b9 if ( cancelled ) QUEUE_REMOVE ( & w -> wq ); uv_mutex_unlock ( & w -> loop -> wq_mutex ); uv_mutex_unlock ( & mutex ); // \u6b63\u5728\u6267\u884c\u6216\u8005\u5df2\u7ecf\u6267\u884c\u5b8c\u4e86\uff0c\u5219\u4e0d\u80fd\u53d6\u6d88 if ( ! cancelled ) return UV_EBUSY ; // \u6253\u53d6\u6d88\u6807\u8bb0\uff0cLibuv\u6267\u884c\u56de\u8c03\u7684\u65f6\u5019\u7528\u5230 w -> work = uv__cancelled ; uv_mutex_lock ( & loop -> wq_mutex ); /* \u63d2\u5165loop\u7684wq\u961f\u5217\uff0c\u5bf9\u4e8e\u53d6\u6d88\u7684\u52a8\u4f5c\uff0cLibuv\u8ba4\u4e3a\u662f\u4efb\u52a1\u6267\u884c\u5b8c\u4e86\u3002 \u6240\u4ee5\u63d2\u5165\u5df2\u5b8c\u6210\u7684\u961f\u5217\uff0c\u6267\u884c\u56de\u8c03\u7684\u65f6\u5019\u4f1a\u901a\u77e5\u7528\u6237\u8be5\u4efb\u52a1\u7684\u6267\u884c\u7ed3\u679c \u662f\u53d6\u6d88\uff0c\u9519\u8bef\u7801\u662fUV_ECANCELED */ QUEUE_INSERT_TAIL ( & loop -> wq , & w -> wq ); // \u901a\u77e5\u4e3b\u7ebf\u7a0b\u6709\u4efb\u52a1\u5b8c\u6210 uv_async_send ( & loop -> wq_async ); uv_mutex_unlock ( & loop -> wq_mutex ); return 0 ; } \u5728Libuv\u4e2d\uff0c\u53d6\u6d88\u4efb\u52a1\u7684\u65b9\u5f0f\u5c31\u662f\u628a\u8282\u70b9\u4ece\u7ebf\u7a0b\u6c60\u5f85\u5904\u7406\u961f\u5217\u4e2d\u5220\u9664\uff0c\u7136\u540e\u6253\u4e0a\u53d6\u6d88\u7684\u6807\u8bb0\uff08w->work = uv__cancelled\uff09\uff0c\u63a5\u7740\u628a\u8be5\u8282\u70b9\u63d2\u5165\u5df2\u5b8c\u6210\u961f\u5217\uff0cLibuv\u5728\u5904\u7406\u5df2\u5b8c\u6210\u961f\u5217\u7684\u8282\u70b9\u65f6\uff0c\u5224\u65ad\u5982\u679cw->work == uv__cancelled\u5219\u5728\u6267\u884c\u7528\u6237\u56de\u8c03\u65f6\uff0c\u4f20\u5165\u9519\u8bef\u7801UV_ECANCELED\uff0c\u6211\u4eec\u770b\u5230uv__work_cancel\u8fd9\u4e2a\u51fd\u6570\u5b9a\u4e49\u524d\u9762\u52a0\u4e86\u4e00\u4e2astatic\uff0c\u8bf4\u660e\u8fd9\u4e2a\u51fd\u6570\u662f\u53ea\u5728\u672c\u6587\u4ef6\u5185\u4f7f\u7528\u7684\uff0cLibuv\u5bf9\u5916\u63d0\u4f9b\u7684\u53d6\u6d88\u4efb\u52a1\u7684\u63a5\u53e3\u662fuv_cancel\u3002","title":"4.2.5 \u53d6\u6d88\u4efb\u52a1"},{"location":"chapter05-Libuv%E6%B5%81/","text":"\u7b2c\u4e94\u7ae0 Libuv\u6d41 \u00b6 \u6d41\u7684\u5b9e\u73b0\u5728Libuv\u91cc\u5360\u4e86\u5f88\u5927\u7684\u7bc7\u5e45\uff0c\u662f\u975e\u5e38\u6838\u5fc3\u7684\u903b\u8f91\u3002\u6d41\u7684\u672c\u8d28\u662f\u5c01\u88c5\u4e86\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u64cd\u4f5c\uff0c\u4f8b\u5982\u8bfb\u3001\u5199\uff0c\u8fde\u63a5\u3001\u76d1\u542c\u3002\u6211\u4eec\u9996\u5148\u770b\u770b\u6570\u636e\u7ed3\u6784\uff0c\u6d41\u5728Libuv\u91cc\u7528uv_stream_s\u8868\u793a\uff0c\u7ee7\u627f\u4e8euv_handle_s\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 struct uv_stream_s { // uv_handle_s\u7684\u5b57\u6bb5 void * data ; // \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; // handle\u7c7b\u578b uv_handle_type type ; // \u5173\u95edhandle\u65f6\u7684\u56de\u8c03 uv_close_cb close_cb ; // \u7528\u4e8e\u63d2\u5165\u4e8b\u4ef6\u5faa\u73af\u7684handle\u961f\u5217 void * handle_queue [ 2 ]; union { int fd ; void * reserved [ 4 ]; } u ; // \u7528\u4e8e\u63d2\u5165\u4e8b\u4ef6\u5faa\u73af\u7684closing\u9636\u6bb5 uv_handle_t * next_closing ; // \u5404\u79cd\u6807\u8bb0 unsigned int flags ; // \u6d41\u62d3\u5c55\u7684\u5b57\u6bb5 /* \u6237\u5199\u5165\u6d41\u7684\u5b57\u8282\u5927\u5c0f\uff0c\u6d41\u7f13\u5b58\u7528\u6237\u7684\u8f93\u5165\uff0c \u7136\u540e\u7b49\u5230\u53ef\u5199\u7684\u65f6\u5019\u624d\u6267\u884c\u771f\u6b63\u7684\u5199 */ size_t write_queue_size ; // \u5206\u914d\u5185\u5b58\u7684\u51fd\u6570\uff0c\u5185\u5b58\u7531\u7528\u6237\u5b9a\u4e49\uff0c\u7528\u6765\u4fdd\u5b58\u8bfb\u53d6\u7684\u6570\u636e uv_alloc_cb alloc_cb ; // \u8bfb\u56de\u8c03 uv_read_cb read_cb ; // \u8fde\u63a5\u8bf7\u6c42\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53 uv_connect_t * connect_req ; /* \u5173\u95ed\u5199\u7aef\u7684\u65f6\u5019\uff0c\u53d1\u9001\u5b8c\u7f13\u5b58\u7684\u6570\u636e\uff0c \u6267\u884cshutdown_req\u7684\u56de\u8c03\uff08shutdown_req\u5728uv_shutdown\u7684\u65f6\u5019\u8d4b\u503c\uff09 */ uv_shutdown_t * shutdown_req ; /* \u6d41\u5bf9\u5e94\u7684IO\u89c2\u5bdf\u8005 */ uv__io_t io_watcher ; // \u7f13\u5b58\u5f85\u5199\u7684\u6570\u636e\uff0c\u8be5\u5b57\u6bb5\u7528\u4e8e\u63d2\u5165\u961f\u5217 void * write_queue [ 2 ]; // \u5df2\u7ecf\u5b8c\u6210\u4e86\u6570\u636e\u5199\u5165\u7684\u961f\u5217\uff0c\u8be5\u5b57\u6bb5\u7528\u4e8e\u63d2\u5165\u961f\u5217 void * write_completed_queue [ 2 ]; // \u6709\u8fde\u63a5\u5230\u6765\u5e76\u4e14\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u540e\uff0c\u6267\u884c\u7684\u56de\u8c03 uv_connection_cb connection_cb ; // \u64cd\u4f5c\u6d41\u65f6\u51fa\u9519\u7801 int delayed_error ; // accept\u8fd4\u56de\u7684\u901a\u4fe1socket\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0 int accepted_fd ; // \u540c\u4e0a\uff0c\u7528\u4e8eIPC\u65f6\uff0c\u7f13\u5b58\u591a\u4e2a\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 void * queued_fds ; } \u6d41\u7684\u5b9e\u73b0\u4e2d\uff0c\u6700\u6838\u5fc3\u7684\u5b57\u6bb5\u662fIO\u89c2\u5bdf\u8005\uff0c\u5176\u4f59\u7684\u5b57\u6bb5\u662f\u548c\u6d41\u7684\u6027\u8d28\u76f8\u5173\u7684\u3002IO\u89c2\u5bdf\u8005\u5c01\u88c5\u4e86\u6d41\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e8b\u4ef6\u89e6\u53d1\u65f6\u7684\u56de\u8c03\u3002\u6bd4\u5982\u8bfb\u4e00\u4e2a\u6d41\u3001\u5199\u4e00\u4e2a\u6d41\u3001\u5173\u95ed\u4e00\u4e2a\u6d41\u3001\u8fde\u63a5\u4e00\u4e2a\u6d41\u3001\u76d1\u542c\u4e00\u4e2a\u6d41\uff0c\u5728uv_stream_s\u4e2d\u90fd\u6709\u5bf9\u5e94\u7684\u5b57\u6bb5\u53bb\u652f\u6301\u3002\u4f46\u662f\u672c\u8d28\u4e0a\u662f\u9760IO\u89c2\u5bdf\u8005\u53bb\u9a71\u52a8\u7684\u3002 1 \u8bfb\u4e00\u4e2a\u6d41\uff0c\u5c31\u662fIO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u6267\u884c\u7528\u6237\u7684\u8bfb\u56de\u8c03\u3002 2 \u5199\u4e00\u4e2a\u6d41\uff0c\u5148\u628a\u6570\u636e\u5199\u5230\u6d41\u4e2d\uff0c\u7b49\u5230IO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u6267\u884c\u771f\u6b63\u7684\u5199\u5165\uff0c\u5e76\u6267\u884c\u7528\u6237\u7684\u5199\u7ed3\u675f\u56de\u8c03\u3002 3 \u5173\u95ed\u4e00\u4e2a\u6d41\uff0c\u5c31\u662fIO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u5c31\u4f1a\u6267\u884c\u5173\u95ed\u6d41\u7684\u5199\u7aef\u3002\u5982\u679c\u6d41\u4e2d\u8fd8\u6709\u6570\u636e\u6ca1\u6709\u5199\u5b8c\uff0c\u5219\u5148\u5199\u5b8c\uff08\u6bd4\u5982\u53d1\u9001\uff09\u540e\u518d\u6267\u884c\u5173\u95ed\u64cd\u4f5c\uff0c\u63a5\u7740\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 4 \u8fde\u63a5\u6d41\uff0c\u6bd4\u5982\u4f5c\u4e3a\u5ba2\u6237\u7aef\u53bb\u8fde\u63a5\u670d\u52a1\u5668\u3002\u5c31\u662fIO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff08\u6bd4\u5982\u5efa\u7acb\u4e09\u6b21\u63e1\u624b\u6210\u529f\uff09\uff0c\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 5 \u76d1\u542c\u6d41\uff0c\u5c31\u662fIO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff08\u6bd4\u5982\u6709\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u7684\u8fde\u63a5\uff09\uff0c\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u6d41\u7684\u5177\u4f53\u5b9e\u73b0 5.1 \u521d\u59cb\u5316\u6d41 \u00b6 \u5728\u4f7f\u7528uv_stream_t\u4e4b\u524d\u9700\u8981\u9996\u5148\u521d\u59cb\u5316\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u521d\u59cb\u5316\u4e00\u4e2a\u6d41\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void uv__stream_init ( uv_loop_t * loop , uv_stream_t * stream , uv_handle_type type ) { int err ; // \u8bb0\u5f55handle\u7684\u7c7b\u578b uv__handle_init ( loop , ( uv_handle_t * ) stream , type ); stream -> read_cb = NULL ; stream -> alloc_cb = NULL ; stream -> close_cb = NULL ; stream -> connection_cb = NULL ; stream -> connect_req = NULL ; stream -> shutdown_req = NULL ; stream -> accepted_fd = -1 ; stream -> queued_fds = NULL ; stream -> delayed_error = 0 ; QUEUE_INIT ( & stream -> write_queue ); QUEUE_INIT ( & stream -> write_completed_queue ); stream -> write_queue_size = 0 ; /* \u521d\u59cb\u5316IO\u89c2\u5bdf\u8005\uff0c\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff08\u8fd9\u91cc\u8fd8\u6ca1\u6709\uff0c\u6240\u4ee5\u662f-1\uff09\u548c \u56de\u8c03uv__stream_io\u8bb0\u5f55\u5728io_watcher\u4e0a\uff0cfd\u7684\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u7edf\u4e00 \u7531uv__stream_io\u51fd\u6570\u5904\u7406\uff0c\u4f46\u4e5f\u4f1a\u6709\u7279\u6b8a\u60c5\u51b5\uff08\u4e0b\u9762\u4f1a\u8bb2\u5230\uff09 */ uv__io_init ( & stream -> io_watcher , uv__stream_io , -1 ); } \u521d\u59cb\u5316\u4e00\u4e2a\u6d41\u7684\u903b\u8f91\u5f88\u7b80\u5355\u660e\u4e86\uff0c\u5c31\u662f\u521d\u59cb\u5316\u76f8\u5173\u7684\u5b57\u6bb5\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\u521d\u59cb\u5316IO\u89c2\u5bdf\u8005\u65f6\uff0c\u8bbe\u7f6e\u7684\u5904\u7406\u51fd\u6570\u662fuv__stream_io\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u5206\u6790\u8fd9\u4e2a\u51fd\u6570\u7684\u5177\u4f53\u903b\u8f91\u3002 5.2 \u6253\u5f00\u6d41 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int uv__stream_open ( uv_stream_t * stream , int fd , int flags ) { // \u8fd8\u6ca1\u6709\u8bbe\u7f6efd\u6216\u8005\u8bbe\u7f6e\u7684\u540c\u4e00\u4e2afd\u5219\u7ee7\u7eed\uff0c\u5426\u5219\u8fd4\u56deUV_EBUSY if ( ! ( stream -> io_watcher . fd == -1 || stream -> io_watcher . fd == fd )) return UV_EBUSY ; // \u8bbe\u7f6e\u6d41\u7684\u6807\u8bb0 stream -> flags |= flags ; // \u662fTCP\u6d41\u5219\u53ef\u4ee5\u8bbe\u7f6e\u4e0b\u9762\u7684\u5c5e\u6027 if ( stream -> type == UV_TCP ) { // \u5173\u95ednagle\u7b97\u6cd5 if (( stream -> flags & UV_HANDLE_TCP_NODELAY ) && uv__tcp_nodelay ( fd , 1 )) return UV__ERR ( errno ); /* \u5f00\u542fkeepalive\u673a\u5236 */ if (( stream -> flags & UV_HANDLE_TCP_KEEPALIVE ) && uv__tcp_keepalive ( fd , 1 , 60 )) { return UV__ERR ( errno ); } } /* \u4fdd\u5b58socket\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5230IO\u89c2\u5bdf\u8005\u4e2d\uff0cLibuv\u4f1a\u5728 Poll IO\u9636\u6bb5\u76d1\u542c\u8be5\u6587\u4ef6\u63cf\u8ff0\u7b26 */ stream -> io_watcher . fd = fd ; return 0 ; } \u6253\u5f00\u4e00\u4e2a\u6d41\uff0c\u672c\u8d28\u4e0a\u5c31\u662f\u7ed9\u8fd9\u4e2a\u6d41\u5173\u8054\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u540e\u7eed\u7684\u64cd\u4f5c\u7684\u65f6\u5019\u90fd\u662f\u57fa\u4e8e\u8fd9\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\uff0c\u53e6\u5916\u8fd8\u6709\u4e00\u4e9b\u5c5e\u6027\u7684\u8bbe\u7f6e\u3002 5.3 \u8bfb\u6d41 \u00b6 \u6211\u4eec\u5728\u4e00\u4e2a\u6d41\u4e0a\u6267\u884cuv_read_start\u540e\uff0c\u6d41\u7684\u6570\u636e\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u5c31\u4f1a\u901a\u8fc7read_cb\u56de\u8c03\u6e90\u6e90\u4e0d\u65ad\u5730\u6d41\u5411\u8c03\u7528\u65b9\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int uv_read_start ( uv_stream_t * stream , uv_alloc_cb alloc_cb , uv_read_cb read_cb ) { // \u6d41\u5df2\u7ecf\u5173\u95ed\uff0c\u4e0d\u80fd\u8bfb if ( stream -> flags & UV_HANDLE_CLOSING ) return UV_EINVAL ; // \u6d41\u4e0d\u53ef\u8bfb\uff0c\u8bf4\u660e\u53ef\u80fd\u662f\u53ea\u5199\u6d41 if ( ! ( stream -> flags & UV_HANDLE_READABLE )) return - ENOTCONN ; // \u6807\u8bb0\u6b63\u5728\u8bfb stream -> flags |= UV_HANDLE_READING ; // \u8bb0\u5f55\u8bfb\u56de\u8c03\uff0c\u6709\u6570\u636e\u7684\u65f6\u5019\u4f1a\u6267\u884c\u8fd9\u4e2a\u56de\u8c03 stream -> read_cb = read_cb ; // \u5206\u914d\u5185\u5b58\u51fd\u6570\uff0c\u7528\u4e8e\u5b58\u50a8\u8bfb\u53d6\u7684\u6570\u636e stream -> alloc_cb = alloc_cb ; // \u6ce8\u518c\u7b49\u5f85\u8bfb\u4e8b\u4ef6 uv__io_start ( stream -> loop , & stream -> io_watcher , POLLIN ); // \u6fc0\u6d3bhandle\uff0c\u6709\u6fc0\u6d3b\u7684handle\uff0c\u4e8b\u4ef6\u5faa\u73af\u4e0d\u4f1a\u9000\u51fa uv__handle_start ( stream ); return 0 ; } \u6267\u884cuv_read_start\u672c\u8d28\u4e0a\u662f\u7ed9\u6d41\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5728epoll\u4e2d\u6ce8\u518c\u4e86\u4e00\u4e2a\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u5e76\u8bb0\u5f55\u76f8\u5e94\u7684\u4e0a\u4e0b\u6587\uff0c\u6bd4\u5982\u8bfb\u56de\u8c03\u51fd\u6570\uff0c\u5206\u914d\u5185\u5b58\u7684\u51fd\u6570\u3002\u63a5\u7740\u6253\u4e0a\u6b63\u5728\u505a\u8bfb\u53d6\u64cd\u4f5c\u7684\u6807\u8bb0\u3002\u5f53\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u8bfb\u56de\u8c03\u5c31\u4f1a\u88ab\u6267\u884c\uff0c\u9664\u4e86\u8bfb\u53d6\u6570\u636e\uff0c\u8fd8\u6709\u4e00\u4e2a\u8bfb\u64cd\u4f5c\u5c31\u662f\u505c\u6b62\u8bfb\u53d6\u3002\u5bf9\u5e94\u7684\u51fd\u6570\u662fuv_read_stop\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int uv_read_stop ( uv_stream_t * stream ) { // \u662f\u5426\u6b63\u5728\u6267\u884c\u8bfb\u53d6\u64cd\u4f5c\uff0c\u5982\u679c\u4e0d\u662f\uff0c\u5219\u6ca1\u6709\u5fc5\u8981\u505c\u6b62 if ( ! ( stream -> flags & UV_HANDLE_READING )) return 0 ; // \u6e05\u9664\u6b63\u5728\u8bfb\u53d6\u7684\u6807\u8bb0 stream -> flags &= ~ UV_HANDLE_READING ; // \u64a4\u9500\u7b49\u5f85\u8bfb\u4e8b\u4ef6 uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLIN ); // \u5bf9\u5199\u4e8b\u4ef6\u4e5f\u4e0d\u611f\u5174\u8da3\uff0c\u505c\u6389handle\u3002\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa if ( ! uv__io_active ( & stream -> io_watcher , POLLOUT )) uv__handle_stop ( stream ); stream -> read_cb = NULL ; stream -> alloc_cb = NULL ; return 0 ; } \u53e6\u5916\u8fd8\u6709\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570\uff0c\u5224\u65ad\u6d41\u662f\u5426\u8bbe\u7f6e\u4e86\u53ef\u8bfb\u5c5e\u6027\u3002 1 2 3 int uv_is_readable ( const uv_stream_t * stream ) { return !! ( stream -> flags & UV_HANDLE_READABLE ); } \u4e0a\u9762\u7684\u51fd\u6570\u53ea\u662f\u6ce8\u518c\u548c\u6ce8\u9500\u8bfb\u4e8b\u4ef6\uff0c\u5982\u679c\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u81ea\u5df1\u53bb\u8bfb\u53d6\u6570\u636e\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u771f\u6b63\u7684\u8bfb\u903b\u8f91 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 static void uv__read ( uv_stream_t * stream ) { uv_buf_t buf ; ssize_t nread ; struct msghdr msg ; char cmsg_space [ CMSG_SPACE ( UV__CMSG_FD_SIZE )]; int count ; int err ; int is_ipc ; // \u6e05\u9664\u8bfb\u53d6\u90e8\u5206\u6807\u8bb0 stream -> flags &= ~ UV_STREAM_READ_PARTIAL ; count = 32 ; /* \u6d41\u662fUnix\u57df\u7c7b\u578b\u5e76\u4e14\u7528\u4e8eIPC\uff0cUnix\u57df\u4e0d\u4e00\u5b9a\u7528\u4e8eIPC\uff0c \u7528\u4f5cIPC\u53ef\u4ee5\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 */ is_ipc = stream -> type == UV_NAMED_PIPE && (( uv_pipe_t * ) stream ) -> ipc ; // \u8bbe\u7f6e\u4e86\u8bfb\u56de\u8c03\uff0c\u6b63\u5728\u8bfb\uff0ccount\u5927\u4e8e0 while ( stream -> read_cb && ( stream -> flags & UV_STREAM_READING ) && ( count -- > 0 )) { buf = uv_buf_init ( NULL , 0 ); // \u8c03\u7528\u8c03\u7528\u65b9\u63d0\u4f9b\u7684\u5206\u914d\u5185\u5b58\u51fd\u6570\uff0c\u5206\u914d\u5185\u5b58\u627f\u8f7d\u6570\u636e stream -> alloc_cb (( uv_handle_t * ) stream , 64 * 1024 , & buf ); /* \u4e0d\u662fIPC\u5219\u76f4\u63a5\u8bfb\u53d6\u6570\u636e\u5230buf\uff0c\u5426\u5219\u7528recvmsg\u8bfb\u53d6\u6570\u636e \u548c\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09 */ if ( ! is_ipc ) { do { nread = read ( uv__stream_fd ( stream ), buf . base , buf . len ); } while ( nread < 0 && errno == EINTR ); } else { /* ipc uses recvmsg */ msg . msg_flags = 0 ; msg . msg_iov = ( struct iovec * ) & buf ; msg . msg_iovlen = 1 ; msg . msg_name = NULL ; msg . msg_namelen = 0 ; msg . msg_controllen = sizeof ( cmsg_space ); msg . msg_control = cmsg_space ; do { nread = uv__recvmsg ( uv__stream_fd ( stream ), & msg , 0 ); } while ( nread < 0 && errno == EINTR ); } // \u8bfb\u5931\u8d25 if ( nread < 0 ) { // \u8bfb\u7e41\u5fd9 if ( errno == EAGAIN || errno == EWOULDBLOCK ) { // \u6267\u884c\u8bfb\u56de\u8c03 stream -> read_cb ( stream , 0 , & buf ); } else { /* Error. User should call uv_close(). */ // \u8bfb\u5931\u8d25 stream -> read_cb ( stream , - errno , & buf ); } return ; } else if ( nread == 0 ) { // \u8bfb\u5230\u7ed3\u5c3e\u4e86 uv__stream_eof ( stream , & buf ); return ; } else { // \u8bfb\u6210\u529f\uff0c\u8bfb\u53d6\u6570\u636e\u7684\u957f\u5ea6 ssize_t buflen = buf . len ; /* \u662fIPC\u5219\u89e3\u6790\u8bfb\u53d6\u7684\u6570\u636e\uff0c\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u89e3\u6790\u51fa\u6765\uff0c \u653e\u5230stream\u7684accepted_fd\u548cqueued_fds\u5b57\u6bb5 */ if ( is_ipc ) { err = uv__stream_recv_cmsg ( stream , & msg ); if ( err != 0 ) { stream -> read_cb ( stream , err , & buf ); return ; } } // \u6267\u884c\u8bfb\u56de\u8c03 stream -> read_cb ( stream , nread , & buf ); } } } uv_read\u9664\u4e86\u53ef\u4ee5\u8bfb\u53d6\u4e00\u822c\u7684\u6570\u636e\u5916\uff0c\u8fd8\u652f\u6301\u8bfb\u53d6\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u63cf\u8ff0\u7b26\u4f20\u9012\u7684\u539f\u7406\u3002\u6211\u4eec\u77e5\u9053\uff0c\u7236\u8fdb\u7a0bfork\u51fa\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\uff0c\u5b50\u8fdb\u7a0b\u662f\u7ee7\u627f\u7236\u8fdb\u7a0b\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5217\u8868\u7684\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fdb\u7a0b\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5173\u7cfb\u3002 fork\u4e4b\u524d\u5982\u56fe5-1\u6240\u793a\u3002 \u6211\u4eec\u518d\u770b\u4e00\u4e0bfork\u4e4b\u540e\u7684\u7ed3\u6784\u5982\u56fe5-2\u6240\u793a\u3002 \u5982\u679c\u7236\u8fdb\u7a0b\u6216\u8005\u5b50\u8fdb\u7a0b\u5728fork\u4e4b\u540e\u521b\u5efa\u4e86\u65b0\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u90a3\u7236\u5b50\u8fdb\u7a0b\u95f4\u5c31\u4e0d\u80fd\u5171\u4eab\u4e86\uff0c\u5047\u8bbe\u7236\u8fdb\u7a0b\u8981\u628a\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u7ed9\u5b50\u8fdb\u7a0b\uff0c\u90a3\u600e\u4e48\u529e\u5462\uff1f\u6839\u636e\u8fdb\u7a0b\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5173\u7cfb\u3002\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u8981\u505a\u7684\u4e8b\u60c5\uff0c\u4e0d\u4ec5\u4ec5\u662f\u5728\u5b50\u8fdb\u7a0b\u4e2d\u65b0\u5efa\u4e00\u4e2afd\uff0c\u8fd8\u8981\u5efa\u7acb\u8d77fd->file->inode\u7684\u5173\u8054\uff0c\u4e0d\u8fc7\u6211\u4eec\u4e0d\u9700\u8981\u5173\u6ce8\u8fd9\u4e9b\uff0c\u56e0\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u90fd\u5e2e\u6211\u4eec\u5904\u7406\u4e86\uff0c\u6211\u4eec\u53ea\u9700\u8981\u901a\u8fc7sendmsg\u628a\u60f3\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53d1\u9001\u7ed9Unix\u57df\u7684\u53e6\u4e00\u7aef\u3002Unix\u57df\u53e6\u4e00\u7aef\u5c31\u53ef\u4ee5\u901a\u8fc7recvmsg\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4ece\u6570\u636e\u4e2d\u8bfb\u53d6\u51fa\u6765\u3002\u63a5\u7740\u4f7f\u7528uv__stream_recv_cmsg\u51fd\u6570\u4fdd\u5b58\u6570\u636e\u91cc\u89e3\u6790\u51fa\u6765\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 static int uv__stream_recv_cmsg ( uv_stream_t * stream , struct msghdr * msg ) { struct cmsghdr * cmsg ; // \u904d\u5386msg for ( cmsg = CMSG_FIRSTHDR ( msg ); cmsg != NULL ; cmsg = CMSG_NXTHDR ( msg , cmsg )) { char * start ; char * end ; int err ; void * pv ; int * pi ; unsigned int i ; unsigned int count ; pv = CMSG_DATA ( cmsg ); pi = pv ; start = ( char * ) cmsg ; end = ( char * ) cmsg + cmsg -> cmsg_len ; count = 0 ; while ( start + CMSG_LEN ( count * sizeof ( * pi )) < end ) count ++ ; for ( i = 0 ; i < count ; i ++ ) { /* accepted_fd\u4ee3\u8868\u5f53\u524d\u5f85\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c \u5982\u679c\u5df2\u7ecf\u6709\u503c\u5219\u5269\u4f59\u63cf\u8ff0\u7b26\u5c31\u901a\u8fc7uv__stream_queue_fd\u6392\u961f \u5982\u679c\u8fd8\u6ca1\u6709\u503c\u5219\u5148\u8d4b\u503c */ if ( stream -> accepted_fd != -1 ) { err = uv__stream_queue_fd ( stream , pi [ i ]); } else { stream -> accepted_fd = pi [ i ]; } } } return 0 ; } uv__stream_recv_cmsg\u4f1a\u4ece\u6570\u636e\u4e2d\u89e3\u6790\u51fa\u4e00\u4e2a\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u5b58\u5230stream\u4e2d\uff0c\u7b2c\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5728accepted_fd\uff0c\u5269\u4e0b\u7684\u4f7f\u7528uv__stream_queue_fd\u5904\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 struct uv__stream_queued_fds_s { unsigned int size ; unsigned int offset ; int fds [ 1 ]; }; static int uv__stream_queue_fd ( uv_stream_t * stream , int fd ) { uv__stream_queued_fds_t * queued_fds ; unsigned int queue_size ; // \u539f\u6765\u7684\u5185\u5b58 queued_fds = stream -> queued_fds ; // \u6ca1\u6709\u5185\u5b58\uff0c\u5219\u5206\u914d if ( queued_fds == NULL ) { // \u9ed8\u8ba48\u4e2a queue_size = 8 ; /* \u4e00\u4e2a\u5143\u6570\u636e\u5185\u5b58+\u591a\u4e2afd\u7684\u5185\u5b58 \uff08\u524d\u9762\u52a0*\u4ee3\u8868\u89e3\u5f15\u7528\u540e\u7684\u503c\u7684\u7c7b\u578b\u6240\u5360\u7684\u5185\u5b58\u5927\u5c0f\uff0c \u51cf\u4e00\u662f\u56e0\u4e3auv__stream_queued_fds_t \u7ed3\u6784\u4f53\u672c\u8eab\u6709\u4e00\u4e2a\u7a7a\u95f4\uff09 */ queued_fds = uv__malloc (( queue_size - 1 ) * sizeof ( * queued_fds -> fds ) + sizeof ( * queued_fds )); if ( queued_fds == NULL ) return UV_ENOMEM ; // \u5bb9\u91cf queued_fds -> size = queue_size ; // \u5df2\u4f7f\u7528\u4e2a\u6570 queued_fds -> offset = 0 ; // \u6307\u5411\u53ef\u7528\u7684\u5185\u5b58 stream -> queued_fds = queued_fds ; // \u4e4b\u524d\u7684\u5185\u5b58\u7528\u5b8c\u4e86\uff0c\u6269\u5bb9 } else if ( queued_fds -> size == queued_fds -> offset ) { // \u6bcf\u6b21\u52a08\u4e2a queue_size = queued_fds -> size + 8 ; queued_fds = uv__realloc ( queued_fds , ( queue_size - 1 ) * sizeof ( * queued_fds -> fds ) + sizeof ( * queued_fds )); if ( queued_fds == NULL ) return UV_ENOMEM ; // \u66f4\u65b0\u5bb9\u91cf\u5927\u5c0f queued_fds -> size = queue_size ; // \u4fdd\u5b58\u65b0\u7684\u5185\u5b58 stream -> queued_fds = queued_fds ; } /* Put fd in a queue */ // \u4fdd\u5b58fd queued_fds -> fds [ queued_fds -> offset ++ ] = fd ; return 0 ; } \u5185\u5b58\u7ed3\u6784\u5982\u56fe5-3\u6240\u793a\u3002 \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u8bfb\u7ed3\u675f\u540e\u7684\u5904\u7406\uff0c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static void uv__stream_eof ( uv_stream_t * stream , const uv_buf_t * buf ) { // \u6253\u4e0a\u8bfb\u7ed3\u675f\u6807\u8bb0 stream -> flags |= UV_STREAM_READ_EOF ; // \u6ce8\u9500\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLIN ); // \u6ca1\u6709\u6ce8\u518c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\u5219\u505c\u6389handle\uff0c\u5426\u5219\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa if ( ! uv__io_active ( & stream -> io_watcher , POLLOUT )) uv__handle_stop ( stream ); uv__stream_osx_interrupt_select ( stream ); // \u6267\u884c\u8bfb\u56de\u8c03 stream -> read_cb ( stream , UV_EOF , buf ); // \u6e05\u9664\u6b63\u5728\u8bfb\u6807\u8bb0 stream -> flags &= ~ UV_STREAM_READING ; } \u6211\u4eec\u770b\u5230\uff0c\u6d41\u7ed3\u675f\u7684\u65f6\u5019\uff0c\u9996\u5148\u6ce8\u9500\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u7136\u540e\u901a\u8fc7\u56de\u8c03\u901a\u77e5\u4e0a\u5c42\u3002 5.4 \u5199\u6d41 \u00b6 \u6211\u4eec\u5728\u6d41\u4e0a\u6267\u884cuv_write\u5c31\u53ef\u4ee5\u5f80\u6d41\u4e2d\u5199\u5165\u6570\u636e\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int uv_write ( /* \u4e00\u4e2a\u5199\u8bf7\u6c42\uff0c\u8bb0\u5f55\u4e86\u9700\u8981\u5199\u5165\u7684\u6570\u636e\u548c\u4fe1\u606f\u3002 \u6570\u636e\u6765\u81ea\u4e0b\u9762\u7684const uv_buf_t bufs[] */ uv_write_t * req , // \u5f80\u54ea\u4e2a\u6d41\u5199 uv_stream_t * handle , // \u9700\u8981\u5199\u5165\u7684\u6570\u636e const uv_buf_t bufs [], // uv_buf_t\u4e2a\u6570 unsigned int nbufs , // \u5199\u5b8c\u540e\u6267\u884c\u7684\u56de\u8c03 uv_write_cb cb ) { return uv_write2 ( req , handle , bufs , nbufs , NULL , cb ); } uv_write\u662f\u76f4\u63a5\u8c03\u7528uv_write2\u3002\u7b2c\u56db\u4e2a\u53c2\u6570\u662fNULL\u3002\u4ee3\u8868\u662f\u4e00\u822c\u7684\u5199\u6570\u636e\uff0c\u4e0d\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 int uv_write2 ( uv_write_t * req , uv_stream_t * stream , const uv_buf_t bufs [], unsigned int nbufs , uv_stream_t * send_handle , uv_write_cb cb ) { int empty_queue ; // \u5f85\u53d1\u9001\u961f\u5217\u662f\u5426\u4e3a\u7a7a empty_queue = ( stream -> write_queue_size == 0 ); // \u6784\u9020\u4e00\u4e2a\u5199\u8bf7\u6c42 uv__req_init ( stream -> loop , req , UV_WRITE ); // \u5199\u8bf7\u6c42\u5bf9\u5e94\u7684\u56de\u8c03 req -> cb = cb ; // \u5199\u8bf7\u6c42\u5bf9\u5e94\u7684\u6d41 req -> handle = stream ; req -> error = 0 ; // \u9700\u8981\u53d1\u9001\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u4e5f\u53ef\u4ee5\u662fNULL\u8bf4\u660e\u4e0d\u9700\u8981\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 req -> send_handle = send_handle ; QUEUE_INIT ( & req -> queue ); // bufs\u6307\u5411\u5f85\u5199\u7684\u6570\u636e req -> bufs = req -> bufsml ; // \u590d\u5236\u8c03\u7528\u65b9\u7684\u6570\u636e\u8fc7\u6765 memcpy ( req -> bufs , bufs , nbufs * sizeof ( bufs [ 0 ])); // buf\u4e2a\u6570 req -> nbufs = nbufs ; // \u5f53\u524d\u5199\u6210\u529f\u7684buf\u7d22\u5f15\uff0c\u9488\u5bf9bufs\u6570\u7ec4 req -> write_index = 0 ; // \u5f85\u5199\u7684\u6570\u636e\u5927\u5c0f = \u4e4b\u524d\u7684\u5927\u5c0f + \u672c\u6b21\u5927\u5c0f stream -> write_queue_size += uv__count_bufs ( bufs , nbufs ); // \u63d2\u5165\u5f85\u5199\u961f\u5217 QUEUE_INSERT_TAIL ( & stream -> write_queue , & req -> queue ); // \u975e\u7a7a\u8bf4\u660e\u6b63\u5728\u8fde\u63a5\uff0c\u8fd8\u4e0d\u80fd\u5199\uff0c\u6bd4\u5982TCP\u6d41 if ( stream -> connect_req ) { /* Still connecting, do nothing. */ } else if ( empty_queue ) { // \u5f53\u524d\u5f85\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u76f4\u63a5\u5199 uv__write ( stream ); } else { // \u8fd8\u6709\u6570\u636e\u6ca1\u6709\u5199\u5b8c\uff0c\u6ce8\u518c\u7b49\u5f85\u5199\u4e8b\u4ef6 uv__io_start ( stream -> loop , & stream -> io_watcher , POLLOUT ); uv__stream_osx_interrupt_select ( stream ); } return 0 ; } uv_write2\u7684\u4e3b\u8981\u903b\u8f91\u5c31\u662f\u5c01\u88c5\u4e00\u4e2a\u5199\u8bf7\u6c42\uff0c\u63d2\u5165\u5230\u6d41\u7684\u5f85\u5199\u961f\u5217\u3002\u7136\u540e\u6839\u636e\u5f53\u524d\u6d41\u7684\u60c5\u51b5\u3002\u770b\u662f\u76f4\u63a5\u5199\u5165\u8fd8\u662f\u7b49\u5f85\u4f1a\u518d\u5199\u5165\u3002\u5173\u7cfb\u56fe\u5927\u81f4\u5982\u56fe5-4\u6240\u793a\u3002 uv_write2\u53ea\u662f\u5bf9\u5199\u8bf7\u6c42\u8fdb\u884c\u4e00\u4e9b\u9884\u5904\u7406\uff0c\u771f\u6b63\u6267\u884c\u5199\u7684\u51fd\u6570\u662fuv__write 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 static void uv__write ( uv_stream_t * stream ) { struct iovec * iov ; QUEUE * q ; uv_write_t * req ; int iovmax ; int iovcnt ; ssize_t n ; int err ; start : // \u6ca1\u6709\u6570\u636e\u9700\u8981\u5199 if ( QUEUE_EMPTY ( & stream -> write_queue )) return ; q = QUEUE_HEAD ( & stream -> write_queue ); req = QUEUE_DATA ( q , uv_write_t , queue ); // \u4ece\u54ea\u91cc\u5f00\u59cb\u5199 iov = ( struct iovec * ) & ( req -> bufs [ req -> write_index ]); // \u8fd8\u6709\u591a\u5c11\u6ca1\u5199 iovcnt = req -> nbufs - req -> write_index ; // \u6700\u591a\u53ef\u4ee5\u5199\u591a\u5c11 iovmax = uv__getiovmax (); // \u53d6\u6700\u5c0f\u503c if ( iovcnt > iovmax ) iovcnt = iovmax ; // \u9700\u8981\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 if ( req -> send_handle ) { int fd_to_send ; struct msghdr msg ; struct cmsghdr * cmsg ; union { char data [ 64 ]; struct cmsghdr alias ; } scratch ; if ( uv__is_closing ( req -> send_handle )) { err = - EBADF ; goto error ; } // \u5f85\u53d1\u9001\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 fd_to_send = uv__handle_fd (( uv_handle_t * ) req -> send_handle ); memset ( & scratch , 0 , sizeof ( scratch )); msg . msg_name = NULL ; msg . msg_namelen = 0 ; msg . msg_iov = iov ; msg . msg_iovlen = iovcnt ; msg . msg_flags = 0 ; msg . msg_control = & scratch . alias ; msg . msg_controllen = CMSG_SPACE ( sizeof ( fd_to_send )); cmsg = CMSG_FIRSTHDR ( & msg ); cmsg -> cmsg_level = SOL_SOCKET ; cmsg -> cmsg_type = SCM_RIGHTS ; cmsg -> cmsg_len = CMSG_LEN ( sizeof ( fd_to_send )); { void * pv = CMSG_DATA ( cmsg ); int * pi = pv ; * pi = fd_to_send ; } do { // \u4f7f\u7528sendmsg\u51fd\u6570\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 n = sendmsg ( uv__stream_fd ( stream ), & msg , 0 ); } while ( n == -1 && errno == EINTR ); } else { do { // \u5199\u4e00\u4e2a\u6216\u8005\u5199\u6279\u91cf\u5199 if ( iovcnt == 1 ) { n = write ( uv__stream_fd ( stream ), iov [ 0 ]. iov_base , iov [ 0 ]. iov_len ); } else { n = writev ( uv__stream_fd ( stream ), iov , iovcnt ); } } while ( n == -1 && errno == EINTR ); } // \u5199\u5931\u8d25 if ( n < 0 ) { /* \u4e0d\u662f\u5199\u7e41\u5fd9\uff0c\u5219\u62a5\u9519\uff0c \u5426\u5219\u5982\u679c\u8bbe\u7f6e\u4e86\u540c\u6b65\u5199\u6807\u8bb0\uff0c\u5219\u7ee7\u7eed\u5c1d\u8bd5\u5199 */ if ( errno != EAGAIN && errno != EWOULDBLOCK && errno != ENOBUFS ) { err = - errno ; goto error ; } else if ( stream -> flags & UV_STREAM_BLOCKING ) { /* If this is a blocking stream, try again. */ goto start ; } } else { // \u5199\u6210\u529f while ( n >= 0 ) { // \u5f53\u524dbuf\u9996\u5730\u5740 uv_buf_t * buf = & ( req -> bufs [ req -> write_index ]); // \u5f53\u524dbuf\u7684\u6570\u636e\u957f\u5ea6 size_t len = buf -> len ; // \u5c0f\u4e8e\u8bf4\u660e\u5f53\u524dbuf\u8fd8\u6ca1\u6709\u5199\u5b8c\uff08\u8fd8\u6ca1\u6709\u88ab\u6d88\u8d39\u5b8c\uff09 if (( size_t ) n < len ) { // \u66f4\u65b0\u5f85\u5199\u7684\u9996\u5730\u5740 buf -> base += n ; // \u66f4\u65b0\u5f85\u5199\u7684\u6570\u636e\u957f\u5ea6 buf -> len -= n ; /* \u66f4\u65b0\u5f85\u5199\u961f\u5217\u7684\u957f\u5ea6\uff0c\u8fd9\u4e2a\u961f\u5217\u662f\u5f85\u5199\u6570\u636e\u7684 \u603b\u957f\u5ea6\uff0c\u7b49\u4e8e\u591a\u4e2abuf\u7684\u548c */ stream -> write_queue_size -= n ; n = 0 ; /* \u8fd8\u6ca1\u5199\u5b8c\uff0c\u8bbe\u7f6e\u4e86\u540c\u6b65\u5199\uff0c\u5219\u7ee7\u7eed\u5c1d\u8bd5\u5199\uff0c \u5426\u5219\u9000\u51fa\uff0c\u6ce8\u518c\u5f85\u5199\u4e8b\u4ef6 */ if ( stream -> flags & UV_STREAM_BLOCKING ) { goto start ; } else { break ; } } else { /* \u5f53\u524dbuf\u7684\u6570\u636e\u90fd\u5199\u5b8c\u4e86\uff0c\u5219\u66f4\u65b0\u5f85\u5199\u6570\u636e\u7684\u7684\u9996 \u5730\u5740\uff0c\u5373\u4e0b\u4e00\u4e2abuf\uff0c\u56e0\u4e3a\u5f53\u524dbuf\u5199\u5b8c\u4e86 */ req -> write_index ++ ; // \u66f4\u65b0n\uff0c\u7528\u4e8e\u4e0b\u4e00\u4e2a\u5faa\u73af\u7684\u8ba1\u7b97 n -= len ; // \u66f4\u65b0\u5f85\u5199\u961f\u5217\u7684\u957f\u5ea6 stream -> write_queue_size -= len ; /* \u7b49\u4e8e\u6700\u540e\u4e00\u4e2abuf\u4e86\uff0c\u8bf4\u660e\u5f85\u5199\u961f\u5217\u7684\u6570\u636e \u90fd\u5199\u5b8c\u4e86 */ if ( req -> write_index == req -> nbufs ) { /* \u91ca\u653ebuf\u5bf9\u5e94\u7684\u5185\u5b58\uff0c\u5e76\u628a\u8bf7\u6c42\u63d2\u5165\u5199\u5b8c\u6210 \u961f\u5217\uff0c\u7136\u540e\u51c6\u5907\u89e6\u53d1\u5199\u5b8c\u6210\u56de\u8c03 */ uv__write_req_finish ( req ); return ; } } } } /* \u5199\u6210\u529f\uff0c\u4f46\u662f\u8fd8\u6ca1\u6709\u5199\u5b8c\uff0c\u6ce8\u518c\u5f85\u5199\u4e8b\u4ef6\uff0c \u7b49\u5f85\u53ef\u5199\u7684\u65f6\u5019\u7ee7\u7eed\u5199 */ uv__io_start ( stream -> loop , & stream -> io_watcher , POLLOUT ); uv__stream_osx_interrupt_select ( stream ); return ; // \u5199\u51fa\u9519 error : // \u8bb0\u5f55\u9519\u8bef req -> error = err ; /* \u91ca\u653e\u5185\u5b58\uff0c\u4e22\u5f03\u6570\u636e\uff0c\u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217\uff0c \u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0c\u7b49\u5f85pending\u9636\u6bb5\u6267\u884c\u56de\u8c03 */ uv__write_req_finish ( req ); // \u6ce8\u9500\u5f85\u5199\u4e8b\u4ef6 uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLOUT ); // \u5982\u679c\u4e5f\u6ca1\u6709\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u5219\u628ahandle\u5173\u95ed if ( ! uv__io_active ( & stream -> io_watcher , POLLIN )) uv__handle_stop ( stream ); uv__stream_osx_interrupt_select ( stream ); } \u6211\u4eec\u770b\u4e00\u4e0b\u4e00\u4e2a\u5199\u8bf7\u6c42\u7ed3\u675f\u540e\uff08\u6210\u529f\u6216\u8005\u5931\u8d25\uff09\uff0cLibuv\u5982\u4f55\u5904\u7406\u7684\u3002\u903b\u8f91\u5728uv__write_req_finish\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static void uv__write_req_finish ( uv_write_t * req ) { uv_stream_t * stream = req -> handle ; // \u4ece\u5f85\u5199\u961f\u5217\u4e2d\u79fb\u9664 QUEUE_REMOVE ( & req -> queue ); // \u5199\u6210\u529f\uff0c\u5e76\u4e14\u5206\u914d\u4e86\u989d\u5916\u7684\u5806\u5185\u5b58\uff0c\u5219\u9700\u8981\u91ca\u653e\uff0c\u89c1uv__write if ( req -> error == 0 ) { if ( req -> bufs != req -> bufsml ) uv__free ( req -> bufs ); req -> bufs = NULL ; } // \u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217 QUEUE_INSERT_TAIL ( & stream -> write_completed_queue , & req -> queue ); /* \u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0cLibuv\u5728\u5904\u7406pending\u9636\u6bb5\u65f6, \u4f1a\u89e6\u53d1IO\u89c2\u5bdf\u8005\u7684\u5199\u4e8b\u4ef6 */ uv__io_feed ( stream -> loop , & stream -> io_watcher ); } uv__write_req_finish\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355 1\u628a\u8282\u70b9\u4ece\u5f85\u5199\u961f\u5217\u4e2d\u79fb\u9664 2 req->bufs != req->bufsml\u4e0d\u76f8\u7b49\u8bf4\u660e\u5206\u914d\u4e86\u5806\u5185\u5b58\uff0c\u9700\u8981\u81ea\u5df1\u91ca\u653e 3\u5e76\u628a\u8bf7\u6c42\u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217\uff0c\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0c\u7b49\u5f85pending\u9636\u6bb5\u6267\u884c\u56de\u8c03\uff0c\u5728pending\u8282\u70b9\u4f1a\u6267\u884cIO\u89c2\u5bdf\u8005\u7684\u56de\u8c03\uff08uv__stream_io\uff09\u3002 \u6211\u4eec\u770b\u4e00\u4e0buv__stream_io\u5982\u4f55\u5904\u7406\u7684\uff0c\u4e0b\u9762\u662f\u5177\u4f53\u7684\u5904\u7406\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 // \u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1 if ( events & ( POLLOUT | POLLERR | POLLHUP )) { // \u7ee7\u7eed\u6267\u884c\u5199 uv__write ( stream ); // \u5904\u7406\u5199\u6210\u529f\u56de\u8c03 uv__write_callbacks ( stream ); // \u5f85\u5199\u961f\u5217\u7a7a\uff0c\u6ce8\u9500\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u5373\u4e0d\u9700\u8981\u5199\u4e86 if ( QUEUE_EMPTY ( & stream -> write_queue )) uv__drain ( stream ); } \u6211\u4eec\u53ea\u5173\u6ce8uv__write_callbacks\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 static void uv__write_callbacks ( uv_stream_t * stream ) { uv_write_t * req ; QUEUE * q ; // \u5199\u5b8c\u6210\u961f\u5217\u975e\u7a7a while ( ! QUEUE_EMPTY ( & stream -> write_completed_queue )) { q = QUEUE_HEAD ( & stream -> write_completed_queue ); req = QUEUE_DATA ( q , uv_write_t , queue ); QUEUE_REMOVE ( q ); uv__req_unregister ( stream -> loop , req ); // bufs\u7684\u5185\u5b58\u8fd8\u6ca1\u6709\u88ab\u91ca\u653e if ( req -> bufs != NULL ) { // \u66f4\u65b0\u5f85\u5199\u961f\u5217\u7684\u5927\u5c0f\uff0c\u5373\u51cf\u53bbreq\u5bf9\u5e94\u7684\u6240\u6709\u6570\u636e\u7684\u5927\u5c0f stream -> write_queue_size -= uv__write_req_size ( req ); /* bufs\u9ed8\u8ba4\u6307\u5411bufsml\uff0c\u8d85\u8fc7\u9ed8\u8ba4\u5927\u5c0f\u65f6\uff0c bufs\u6307\u5411\u65b0\u7533\u8bf7\u7684\u5806\u5185\u5b58\uff0c\u6240\u4ee5\u9700\u8981\u91ca\u653e */ if ( req -> bufs != req -> bufsml ) uv__free ( req -> bufs ); req -> bufs = NULL ; } // \u6267\u884c\u56de\u8c03 if ( req -> cb ) req -> cb ( req , req -> error ); } } uv__write_callbacks\u8d1f\u8d23\u66f4\u65b0\u6d41\u7684\u5f85\u5199\u961f\u5217\u5927\u5c0f\u3001\u91ca\u653e\u989d\u5916\u7533\u8bf7\u7684\u5806\u5185\u5b58\u3001\u6267\u884c\u6bcf\u4e2a\u5199\u8bf7\u6c42\u7684\u56de\u8c03\u3002 5.5 \u5173\u95ed\u6d41\u7684\u5199\u7aef \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // \u5173\u95ed\u6d41\u7684\u5199\u7aef int uv_shutdown ( uv_shutdown_t * req , uv_stream_t * stream , uv_shutdown_cb cb ) { // \u521d\u59cb\u5316\u4e00\u4e2a\u5173\u95ed\u8bf7\u6c42\uff0c\u5173\u8054\u7684handle\u662fstream uv__req_init ( stream -> loop , req , UV_SHUTDOWN ); req -> handle = stream ; // \u5173\u95ed\u540e\u6267\u884c\u7684\u56de\u8c03 req -> cb = cb ; stream -> shutdown_req = req ; // \u8bbe\u7f6e\u6b63\u5728\u5173\u95ed\u7684\u6807\u8bb0 stream -> flags |= UV_HANDLE_SHUTTING ; // \u6ce8\u518c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6 uv__io_start ( stream -> loop , & stream -> io_watcher , POLLOUT ); return 0 ; } \u5173\u95ed\u6d41\u7684\u5199\u7aef\u5c31\u662f\u76f8\u5f53\u4e8e\u7ed9\u6d41\u53d1\u9001\u4e00\u4e2a\u5173\u95ed\u8bf7\u6c42\uff0c\u628a\u8bf7\u6c42\u6302\u8f7d\u5230\u6d41\u4e2d\uff0c\u7136\u540e\u6ce8\u518c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u5728\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\u5c31\u4f1a\u6267\u884c\u5173\u95ed\u64cd\u4f5c\u3002\u5728\u5206\u6790\u5199\u6d41\u7684\u7ae0\u8282\u4e2d\u6211\u4eec\u63d0\u5230\uff0c\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884cuv__drain\u6ce8\u9500\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u9664\u6b64\u4e4b\u5916\uff0cuv__drain\u8fd8\u505a\u4e86\u4e00\u4e2a\u4e8b\u60c5\uff0c\u5c31\u662f\u5173\u95ed\u6d41\u7684\u5199\u7aef\u3002\u6211\u4eec\u770b\u770b\u5177\u4f53\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 static void uv__drain ( uv_stream_t * stream ) { uv_shutdown_t * req ; int err ; // \u64a4\u9500\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u56e0\u4e3a\u6ca1\u6709\u6570\u636e\u9700\u8981\u5199\u5165\u4e86 uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLOUT ); uv__stream_osx_interrupt_select ( stream ); // \u8bbe\u7f6e\u4e86\u5173\u95ed\u5199\u7aef\uff0c\u4f46\u662f\u8fd8\u6ca1\u6709\u5173\u95ed\uff0c\u5219\u6267\u884c\u5173\u95ed\u5199\u7aef if (( stream -> flags & UV_HANDLE_SHUTTING ) && ! ( stream -> flags & UV_HANDLE_CLOSING ) && ! ( stream -> flags & UV_HANDLE_SHUT )) { req = stream -> shutdown_req ; stream -> shutdown_req = NULL ; // \u6e05\u9664\u6807\u8bb0 stream -> flags &= ~ UV_HANDLE_SHUTTING ; uv__req_unregister ( stream -> loop , req ); err = 0 ; // \u5173\u95ed\u5199\u7aef if ( shutdown ( uv__stream_fd ( stream ), SHUT_WR )) err = UV__ERR ( errno ); // \u6807\u8bb0\u5df2\u5173\u95ed\u5199\u7aef if ( err == 0 ) stream -> flags |= UV_HANDLE_SHUT ; // \u6267\u884c\u56de\u8c03 if ( req -> cb != NULL ) req -> cb ( req , err ); } } \u901a\u8fc7\u8c03\u7528shutdown\u5173\u95ed\u6d41\u7684\u5199\u7aef\uff0c\u6bd4\u5982TCP\u6d41\u53d1\u9001\u5b8c\u6570\u636e\u540e\u53ef\u4ee5\u5173\u95ed\u5199\u7aef\u3002\u4f46\u662f\u4ecd\u7136\u53ef\u4ee5\u8bfb\u3002 5.6 \u5173\u95ed\u6d41 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void uv__stream_close ( uv_stream_t * handle ) { unsigned int i ; uv__stream_queued_fds_t * queued_fds ; // \u4ece\u4e8b\u4ef6\u5faa\u73af\u4e2d\u5220\u9664IO\u89c2\u5bdf\u8005\uff0c\u79fb\u51fapending\u961f\u5217 uv__io_close ( handle -> loop , & handle -> io_watcher ); // \u505c\u6b62\u8bfb uv_read_stop ( handle ); // \u505c\u6389handle uv__handle_stop ( handle ); // \u4e0d\u53ef\u8bfb\u3001\u5199 handle -> flags &= ~ ( UV_HANDLE_READABLE | UV_HANDLE_WRITABLE ); // \u5173\u95ed\u975e\u6807\u51c6\u6d41\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 if ( handle -> io_watcher . fd != -1 ) { /* Don't close stdio file descriptors. Nothing good comes from it. */ if ( handle -> io_watcher . fd > STDERR_FILENO ) uv__close ( handle -> io_watcher . fd ); handle -> io_watcher . fd = -1 ; } // \u5173\u95ed\u901a\u4fe1socket\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 if ( handle -> accepted_fd != -1 ) { uv__close ( handle -> accepted_fd ); handle -> accepted_fd = -1 ; } // \u540c\u4e0a\uff0c\u8fd9\u662f\u5728\u6392\u961f\u7b49\u5f85\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 if ( handle -> queued_fds != NULL ) { queued_fds = handle -> queued_fds ; for ( i = 0 ; i < queued_fds -> offset ; i ++ ) uv__close ( queued_fds -> fds [ i ]); uv__free ( handle -> queued_fds ); handle -> queued_fds = NULL ; } } \u5173\u95ed\u6d41\u5c31\u662f\u628a\u6d41\u6ce8\u518c\u5728epoll\u7684\u4e8b\u4ef6\u6ce8\u9500\uff0c\u5173\u95ed\u6240\u6301\u6709\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 5.7 \u8fde\u63a5\u6d41 \u00b6 \u8fde\u63a5\u6d41\u662f\u9488\u5bf9TCP\u548cUnix\u57df\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u9996\u5148\u4ecb\u7ecd\u4e00\u4e0b\u4e00\u4e9b\u7f51\u7edc\u7f16\u7a0b\u76f8\u5173\u7684\u5185\u5bb9\uff0c\u9996\u5148\u6211\u4eec\u5148\u8981\u6709\u4e00\u4e2asocket\u3002\u6211\u4eec\u770bLibuv\u4e2d\u5982\u4f55\u65b0\u5efa\u4e00\u4e2asocket\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int uv__socket ( int domain , int type , int protocol ) { int sockfd ; int err ; // \u65b0\u5efa\u4e00\u4e2asocket\uff0c\u5e76\u8bbe\u7f6e\u975e\u963b\u585e\u548cLOEXEC\u6807\u8bb0 sockfd = socket ( domain , type | SOCK_NONBLOCK | SOCK_CLOEXEC , protocol ); // \u4e0d\u89e6\u53d1SIGPIPE\u4fe1\u53f7\uff0c\u6bd4\u5982\u5bf9\u7aef\u5df2\u7ecf\u5173\u95ed\uff0c\u672c\u7aef\u53c8\u6267\u884c\u5199 #if defined(SO_NOSIGPIPE) { int on = 1 ; setsockopt ( sockfd , SOL_SOCKET , SO_NOSIGPIPE , & on , sizeof ( on )); } #endif return sockfd ; } \u5728Libuv\u4e2d\uff0csocket\u7684\u6a21\u5f0f\u90fd\u662f\u975e\u963b\u585e\u7684\uff0cuv__socket\u662fLibuv\u4e2d\u7533\u8bf7socket\u7684\u51fd\u6570\uff0c\u4e0d\u8fc7Libuv\u4e0d\u76f4\u63a5\u8c03\u7528\u8be5\u51fd\u6570\uff0c\u800c\u662f\u5c01\u88c5\u4e86\u4e00\u4e0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* 1 \u83b7\u53d6\u4e00\u4e2a\u65b0\u7684socket fd 2 \u628afd\u4fdd\u5b58\u5230handle\u91cc\uff0c\u5e76\u6839\u636eflag\u8fdb\u884c\u76f8\u5173\u8bbe\u7f6e 3 \u7ed1\u5b9a\u5230\u672c\u673a\u968f\u610f\u7684\u5730\u5740\uff08\u5982\u679c\u8bbe\u7f6e\u4e86\u8be5\u6807\u8bb0\u7684\u8bdd\uff09 */ static int new_socket ( uv_tcp_t * handle , int domain , unsigned long flags ) { struct sockaddr_storage saddr ; socklen_t slen ; int sockfd ; // \u83b7\u53d6\u4e00\u4e2asocket sockfd = uv__socket ( domain , SOCK_STREAM , 0 ); // \u8bbe\u7f6e\u9009\u9879\u548c\u4fdd\u5b58socket\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5230IO\u89c2\u5bdf\u8005\u4e2d uv__stream_open (( uv_stream_t * ) handle , sockfd , flags ); // \u8bbe\u7f6e\u4e86\u9700\u8981\u7ed1\u5b9a\u6807\u8bb0UV_HANDLE_BOUND if ( flags & UV_HANDLE_BOUND ) { slen = sizeof ( saddr ); memset ( & saddr , 0 , sizeof ( saddr )); // \u83b7\u53d6fd\u5bf9\u5e94\u7684socket\u4fe1\u606f\uff0c\u6bd4\u5982IP\uff0c\u7aef\u53e3\uff0c\u53ef\u80fd\u6ca1\u6709 getsockname ( uv__stream_fd ( handle ), ( struct sockaddr * ) & saddr , & slen ); // \u7ed1\u5b9a\u5230socket\u4e2d\uff0c\u5982\u679c\u6ca1\u6709\u5219\u7ed1\u5b9a\u5230\u7cfb\u7edf\u968f\u673a\u9009\u62e9\u7684\u5730\u5740 bind ( uv__stream_fd ( handle ),( struct sockaddr * ) & saddr , slen ); } return 0 ; } \u4e0a\u9762\u7684\u4ee3\u7801\u5c31\u662f\u5728Libuv\u7533\u8bf7\u4e00\u4e2asocket\u7684\u903b\u8f91\uff0c\u53e6\u5916\u5b83\u8fd8\u652f\u6301\u65b0\u5efa\u7684socket\uff0c\u53ef\u4ee5\u7ed1\u5b9a\u5230\u4e00\u4e2a\u7528\u6237\u8bbe\u7f6e\u7684\uff0c\u6216\u8005\u64cd\u4f5c\u7cfb\u7edf\u968f\u673a\u9009\u62e9\u7684\u5730\u5740\u3002\u4e0d\u8fc7Libuv\u5e76\u4e0d\u76f4\u63a5\u4f7f\u7528\u8fd9\u4e2a\u51fd\u6570\u3002\u800c\u662f\u53c8\u5c01\u88c5\u4e86\u4e00\u5c42\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // \u5982\u679c\u6d41\u8fd8\u6ca1\u6709\u5bf9\u5e94\u7684fd\uff0c\u5219\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684\uff0c\u5982\u679c\u6709\u5219\u4fee\u6539\u6d41\u7684\u914d\u7f6e static int maybe_new_socket ( uv_tcp_t * handle , int domain , unsigned long flags ) { struct sockaddr_storage saddr ; socklen_t slen ; // \u5df2\u7ecf\u6709fd\u4e86 if ( uv__stream_fd ( handle ) != -1 ) { // \u8be5\u6d41\u9700\u8981\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740 if ( flags & UV_HANDLE_BOUND ) { /* \u6d41\u662f\u5426\u5df2\u7ecf\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740\u4e86\u3002handle\u7684flag\u662f\u5728 new_socket\u91cc\u8bbe\u7f6e\u7684\uff0c\u5982\u679c\u6709\u8fd9\u4e2a\u6807\u8bb0\u8bf4\u660e\u5df2\u7ecf\u6267\u884c\u8fc7\u7ed1\u5b9a\u4e86\uff0c \u76f4\u63a5\u66f4\u65b0flags\u5c31\u884c\u3002 */ if ( handle -> flags & UV_HANDLE_BOUND ) { handle -> flags |= flags ; return 0 ; } // \u6709fd\uff0c\u4f46\u662f\u53ef\u80fd\u8fd8\u6ca1\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740 slen = sizeof ( saddr ); memset ( & saddr , 0 , sizeof ( saddr )); // \u83b7\u53d6socket\u7ed1\u5b9a\u5230\u7684\u5730\u5740 if ( getsockname ( uv__stream_fd ( handle ), ( struct sockaddr * ) & saddr , & slen )) return UV__ERR ( errno ); // \u7ed1\u5b9a\u8fc7\u4e86socket\u5730\u5740\uff0c\u5219\u66f4\u65b0flags\u5c31\u884c if (( saddr . ss_family == AF_INET6 && (( struct sockaddr_in6 * ) & saddr ) -> sin6_port != 0 ) || ( saddr . ss_family == AF_INET && (( struct sockaddr_in * ) & saddr ) -> sin_port != 0 )) { handle -> flags |= flags ; return 0 ; } // \u6ca1\u7ed1\u5b9a\u5219\u7ed1\u5b9a\u5230\u968f\u673a\u5730\u5740\uff0cbind\u4e2d\u5b9e\u73b0 if ( bind ( uv__stream_fd ( handle ), ( struct sockaddr * ) & saddr , slen )) return UV__ERR ( errno ); } handle -> flags |= flags ; return 0 ; } // \u7533\u8bf7\u4e00\u4e2a\u65b0\u7684fd\u5173\u8054\u5230\u6d41 return new_socket ( handle , domain , flags ); } maybe_new_socket\u51fd\u6570\u7684\u903b\u8f91\u5206\u652f\u5f88\u591a\uff0c\u4e3b\u8981\u5982\u4e0b 1 \u5982\u679c\u6d41\u8fd8\u6ca1\u6709\u5173\u8054\u5230fd\uff0c\u5219\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684fd\u5173\u8054\u5230\u6d41\u4e0a 2 \u5982\u679c\u6d41\u5df2\u7ecf\u5173\u8054\u4e86\u4e00\u4e2afd\u3002 \u5982\u679c\u6d41\u8bbe\u7f6e\u4e86\u7ed1\u5b9a\u5730\u5740\u7684\u6807\u8bb0\uff0c\u4f46\u662f\u5df2\u7ecf\u901a\u8fc7Libuv\u7ed1\u5b9a\u4e86\u4e00\u4e2a\u5730\u5740\uff08Libuv\u4f1a\u8bbe\u7f6eUV_HANDLE_BOUND\u6807\u8bb0\uff0c\u7528\u6237\u4e5f\u53ef\u80fd\u662f\u76f4\u63a5\u8c03bind\u51fd\u6570\u7ed1\u5b9a\u4e86\uff09\u3002\u5219\u4e0d\u9700\u8981\u518d\u6b21\u7ed1\u5b9a\uff0c\u66f4\u65b0flags\u5c31\u884c\u3002 \u5982\u679c\u6d41\u8bbe\u7f6e\u4e86\u7ed1\u5b9a\u5730\u5740\u7684\u6807\u8bb0\uff0c\u4f46\u662f\u8fd8\u6ca1\u6709\u901a\u8fc7Libuv\u7ed1\u5b9a\u4e00\u4e2a\u5730\u5740\uff0c\u8fd9\u65f6\u5019\u901a\u8fc7getsocketname\u5224\u65ad\u7528\u6237\u662f\u5426\u81ea\u5df1\u901a\u8fc7bind\u51fd\u6570\u7ed1\u5b9a\u4e86\u4e00\u4e2a\u5730\u5740\uff0c\u662f\u7684\u8bdd\u5219\u4e0d\u9700\u8981\u518d\u6b21\u6267\u884c\u7ed1\u5b9a\u64cd\u4f5c\u3002\u5426\u5219\u968f\u673a\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740\u3002 \u4ee5\u4e0a\u4e24\u4e2a\u51fd\u6570\u7684\u903b\u8f91\u4e3b\u8981\u662f\u7533\u8bf7\u4e00\u4e2asocket\u548c\u7ed9socket\u7ed1\u5b9a\u4e00\u4e2a\u5730\u5740\u3002\u4e0b\u9762\u6211\u4eec\u5f00\u770b\u4e00\u4e0b\u8fde\u63a5\u6d41\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 int uv__tcp_connect ( uv_connect_t * req , uv_tcp_t * handle , const struct sockaddr * addr , unsigned int addrlen , uv_connect_cb cb ) { int err ; int r ; // \u5df2\u7ecf\u53d1\u8d77\u4e86connect\u4e86 if ( handle -> connect_req != NULL ) return UV_EALREADY ; // \u7533\u8bf7\u4e00\u4e2asocket\u548c\u7ed1\u5b9a\u4e00\u4e2a\u5730\u5740\uff0c\u5982\u679c\u8fd8\u6ca1\u6709\u7684\u8bdd err = maybe_new_socket ( handle , addr -> sa_family , UV_HANDLE_READABLE | UV_HANDLE_WRITABLE if ( err ) return err ; handle -> delayed_error = 0 ; do { // \u6e05\u9664\u5168\u5c40\u9519\u8bef\u53d8\u91cf\u7684\u503c errno = 0 ; // \u975e\u963b\u585e\u53d1\u8d77\u4e09\u6b21\u63e1\u624b r = connect ( uv__stream_fd ( handle ), addr , addrlen ); } while ( r == -1 && errno == EINTR ); if ( r == -1 && errno != 0 ) { // \u4e09\u6b21\u63e1\u624b\u8fd8\u6ca1\u6709\u5b8c\u6210 if ( errno == EINPROGRESS ) ; /* not an error */ else if ( errno == ECONNREFUSED ) // \u5bf9\u65b9\u62d2\u7edd\u5efa\u7acb\u8fde\u63a5\uff0c\u5ef6\u8fdf\u62a5\u9519 handle -> delayed_error = UV__ERR ( errno ); else // \u76f4\u63a5\u62a5\u9519 return UV__ERR ( errno ); } // \u521d\u59cb\u5316\u4e00\u4e2a\u8fde\u63a5\u578brequest\uff0c\u5e76\u8bbe\u7f6e\u67d0\u4e9b\u5b57\u6bb5 uv__req_init ( handle -> loop , req , UV_CONNECT ); req -> cb = cb ; req -> handle = ( uv_stream_t * ) handle ; QUEUE_INIT ( & req -> queue ); // \u8fde\u63a5\u8bf7\u6c42 handle -> connect_req = req ; // \u6ce8\u518c\u5230Libuv\u89c2\u5bdf\u8005\u961f\u5217 uv__io_start ( handle -> loop , & handle -> io_watcher , POLLOUT ); // \u8fde\u63a5\u51fa\u9519\uff0c\u63d2\u5165pending\u961f\u5c3e if ( handle -> delayed_error ) uv__io_feed ( handle -> loop , & handle -> io_watcher ); return 0 ; } \u8fde\u63a5\u6d41\u7684\u903b\u8f91\uff0c\u5927\u81f4\u5982\u4e0b 1 \u7533\u8bf7\u4e00\u4e2asocket\uff0c\u7ed1\u5b9a\u4e00\u4e2a\u5730\u5740\u3002 2 \u6839\u636e\u7ed9\u5b9a\u7684\u670d\u52a1\u5668\u5730\u5740\uff0c\u53d1\u8d77\u4e09\u6b21\u63e1\u624b\uff0c\u975e\u963b\u585e\u7684\uff0c\u4f1a\u76f4\u63a5\u8fd4\u56de\u7ee7\u7eed\u6267\u884c\uff0c\u4e0d\u4f1a\u7b49\u5230\u4e09\u6b21\u63e1\u624b\u5b8c\u6210\u3002 3 \u5f80\u6d41\u4e0a\u6302\u8f7d\u4e00\u4e2aconnect\u578b\u7684\u8bf7\u6c42\u3002 4 \u8bbe\u7f6eIO\u89c2\u5bdf\u8005\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u4e3a\u53ef\u5199\u3002\u7136\u540e\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165\u4e8b\u4ef6\u5faa\u73af\u7684IO\u89c2\u5bdf\u8005\u961f\u5217\u3002\u7b49\u5f85\u53ef\u5199\u7684\u65f6\u5019\u65f6\u5019\uff08\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\uff09\uff0c\u5c31\u4f1a\u6267\u884ccb\u56de\u8c03\u3002 \u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u4f1a\u6267\u884cuv__stream_io\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u903b\u8f91\u3002 1 2 3 4 if ( stream -> connect_req ) { uv__stream_connect ( stream ); return ; } \u6211\u4eec\u7ee7\u7eed\u770buv__stream_connect\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 static void uv__stream_connect ( uv_stream_t * stream ) { int error ; uv_connect_t * req = stream -> connect_req ; socklen_t errorsize = sizeof ( int ); // \u8fde\u63a5\u51fa\u9519 if ( stream -> delayed_error ) { error = stream -> delayed_error ; stream -> delayed_error = 0 ; } else { // \u8fd8\u662f\u9700\u8981\u5224\u65ad\u4e00\u4e0b\u662f\u4e0d\u662f\u51fa\u9519\u4e86 getsockopt ( uv__stream_fd ( stream ), SOL_SOCKET , SO_ERROR , & error , & errorsize ); error = UV__ERR ( error ); } // \u8fd8\u6ca1\u8fde\u63a5\u6210\u529f\uff0c\u5148\u8fd4\u56de\uff0c\u7b49\u5f85\u4e0b\u6b21\u53ef\u5199\u4e8b\u4ef6\u7684\u89e6\u53d1 if ( error == UV__ERR ( EINPROGRESS )) return ; // \u6e05\u7a7a stream -> connect_req = NULL ; uv__req_unregister ( stream -> loop , req ); /* \u8fde\u63a5\u51fa\u9519\u5219\u6ce8\u9500\u4e4b\u524d\u6ce8\u518c\u7684\u7b49\u5f85\u53ef\u5199\u961f\u5217\uff0c \u8fde\u63a5\u6210\u529f\u5982\u679c\u5f85\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u4e5f\u6ce8\u9500\u4e8b\u4ef6\uff0c\u6709\u6570\u636e\u9700\u8981\u5199\u7684\u65f6\u5019\u518d\u6ce8\u518c */ if ( error < 0 || QUEUE_EMPTY ( & stream -> write_queue )) { uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLOUT ); } // \u6267\u884c\u56de\u8c03\uff0c\u901a\u77e5\u4e0a\u5c42\u8fde\u63a5\u7ed3\u679c if ( req -> cb ) req -> cb ( req , error ); if ( uv__stream_fd ( stream ) == -1 ) return ; // \u8fde\u63a5\u5931\u8d25\uff0c\u6e05\u7a7a\u5f85\u5199\u7684\u6570\u636e\u548c\u6267\u884c\u5199\u8bf7\u6c42\u7684\u56de\u8c03\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09 if ( error < 0 ) { uv__stream_flush_write_queue ( stream , UV_ECANCELED ); uv__write_callbacks ( stream ); } } \u8fde\u63a5\u6d41\u7684\u903b\u8f91\u662f 1\u53d1\u8d77\u975e\u963b\u585e\u5f0f\u8fde\u63a5 2 \u6ce8\u518c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6 3 \u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u628a\u8fde\u63a5\u7ed3\u679c\u544a\u8bc9\u8c03\u7528\u65b9 4 \u8fde\u63a5\u6210\u529f\u5219\u53d1\u9001\u5199\u961f\u5217\u7684\u6570\u636e\uff0c\u8fde\u63a5\u5931\u8d25\u5219\u6e05\u9664\u5199\u961f\u5217\u7684\u6570\u636e\u5e76\u6267\u884c\u6bcf\u4e2a\u5199\u8bf7\u6c42\u7684\u56de\u8c03\uff08\u6709\u7684\u8bdd\uff09\u3002 5.8 \u76d1\u542c\u6d41 \u00b6 \u76d1\u542c\u6d41\u662f\u9488\u5bf9TCP\u6216Unix\u57df\u7684\uff0c\u4e3b\u8981\u662f\u628a\u4e00\u4e2asocket\u53d8\u6210listen\u72b6\u6001\u3002\u5e76\u4e14\u8bbe\u7f6e\u4e00\u4e9b\u5c5e\u6027\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 int uv_tcp_listen ( uv_tcp_t * tcp , int backlog , uv_connection_cb cb ) { static int single_accept = -1 ; unsigned long flags ; int err ; if ( tcp -> delayed_error ) return tcp -> delayed_error ; // \u662f\u5426\u8bbe\u7f6e\u4e86\u4e0d\u8fde\u7eedaccept\u3002\u9ed8\u8ba4\u662f\u8fde\u7eedaccept\u3002 if ( single_accept == -1 ) { const char * val = getenv ( \"UV_TCP_SINGLE_ACCEPT\" ); single_accept = ( val != NULL && atoi ( val ) != 0 ); } // \u8bbe\u7f6e\u4e0d\u8fde\u7eedaccept if ( single_accept ) tcp -> flags |= UV_HANDLE_TCP_SINGLE_ACCEPT ; flags = 0 ; /* \u53ef\u80fd\u8fd8\u6ca1\u6709\u7528\u4e8elisten\u7684fd\uff0csocket\u5730\u5740\u7b49\u3002 \u8fd9\u91cc\u7533\u8bf7\u4e00\u4e2asocket\u548c\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740 \uff08\u5982\u679c\u8c03listen\u4e4b\u524d\u6ca1\u6709\u8c03bind\u5219\u7ed1\u5b9a\u5230\u968f\u673a\u5730\u5740\uff09 */ err = maybe_new_socket ( tcp , AF_INET , flags ); if ( err ) return err ; // \u8bbe\u7f6efd\u4e3alisten\u72b6\u6001 if ( listen ( tcp -> io_watcher . fd , backlog )) return UV__ERR ( errno ); // \u5efa\u7acb\u8fde\u63a5\u540e\u7684\u4e1a\u52a1\u56de\u8c03 tcp -> connection_cb = cb ; tcp -> flags |= UV_HANDLE_BOUND ; // \u8bbe\u7f6eio\u89c2\u5bdf\u8005\u7684\u56de\u8c03\uff0c\u7531epoll\u76d1\u542c\u5230\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c tcp -> io_watcher . cb = uv__server_io ; /* \u63d2\u5165\u89c2\u5bdf\u8005\u961f\u5217\uff0c\u8fd9\u65f6\u5019\u8fd8\u6ca1\u6709\u589e\u52a0\u5230epoll\uff0c Poll IO\u9636\u6bb5\u518d\u904d\u5386\u89c2\u5bdf\u8005\u961f\u5217\u8fdb\u884c\u5904\u7406\uff08epoll_ctl\uff09 */ uv__io_start ( tcp -> loop , & tcp -> io_watcher , POLLIN ); return 0 ; } \u76d1\u542c\u6d41\u7684\u903b\u8f91\u770b\u8d77\u6765\u5f88\u591a\uff0c\u4f46\u662f\u4e3b\u8981\u7684\u903b\u8f91\u662f\u628a\u6d41\u5bf9\u7684fd\u6539\u6210listen\u72b6\u6001\uff0c\u8fd9\u6837\u6d41\u5c31\u53ef\u4ee5\u63a5\u6536\u8fde\u63a5\u8bf7\u6c42\u4e86\u3002\u63a5\u7740\u8bbe\u7f6e\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c\u7684\u56de\u8c03\u3002\u6700\u540e\u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230\u4e8b\u4ef6\u5faa\u73af\u3002\u7b49\u5f85\u8fde\u63a5\u5230\u6765\u3002\u5c31\u4f1a\u6267\u884cuv__server_io\u3002uv__server_io\u518d\u6267\u884cconnection_cb\u3002\u76d1\u542c\u6d41\u548c\u5176\u5b83\u6d41\u6709\u4e00\u4e2a\u533a\u522b\u662f\uff0c\u5f53IO\u89c2\u5bdf\u8005\u7684\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u76d1\u542c\u6d41\u6267\u884c\u7684\u56de\u8c03\u662fuv__server_io\u51fd\u6570\u3002\u800c\u5176\u5b83\u6d41\u662f\u5728uv__stream_io\u91cc\u7edf\u4e00\u5904\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fde\u63a5\u5230\u6765\u6216\u8005Unix\u57df\u4e0a\u6709\u6570\u636e\u5230\u6765\u65f6\u7684\u5904\u7406\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 void uv__server_io ( uv_loop_t * loop , uv__io_t * w , unsigned int events ) { uv_stream_t * stream ; int err ; stream = container_of ( w , uv_stream_t , io_watcher ); // \u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 uv__io_start ( stream -> loop , & stream -> io_watcher , POLLIN ); while ( uv__stream_fd ( stream ) != -1 ) { /* \u901a\u8fc7accept\u62ff\u5230\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684fd\uff0c\u6211\u4eec\u770b\u5230\u8fd9\u4e2a fd\u548c\u670d\u52a1\u5668\u7684fd\u662f\u4e0d\u4e00\u6837\u7684 */ err = uv__accept ( uv__stream_fd ( stream )); // \u9519\u8bef\u5904\u7406 if ( err < 0 ) { /* uv__stream_fd(stream)\u5bf9\u5e94\u7684fd\u662f\u975e\u963b\u585e\u7684\uff0c \u8fd4\u56de\u8fd9\u4e2a\u9519\u8bf4\u660e\u6ca1\u6709\u8fde\u63a5\u53ef\u7528accept\u4e86\uff0c\u76f4\u63a5\u8fd4\u56de */ if ( err == - EAGAIN || err == - EWOULDBLOCK ) return ; /* Not an error. */ if ( err == - ECONNABORTED ) continue ; // \u8fdb\u7a0b\u7684\u6253\u5f00\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e2a\u6570\u8fbe\u5230\u9608\u503c\uff0c\u770b\u662f\u5426\u6709\u5907\u7528\u7684 if ( err == - EMFILE || err == - ENFILE ) { err = uv__emfile_trick ( loop , uv__stream_fd ( stream )); if ( err == - EAGAIN || err == - EWOULDBLOCK ) break ; } // \u53d1\u751f\u9519\u8bef\uff0c\u6267\u884c\u56de\u8c03 stream -> connection_cb ( stream , err ); continue ; } // \u8bb0\u5f55\u62ff\u5230\u7684\u901a\u4fe1socket\u5bf9\u5e94\u7684fd stream -> accepted_fd = err ; // \u6267\u884c\u4e0a\u4f20\u56de\u8c03 stream -> connection_cb ( stream , 0 ); /* stream->accepted_fd\u4e3a-1\u8bf4\u660e\u5728\u56de\u8c03connection_cb\u91cc\u5df2\u7ecf\u6d88\u8d39 \u4e86 accepted_fd\uff0c\u5426\u5219\u5148\u6ce8\u9500\u670d\u52a1\u5668\u5728epoll\u4e2d\u7684fd\u7684\u8bfb\u4e8b\u4ef6\uff0c\u7b49 \u5f85\u6d88\u8d39\u540e\u518d\u6ce8\u518c\uff0c\u5373\u4e0d\u518d\u5904\u7406\u8bf7\u6c42\u4e86 */ if ( stream -> accepted_fd != -1 ) { /* The user hasn't yet accepted called uv_accept() */ uv__io_stop ( loop , & stream -> io_watcher , POLLIN ); return ; } /* \u662fTCP\u7c7b\u578b\u7684\u6d41\u5e76\u4e14\u8bbe\u7f6e\u6bcf\u6b21\u53eaaccpet\u4e00\u4e2a\u8fde\u63a5\uff0c\u5219\u5b9a\u65f6\u963b\u585e\uff0c \u88ab\u5524\u9192\u540e\u518daccept\uff0c\u5426\u5219\u4e00\u76f4accept\uff08\u5982\u679c\u7528\u6237\u5728connect\u56de \u8c03\u91cc\u6d88\u8d39\u4e86accept_fd\u7684\u8bdd\uff09\uff0c\u5b9a\u65f6\u963b\u585e\u7528\u4e8e\u591a\u8fdb\u7a0b\u7ade\u4e89\u5904\u7406\u8fde\u63a5 */ if ( stream -> type == UV_TCP && ( stream -> flags & UV_TCP_SINGLE_ACCEPT )) { struct timespec timeout = { 0 , 1 }; nanosleep ( & timeout , NULL ); } } } \u6211\u4eec\u770b\u5230\u8fde\u63a5\u5230\u6765\u65f6\uff0cLibuv\u4f1a\u4ece\u5df2\u5b8c\u6210\u8fde\u63a5\u7684\u961f\u5217\u4e2d\u6458\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u7136\u540e\u6267\u884cconnection_cb\u56de\u8c03\u3002\u5728connection_cb\u56de\u8c03\u91cc\uff0c\u9700\u8981uv_accept\u6d88\u8d39accpet_fd\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 int uv_accept ( uv_stream_t * server , uv_stream_t * client ) { int err ; switch ( client -> type ) { case UV_NAMED_PIPE : case UV_TCP : // \u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5230client err = uv__stream_open ( client , server -> accepted_fd , UV_STREAM_READABLE | UV_STREAM_WRITABLE ); if ( err ) { uv__close ( server -> accepted_fd ); goto done ; } break ; case UV_UDP : err = uv_udp_open (( uv_udp_t * ) client , server -> accepted_fd ); if ( err ) { uv__close ( server -> accepted_fd ); goto done ; } break ; default : return - EINVAL ; } client -> flags |= UV_HANDLE_BOUND ; done : // \u975e\u7a7a\u5219\u7ee7\u7eed\u653e\u4e00\u4e2a\u5230accpet_fd\u4e2d\u7b49\u5f85accept,\u7528\u4e8e\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012 if ( server -> queued_fds != NULL ) { uv__stream_queued_fds_t * queued_fds ; queued_fds = server -> queued_fds ; // \u628a\u7b2c\u4e00\u4e2a\u8d4b\u503c\u5230accept_fd server -> accepted_fd = queued_fds -> fds [ 0 ]; /* offset\u51cf\u53bb\u4e00\u4e2a\u5355\u4f4d\uff0c\u5982\u679c\u6ca1\u6709\u4e86\uff0c\u5219\u91ca\u653e\u5185\u5b58\uff0c \u5426\u5219\u9700\u8981\u628a\u540e\u9762\u7684\u5f80\u524d\u632a\uff0coffset\u6267\u884c\u6700\u540e\u4e00\u4e2a */ if ( -- queued_fds -> offset == 0 ) { uv__free ( queued_fds ); server -> queued_fds = NULL ; } else { memmove ( queued_fds -> fds , queued_fds -> fds + 1 , queued_fds -> offset * sizeof ( * queued_fds -> fds )); } } else { // \u6ca1\u6709\u6392\u961f\u7684fd\u4e86\uff0c\u5219\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u7b49\u5f85accept\u65b0\u7684fd server -> accepted_fd = -1 ; if ( err == 0 ) uv__io_start ( server -> loop , & server -> io_watcher , POLLIN ); } return err ; } client\u662f\u7528\u4e8e\u548c\u5ba2\u6237\u7aef\u8fdb\u884c\u901a\u4fe1\u7684\u6d41\uff0caccept\u5c31\u662f\u628aaccept_fd\u4fdd\u5b58\u5230client\u4e2d\uff0cclient\u5c31\u53ef\u4ee5\u901a\u8fc7fd\u548c\u5bf9\u7aef\u8fdb\u884c\u901a\u4fe1\u4e86\u3002\u6d88\u8d39\u5b8caccept_fd\u540e\uff0c\u5982\u679c\u8fd8\u6709\u5f85\u5904\u7406\u7684fd\u7684\u8bdd\uff0c\u9700\u8981\u8865\u5145\u4e00\u4e2a\u5230accept_fd\uff08\u9488\u5bf9Unix\u57df\uff09\uff0c\u5176\u5b83\u7684\u7ee7\u7eed\u6392\u961f\u7b49\u5f85\u5904\u7406\uff0c\u5982\u679c\u6ca1\u6709\u5f85\u5904\u7406\u7684fd\u5219\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u7ee7\u7eed\u5904\u7406\u65b0\u7684\u8fde\u63a5\u3002 5.9 \u9500\u6bc1\u6d41 \u00b6 \u5f53\u6211\u4eec\u4e0d\u518d\u9700\u8981\u4e00\u4e2a\u6d41\u7684\u65f6\u5019\uff0c\u6211\u4eec\u4f1a\u9996\u5148\u8c03\u7528uv_close\u5173\u95ed\u8fd9\u4e2a\u6d41\uff0c\u5173\u95ed\u6d41\u53ea\u662f\u6ce8\u9500\u4e86\u4e8b\u4ef6\u548c\u91ca\u653e\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u8c03\u7528uv_close\u4e4b\u540e\uff0c\u6d41\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53\u5c31\u4f1a\u88ab\u52a0\u5165\u5230closing\u961f\u5217\uff0c\u5728closing\u9636\u6bb5\u7684\u65f6\u5019\uff0c\u624d\u4f1a\u6267\u884c\u9500\u6bc1\u6d41\u7684\u64cd\u4f5c\uff0c\u6bd4\u5982\u4e22\u5f03\u8fd8\u6ca1\u6709\u5199\u5b8c\u6210\u7684\u6570\u636e\uff0c\u6267\u884c\u5bf9\u5e94\u6d41\u7684\u56de\u8c03\uff0c\u6211\u4eec\u770b\u770b\u9500\u6bc1\u6d41\u7684\u51fd\u6570uv__stream_destroy\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void uv__stream_destroy ( uv_stream_t * stream ) { // \u6b63\u5728\u8fde\u63a5\uff0c\u5219\u6267\u884c\u56de\u8c03 if ( stream -> connect_req ) { uv__req_unregister ( stream -> loop , stream -> connect_req ); stream -> connect_req -> cb ( stream -> connect_req , - ECANCELED ); stream -> connect_req = NULL ; } // \u4e22\u5f03\u5f85\u5199\u7684\u6570\u636e\uff0c\u5982\u679c\u6709\u7684\u8bdd uv__stream_flush_write_queue ( stream , - ECANCELED ); // \u5904\u7406\u5199\u5b8c\u6210\u961f\u5217\uff0c\u8fd9\u91cc\u662f\u5904\u7406\u88ab\u4e22\u5f03\u7684\u6570\u636e uv__write_callbacks ( stream ); // \u6b63\u5728\u5173\u95ed\u6d41\uff0c\u76f4\u63a5\u56de\u8c03 if ( stream -> shutdown_req ) { uv__req_unregister ( stream -> loop , stream -> shutdown_req ); stream -> shutdown_req -> cb ( stream -> shutdown_req , - ECANCELED ); stream -> shutdown_req = NULL ; } } \u6211\u4eec\u770b\u5230\uff0c\u9500\u6bc1\u6d41\u7684\u65f6\u5019\uff0c\u5982\u679c\u6d41\u4e2d\u8fd8\u6709\u5f85\u5199\u7684\u6570\u636e\uff0c\u5219\u4f1a\u4e22\u5f03\u3002\u6211\u4eec\u770b\u4e00\u4e0buv__stream_flush_write_queue\u548cuv__write_callbacks\u3002 1 2 3 4 5 6 7 8 9 10 11 12 void uv__stream_flush_write_queue ( uv_stream_t * stream , int error ) { uv_write_t * req ; QUEUE * q ; while ( ! QUEUE_EMPTY ( & stream -> write_queue )) { q = QUEUE_HEAD ( & stream -> write_queue ); QUEUE_REMOVE ( q ); req = QUEUE_DATA ( q , uv_write_t , queue ); // \u628a\u9519\u8bef\u5199\u5230\u6bcf\u4e2a\u8bf7\u6c42\u4e2d req -> error = error ; QUEUE_INSERT_TAIL ( & stream -> write_completed_queue , & req -> queue ); } } uv__stream_flush_write_queue\u4e22\u5f03\u5f85\u5199\u961f\u5217\u4e2d\u7684\u8bf7\u6c42\uff0c\u5e76\u76f4\u63a5\u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217\u4e2d\u3002uv__write_callbacks\u662f\u5199\u5b8c\u6216\u8005\u5199\u51fa\u9519\u65f6\u6267\u884c\u7684\u51fd\u6570\uff0c\u5b83\u9010\u4e2a\u5904\u7406\u5199\u5b8c\u6210\u961f\u5217\u4e2d\u7684\u8282\u70b9\uff0c\u6bcf\u4e2a\u8282\u70b9\u662f\u4e00\u4e2a\u5199\u8bf7\u6c42\uff0c\u6267\u884c\u5b83\u7684\u56de\u8c03\uff0c\u5982\u4f55\u5206\u914d\u4e86\u5806\u5185\u5b58\uff0c\u5219\u91ca\u653e\u5185\u5b58\u3002\u5728\u5199\u6d41\u7ae0\u8282\u5df2\u7ecf\u5206\u6790\uff0c\u4e0d\u518d\u5177\u4f53\u5c55\u5f00\u3002 5.10 \u4e8b\u4ef6\u89e6\u53d1\u7684\u5904\u7406 \u00b6 \u5728\u6d41\u7684\u5b9e\u73b0\u4e2d\uff0c\u8bfb\u5199\u7b49\u64cd\u4f5c\u90fd\u53ea\u662f\u6ce8\u518c\u4e8b\u4ef6\u5230epoll\uff0c\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884c\u7edf\u4e00\u7684\u56de\u8c03\u51fd\u6570uv__stream_io\u3002\u4e0b\u9762\u5217\u4e00\u4e0b\u8be5\u51fd\u6570\u7684\u4ee3\u7801\uff0c\u5177\u4f53\u5b9e\u73b0\u5728\u5176\u5b83\u7ae0\u8282\u5df2\u7ecf\u5206\u6790\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 static void uv__stream_io ( uv_loop_t * loop , uv__io_t * w , unsigned int events ) { uv_stream_t * stream ; stream = container_of ( w , uv_stream_t , io_watcher ); // \u662f\u8fde\u63a5\u6d41\uff0c\u5219\u6267\u884c\u8fde\u63a5\u5904\u7406\u51fd\u6570 if ( stream -> connect_req ) { uv__stream_connect ( stream ); return ; } /* Ignore POLLHUP here. Even it it's set, there may still be data to read. */ // \u53ef\u8bfb\u662f\u89e6\u53d1\uff0c\u5219\u6267\u884c\u8bfb\u5904\u7406 if ( events & ( POLLIN | POLLERR | POLLHUP )) uv__read ( stream ); // \u8bfb\u56de\u8c03\u5173\u95ed\u4e86\u6d41 if ( uv__stream_fd ( stream ) == -1 ) return ; /* read_cb closed stream. */ /* \u00ac\u00ac POLLHUP\u8bf4\u660e\u5bf9\u7aef\u5173\u95ed\u4e86\uff0c\u5373\u4e0d\u4f1a\u53d1\u751f\u6570\u636e\u8fc7\u6765\u4e86\u3002 \u5982\u679c\u6d41\u7684\u6a21\u5f0f\u662f\u6301\u7eed\u8bfb\uff0c 1 \u5982\u679c\u53ea\u8bfb\u53d6\u4e86\u90e8\u5206\uff08\u8bbe\u7f6eUV_STREAM_READ_PARTIAL\uff09\uff0c \u5e76\u4e14\u6ca1\u6709\u8bfb\u5230\u7ed3\u5c3e(\u6ca1\u6709\u8bbe\u7f6eUV_STREAM_READ_EOF)\uff0c \u5219\u76f4\u63a5\u4f5c\u8bfb\u7ed3\u675f\u5904\u7406\uff0c 2 \u5982\u679c\u53ea\u8bfb\u53d6\u4e86\u90e8\u5206\uff0c\u4e0a\u9762\u7684\u8bfb\u56de\u8c03\u6267\u884c\u4e86\u8bfb\u7ed3\u675f\u64cd\u4f5c\uff0c \u5219\u8fd9\u91cc\u5c31\u4e0d\u9700\u8981\u5904\u7406\u4e86 3 \u5982\u679c\u6ca1\u6709\u8bbe\u7f6e\u53ea\u8bfb\u4e86\u90e8\u5206\uff0c\u8fd8\u6ca1\u6709\u6267\u884c\u8bfb\u7ed3\u675f\u64cd\u4f5c\uff0c \u5219\u4e0d\u80fd\u4f5c\u8bfb\u7ed3\u675f\u64cd\u4f5c\uff0c\u56e0\u4e3a\u5bf9\u7aef\u867d\u7136\u5173\u95ed\u4e86\uff0c\u4f46\u662f\u4e4b \u524d\u7684\u4f20\u8fc7\u6765\u7684\u6570\u636e\u53ef\u80fd\u8fd8\u6ca1\u6709\u88ab\u6d88\u8d39\u5b8c 4 \u5982\u679c\u6ca1\u6709\u8bbe\u7f6e\u53ea\u8bfb\u4e86\u90e8\u5206\uff0c\u6267\u884c\u4e86\u8bfb\u7ed3\u675f\u64cd\u4f5c\uff0c\u90a3\u8fd9 \u91cc\u4e5f\u4e0d\u9700\u8981\u5904\u7406 */ if (( events & POLLHUP ) && ( stream -> flags & UV_STREAM_READING ) && ( stream -> flags & UV_STREAM_READ_PARTIAL ) && ! ( stream -> flags & UV_STREAM_READ_EOF )) { uv_buf_t buf = { NULL , 0 }; uv__stream_eof ( stream , & buf ); } if ( uv__stream_fd ( stream ) == -1 ) return ; /* read_cb closed stream. */ // \u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1 if ( events & ( POLLOUT | POLLERR | POLLHUP )) { // \u5199\u6570\u636e uv__write ( stream ); // \u5199\u5b8c\u540e\u505a\u540e\u7f6e\u5904\u7406\uff0c\u91ca\u653e\u5185\u5b58\uff0c\u6267\u884c\u56de\u8c03\u7b49 uv__write_callbacks ( stream ); // \u5f85\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u6ce8\u9500\u7b49\u5f85\u5199\u4e8b\u4ef6 if ( QUEUE_EMPTY ( & stream -> write_queue )) uv__drain ( stream ); } }","title":"05-Libuv\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#libuv","text":"\u6d41\u7684\u5b9e\u73b0\u5728Libuv\u91cc\u5360\u4e86\u5f88\u5927\u7684\u7bc7\u5e45\uff0c\u662f\u975e\u5e38\u6838\u5fc3\u7684\u903b\u8f91\u3002\u6d41\u7684\u672c\u8d28\u662f\u5c01\u88c5\u4e86\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u64cd\u4f5c\uff0c\u4f8b\u5982\u8bfb\u3001\u5199\uff0c\u8fde\u63a5\u3001\u76d1\u542c\u3002\u6211\u4eec\u9996\u5148\u770b\u770b\u6570\u636e\u7ed3\u6784\uff0c\u6d41\u5728Libuv\u91cc\u7528uv_stream_s\u8868\u793a\uff0c\u7ee7\u627f\u4e8euv_handle_s\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 struct uv_stream_s { // uv_handle_s\u7684\u5b57\u6bb5 void * data ; // \u6240\u5c5e\u4e8b\u4ef6\u5faa\u73af uv_loop_t * loop ; // handle\u7c7b\u578b uv_handle_type type ; // \u5173\u95edhandle\u65f6\u7684\u56de\u8c03 uv_close_cb close_cb ; // \u7528\u4e8e\u63d2\u5165\u4e8b\u4ef6\u5faa\u73af\u7684handle\u961f\u5217 void * handle_queue [ 2 ]; union { int fd ; void * reserved [ 4 ]; } u ; // \u7528\u4e8e\u63d2\u5165\u4e8b\u4ef6\u5faa\u73af\u7684closing\u9636\u6bb5 uv_handle_t * next_closing ; // \u5404\u79cd\u6807\u8bb0 unsigned int flags ; // \u6d41\u62d3\u5c55\u7684\u5b57\u6bb5 /* \u6237\u5199\u5165\u6d41\u7684\u5b57\u8282\u5927\u5c0f\uff0c\u6d41\u7f13\u5b58\u7528\u6237\u7684\u8f93\u5165\uff0c \u7136\u540e\u7b49\u5230\u53ef\u5199\u7684\u65f6\u5019\u624d\u6267\u884c\u771f\u6b63\u7684\u5199 */ size_t write_queue_size ; // \u5206\u914d\u5185\u5b58\u7684\u51fd\u6570\uff0c\u5185\u5b58\u7531\u7528\u6237\u5b9a\u4e49\uff0c\u7528\u6765\u4fdd\u5b58\u8bfb\u53d6\u7684\u6570\u636e uv_alloc_cb alloc_cb ; // \u8bfb\u56de\u8c03 uv_read_cb read_cb ; // \u8fde\u63a5\u8bf7\u6c42\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53 uv_connect_t * connect_req ; /* \u5173\u95ed\u5199\u7aef\u7684\u65f6\u5019\uff0c\u53d1\u9001\u5b8c\u7f13\u5b58\u7684\u6570\u636e\uff0c \u6267\u884cshutdown_req\u7684\u56de\u8c03\uff08shutdown_req\u5728uv_shutdown\u7684\u65f6\u5019\u8d4b\u503c\uff09 */ uv_shutdown_t * shutdown_req ; /* \u6d41\u5bf9\u5e94\u7684IO\u89c2\u5bdf\u8005 */ uv__io_t io_watcher ; // \u7f13\u5b58\u5f85\u5199\u7684\u6570\u636e\uff0c\u8be5\u5b57\u6bb5\u7528\u4e8e\u63d2\u5165\u961f\u5217 void * write_queue [ 2 ]; // \u5df2\u7ecf\u5b8c\u6210\u4e86\u6570\u636e\u5199\u5165\u7684\u961f\u5217\uff0c\u8be5\u5b57\u6bb5\u7528\u4e8e\u63d2\u5165\u961f\u5217 void * write_completed_queue [ 2 ]; // \u6709\u8fde\u63a5\u5230\u6765\u5e76\u4e14\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u540e\uff0c\u6267\u884c\u7684\u56de\u8c03 uv_connection_cb connection_cb ; // \u64cd\u4f5c\u6d41\u65f6\u51fa\u9519\u7801 int delayed_error ; // accept\u8fd4\u56de\u7684\u901a\u4fe1socket\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0 int accepted_fd ; // \u540c\u4e0a\uff0c\u7528\u4e8eIPC\u65f6\uff0c\u7f13\u5b58\u591a\u4e2a\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 void * queued_fds ; } \u6d41\u7684\u5b9e\u73b0\u4e2d\uff0c\u6700\u6838\u5fc3\u7684\u5b57\u6bb5\u662fIO\u89c2\u5bdf\u8005\uff0c\u5176\u4f59\u7684\u5b57\u6bb5\u662f\u548c\u6d41\u7684\u6027\u8d28\u76f8\u5173\u7684\u3002IO\u89c2\u5bdf\u8005\u5c01\u88c5\u4e86\u6d41\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e8b\u4ef6\u89e6\u53d1\u65f6\u7684\u56de\u8c03\u3002\u6bd4\u5982\u8bfb\u4e00\u4e2a\u6d41\u3001\u5199\u4e00\u4e2a\u6d41\u3001\u5173\u95ed\u4e00\u4e2a\u6d41\u3001\u8fde\u63a5\u4e00\u4e2a\u6d41\u3001\u76d1\u542c\u4e00\u4e2a\u6d41\uff0c\u5728uv_stream_s\u4e2d\u90fd\u6709\u5bf9\u5e94\u7684\u5b57\u6bb5\u53bb\u652f\u6301\u3002\u4f46\u662f\u672c\u8d28\u4e0a\u662f\u9760IO\u89c2\u5bdf\u8005\u53bb\u9a71\u52a8\u7684\u3002 1 \u8bfb\u4e00\u4e2a\u6d41\uff0c\u5c31\u662fIO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u6267\u884c\u7528\u6237\u7684\u8bfb\u56de\u8c03\u3002 2 \u5199\u4e00\u4e2a\u6d41\uff0c\u5148\u628a\u6570\u636e\u5199\u5230\u6d41\u4e2d\uff0c\u7b49\u5230IO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u6267\u884c\u771f\u6b63\u7684\u5199\u5165\uff0c\u5e76\u6267\u884c\u7528\u6237\u7684\u5199\u7ed3\u675f\u56de\u8c03\u3002 3 \u5173\u95ed\u4e00\u4e2a\u6d41\uff0c\u5c31\u662fIO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u5c31\u4f1a\u6267\u884c\u5173\u95ed\u6d41\u7684\u5199\u7aef\u3002\u5982\u679c\u6d41\u4e2d\u8fd8\u6709\u6570\u636e\u6ca1\u6709\u5199\u5b8c\uff0c\u5219\u5148\u5199\u5b8c\uff08\u6bd4\u5982\u53d1\u9001\uff09\u540e\u518d\u6267\u884c\u5173\u95ed\u64cd\u4f5c\uff0c\u63a5\u7740\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 4 \u8fde\u63a5\u6d41\uff0c\u6bd4\u5982\u4f5c\u4e3a\u5ba2\u6237\u7aef\u53bb\u8fde\u63a5\u670d\u52a1\u5668\u3002\u5c31\u662fIO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff08\u6bd4\u5982\u5efa\u7acb\u4e09\u6b21\u63e1\u624b\u6210\u529f\uff09\uff0c\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 5 \u76d1\u542c\u6d41\uff0c\u5c31\u662fIO\u89c2\u5bdf\u8005\u4e2d\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff08\u6bd4\u5982\u6709\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u7684\u8fde\u63a5\uff09\uff0c\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u6d41\u7684\u5177\u4f53\u5b9e\u73b0","title":"\u7b2c\u4e94\u7ae0 Libuv\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#51","text":"\u5728\u4f7f\u7528uv_stream_t\u4e4b\u524d\u9700\u8981\u9996\u5148\u521d\u59cb\u5316\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u521d\u59cb\u5316\u4e00\u4e2a\u6d41\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void uv__stream_init ( uv_loop_t * loop , uv_stream_t * stream , uv_handle_type type ) { int err ; // \u8bb0\u5f55handle\u7684\u7c7b\u578b uv__handle_init ( loop , ( uv_handle_t * ) stream , type ); stream -> read_cb = NULL ; stream -> alloc_cb = NULL ; stream -> close_cb = NULL ; stream -> connection_cb = NULL ; stream -> connect_req = NULL ; stream -> shutdown_req = NULL ; stream -> accepted_fd = -1 ; stream -> queued_fds = NULL ; stream -> delayed_error = 0 ; QUEUE_INIT ( & stream -> write_queue ); QUEUE_INIT ( & stream -> write_completed_queue ); stream -> write_queue_size = 0 ; /* \u521d\u59cb\u5316IO\u89c2\u5bdf\u8005\uff0c\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff08\u8fd9\u91cc\u8fd8\u6ca1\u6709\uff0c\u6240\u4ee5\u662f-1\uff09\u548c \u56de\u8c03uv__stream_io\u8bb0\u5f55\u5728io_watcher\u4e0a\uff0cfd\u7684\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u7edf\u4e00 \u7531uv__stream_io\u51fd\u6570\u5904\u7406\uff0c\u4f46\u4e5f\u4f1a\u6709\u7279\u6b8a\u60c5\u51b5\uff08\u4e0b\u9762\u4f1a\u8bb2\u5230\uff09 */ uv__io_init ( & stream -> io_watcher , uv__stream_io , -1 ); } \u521d\u59cb\u5316\u4e00\u4e2a\u6d41\u7684\u903b\u8f91\u5f88\u7b80\u5355\u660e\u4e86\uff0c\u5c31\u662f\u521d\u59cb\u5316\u76f8\u5173\u7684\u5b57\u6bb5\uff0c\u9700\u8981\u6ce8\u610f\u7684\u662f\u521d\u59cb\u5316IO\u89c2\u5bdf\u8005\u65f6\uff0c\u8bbe\u7f6e\u7684\u5904\u7406\u51fd\u6570\u662fuv__stream_io\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u5206\u6790\u8fd9\u4e2a\u51fd\u6570\u7684\u5177\u4f53\u903b\u8f91\u3002","title":"5.1 \u521d\u59cb\u5316\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#52","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 int uv__stream_open ( uv_stream_t * stream , int fd , int flags ) { // \u8fd8\u6ca1\u6709\u8bbe\u7f6efd\u6216\u8005\u8bbe\u7f6e\u7684\u540c\u4e00\u4e2afd\u5219\u7ee7\u7eed\uff0c\u5426\u5219\u8fd4\u56deUV_EBUSY if ( ! ( stream -> io_watcher . fd == -1 || stream -> io_watcher . fd == fd )) return UV_EBUSY ; // \u8bbe\u7f6e\u6d41\u7684\u6807\u8bb0 stream -> flags |= flags ; // \u662fTCP\u6d41\u5219\u53ef\u4ee5\u8bbe\u7f6e\u4e0b\u9762\u7684\u5c5e\u6027 if ( stream -> type == UV_TCP ) { // \u5173\u95ednagle\u7b97\u6cd5 if (( stream -> flags & UV_HANDLE_TCP_NODELAY ) && uv__tcp_nodelay ( fd , 1 )) return UV__ERR ( errno ); /* \u5f00\u542fkeepalive\u673a\u5236 */ if (( stream -> flags & UV_HANDLE_TCP_KEEPALIVE ) && uv__tcp_keepalive ( fd , 1 , 60 )) { return UV__ERR ( errno ); } } /* \u4fdd\u5b58socket\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5230IO\u89c2\u5bdf\u8005\u4e2d\uff0cLibuv\u4f1a\u5728 Poll IO\u9636\u6bb5\u76d1\u542c\u8be5\u6587\u4ef6\u63cf\u8ff0\u7b26 */ stream -> io_watcher . fd = fd ; return 0 ; } \u6253\u5f00\u4e00\u4e2a\u6d41\uff0c\u672c\u8d28\u4e0a\u5c31\u662f\u7ed9\u8fd9\u4e2a\u6d41\u5173\u8054\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u540e\u7eed\u7684\u64cd\u4f5c\u7684\u65f6\u5019\u90fd\u662f\u57fa\u4e8e\u8fd9\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\uff0c\u53e6\u5916\u8fd8\u6709\u4e00\u4e9b\u5c5e\u6027\u7684\u8bbe\u7f6e\u3002","title":"5.2 \u6253\u5f00\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#53","text":"\u6211\u4eec\u5728\u4e00\u4e2a\u6d41\u4e0a\u6267\u884cuv_read_start\u540e\uff0c\u6d41\u7684\u6570\u636e\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u5c31\u4f1a\u901a\u8fc7read_cb\u56de\u8c03\u6e90\u6e90\u4e0d\u65ad\u5730\u6d41\u5411\u8c03\u7528\u65b9\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int uv_read_start ( uv_stream_t * stream , uv_alloc_cb alloc_cb , uv_read_cb read_cb ) { // \u6d41\u5df2\u7ecf\u5173\u95ed\uff0c\u4e0d\u80fd\u8bfb if ( stream -> flags & UV_HANDLE_CLOSING ) return UV_EINVAL ; // \u6d41\u4e0d\u53ef\u8bfb\uff0c\u8bf4\u660e\u53ef\u80fd\u662f\u53ea\u5199\u6d41 if ( ! ( stream -> flags & UV_HANDLE_READABLE )) return - ENOTCONN ; // \u6807\u8bb0\u6b63\u5728\u8bfb stream -> flags |= UV_HANDLE_READING ; // \u8bb0\u5f55\u8bfb\u56de\u8c03\uff0c\u6709\u6570\u636e\u7684\u65f6\u5019\u4f1a\u6267\u884c\u8fd9\u4e2a\u56de\u8c03 stream -> read_cb = read_cb ; // \u5206\u914d\u5185\u5b58\u51fd\u6570\uff0c\u7528\u4e8e\u5b58\u50a8\u8bfb\u53d6\u7684\u6570\u636e stream -> alloc_cb = alloc_cb ; // \u6ce8\u518c\u7b49\u5f85\u8bfb\u4e8b\u4ef6 uv__io_start ( stream -> loop , & stream -> io_watcher , POLLIN ); // \u6fc0\u6d3bhandle\uff0c\u6709\u6fc0\u6d3b\u7684handle\uff0c\u4e8b\u4ef6\u5faa\u73af\u4e0d\u4f1a\u9000\u51fa uv__handle_start ( stream ); return 0 ; } \u6267\u884cuv_read_start\u672c\u8d28\u4e0a\u662f\u7ed9\u6d41\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5728epoll\u4e2d\u6ce8\u518c\u4e86\u4e00\u4e2a\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u5e76\u8bb0\u5f55\u76f8\u5e94\u7684\u4e0a\u4e0b\u6587\uff0c\u6bd4\u5982\u8bfb\u56de\u8c03\u51fd\u6570\uff0c\u5206\u914d\u5185\u5b58\u7684\u51fd\u6570\u3002\u63a5\u7740\u6253\u4e0a\u6b63\u5728\u505a\u8bfb\u53d6\u64cd\u4f5c\u7684\u6807\u8bb0\u3002\u5f53\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u8bfb\u56de\u8c03\u5c31\u4f1a\u88ab\u6267\u884c\uff0c\u9664\u4e86\u8bfb\u53d6\u6570\u636e\uff0c\u8fd8\u6709\u4e00\u4e2a\u8bfb\u64cd\u4f5c\u5c31\u662f\u505c\u6b62\u8bfb\u53d6\u3002\u5bf9\u5e94\u7684\u51fd\u6570\u662fuv_read_stop\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int uv_read_stop ( uv_stream_t * stream ) { // \u662f\u5426\u6b63\u5728\u6267\u884c\u8bfb\u53d6\u64cd\u4f5c\uff0c\u5982\u679c\u4e0d\u662f\uff0c\u5219\u6ca1\u6709\u5fc5\u8981\u505c\u6b62 if ( ! ( stream -> flags & UV_HANDLE_READING )) return 0 ; // \u6e05\u9664\u6b63\u5728\u8bfb\u53d6\u7684\u6807\u8bb0 stream -> flags &= ~ UV_HANDLE_READING ; // \u64a4\u9500\u7b49\u5f85\u8bfb\u4e8b\u4ef6 uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLIN ); // \u5bf9\u5199\u4e8b\u4ef6\u4e5f\u4e0d\u611f\u5174\u8da3\uff0c\u505c\u6389handle\u3002\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa if ( ! uv__io_active ( & stream -> io_watcher , POLLOUT )) uv__handle_stop ( stream ); stream -> read_cb = NULL ; stream -> alloc_cb = NULL ; return 0 ; } \u53e6\u5916\u8fd8\u6709\u4e00\u4e2a\u8f85\u52a9\u51fd\u6570\uff0c\u5224\u65ad\u6d41\u662f\u5426\u8bbe\u7f6e\u4e86\u53ef\u8bfb\u5c5e\u6027\u3002 1 2 3 int uv_is_readable ( const uv_stream_t * stream ) { return !! ( stream -> flags & UV_HANDLE_READABLE ); } \u4e0a\u9762\u7684\u51fd\u6570\u53ea\u662f\u6ce8\u518c\u548c\u6ce8\u9500\u8bfb\u4e8b\u4ef6\uff0c\u5982\u679c\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u81ea\u5df1\u53bb\u8bfb\u53d6\u6570\u636e\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u771f\u6b63\u7684\u8bfb\u903b\u8f91 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 static void uv__read ( uv_stream_t * stream ) { uv_buf_t buf ; ssize_t nread ; struct msghdr msg ; char cmsg_space [ CMSG_SPACE ( UV__CMSG_FD_SIZE )]; int count ; int err ; int is_ipc ; // \u6e05\u9664\u8bfb\u53d6\u90e8\u5206\u6807\u8bb0 stream -> flags &= ~ UV_STREAM_READ_PARTIAL ; count = 32 ; /* \u6d41\u662fUnix\u57df\u7c7b\u578b\u5e76\u4e14\u7528\u4e8eIPC\uff0cUnix\u57df\u4e0d\u4e00\u5b9a\u7528\u4e8eIPC\uff0c \u7528\u4f5cIPC\u53ef\u4ee5\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 */ is_ipc = stream -> type == UV_NAMED_PIPE && (( uv_pipe_t * ) stream ) -> ipc ; // \u8bbe\u7f6e\u4e86\u8bfb\u56de\u8c03\uff0c\u6b63\u5728\u8bfb\uff0ccount\u5927\u4e8e0 while ( stream -> read_cb && ( stream -> flags & UV_STREAM_READING ) && ( count -- > 0 )) { buf = uv_buf_init ( NULL , 0 ); // \u8c03\u7528\u8c03\u7528\u65b9\u63d0\u4f9b\u7684\u5206\u914d\u5185\u5b58\u51fd\u6570\uff0c\u5206\u914d\u5185\u5b58\u627f\u8f7d\u6570\u636e stream -> alloc_cb (( uv_handle_t * ) stream , 64 * 1024 , & buf ); /* \u4e0d\u662fIPC\u5219\u76f4\u63a5\u8bfb\u53d6\u6570\u636e\u5230buf\uff0c\u5426\u5219\u7528recvmsg\u8bfb\u53d6\u6570\u636e \u548c\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09 */ if ( ! is_ipc ) { do { nread = read ( uv__stream_fd ( stream ), buf . base , buf . len ); } while ( nread < 0 && errno == EINTR ); } else { /* ipc uses recvmsg */ msg . msg_flags = 0 ; msg . msg_iov = ( struct iovec * ) & buf ; msg . msg_iovlen = 1 ; msg . msg_name = NULL ; msg . msg_namelen = 0 ; msg . msg_controllen = sizeof ( cmsg_space ); msg . msg_control = cmsg_space ; do { nread = uv__recvmsg ( uv__stream_fd ( stream ), & msg , 0 ); } while ( nread < 0 && errno == EINTR ); } // \u8bfb\u5931\u8d25 if ( nread < 0 ) { // \u8bfb\u7e41\u5fd9 if ( errno == EAGAIN || errno == EWOULDBLOCK ) { // \u6267\u884c\u8bfb\u56de\u8c03 stream -> read_cb ( stream , 0 , & buf ); } else { /* Error. User should call uv_close(). */ // \u8bfb\u5931\u8d25 stream -> read_cb ( stream , - errno , & buf ); } return ; } else if ( nread == 0 ) { // \u8bfb\u5230\u7ed3\u5c3e\u4e86 uv__stream_eof ( stream , & buf ); return ; } else { // \u8bfb\u6210\u529f\uff0c\u8bfb\u53d6\u6570\u636e\u7684\u957f\u5ea6 ssize_t buflen = buf . len ; /* \u662fIPC\u5219\u89e3\u6790\u8bfb\u53d6\u7684\u6570\u636e\uff0c\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u89e3\u6790\u51fa\u6765\uff0c \u653e\u5230stream\u7684accepted_fd\u548cqueued_fds\u5b57\u6bb5 */ if ( is_ipc ) { err = uv__stream_recv_cmsg ( stream , & msg ); if ( err != 0 ) { stream -> read_cb ( stream , err , & buf ); return ; } } // \u6267\u884c\u8bfb\u56de\u8c03 stream -> read_cb ( stream , nread , & buf ); } } } uv_read\u9664\u4e86\u53ef\u4ee5\u8bfb\u53d6\u4e00\u822c\u7684\u6570\u636e\u5916\uff0c\u8fd8\u652f\u6301\u8bfb\u53d6\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u63cf\u8ff0\u7b26\u4f20\u9012\u7684\u539f\u7406\u3002\u6211\u4eec\u77e5\u9053\uff0c\u7236\u8fdb\u7a0bfork\u51fa\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\uff0c\u5b50\u8fdb\u7a0b\u662f\u7ee7\u627f\u7236\u8fdb\u7a0b\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5217\u8868\u7684\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fdb\u7a0b\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5173\u7cfb\u3002 fork\u4e4b\u524d\u5982\u56fe5-1\u6240\u793a\u3002 \u6211\u4eec\u518d\u770b\u4e00\u4e0bfork\u4e4b\u540e\u7684\u7ed3\u6784\u5982\u56fe5-2\u6240\u793a\u3002 \u5982\u679c\u7236\u8fdb\u7a0b\u6216\u8005\u5b50\u8fdb\u7a0b\u5728fork\u4e4b\u540e\u521b\u5efa\u4e86\u65b0\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u90a3\u7236\u5b50\u8fdb\u7a0b\u95f4\u5c31\u4e0d\u80fd\u5171\u4eab\u4e86\uff0c\u5047\u8bbe\u7236\u8fdb\u7a0b\u8981\u628a\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u7ed9\u5b50\u8fdb\u7a0b\uff0c\u90a3\u600e\u4e48\u529e\u5462\uff1f\u6839\u636e\u8fdb\u7a0b\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5173\u7cfb\u3002\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u8981\u505a\u7684\u4e8b\u60c5\uff0c\u4e0d\u4ec5\u4ec5\u662f\u5728\u5b50\u8fdb\u7a0b\u4e2d\u65b0\u5efa\u4e00\u4e2afd\uff0c\u8fd8\u8981\u5efa\u7acb\u8d77fd->file->inode\u7684\u5173\u8054\uff0c\u4e0d\u8fc7\u6211\u4eec\u4e0d\u9700\u8981\u5173\u6ce8\u8fd9\u4e9b\uff0c\u56e0\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u90fd\u5e2e\u6211\u4eec\u5904\u7406\u4e86\uff0c\u6211\u4eec\u53ea\u9700\u8981\u901a\u8fc7sendmsg\u628a\u60f3\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u53d1\u9001\u7ed9Unix\u57df\u7684\u53e6\u4e00\u7aef\u3002Unix\u57df\u53e6\u4e00\u7aef\u5c31\u53ef\u4ee5\u901a\u8fc7recvmsg\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4ece\u6570\u636e\u4e2d\u8bfb\u53d6\u51fa\u6765\u3002\u63a5\u7740\u4f7f\u7528uv__stream_recv_cmsg\u51fd\u6570\u4fdd\u5b58\u6570\u636e\u91cc\u89e3\u6790\u51fa\u6765\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 static int uv__stream_recv_cmsg ( uv_stream_t * stream , struct msghdr * msg ) { struct cmsghdr * cmsg ; // \u904d\u5386msg for ( cmsg = CMSG_FIRSTHDR ( msg ); cmsg != NULL ; cmsg = CMSG_NXTHDR ( msg , cmsg )) { char * start ; char * end ; int err ; void * pv ; int * pi ; unsigned int i ; unsigned int count ; pv = CMSG_DATA ( cmsg ); pi = pv ; start = ( char * ) cmsg ; end = ( char * ) cmsg + cmsg -> cmsg_len ; count = 0 ; while ( start + CMSG_LEN ( count * sizeof ( * pi )) < end ) count ++ ; for ( i = 0 ; i < count ; i ++ ) { /* accepted_fd\u4ee3\u8868\u5f53\u524d\u5f85\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c \u5982\u679c\u5df2\u7ecf\u6709\u503c\u5219\u5269\u4f59\u63cf\u8ff0\u7b26\u5c31\u901a\u8fc7uv__stream_queue_fd\u6392\u961f \u5982\u679c\u8fd8\u6ca1\u6709\u503c\u5219\u5148\u8d4b\u503c */ if ( stream -> accepted_fd != -1 ) { err = uv__stream_queue_fd ( stream , pi [ i ]); } else { stream -> accepted_fd = pi [ i ]; } } } return 0 ; } uv__stream_recv_cmsg\u4f1a\u4ece\u6570\u636e\u4e2d\u89e3\u6790\u51fa\u4e00\u4e2a\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u5b58\u5230stream\u4e2d\uff0c\u7b2c\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5728accepted_fd\uff0c\u5269\u4e0b\u7684\u4f7f\u7528uv__stream_queue_fd\u5904\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 struct uv__stream_queued_fds_s { unsigned int size ; unsigned int offset ; int fds [ 1 ]; }; static int uv__stream_queue_fd ( uv_stream_t * stream , int fd ) { uv__stream_queued_fds_t * queued_fds ; unsigned int queue_size ; // \u539f\u6765\u7684\u5185\u5b58 queued_fds = stream -> queued_fds ; // \u6ca1\u6709\u5185\u5b58\uff0c\u5219\u5206\u914d if ( queued_fds == NULL ) { // \u9ed8\u8ba48\u4e2a queue_size = 8 ; /* \u4e00\u4e2a\u5143\u6570\u636e\u5185\u5b58+\u591a\u4e2afd\u7684\u5185\u5b58 \uff08\u524d\u9762\u52a0*\u4ee3\u8868\u89e3\u5f15\u7528\u540e\u7684\u503c\u7684\u7c7b\u578b\u6240\u5360\u7684\u5185\u5b58\u5927\u5c0f\uff0c \u51cf\u4e00\u662f\u56e0\u4e3auv__stream_queued_fds_t \u7ed3\u6784\u4f53\u672c\u8eab\u6709\u4e00\u4e2a\u7a7a\u95f4\uff09 */ queued_fds = uv__malloc (( queue_size - 1 ) * sizeof ( * queued_fds -> fds ) + sizeof ( * queued_fds )); if ( queued_fds == NULL ) return UV_ENOMEM ; // \u5bb9\u91cf queued_fds -> size = queue_size ; // \u5df2\u4f7f\u7528\u4e2a\u6570 queued_fds -> offset = 0 ; // \u6307\u5411\u53ef\u7528\u7684\u5185\u5b58 stream -> queued_fds = queued_fds ; // \u4e4b\u524d\u7684\u5185\u5b58\u7528\u5b8c\u4e86\uff0c\u6269\u5bb9 } else if ( queued_fds -> size == queued_fds -> offset ) { // \u6bcf\u6b21\u52a08\u4e2a queue_size = queued_fds -> size + 8 ; queued_fds = uv__realloc ( queued_fds , ( queue_size - 1 ) * sizeof ( * queued_fds -> fds ) + sizeof ( * queued_fds )); if ( queued_fds == NULL ) return UV_ENOMEM ; // \u66f4\u65b0\u5bb9\u91cf\u5927\u5c0f queued_fds -> size = queue_size ; // \u4fdd\u5b58\u65b0\u7684\u5185\u5b58 stream -> queued_fds = queued_fds ; } /* Put fd in a queue */ // \u4fdd\u5b58fd queued_fds -> fds [ queued_fds -> offset ++ ] = fd ; return 0 ; } \u5185\u5b58\u7ed3\u6784\u5982\u56fe5-3\u6240\u793a\u3002 \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u8bfb\u7ed3\u675f\u540e\u7684\u5904\u7406\uff0c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static void uv__stream_eof ( uv_stream_t * stream , const uv_buf_t * buf ) { // \u6253\u4e0a\u8bfb\u7ed3\u675f\u6807\u8bb0 stream -> flags |= UV_STREAM_READ_EOF ; // \u6ce8\u9500\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLIN ); // \u6ca1\u6709\u6ce8\u518c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\u5219\u505c\u6389handle\uff0c\u5426\u5219\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa if ( ! uv__io_active ( & stream -> io_watcher , POLLOUT )) uv__handle_stop ( stream ); uv__stream_osx_interrupt_select ( stream ); // \u6267\u884c\u8bfb\u56de\u8c03 stream -> read_cb ( stream , UV_EOF , buf ); // \u6e05\u9664\u6b63\u5728\u8bfb\u6807\u8bb0 stream -> flags &= ~ UV_STREAM_READING ; } \u6211\u4eec\u770b\u5230\uff0c\u6d41\u7ed3\u675f\u7684\u65f6\u5019\uff0c\u9996\u5148\u6ce8\u9500\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u7136\u540e\u901a\u8fc7\u56de\u8c03\u901a\u77e5\u4e0a\u5c42\u3002","title":"5.3 \u8bfb\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#54","text":"\u6211\u4eec\u5728\u6d41\u4e0a\u6267\u884cuv_write\u5c31\u53ef\u4ee5\u5f80\u6d41\u4e2d\u5199\u5165\u6570\u636e\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int uv_write ( /* \u4e00\u4e2a\u5199\u8bf7\u6c42\uff0c\u8bb0\u5f55\u4e86\u9700\u8981\u5199\u5165\u7684\u6570\u636e\u548c\u4fe1\u606f\u3002 \u6570\u636e\u6765\u81ea\u4e0b\u9762\u7684const uv_buf_t bufs[] */ uv_write_t * req , // \u5f80\u54ea\u4e2a\u6d41\u5199 uv_stream_t * handle , // \u9700\u8981\u5199\u5165\u7684\u6570\u636e const uv_buf_t bufs [], // uv_buf_t\u4e2a\u6570 unsigned int nbufs , // \u5199\u5b8c\u540e\u6267\u884c\u7684\u56de\u8c03 uv_write_cb cb ) { return uv_write2 ( req , handle , bufs , nbufs , NULL , cb ); } uv_write\u662f\u76f4\u63a5\u8c03\u7528uv_write2\u3002\u7b2c\u56db\u4e2a\u53c2\u6570\u662fNULL\u3002\u4ee3\u8868\u662f\u4e00\u822c\u7684\u5199\u6570\u636e\uff0c\u4e0d\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 int uv_write2 ( uv_write_t * req , uv_stream_t * stream , const uv_buf_t bufs [], unsigned int nbufs , uv_stream_t * send_handle , uv_write_cb cb ) { int empty_queue ; // \u5f85\u53d1\u9001\u961f\u5217\u662f\u5426\u4e3a\u7a7a empty_queue = ( stream -> write_queue_size == 0 ); // \u6784\u9020\u4e00\u4e2a\u5199\u8bf7\u6c42 uv__req_init ( stream -> loop , req , UV_WRITE ); // \u5199\u8bf7\u6c42\u5bf9\u5e94\u7684\u56de\u8c03 req -> cb = cb ; // \u5199\u8bf7\u6c42\u5bf9\u5e94\u7684\u6d41 req -> handle = stream ; req -> error = 0 ; // \u9700\u8981\u53d1\u9001\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u4e5f\u53ef\u4ee5\u662fNULL\u8bf4\u660e\u4e0d\u9700\u8981\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 req -> send_handle = send_handle ; QUEUE_INIT ( & req -> queue ); // bufs\u6307\u5411\u5f85\u5199\u7684\u6570\u636e req -> bufs = req -> bufsml ; // \u590d\u5236\u8c03\u7528\u65b9\u7684\u6570\u636e\u8fc7\u6765 memcpy ( req -> bufs , bufs , nbufs * sizeof ( bufs [ 0 ])); // buf\u4e2a\u6570 req -> nbufs = nbufs ; // \u5f53\u524d\u5199\u6210\u529f\u7684buf\u7d22\u5f15\uff0c\u9488\u5bf9bufs\u6570\u7ec4 req -> write_index = 0 ; // \u5f85\u5199\u7684\u6570\u636e\u5927\u5c0f = \u4e4b\u524d\u7684\u5927\u5c0f + \u672c\u6b21\u5927\u5c0f stream -> write_queue_size += uv__count_bufs ( bufs , nbufs ); // \u63d2\u5165\u5f85\u5199\u961f\u5217 QUEUE_INSERT_TAIL ( & stream -> write_queue , & req -> queue ); // \u975e\u7a7a\u8bf4\u660e\u6b63\u5728\u8fde\u63a5\uff0c\u8fd8\u4e0d\u80fd\u5199\uff0c\u6bd4\u5982TCP\u6d41 if ( stream -> connect_req ) { /* Still connecting, do nothing. */ } else if ( empty_queue ) { // \u5f53\u524d\u5f85\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u76f4\u63a5\u5199 uv__write ( stream ); } else { // \u8fd8\u6709\u6570\u636e\u6ca1\u6709\u5199\u5b8c\uff0c\u6ce8\u518c\u7b49\u5f85\u5199\u4e8b\u4ef6 uv__io_start ( stream -> loop , & stream -> io_watcher , POLLOUT ); uv__stream_osx_interrupt_select ( stream ); } return 0 ; } uv_write2\u7684\u4e3b\u8981\u903b\u8f91\u5c31\u662f\u5c01\u88c5\u4e00\u4e2a\u5199\u8bf7\u6c42\uff0c\u63d2\u5165\u5230\u6d41\u7684\u5f85\u5199\u961f\u5217\u3002\u7136\u540e\u6839\u636e\u5f53\u524d\u6d41\u7684\u60c5\u51b5\u3002\u770b\u662f\u76f4\u63a5\u5199\u5165\u8fd8\u662f\u7b49\u5f85\u4f1a\u518d\u5199\u5165\u3002\u5173\u7cfb\u56fe\u5927\u81f4\u5982\u56fe5-4\u6240\u793a\u3002 uv_write2\u53ea\u662f\u5bf9\u5199\u8bf7\u6c42\u8fdb\u884c\u4e00\u4e9b\u9884\u5904\u7406\uff0c\u771f\u6b63\u6267\u884c\u5199\u7684\u51fd\u6570\u662fuv__write 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 static void uv__write ( uv_stream_t * stream ) { struct iovec * iov ; QUEUE * q ; uv_write_t * req ; int iovmax ; int iovcnt ; ssize_t n ; int err ; start : // \u6ca1\u6709\u6570\u636e\u9700\u8981\u5199 if ( QUEUE_EMPTY ( & stream -> write_queue )) return ; q = QUEUE_HEAD ( & stream -> write_queue ); req = QUEUE_DATA ( q , uv_write_t , queue ); // \u4ece\u54ea\u91cc\u5f00\u59cb\u5199 iov = ( struct iovec * ) & ( req -> bufs [ req -> write_index ]); // \u8fd8\u6709\u591a\u5c11\u6ca1\u5199 iovcnt = req -> nbufs - req -> write_index ; // \u6700\u591a\u53ef\u4ee5\u5199\u591a\u5c11 iovmax = uv__getiovmax (); // \u53d6\u6700\u5c0f\u503c if ( iovcnt > iovmax ) iovcnt = iovmax ; // \u9700\u8981\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 if ( req -> send_handle ) { int fd_to_send ; struct msghdr msg ; struct cmsghdr * cmsg ; union { char data [ 64 ]; struct cmsghdr alias ; } scratch ; if ( uv__is_closing ( req -> send_handle )) { err = - EBADF ; goto error ; } // \u5f85\u53d1\u9001\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 fd_to_send = uv__handle_fd (( uv_handle_t * ) req -> send_handle ); memset ( & scratch , 0 , sizeof ( scratch )); msg . msg_name = NULL ; msg . msg_namelen = 0 ; msg . msg_iov = iov ; msg . msg_iovlen = iovcnt ; msg . msg_flags = 0 ; msg . msg_control = & scratch . alias ; msg . msg_controllen = CMSG_SPACE ( sizeof ( fd_to_send )); cmsg = CMSG_FIRSTHDR ( & msg ); cmsg -> cmsg_level = SOL_SOCKET ; cmsg -> cmsg_type = SCM_RIGHTS ; cmsg -> cmsg_len = CMSG_LEN ( sizeof ( fd_to_send )); { void * pv = CMSG_DATA ( cmsg ); int * pi = pv ; * pi = fd_to_send ; } do { // \u4f7f\u7528sendmsg\u51fd\u6570\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 n = sendmsg ( uv__stream_fd ( stream ), & msg , 0 ); } while ( n == -1 && errno == EINTR ); } else { do { // \u5199\u4e00\u4e2a\u6216\u8005\u5199\u6279\u91cf\u5199 if ( iovcnt == 1 ) { n = write ( uv__stream_fd ( stream ), iov [ 0 ]. iov_base , iov [ 0 ]. iov_len ); } else { n = writev ( uv__stream_fd ( stream ), iov , iovcnt ); } } while ( n == -1 && errno == EINTR ); } // \u5199\u5931\u8d25 if ( n < 0 ) { /* \u4e0d\u662f\u5199\u7e41\u5fd9\uff0c\u5219\u62a5\u9519\uff0c \u5426\u5219\u5982\u679c\u8bbe\u7f6e\u4e86\u540c\u6b65\u5199\u6807\u8bb0\uff0c\u5219\u7ee7\u7eed\u5c1d\u8bd5\u5199 */ if ( errno != EAGAIN && errno != EWOULDBLOCK && errno != ENOBUFS ) { err = - errno ; goto error ; } else if ( stream -> flags & UV_STREAM_BLOCKING ) { /* If this is a blocking stream, try again. */ goto start ; } } else { // \u5199\u6210\u529f while ( n >= 0 ) { // \u5f53\u524dbuf\u9996\u5730\u5740 uv_buf_t * buf = & ( req -> bufs [ req -> write_index ]); // \u5f53\u524dbuf\u7684\u6570\u636e\u957f\u5ea6 size_t len = buf -> len ; // \u5c0f\u4e8e\u8bf4\u660e\u5f53\u524dbuf\u8fd8\u6ca1\u6709\u5199\u5b8c\uff08\u8fd8\u6ca1\u6709\u88ab\u6d88\u8d39\u5b8c\uff09 if (( size_t ) n < len ) { // \u66f4\u65b0\u5f85\u5199\u7684\u9996\u5730\u5740 buf -> base += n ; // \u66f4\u65b0\u5f85\u5199\u7684\u6570\u636e\u957f\u5ea6 buf -> len -= n ; /* \u66f4\u65b0\u5f85\u5199\u961f\u5217\u7684\u957f\u5ea6\uff0c\u8fd9\u4e2a\u961f\u5217\u662f\u5f85\u5199\u6570\u636e\u7684 \u603b\u957f\u5ea6\uff0c\u7b49\u4e8e\u591a\u4e2abuf\u7684\u548c */ stream -> write_queue_size -= n ; n = 0 ; /* \u8fd8\u6ca1\u5199\u5b8c\uff0c\u8bbe\u7f6e\u4e86\u540c\u6b65\u5199\uff0c\u5219\u7ee7\u7eed\u5c1d\u8bd5\u5199\uff0c \u5426\u5219\u9000\u51fa\uff0c\u6ce8\u518c\u5f85\u5199\u4e8b\u4ef6 */ if ( stream -> flags & UV_STREAM_BLOCKING ) { goto start ; } else { break ; } } else { /* \u5f53\u524dbuf\u7684\u6570\u636e\u90fd\u5199\u5b8c\u4e86\uff0c\u5219\u66f4\u65b0\u5f85\u5199\u6570\u636e\u7684\u7684\u9996 \u5730\u5740\uff0c\u5373\u4e0b\u4e00\u4e2abuf\uff0c\u56e0\u4e3a\u5f53\u524dbuf\u5199\u5b8c\u4e86 */ req -> write_index ++ ; // \u66f4\u65b0n\uff0c\u7528\u4e8e\u4e0b\u4e00\u4e2a\u5faa\u73af\u7684\u8ba1\u7b97 n -= len ; // \u66f4\u65b0\u5f85\u5199\u961f\u5217\u7684\u957f\u5ea6 stream -> write_queue_size -= len ; /* \u7b49\u4e8e\u6700\u540e\u4e00\u4e2abuf\u4e86\uff0c\u8bf4\u660e\u5f85\u5199\u961f\u5217\u7684\u6570\u636e \u90fd\u5199\u5b8c\u4e86 */ if ( req -> write_index == req -> nbufs ) { /* \u91ca\u653ebuf\u5bf9\u5e94\u7684\u5185\u5b58\uff0c\u5e76\u628a\u8bf7\u6c42\u63d2\u5165\u5199\u5b8c\u6210 \u961f\u5217\uff0c\u7136\u540e\u51c6\u5907\u89e6\u53d1\u5199\u5b8c\u6210\u56de\u8c03 */ uv__write_req_finish ( req ); return ; } } } } /* \u5199\u6210\u529f\uff0c\u4f46\u662f\u8fd8\u6ca1\u6709\u5199\u5b8c\uff0c\u6ce8\u518c\u5f85\u5199\u4e8b\u4ef6\uff0c \u7b49\u5f85\u53ef\u5199\u7684\u65f6\u5019\u7ee7\u7eed\u5199 */ uv__io_start ( stream -> loop , & stream -> io_watcher , POLLOUT ); uv__stream_osx_interrupt_select ( stream ); return ; // \u5199\u51fa\u9519 error : // \u8bb0\u5f55\u9519\u8bef req -> error = err ; /* \u91ca\u653e\u5185\u5b58\uff0c\u4e22\u5f03\u6570\u636e\uff0c\u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217\uff0c \u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0c\u7b49\u5f85pending\u9636\u6bb5\u6267\u884c\u56de\u8c03 */ uv__write_req_finish ( req ); // \u6ce8\u9500\u5f85\u5199\u4e8b\u4ef6 uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLOUT ); // \u5982\u679c\u4e5f\u6ca1\u6709\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u5219\u628ahandle\u5173\u95ed if ( ! uv__io_active ( & stream -> io_watcher , POLLIN )) uv__handle_stop ( stream ); uv__stream_osx_interrupt_select ( stream ); } \u6211\u4eec\u770b\u4e00\u4e0b\u4e00\u4e2a\u5199\u8bf7\u6c42\u7ed3\u675f\u540e\uff08\u6210\u529f\u6216\u8005\u5931\u8d25\uff09\uff0cLibuv\u5982\u4f55\u5904\u7406\u7684\u3002\u903b\u8f91\u5728uv__write_req_finish\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static void uv__write_req_finish ( uv_write_t * req ) { uv_stream_t * stream = req -> handle ; // \u4ece\u5f85\u5199\u961f\u5217\u4e2d\u79fb\u9664 QUEUE_REMOVE ( & req -> queue ); // \u5199\u6210\u529f\uff0c\u5e76\u4e14\u5206\u914d\u4e86\u989d\u5916\u7684\u5806\u5185\u5b58\uff0c\u5219\u9700\u8981\u91ca\u653e\uff0c\u89c1uv__write if ( req -> error == 0 ) { if ( req -> bufs != req -> bufsml ) uv__free ( req -> bufs ); req -> bufs = NULL ; } // \u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217 QUEUE_INSERT_TAIL ( & stream -> write_completed_queue , & req -> queue ); /* \u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0cLibuv\u5728\u5904\u7406pending\u9636\u6bb5\u65f6, \u4f1a\u89e6\u53d1IO\u89c2\u5bdf\u8005\u7684\u5199\u4e8b\u4ef6 */ uv__io_feed ( stream -> loop , & stream -> io_watcher ); } uv__write_req_finish\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355 1\u628a\u8282\u70b9\u4ece\u5f85\u5199\u961f\u5217\u4e2d\u79fb\u9664 2 req->bufs != req->bufsml\u4e0d\u76f8\u7b49\u8bf4\u660e\u5206\u914d\u4e86\u5806\u5185\u5b58\uff0c\u9700\u8981\u81ea\u5df1\u91ca\u653e 3\u5e76\u628a\u8bf7\u6c42\u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217\uff0c\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0c\u7b49\u5f85pending\u9636\u6bb5\u6267\u884c\u56de\u8c03\uff0c\u5728pending\u8282\u70b9\u4f1a\u6267\u884cIO\u89c2\u5bdf\u8005\u7684\u56de\u8c03\uff08uv__stream_io\uff09\u3002 \u6211\u4eec\u770b\u4e00\u4e0buv__stream_io\u5982\u4f55\u5904\u7406\u7684\uff0c\u4e0b\u9762\u662f\u5177\u4f53\u7684\u5904\u7406\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 // \u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1 if ( events & ( POLLOUT | POLLERR | POLLHUP )) { // \u7ee7\u7eed\u6267\u884c\u5199 uv__write ( stream ); // \u5904\u7406\u5199\u6210\u529f\u56de\u8c03 uv__write_callbacks ( stream ); // \u5f85\u5199\u961f\u5217\u7a7a\uff0c\u6ce8\u9500\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u5373\u4e0d\u9700\u8981\u5199\u4e86 if ( QUEUE_EMPTY ( & stream -> write_queue )) uv__drain ( stream ); } \u6211\u4eec\u53ea\u5173\u6ce8uv__write_callbacks\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 static void uv__write_callbacks ( uv_stream_t * stream ) { uv_write_t * req ; QUEUE * q ; // \u5199\u5b8c\u6210\u961f\u5217\u975e\u7a7a while ( ! QUEUE_EMPTY ( & stream -> write_completed_queue )) { q = QUEUE_HEAD ( & stream -> write_completed_queue ); req = QUEUE_DATA ( q , uv_write_t , queue ); QUEUE_REMOVE ( q ); uv__req_unregister ( stream -> loop , req ); // bufs\u7684\u5185\u5b58\u8fd8\u6ca1\u6709\u88ab\u91ca\u653e if ( req -> bufs != NULL ) { // \u66f4\u65b0\u5f85\u5199\u961f\u5217\u7684\u5927\u5c0f\uff0c\u5373\u51cf\u53bbreq\u5bf9\u5e94\u7684\u6240\u6709\u6570\u636e\u7684\u5927\u5c0f stream -> write_queue_size -= uv__write_req_size ( req ); /* bufs\u9ed8\u8ba4\u6307\u5411bufsml\uff0c\u8d85\u8fc7\u9ed8\u8ba4\u5927\u5c0f\u65f6\uff0c bufs\u6307\u5411\u65b0\u7533\u8bf7\u7684\u5806\u5185\u5b58\uff0c\u6240\u4ee5\u9700\u8981\u91ca\u653e */ if ( req -> bufs != req -> bufsml ) uv__free ( req -> bufs ); req -> bufs = NULL ; } // \u6267\u884c\u56de\u8c03 if ( req -> cb ) req -> cb ( req , req -> error ); } } uv__write_callbacks\u8d1f\u8d23\u66f4\u65b0\u6d41\u7684\u5f85\u5199\u961f\u5217\u5927\u5c0f\u3001\u91ca\u653e\u989d\u5916\u7533\u8bf7\u7684\u5806\u5185\u5b58\u3001\u6267\u884c\u6bcf\u4e2a\u5199\u8bf7\u6c42\u7684\u56de\u8c03\u3002","title":"5.4 \u5199\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#55","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // \u5173\u95ed\u6d41\u7684\u5199\u7aef int uv_shutdown ( uv_shutdown_t * req , uv_stream_t * stream , uv_shutdown_cb cb ) { // \u521d\u59cb\u5316\u4e00\u4e2a\u5173\u95ed\u8bf7\u6c42\uff0c\u5173\u8054\u7684handle\u662fstream uv__req_init ( stream -> loop , req , UV_SHUTDOWN ); req -> handle = stream ; // \u5173\u95ed\u540e\u6267\u884c\u7684\u56de\u8c03 req -> cb = cb ; stream -> shutdown_req = req ; // \u8bbe\u7f6e\u6b63\u5728\u5173\u95ed\u7684\u6807\u8bb0 stream -> flags |= UV_HANDLE_SHUTTING ; // \u6ce8\u518c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6 uv__io_start ( stream -> loop , & stream -> io_watcher , POLLOUT ); return 0 ; } \u5173\u95ed\u6d41\u7684\u5199\u7aef\u5c31\u662f\u76f8\u5f53\u4e8e\u7ed9\u6d41\u53d1\u9001\u4e00\u4e2a\u5173\u95ed\u8bf7\u6c42\uff0c\u628a\u8bf7\u6c42\u6302\u8f7d\u5230\u6d41\u4e2d\uff0c\u7136\u540e\u6ce8\u518c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u5728\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\u5c31\u4f1a\u6267\u884c\u5173\u95ed\u64cd\u4f5c\u3002\u5728\u5206\u6790\u5199\u6d41\u7684\u7ae0\u8282\u4e2d\u6211\u4eec\u63d0\u5230\uff0c\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884cuv__drain\u6ce8\u9500\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u9664\u6b64\u4e4b\u5916\uff0cuv__drain\u8fd8\u505a\u4e86\u4e00\u4e2a\u4e8b\u60c5\uff0c\u5c31\u662f\u5173\u95ed\u6d41\u7684\u5199\u7aef\u3002\u6211\u4eec\u770b\u770b\u5177\u4f53\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 static void uv__drain ( uv_stream_t * stream ) { uv_shutdown_t * req ; int err ; // \u64a4\u9500\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u56e0\u4e3a\u6ca1\u6709\u6570\u636e\u9700\u8981\u5199\u5165\u4e86 uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLOUT ); uv__stream_osx_interrupt_select ( stream ); // \u8bbe\u7f6e\u4e86\u5173\u95ed\u5199\u7aef\uff0c\u4f46\u662f\u8fd8\u6ca1\u6709\u5173\u95ed\uff0c\u5219\u6267\u884c\u5173\u95ed\u5199\u7aef if (( stream -> flags & UV_HANDLE_SHUTTING ) && ! ( stream -> flags & UV_HANDLE_CLOSING ) && ! ( stream -> flags & UV_HANDLE_SHUT )) { req = stream -> shutdown_req ; stream -> shutdown_req = NULL ; // \u6e05\u9664\u6807\u8bb0 stream -> flags &= ~ UV_HANDLE_SHUTTING ; uv__req_unregister ( stream -> loop , req ); err = 0 ; // \u5173\u95ed\u5199\u7aef if ( shutdown ( uv__stream_fd ( stream ), SHUT_WR )) err = UV__ERR ( errno ); // \u6807\u8bb0\u5df2\u5173\u95ed\u5199\u7aef if ( err == 0 ) stream -> flags |= UV_HANDLE_SHUT ; // \u6267\u884c\u56de\u8c03 if ( req -> cb != NULL ) req -> cb ( req , err ); } } \u901a\u8fc7\u8c03\u7528shutdown\u5173\u95ed\u6d41\u7684\u5199\u7aef\uff0c\u6bd4\u5982TCP\u6d41\u53d1\u9001\u5b8c\u6570\u636e\u540e\u53ef\u4ee5\u5173\u95ed\u5199\u7aef\u3002\u4f46\u662f\u4ecd\u7136\u53ef\u4ee5\u8bfb\u3002","title":"5.5 \u5173\u95ed\u6d41\u7684\u5199\u7aef"},{"location":"chapter05-Libuv%E6%B5%81/#56","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void uv__stream_close ( uv_stream_t * handle ) { unsigned int i ; uv__stream_queued_fds_t * queued_fds ; // \u4ece\u4e8b\u4ef6\u5faa\u73af\u4e2d\u5220\u9664IO\u89c2\u5bdf\u8005\uff0c\u79fb\u51fapending\u961f\u5217 uv__io_close ( handle -> loop , & handle -> io_watcher ); // \u505c\u6b62\u8bfb uv_read_stop ( handle ); // \u505c\u6389handle uv__handle_stop ( handle ); // \u4e0d\u53ef\u8bfb\u3001\u5199 handle -> flags &= ~ ( UV_HANDLE_READABLE | UV_HANDLE_WRITABLE ); // \u5173\u95ed\u975e\u6807\u51c6\u6d41\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 if ( handle -> io_watcher . fd != -1 ) { /* Don't close stdio file descriptors. Nothing good comes from it. */ if ( handle -> io_watcher . fd > STDERR_FILENO ) uv__close ( handle -> io_watcher . fd ); handle -> io_watcher . fd = -1 ; } // \u5173\u95ed\u901a\u4fe1socket\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 if ( handle -> accepted_fd != -1 ) { uv__close ( handle -> accepted_fd ); handle -> accepted_fd = -1 ; } // \u540c\u4e0a\uff0c\u8fd9\u662f\u5728\u6392\u961f\u7b49\u5f85\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 if ( handle -> queued_fds != NULL ) { queued_fds = handle -> queued_fds ; for ( i = 0 ; i < queued_fds -> offset ; i ++ ) uv__close ( queued_fds -> fds [ i ]); uv__free ( handle -> queued_fds ); handle -> queued_fds = NULL ; } } \u5173\u95ed\u6d41\u5c31\u662f\u628a\u6d41\u6ce8\u518c\u5728epoll\u7684\u4e8b\u4ef6\u6ce8\u9500\uff0c\u5173\u95ed\u6240\u6301\u6709\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002","title":"5.6 \u5173\u95ed\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#57","text":"\u8fde\u63a5\u6d41\u662f\u9488\u5bf9TCP\u548cUnix\u57df\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u9996\u5148\u4ecb\u7ecd\u4e00\u4e0b\u4e00\u4e9b\u7f51\u7edc\u7f16\u7a0b\u76f8\u5173\u7684\u5185\u5bb9\uff0c\u9996\u5148\u6211\u4eec\u5148\u8981\u6709\u4e00\u4e2asocket\u3002\u6211\u4eec\u770bLibuv\u4e2d\u5982\u4f55\u65b0\u5efa\u4e00\u4e2asocket\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int uv__socket ( int domain , int type , int protocol ) { int sockfd ; int err ; // \u65b0\u5efa\u4e00\u4e2asocket\uff0c\u5e76\u8bbe\u7f6e\u975e\u963b\u585e\u548cLOEXEC\u6807\u8bb0 sockfd = socket ( domain , type | SOCK_NONBLOCK | SOCK_CLOEXEC , protocol ); // \u4e0d\u89e6\u53d1SIGPIPE\u4fe1\u53f7\uff0c\u6bd4\u5982\u5bf9\u7aef\u5df2\u7ecf\u5173\u95ed\uff0c\u672c\u7aef\u53c8\u6267\u884c\u5199 #if defined(SO_NOSIGPIPE) { int on = 1 ; setsockopt ( sockfd , SOL_SOCKET , SO_NOSIGPIPE , & on , sizeof ( on )); } #endif return sockfd ; } \u5728Libuv\u4e2d\uff0csocket\u7684\u6a21\u5f0f\u90fd\u662f\u975e\u963b\u585e\u7684\uff0cuv__socket\u662fLibuv\u4e2d\u7533\u8bf7socket\u7684\u51fd\u6570\uff0c\u4e0d\u8fc7Libuv\u4e0d\u76f4\u63a5\u8c03\u7528\u8be5\u51fd\u6570\uff0c\u800c\u662f\u5c01\u88c5\u4e86\u4e00\u4e0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /* 1 \u83b7\u53d6\u4e00\u4e2a\u65b0\u7684socket fd 2 \u628afd\u4fdd\u5b58\u5230handle\u91cc\uff0c\u5e76\u6839\u636eflag\u8fdb\u884c\u76f8\u5173\u8bbe\u7f6e 3 \u7ed1\u5b9a\u5230\u672c\u673a\u968f\u610f\u7684\u5730\u5740\uff08\u5982\u679c\u8bbe\u7f6e\u4e86\u8be5\u6807\u8bb0\u7684\u8bdd\uff09 */ static int new_socket ( uv_tcp_t * handle , int domain , unsigned long flags ) { struct sockaddr_storage saddr ; socklen_t slen ; int sockfd ; // \u83b7\u53d6\u4e00\u4e2asocket sockfd = uv__socket ( domain , SOCK_STREAM , 0 ); // \u8bbe\u7f6e\u9009\u9879\u548c\u4fdd\u5b58socket\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5230IO\u89c2\u5bdf\u8005\u4e2d uv__stream_open (( uv_stream_t * ) handle , sockfd , flags ); // \u8bbe\u7f6e\u4e86\u9700\u8981\u7ed1\u5b9a\u6807\u8bb0UV_HANDLE_BOUND if ( flags & UV_HANDLE_BOUND ) { slen = sizeof ( saddr ); memset ( & saddr , 0 , sizeof ( saddr )); // \u83b7\u53d6fd\u5bf9\u5e94\u7684socket\u4fe1\u606f\uff0c\u6bd4\u5982IP\uff0c\u7aef\u53e3\uff0c\u53ef\u80fd\u6ca1\u6709 getsockname ( uv__stream_fd ( handle ), ( struct sockaddr * ) & saddr , & slen ); // \u7ed1\u5b9a\u5230socket\u4e2d\uff0c\u5982\u679c\u6ca1\u6709\u5219\u7ed1\u5b9a\u5230\u7cfb\u7edf\u968f\u673a\u9009\u62e9\u7684\u5730\u5740 bind ( uv__stream_fd ( handle ),( struct sockaddr * ) & saddr , slen ); } return 0 ; } \u4e0a\u9762\u7684\u4ee3\u7801\u5c31\u662f\u5728Libuv\u7533\u8bf7\u4e00\u4e2asocket\u7684\u903b\u8f91\uff0c\u53e6\u5916\u5b83\u8fd8\u652f\u6301\u65b0\u5efa\u7684socket\uff0c\u53ef\u4ee5\u7ed1\u5b9a\u5230\u4e00\u4e2a\u7528\u6237\u8bbe\u7f6e\u7684\uff0c\u6216\u8005\u64cd\u4f5c\u7cfb\u7edf\u968f\u673a\u9009\u62e9\u7684\u5730\u5740\u3002\u4e0d\u8fc7Libuv\u5e76\u4e0d\u76f4\u63a5\u4f7f\u7528\u8fd9\u4e2a\u51fd\u6570\u3002\u800c\u662f\u53c8\u5c01\u88c5\u4e86\u4e00\u5c42\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // \u5982\u679c\u6d41\u8fd8\u6ca1\u6709\u5bf9\u5e94\u7684fd\uff0c\u5219\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684\uff0c\u5982\u679c\u6709\u5219\u4fee\u6539\u6d41\u7684\u914d\u7f6e static int maybe_new_socket ( uv_tcp_t * handle , int domain , unsigned long flags ) { struct sockaddr_storage saddr ; socklen_t slen ; // \u5df2\u7ecf\u6709fd\u4e86 if ( uv__stream_fd ( handle ) != -1 ) { // \u8be5\u6d41\u9700\u8981\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740 if ( flags & UV_HANDLE_BOUND ) { /* \u6d41\u662f\u5426\u5df2\u7ecf\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740\u4e86\u3002handle\u7684flag\u662f\u5728 new_socket\u91cc\u8bbe\u7f6e\u7684\uff0c\u5982\u679c\u6709\u8fd9\u4e2a\u6807\u8bb0\u8bf4\u660e\u5df2\u7ecf\u6267\u884c\u8fc7\u7ed1\u5b9a\u4e86\uff0c \u76f4\u63a5\u66f4\u65b0flags\u5c31\u884c\u3002 */ if ( handle -> flags & UV_HANDLE_BOUND ) { handle -> flags |= flags ; return 0 ; } // \u6709fd\uff0c\u4f46\u662f\u53ef\u80fd\u8fd8\u6ca1\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740 slen = sizeof ( saddr ); memset ( & saddr , 0 , sizeof ( saddr )); // \u83b7\u53d6socket\u7ed1\u5b9a\u5230\u7684\u5730\u5740 if ( getsockname ( uv__stream_fd ( handle ), ( struct sockaddr * ) & saddr , & slen )) return UV__ERR ( errno ); // \u7ed1\u5b9a\u8fc7\u4e86socket\u5730\u5740\uff0c\u5219\u66f4\u65b0flags\u5c31\u884c if (( saddr . ss_family == AF_INET6 && (( struct sockaddr_in6 * ) & saddr ) -> sin6_port != 0 ) || ( saddr . ss_family == AF_INET && (( struct sockaddr_in * ) & saddr ) -> sin_port != 0 )) { handle -> flags |= flags ; return 0 ; } // \u6ca1\u7ed1\u5b9a\u5219\u7ed1\u5b9a\u5230\u968f\u673a\u5730\u5740\uff0cbind\u4e2d\u5b9e\u73b0 if ( bind ( uv__stream_fd ( handle ), ( struct sockaddr * ) & saddr , slen )) return UV__ERR ( errno ); } handle -> flags |= flags ; return 0 ; } // \u7533\u8bf7\u4e00\u4e2a\u65b0\u7684fd\u5173\u8054\u5230\u6d41 return new_socket ( handle , domain , flags ); } maybe_new_socket\u51fd\u6570\u7684\u903b\u8f91\u5206\u652f\u5f88\u591a\uff0c\u4e3b\u8981\u5982\u4e0b 1 \u5982\u679c\u6d41\u8fd8\u6ca1\u6709\u5173\u8054\u5230fd\uff0c\u5219\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684fd\u5173\u8054\u5230\u6d41\u4e0a 2 \u5982\u679c\u6d41\u5df2\u7ecf\u5173\u8054\u4e86\u4e00\u4e2afd\u3002 \u5982\u679c\u6d41\u8bbe\u7f6e\u4e86\u7ed1\u5b9a\u5730\u5740\u7684\u6807\u8bb0\uff0c\u4f46\u662f\u5df2\u7ecf\u901a\u8fc7Libuv\u7ed1\u5b9a\u4e86\u4e00\u4e2a\u5730\u5740\uff08Libuv\u4f1a\u8bbe\u7f6eUV_HANDLE_BOUND\u6807\u8bb0\uff0c\u7528\u6237\u4e5f\u53ef\u80fd\u662f\u76f4\u63a5\u8c03bind\u51fd\u6570\u7ed1\u5b9a\u4e86\uff09\u3002\u5219\u4e0d\u9700\u8981\u518d\u6b21\u7ed1\u5b9a\uff0c\u66f4\u65b0flags\u5c31\u884c\u3002 \u5982\u679c\u6d41\u8bbe\u7f6e\u4e86\u7ed1\u5b9a\u5730\u5740\u7684\u6807\u8bb0\uff0c\u4f46\u662f\u8fd8\u6ca1\u6709\u901a\u8fc7Libuv\u7ed1\u5b9a\u4e00\u4e2a\u5730\u5740\uff0c\u8fd9\u65f6\u5019\u901a\u8fc7getsocketname\u5224\u65ad\u7528\u6237\u662f\u5426\u81ea\u5df1\u901a\u8fc7bind\u51fd\u6570\u7ed1\u5b9a\u4e86\u4e00\u4e2a\u5730\u5740\uff0c\u662f\u7684\u8bdd\u5219\u4e0d\u9700\u8981\u518d\u6b21\u6267\u884c\u7ed1\u5b9a\u64cd\u4f5c\u3002\u5426\u5219\u968f\u673a\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740\u3002 \u4ee5\u4e0a\u4e24\u4e2a\u51fd\u6570\u7684\u903b\u8f91\u4e3b\u8981\u662f\u7533\u8bf7\u4e00\u4e2asocket\u548c\u7ed9socket\u7ed1\u5b9a\u4e00\u4e2a\u5730\u5740\u3002\u4e0b\u9762\u6211\u4eec\u5f00\u770b\u4e00\u4e0b\u8fde\u63a5\u6d41\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 int uv__tcp_connect ( uv_connect_t * req , uv_tcp_t * handle , const struct sockaddr * addr , unsigned int addrlen , uv_connect_cb cb ) { int err ; int r ; // \u5df2\u7ecf\u53d1\u8d77\u4e86connect\u4e86 if ( handle -> connect_req != NULL ) return UV_EALREADY ; // \u7533\u8bf7\u4e00\u4e2asocket\u548c\u7ed1\u5b9a\u4e00\u4e2a\u5730\u5740\uff0c\u5982\u679c\u8fd8\u6ca1\u6709\u7684\u8bdd err = maybe_new_socket ( handle , addr -> sa_family , UV_HANDLE_READABLE | UV_HANDLE_WRITABLE if ( err ) return err ; handle -> delayed_error = 0 ; do { // \u6e05\u9664\u5168\u5c40\u9519\u8bef\u53d8\u91cf\u7684\u503c errno = 0 ; // \u975e\u963b\u585e\u53d1\u8d77\u4e09\u6b21\u63e1\u624b r = connect ( uv__stream_fd ( handle ), addr , addrlen ); } while ( r == -1 && errno == EINTR ); if ( r == -1 && errno != 0 ) { // \u4e09\u6b21\u63e1\u624b\u8fd8\u6ca1\u6709\u5b8c\u6210 if ( errno == EINPROGRESS ) ; /* not an error */ else if ( errno == ECONNREFUSED ) // \u5bf9\u65b9\u62d2\u7edd\u5efa\u7acb\u8fde\u63a5\uff0c\u5ef6\u8fdf\u62a5\u9519 handle -> delayed_error = UV__ERR ( errno ); else // \u76f4\u63a5\u62a5\u9519 return UV__ERR ( errno ); } // \u521d\u59cb\u5316\u4e00\u4e2a\u8fde\u63a5\u578brequest\uff0c\u5e76\u8bbe\u7f6e\u67d0\u4e9b\u5b57\u6bb5 uv__req_init ( handle -> loop , req , UV_CONNECT ); req -> cb = cb ; req -> handle = ( uv_stream_t * ) handle ; QUEUE_INIT ( & req -> queue ); // \u8fde\u63a5\u8bf7\u6c42 handle -> connect_req = req ; // \u6ce8\u518c\u5230Libuv\u89c2\u5bdf\u8005\u961f\u5217 uv__io_start ( handle -> loop , & handle -> io_watcher , POLLOUT ); // \u8fde\u63a5\u51fa\u9519\uff0c\u63d2\u5165pending\u961f\u5c3e if ( handle -> delayed_error ) uv__io_feed ( handle -> loop , & handle -> io_watcher ); return 0 ; } \u8fde\u63a5\u6d41\u7684\u903b\u8f91\uff0c\u5927\u81f4\u5982\u4e0b 1 \u7533\u8bf7\u4e00\u4e2asocket\uff0c\u7ed1\u5b9a\u4e00\u4e2a\u5730\u5740\u3002 2 \u6839\u636e\u7ed9\u5b9a\u7684\u670d\u52a1\u5668\u5730\u5740\uff0c\u53d1\u8d77\u4e09\u6b21\u63e1\u624b\uff0c\u975e\u963b\u585e\u7684\uff0c\u4f1a\u76f4\u63a5\u8fd4\u56de\u7ee7\u7eed\u6267\u884c\uff0c\u4e0d\u4f1a\u7b49\u5230\u4e09\u6b21\u63e1\u624b\u5b8c\u6210\u3002 3 \u5f80\u6d41\u4e0a\u6302\u8f7d\u4e00\u4e2aconnect\u578b\u7684\u8bf7\u6c42\u3002 4 \u8bbe\u7f6eIO\u89c2\u5bdf\u8005\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u4e3a\u53ef\u5199\u3002\u7136\u540e\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165\u4e8b\u4ef6\u5faa\u73af\u7684IO\u89c2\u5bdf\u8005\u961f\u5217\u3002\u7b49\u5f85\u53ef\u5199\u7684\u65f6\u5019\u65f6\u5019\uff08\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\uff09\uff0c\u5c31\u4f1a\u6267\u884ccb\u56de\u8c03\u3002 \u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u4f1a\u6267\u884cuv__stream_io\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u903b\u8f91\u3002 1 2 3 4 if ( stream -> connect_req ) { uv__stream_connect ( stream ); return ; } \u6211\u4eec\u7ee7\u7eed\u770buv__stream_connect\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 static void uv__stream_connect ( uv_stream_t * stream ) { int error ; uv_connect_t * req = stream -> connect_req ; socklen_t errorsize = sizeof ( int ); // \u8fde\u63a5\u51fa\u9519 if ( stream -> delayed_error ) { error = stream -> delayed_error ; stream -> delayed_error = 0 ; } else { // \u8fd8\u662f\u9700\u8981\u5224\u65ad\u4e00\u4e0b\u662f\u4e0d\u662f\u51fa\u9519\u4e86 getsockopt ( uv__stream_fd ( stream ), SOL_SOCKET , SO_ERROR , & error , & errorsize ); error = UV__ERR ( error ); } // \u8fd8\u6ca1\u8fde\u63a5\u6210\u529f\uff0c\u5148\u8fd4\u56de\uff0c\u7b49\u5f85\u4e0b\u6b21\u53ef\u5199\u4e8b\u4ef6\u7684\u89e6\u53d1 if ( error == UV__ERR ( EINPROGRESS )) return ; // \u6e05\u7a7a stream -> connect_req = NULL ; uv__req_unregister ( stream -> loop , req ); /* \u8fde\u63a5\u51fa\u9519\u5219\u6ce8\u9500\u4e4b\u524d\u6ce8\u518c\u7684\u7b49\u5f85\u53ef\u5199\u961f\u5217\uff0c \u8fde\u63a5\u6210\u529f\u5982\u679c\u5f85\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u4e5f\u6ce8\u9500\u4e8b\u4ef6\uff0c\u6709\u6570\u636e\u9700\u8981\u5199\u7684\u65f6\u5019\u518d\u6ce8\u518c */ if ( error < 0 || QUEUE_EMPTY ( & stream -> write_queue )) { uv__io_stop ( stream -> loop , & stream -> io_watcher , POLLOUT ); } // \u6267\u884c\u56de\u8c03\uff0c\u901a\u77e5\u4e0a\u5c42\u8fde\u63a5\u7ed3\u679c if ( req -> cb ) req -> cb ( req , error ); if ( uv__stream_fd ( stream ) == -1 ) return ; // \u8fde\u63a5\u5931\u8d25\uff0c\u6e05\u7a7a\u5f85\u5199\u7684\u6570\u636e\u548c\u6267\u884c\u5199\u8bf7\u6c42\u7684\u56de\u8c03\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09 if ( error < 0 ) { uv__stream_flush_write_queue ( stream , UV_ECANCELED ); uv__write_callbacks ( stream ); } } \u8fde\u63a5\u6d41\u7684\u903b\u8f91\u662f 1\u53d1\u8d77\u975e\u963b\u585e\u5f0f\u8fde\u63a5 2 \u6ce8\u518c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6 3 \u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u628a\u8fde\u63a5\u7ed3\u679c\u544a\u8bc9\u8c03\u7528\u65b9 4 \u8fde\u63a5\u6210\u529f\u5219\u53d1\u9001\u5199\u961f\u5217\u7684\u6570\u636e\uff0c\u8fde\u63a5\u5931\u8d25\u5219\u6e05\u9664\u5199\u961f\u5217\u7684\u6570\u636e\u5e76\u6267\u884c\u6bcf\u4e2a\u5199\u8bf7\u6c42\u7684\u56de\u8c03\uff08\u6709\u7684\u8bdd\uff09\u3002","title":"5.7 \u8fde\u63a5\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#58","text":"\u76d1\u542c\u6d41\u662f\u9488\u5bf9TCP\u6216Unix\u57df\u7684\uff0c\u4e3b\u8981\u662f\u628a\u4e00\u4e2asocket\u53d8\u6210listen\u72b6\u6001\u3002\u5e76\u4e14\u8bbe\u7f6e\u4e00\u4e9b\u5c5e\u6027\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 int uv_tcp_listen ( uv_tcp_t * tcp , int backlog , uv_connection_cb cb ) { static int single_accept = -1 ; unsigned long flags ; int err ; if ( tcp -> delayed_error ) return tcp -> delayed_error ; // \u662f\u5426\u8bbe\u7f6e\u4e86\u4e0d\u8fde\u7eedaccept\u3002\u9ed8\u8ba4\u662f\u8fde\u7eedaccept\u3002 if ( single_accept == -1 ) { const char * val = getenv ( \"UV_TCP_SINGLE_ACCEPT\" ); single_accept = ( val != NULL && atoi ( val ) != 0 ); } // \u8bbe\u7f6e\u4e0d\u8fde\u7eedaccept if ( single_accept ) tcp -> flags |= UV_HANDLE_TCP_SINGLE_ACCEPT ; flags = 0 ; /* \u53ef\u80fd\u8fd8\u6ca1\u6709\u7528\u4e8elisten\u7684fd\uff0csocket\u5730\u5740\u7b49\u3002 \u8fd9\u91cc\u7533\u8bf7\u4e00\u4e2asocket\u548c\u7ed1\u5b9a\u5230\u4e00\u4e2a\u5730\u5740 \uff08\u5982\u679c\u8c03listen\u4e4b\u524d\u6ca1\u6709\u8c03bind\u5219\u7ed1\u5b9a\u5230\u968f\u673a\u5730\u5740\uff09 */ err = maybe_new_socket ( tcp , AF_INET , flags ); if ( err ) return err ; // \u8bbe\u7f6efd\u4e3alisten\u72b6\u6001 if ( listen ( tcp -> io_watcher . fd , backlog )) return UV__ERR ( errno ); // \u5efa\u7acb\u8fde\u63a5\u540e\u7684\u4e1a\u52a1\u56de\u8c03 tcp -> connection_cb = cb ; tcp -> flags |= UV_HANDLE_BOUND ; // \u8bbe\u7f6eio\u89c2\u5bdf\u8005\u7684\u56de\u8c03\uff0c\u7531epoll\u76d1\u542c\u5230\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c tcp -> io_watcher . cb = uv__server_io ; /* \u63d2\u5165\u89c2\u5bdf\u8005\u961f\u5217\uff0c\u8fd9\u65f6\u5019\u8fd8\u6ca1\u6709\u589e\u52a0\u5230epoll\uff0c Poll IO\u9636\u6bb5\u518d\u904d\u5386\u89c2\u5bdf\u8005\u961f\u5217\u8fdb\u884c\u5904\u7406\uff08epoll_ctl\uff09 */ uv__io_start ( tcp -> loop , & tcp -> io_watcher , POLLIN ); return 0 ; } \u76d1\u542c\u6d41\u7684\u903b\u8f91\u770b\u8d77\u6765\u5f88\u591a\uff0c\u4f46\u662f\u4e3b\u8981\u7684\u903b\u8f91\u662f\u628a\u6d41\u5bf9\u7684fd\u6539\u6210listen\u72b6\u6001\uff0c\u8fd9\u6837\u6d41\u5c31\u53ef\u4ee5\u63a5\u6536\u8fde\u63a5\u8bf7\u6c42\u4e86\u3002\u63a5\u7740\u8bbe\u7f6e\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c\u7684\u56de\u8c03\u3002\u6700\u540e\u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230\u4e8b\u4ef6\u5faa\u73af\u3002\u7b49\u5f85\u8fde\u63a5\u5230\u6765\u3002\u5c31\u4f1a\u6267\u884cuv__server_io\u3002uv__server_io\u518d\u6267\u884cconnection_cb\u3002\u76d1\u542c\u6d41\u548c\u5176\u5b83\u6d41\u6709\u4e00\u4e2a\u533a\u522b\u662f\uff0c\u5f53IO\u89c2\u5bdf\u8005\u7684\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u76d1\u542c\u6d41\u6267\u884c\u7684\u56de\u8c03\u662fuv__server_io\u51fd\u6570\u3002\u800c\u5176\u5b83\u6d41\u662f\u5728uv__stream_io\u91cc\u7edf\u4e00\u5904\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fde\u63a5\u5230\u6765\u6216\u8005Unix\u57df\u4e0a\u6709\u6570\u636e\u5230\u6765\u65f6\u7684\u5904\u7406\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 void uv__server_io ( uv_loop_t * loop , uv__io_t * w , unsigned int events ) { uv_stream_t * stream ; int err ; stream = container_of ( w , uv_stream_t , io_watcher ); // \u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 uv__io_start ( stream -> loop , & stream -> io_watcher , POLLIN ); while ( uv__stream_fd ( stream ) != -1 ) { /* \u901a\u8fc7accept\u62ff\u5230\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684fd\uff0c\u6211\u4eec\u770b\u5230\u8fd9\u4e2a fd\u548c\u670d\u52a1\u5668\u7684fd\u662f\u4e0d\u4e00\u6837\u7684 */ err = uv__accept ( uv__stream_fd ( stream )); // \u9519\u8bef\u5904\u7406 if ( err < 0 ) { /* uv__stream_fd(stream)\u5bf9\u5e94\u7684fd\u662f\u975e\u963b\u585e\u7684\uff0c \u8fd4\u56de\u8fd9\u4e2a\u9519\u8bf4\u660e\u6ca1\u6709\u8fde\u63a5\u53ef\u7528accept\u4e86\uff0c\u76f4\u63a5\u8fd4\u56de */ if ( err == - EAGAIN || err == - EWOULDBLOCK ) return ; /* Not an error. */ if ( err == - ECONNABORTED ) continue ; // \u8fdb\u7a0b\u7684\u6253\u5f00\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e2a\u6570\u8fbe\u5230\u9608\u503c\uff0c\u770b\u662f\u5426\u6709\u5907\u7528\u7684 if ( err == - EMFILE || err == - ENFILE ) { err = uv__emfile_trick ( loop , uv__stream_fd ( stream )); if ( err == - EAGAIN || err == - EWOULDBLOCK ) break ; } // \u53d1\u751f\u9519\u8bef\uff0c\u6267\u884c\u56de\u8c03 stream -> connection_cb ( stream , err ); continue ; } // \u8bb0\u5f55\u62ff\u5230\u7684\u901a\u4fe1socket\u5bf9\u5e94\u7684fd stream -> accepted_fd = err ; // \u6267\u884c\u4e0a\u4f20\u56de\u8c03 stream -> connection_cb ( stream , 0 ); /* stream->accepted_fd\u4e3a-1\u8bf4\u660e\u5728\u56de\u8c03connection_cb\u91cc\u5df2\u7ecf\u6d88\u8d39 \u4e86 accepted_fd\uff0c\u5426\u5219\u5148\u6ce8\u9500\u670d\u52a1\u5668\u5728epoll\u4e2d\u7684fd\u7684\u8bfb\u4e8b\u4ef6\uff0c\u7b49 \u5f85\u6d88\u8d39\u540e\u518d\u6ce8\u518c\uff0c\u5373\u4e0d\u518d\u5904\u7406\u8bf7\u6c42\u4e86 */ if ( stream -> accepted_fd != -1 ) { /* The user hasn't yet accepted called uv_accept() */ uv__io_stop ( loop , & stream -> io_watcher , POLLIN ); return ; } /* \u662fTCP\u7c7b\u578b\u7684\u6d41\u5e76\u4e14\u8bbe\u7f6e\u6bcf\u6b21\u53eaaccpet\u4e00\u4e2a\u8fde\u63a5\uff0c\u5219\u5b9a\u65f6\u963b\u585e\uff0c \u88ab\u5524\u9192\u540e\u518daccept\uff0c\u5426\u5219\u4e00\u76f4accept\uff08\u5982\u679c\u7528\u6237\u5728connect\u56de \u8c03\u91cc\u6d88\u8d39\u4e86accept_fd\u7684\u8bdd\uff09\uff0c\u5b9a\u65f6\u963b\u585e\u7528\u4e8e\u591a\u8fdb\u7a0b\u7ade\u4e89\u5904\u7406\u8fde\u63a5 */ if ( stream -> type == UV_TCP && ( stream -> flags & UV_TCP_SINGLE_ACCEPT )) { struct timespec timeout = { 0 , 1 }; nanosleep ( & timeout , NULL ); } } } \u6211\u4eec\u770b\u5230\u8fde\u63a5\u5230\u6765\u65f6\uff0cLibuv\u4f1a\u4ece\u5df2\u5b8c\u6210\u8fde\u63a5\u7684\u961f\u5217\u4e2d\u6458\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u7136\u540e\u6267\u884cconnection_cb\u56de\u8c03\u3002\u5728connection_cb\u56de\u8c03\u91cc\uff0c\u9700\u8981uv_accept\u6d88\u8d39accpet_fd\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 int uv_accept ( uv_stream_t * server , uv_stream_t * client ) { int err ; switch ( client -> type ) { case UV_NAMED_PIPE : case UV_TCP : // \u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5230client err = uv__stream_open ( client , server -> accepted_fd , UV_STREAM_READABLE | UV_STREAM_WRITABLE ); if ( err ) { uv__close ( server -> accepted_fd ); goto done ; } break ; case UV_UDP : err = uv_udp_open (( uv_udp_t * ) client , server -> accepted_fd ); if ( err ) { uv__close ( server -> accepted_fd ); goto done ; } break ; default : return - EINVAL ; } client -> flags |= UV_HANDLE_BOUND ; done : // \u975e\u7a7a\u5219\u7ee7\u7eed\u653e\u4e00\u4e2a\u5230accpet_fd\u4e2d\u7b49\u5f85accept,\u7528\u4e8e\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012 if ( server -> queued_fds != NULL ) { uv__stream_queued_fds_t * queued_fds ; queued_fds = server -> queued_fds ; // \u628a\u7b2c\u4e00\u4e2a\u8d4b\u503c\u5230accept_fd server -> accepted_fd = queued_fds -> fds [ 0 ]; /* offset\u51cf\u53bb\u4e00\u4e2a\u5355\u4f4d\uff0c\u5982\u679c\u6ca1\u6709\u4e86\uff0c\u5219\u91ca\u653e\u5185\u5b58\uff0c \u5426\u5219\u9700\u8981\u628a\u540e\u9762\u7684\u5f80\u524d\u632a\uff0coffset\u6267\u884c\u6700\u540e\u4e00\u4e2a */ if ( -- queued_fds -> offset == 0 ) { uv__free ( queued_fds ); server -> queued_fds = NULL ; } else { memmove ( queued_fds -> fds , queued_fds -> fds + 1 , queued_fds -> offset * sizeof ( * queued_fds -> fds )); } } else { // \u6ca1\u6709\u6392\u961f\u7684fd\u4e86\uff0c\u5219\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u7b49\u5f85accept\u65b0\u7684fd server -> accepted_fd = -1 ; if ( err == 0 ) uv__io_start ( server -> loop , & server -> io_watcher , POLLIN ); } return err ; } client\u662f\u7528\u4e8e\u548c\u5ba2\u6237\u7aef\u8fdb\u884c\u901a\u4fe1\u7684\u6d41\uff0caccept\u5c31\u662f\u628aaccept_fd\u4fdd\u5b58\u5230client\u4e2d\uff0cclient\u5c31\u53ef\u4ee5\u901a\u8fc7fd\u548c\u5bf9\u7aef\u8fdb\u884c\u901a\u4fe1\u4e86\u3002\u6d88\u8d39\u5b8caccept_fd\u540e\uff0c\u5982\u679c\u8fd8\u6709\u5f85\u5904\u7406\u7684fd\u7684\u8bdd\uff0c\u9700\u8981\u8865\u5145\u4e00\u4e2a\u5230accept_fd\uff08\u9488\u5bf9Unix\u57df\uff09\uff0c\u5176\u5b83\u7684\u7ee7\u7eed\u6392\u961f\u7b49\u5f85\u5904\u7406\uff0c\u5982\u679c\u6ca1\u6709\u5f85\u5904\u7406\u7684fd\u5219\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u7ee7\u7eed\u5904\u7406\u65b0\u7684\u8fde\u63a5\u3002","title":"5.8 \u76d1\u542c\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#59","text":"\u5f53\u6211\u4eec\u4e0d\u518d\u9700\u8981\u4e00\u4e2a\u6d41\u7684\u65f6\u5019\uff0c\u6211\u4eec\u4f1a\u9996\u5148\u8c03\u7528uv_close\u5173\u95ed\u8fd9\u4e2a\u6d41\uff0c\u5173\u95ed\u6d41\u53ea\u662f\u6ce8\u9500\u4e86\u4e8b\u4ef6\u548c\u91ca\u653e\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u8c03\u7528uv_close\u4e4b\u540e\uff0c\u6d41\u5bf9\u5e94\u7684\u7ed3\u6784\u4f53\u5c31\u4f1a\u88ab\u52a0\u5165\u5230closing\u961f\u5217\uff0c\u5728closing\u9636\u6bb5\u7684\u65f6\u5019\uff0c\u624d\u4f1a\u6267\u884c\u9500\u6bc1\u6d41\u7684\u64cd\u4f5c\uff0c\u6bd4\u5982\u4e22\u5f03\u8fd8\u6ca1\u6709\u5199\u5b8c\u6210\u7684\u6570\u636e\uff0c\u6267\u884c\u5bf9\u5e94\u6d41\u7684\u56de\u8c03\uff0c\u6211\u4eec\u770b\u770b\u9500\u6bc1\u6d41\u7684\u51fd\u6570uv__stream_destroy\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void uv__stream_destroy ( uv_stream_t * stream ) { // \u6b63\u5728\u8fde\u63a5\uff0c\u5219\u6267\u884c\u56de\u8c03 if ( stream -> connect_req ) { uv__req_unregister ( stream -> loop , stream -> connect_req ); stream -> connect_req -> cb ( stream -> connect_req , - ECANCELED ); stream -> connect_req = NULL ; } // \u4e22\u5f03\u5f85\u5199\u7684\u6570\u636e\uff0c\u5982\u679c\u6709\u7684\u8bdd uv__stream_flush_write_queue ( stream , - ECANCELED ); // \u5904\u7406\u5199\u5b8c\u6210\u961f\u5217\uff0c\u8fd9\u91cc\u662f\u5904\u7406\u88ab\u4e22\u5f03\u7684\u6570\u636e uv__write_callbacks ( stream ); // \u6b63\u5728\u5173\u95ed\u6d41\uff0c\u76f4\u63a5\u56de\u8c03 if ( stream -> shutdown_req ) { uv__req_unregister ( stream -> loop , stream -> shutdown_req ); stream -> shutdown_req -> cb ( stream -> shutdown_req , - ECANCELED ); stream -> shutdown_req = NULL ; } } \u6211\u4eec\u770b\u5230\uff0c\u9500\u6bc1\u6d41\u7684\u65f6\u5019\uff0c\u5982\u679c\u6d41\u4e2d\u8fd8\u6709\u5f85\u5199\u7684\u6570\u636e\uff0c\u5219\u4f1a\u4e22\u5f03\u3002\u6211\u4eec\u770b\u4e00\u4e0buv__stream_flush_write_queue\u548cuv__write_callbacks\u3002 1 2 3 4 5 6 7 8 9 10 11 12 void uv__stream_flush_write_queue ( uv_stream_t * stream , int error ) { uv_write_t * req ; QUEUE * q ; while ( ! QUEUE_EMPTY ( & stream -> write_queue )) { q = QUEUE_HEAD ( & stream -> write_queue ); QUEUE_REMOVE ( q ); req = QUEUE_DATA ( q , uv_write_t , queue ); // \u628a\u9519\u8bef\u5199\u5230\u6bcf\u4e2a\u8bf7\u6c42\u4e2d req -> error = error ; QUEUE_INSERT_TAIL ( & stream -> write_completed_queue , & req -> queue ); } } uv__stream_flush_write_queue\u4e22\u5f03\u5f85\u5199\u961f\u5217\u4e2d\u7684\u8bf7\u6c42\uff0c\u5e76\u76f4\u63a5\u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217\u4e2d\u3002uv__write_callbacks\u662f\u5199\u5b8c\u6216\u8005\u5199\u51fa\u9519\u65f6\u6267\u884c\u7684\u51fd\u6570\uff0c\u5b83\u9010\u4e2a\u5904\u7406\u5199\u5b8c\u6210\u961f\u5217\u4e2d\u7684\u8282\u70b9\uff0c\u6bcf\u4e2a\u8282\u70b9\u662f\u4e00\u4e2a\u5199\u8bf7\u6c42\uff0c\u6267\u884c\u5b83\u7684\u56de\u8c03\uff0c\u5982\u4f55\u5206\u914d\u4e86\u5806\u5185\u5b58\uff0c\u5219\u91ca\u653e\u5185\u5b58\u3002\u5728\u5199\u6d41\u7ae0\u8282\u5df2\u7ecf\u5206\u6790\uff0c\u4e0d\u518d\u5177\u4f53\u5c55\u5f00\u3002","title":"5.9 \u9500\u6bc1\u6d41"},{"location":"chapter05-Libuv%E6%B5%81/#510","text":"\u5728\u6d41\u7684\u5b9e\u73b0\u4e2d\uff0c\u8bfb\u5199\u7b49\u64cd\u4f5c\u90fd\u53ea\u662f\u6ce8\u518c\u4e8b\u4ef6\u5230epoll\uff0c\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884c\u7edf\u4e00\u7684\u56de\u8c03\u51fd\u6570uv__stream_io\u3002\u4e0b\u9762\u5217\u4e00\u4e0b\u8be5\u51fd\u6570\u7684\u4ee3\u7801\uff0c\u5177\u4f53\u5b9e\u73b0\u5728\u5176\u5b83\u7ae0\u8282\u5df2\u7ecf\u5206\u6790\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 static void uv__stream_io ( uv_loop_t * loop , uv__io_t * w , unsigned int events ) { uv_stream_t * stream ; stream = container_of ( w , uv_stream_t , io_watcher ); // \u662f\u8fde\u63a5\u6d41\uff0c\u5219\u6267\u884c\u8fde\u63a5\u5904\u7406\u51fd\u6570 if ( stream -> connect_req ) { uv__stream_connect ( stream ); return ; } /* Ignore POLLHUP here. Even it it's set, there may still be data to read. */ // \u53ef\u8bfb\u662f\u89e6\u53d1\uff0c\u5219\u6267\u884c\u8bfb\u5904\u7406 if ( events & ( POLLIN | POLLERR | POLLHUP )) uv__read ( stream ); // \u8bfb\u56de\u8c03\u5173\u95ed\u4e86\u6d41 if ( uv__stream_fd ( stream ) == -1 ) return ; /* read_cb closed stream. */ /* \u00ac\u00ac POLLHUP\u8bf4\u660e\u5bf9\u7aef\u5173\u95ed\u4e86\uff0c\u5373\u4e0d\u4f1a\u53d1\u751f\u6570\u636e\u8fc7\u6765\u4e86\u3002 \u5982\u679c\u6d41\u7684\u6a21\u5f0f\u662f\u6301\u7eed\u8bfb\uff0c 1 \u5982\u679c\u53ea\u8bfb\u53d6\u4e86\u90e8\u5206\uff08\u8bbe\u7f6eUV_STREAM_READ_PARTIAL\uff09\uff0c \u5e76\u4e14\u6ca1\u6709\u8bfb\u5230\u7ed3\u5c3e(\u6ca1\u6709\u8bbe\u7f6eUV_STREAM_READ_EOF)\uff0c \u5219\u76f4\u63a5\u4f5c\u8bfb\u7ed3\u675f\u5904\u7406\uff0c 2 \u5982\u679c\u53ea\u8bfb\u53d6\u4e86\u90e8\u5206\uff0c\u4e0a\u9762\u7684\u8bfb\u56de\u8c03\u6267\u884c\u4e86\u8bfb\u7ed3\u675f\u64cd\u4f5c\uff0c \u5219\u8fd9\u91cc\u5c31\u4e0d\u9700\u8981\u5904\u7406\u4e86 3 \u5982\u679c\u6ca1\u6709\u8bbe\u7f6e\u53ea\u8bfb\u4e86\u90e8\u5206\uff0c\u8fd8\u6ca1\u6709\u6267\u884c\u8bfb\u7ed3\u675f\u64cd\u4f5c\uff0c \u5219\u4e0d\u80fd\u4f5c\u8bfb\u7ed3\u675f\u64cd\u4f5c\uff0c\u56e0\u4e3a\u5bf9\u7aef\u867d\u7136\u5173\u95ed\u4e86\uff0c\u4f46\u662f\u4e4b \u524d\u7684\u4f20\u8fc7\u6765\u7684\u6570\u636e\u53ef\u80fd\u8fd8\u6ca1\u6709\u88ab\u6d88\u8d39\u5b8c 4 \u5982\u679c\u6ca1\u6709\u8bbe\u7f6e\u53ea\u8bfb\u4e86\u90e8\u5206\uff0c\u6267\u884c\u4e86\u8bfb\u7ed3\u675f\u64cd\u4f5c\uff0c\u90a3\u8fd9 \u91cc\u4e5f\u4e0d\u9700\u8981\u5904\u7406 */ if (( events & POLLHUP ) && ( stream -> flags & UV_STREAM_READING ) && ( stream -> flags & UV_STREAM_READ_PARTIAL ) && ! ( stream -> flags & UV_STREAM_READ_EOF )) { uv_buf_t buf = { NULL , 0 }; uv__stream_eof ( stream , & buf ); } if ( uv__stream_fd ( stream ) == -1 ) return ; /* read_cb closed stream. */ // \u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1 if ( events & ( POLLOUT | POLLERR | POLLHUP )) { // \u5199\u6570\u636e uv__write ( stream ); // \u5199\u5b8c\u540e\u505a\u540e\u7f6e\u5904\u7406\uff0c\u91ca\u653e\u5185\u5b58\uff0c\u6267\u884c\u56de\u8c03\u7b49 uv__write_callbacks ( stream ); // \u5f85\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u6ce8\u9500\u7b49\u5f85\u5199\u4e8b\u4ef6 if ( QUEUE_EMPTY ( & stream -> write_queue )) uv__drain ( stream ); } }","title":"5.10 \u4e8b\u4ef6\u89e6\u53d1\u7684\u5904\u7406"},{"location":"chapter06-C%2B%2B%E5%B1%82/","text":"\u672c\u7ae0\u4ecb\u7ecdNode.js\u4e2dC++\u5c42\u7684\u4e00\u4e9b\u6838\u5fc3\u6a21\u5757\u7684\u539f\u7406\u548c\u5b9e\u73b0\uff0c\u8fd9\u4e9b\u6a21\u5757\u662fNode.js\u4e2d\u5f88\u591a\u6a21\u5757\u90fd\u4f1a\u4f7f\u7528\u7684\u3002\u7406\u89e3\u8fd9\u4e9b\u6a21\u5757\u7684\u539f\u7406\uff0c\u624d\u80fd\u66f4\u597d\u5730\u7406\u89e3\u5728Node.js\u4e2d\uff0cJS\u662f\u5982\u4f55\u901a\u8fc7C++\u5c42\u8c03\u7528Libuv\uff0c\u53c8\u662f\u5982\u4f55\u4eceLibuv\u8fd4\u56de\u7684\u3002 6.1 BaseObject \u00b6 BaseObject\u662fC++\u5c42\u5927\u591a\u6570\u7c7b\u7684\u57fa\u7c7b\u3002 1 2 3 4 5 6 7 8 9 class BaseObject : public MemoryRetainer { public : // \u2026 private : v8 :: Local < v8 :: Object > WrappedObject () const override ; // \u6307\u5411\u5c01\u88c5\u7684\u5bf9\u8c61 v8 :: Global < v8 :: Object > persistent_handle_ ; Environment * env_ ; }; BaseObject\u7684\u5b9e\u73b0\u5f88\u590d\u6742\uff0c\u8fd9\u91cc\u53ea\u4ecb\u7ecd\u5e38\u7528\u7684\u4e00\u4e9b\u5b9e\u73b0\u3002 6.1.1 \u6784\u9020\u51fd\u6570 \u00b6 1 2 3 4 5 6 7 8 // \u628a\u5bf9\u8c61\u5b58\u50a8\u5230persistent_handle_\u4e2d\uff0c\u5fc5\u8981\u7684\u65f6\u5019\u901a\u8fc7object()\u53d6\u51fa\u6765 BaseObject :: BaseObject ( Environment * env , v8 :: Local < v8 :: Object > object ) : persistent_handle_ ( env -> isolate (), object ), env_ ( env ) { // \u628athis\u5b58\u5230object\u4e2d object -> SetAlignedPointerInInternalField ( 0 , static_cast < void *> ( this )); } \u6784\u9020\u51fd\u6570\u7528\u4e8e\u4fdd\u5b58\u5bf9\u8c61\u95f4\u7684\u5173\u7cfb\uff08JS\u4f7f\u7528\u7684\u5bf9\u8c61\u548c\u4e0e\u5176\u5173\u7cfb\u7684C++\u5c42\u5bf9\u8c61\uff0c\u4e0b\u56fe\u4e2d\u7684\u5bf9\u8c61\u5373\u6211\u4eec\u5e73\u65f6\u5728JS\u5c42\u4f7f\u7528C++\u6a21\u5757\u521b\u5efa\u7684\u5bf9\u8c61\uff0c\u6bd4\u5982new TCP()\uff09\u3002\u540e\u9762\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u7528\u5904\uff0c\u5173\u7cfb\u5982\u56fe6-1\u6240\u793a\u3002 \u56fe6-1 6.1.2 \u83b7\u53d6\u5c01\u88c5\u7684\u5bf9\u8c61 \u00b6 1 2 3 4 v8 :: Local < v8 :: Object > BaseObject :: object () const { return PersistentToLocal :: Default ( env () -> isolate (), persistent_handle_ ); } 6.1.3 \u4ece\u5bf9\u8c61\u4e2d\u83b7\u53d6\u4fdd\u5b58\u7684BaseObject\u5bf9\u8c61 \u00b6 1 2 3 4 5 6 7 8 9 // \u901a\u8fc7obj\u53d6\u51fa\u91cc\u9762\u4fdd\u5b58\u7684BaseObject\u5bf9\u8c61 BaseObject * BaseObject::FromJSObject ( v8 :: Local < v8 :: Object > obj ) { return static_cast < BaseObject *> ( obj -> GetAlignedPointerFromInternalField ( 0 )); } template < typename T > T * BaseObject :: FromJSObject ( v8 :: Local < v8 :: Object > object ) { return static_cast < T *> ( FromJSObject ( object )); } 6.1.4 \u89e3\u5305 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // \u4eceobj\u4e2d\u53d6\u51fa\u5bf9\u5e94\u7684BaseObject\u5bf9\u8c61 template < typename T > inline T * Unwrap ( v8 :: Local < v8 :: Object > obj ) { return BaseObject :: FromJSObject < T > ( obj ); } // \u4eceobj\u4e2d\u83b7\u53d6\u5bf9\u5e94\u7684BaseObject\u5bf9\u8c61\uff0c\u5982\u679c\u4e3a\u7a7a\u5219\u8fd4\u56de\u7b2c\u4e09\u4e2a\u53c2\u6570\u7684\u503c\uff08\u9ed8\u8ba4\u503c\uff09 #define ASSIGN_OR_RETURN_UNWRAP(ptr, obj, ...) \\ do { \\ * ptr = static_cast < typename std :: remove_reference < decltype ( * ptr ) >:: type > ( \\ BaseObject :: FromJSObject ( obj )); \\ if ( * ptr == nullptr ) \\ return __VA_ARGS__ ; \\ } while ( 0 ) 6.2 AsyncWrap \u00b6 AsyncWrap\u5b9e\u73b0async_hook\u7684\u6a21\u5757\uff0c\u4e0d\u8fc7\u8fd9\u91cc\u6211\u4eec\u53ea\u5173\u6ce8\u5b83\u56de\u8c03JS\u7684\u529f\u80fd\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 inline v8 :: MaybeLocal < v8 :: Value > AsyncWrap :: MakeCallback ( const v8 :: Local < v8 :: Name > symbol , int argc , v8 :: Local < v8 :: Value >* argv ) { v8 :: Local < v8 :: Value > cb_v ; // \u6839\u636e\u5b57\u7b26\u4e32\u8868\u793a\u7684\u5c5e\u6027\u503c\uff0c\u4ece\u5bf9\u8c61\u4e2d\u53d6\u51fa\u8be5\u5c5e\u6027\u5bf9\u5e94\u7684\u503c\u3002\u662f\u4e2a\u51fd\u6570 if ( ! object () -> Get ( env () -> context (), symbol ). ToLocal ( & cb_v )) return v8 :: MaybeLocal < v8 :: Value > (); // \u662f\u4e2a\u51fd\u6570 if ( ! cb_v -> IsFunction ()) { return v8 :: MaybeLocal < v8 :: Value > (); } // \u56de\u8c03,\u89c1async_wrap.cc return MakeCallback ( cb_v . As < v8 :: Function > (), argc , argv ); } \u4ee5\u4e0a\u53ea\u662f\u5165\u53e3\u51fd\u6570\uff0c\u6211\u4eec\u770b\u770b\u771f\u6b63\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 MaybeLocal<Value> AsyncWrap::MakeCallback(const Local<Function> cb, int argc, Local<Value>* argv) { MaybeLocal<Value> ret = InternalMakeCallback(env(), object(), cb, argc, argv, context); return ret; } \u63a5\u7740\u770b\u4e00\u4e0bInternalMakeCallback 1 2 3 4 5 6 7 8 9 MaybeLocal<Value> InternalMakeCallback(Environment* env, Local<Object> recv, const Local<Function> callback, int argc, Local<Value> argv[], async_context asyncContext) { // \u2026\u7701\u7565\u5176\u4ed6\u4ee3\u7801 // \u6267\u884c\u56de\u8c03 callback->Call(env->context(), recv, argc, argv);} 6.3 HandleWrap \u00b6 HandleWrap\u662f\u5bf9Libuv uv_handle_t\u7684\u5c01\u88c5,\u4e5f\u662f\u5f88\u591aC++\u7c7b\u7684\u57fa\u7c7b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class HandleWrap : public AsyncWrap { public : // \u64cd\u4f5c\u548c\u5224\u65adhandle\u72b6\u6001\u51fd\u6570\uff0c\u89c1Libuv static void Close ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static void Ref ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static void Unref ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static void HasRef ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static inline bool IsAlive ( const HandleWrap * wrap ) { return wrap != nullptr && wrap -> state_ != kClosed ; } static inline bool HasRef ( const HandleWrap * wrap ) { return IsAlive ( wrap ) && uv_has_ref ( wrap -> GetHandle ()); } // \u83b7\u53d6\u5c01\u88c5\u7684handle inline uv_handle_t * GetHandle () const { return handle_ ; } // \u5173\u95edhandle\uff0c\u5173\u95ed\u6210\u529f\u540e\u6267\u884c\u56de\u8c03 virtual void Close ( v8 :: Local < v8 :: Value > close_callback = v8 :: Local < v8 :: Value > ()); static v8 :: Local < v8 :: FunctionTemplate > GetConstructorTemplate ( Environment * env ); protected : HandleWrap ( Environment * env , v8 :: Local < v8 :: Object > object , uv_handle_t * handle , AsyncWrap :: ProviderType provider ); virtual void OnClose () {} // handle\u72b6\u6001 inline bool IsHandleClosing () const { return state_ == kClosing || state_ == kClosed ; } private : friend class Environment ; friend void GetActiveHandles ( const v8 :: FunctionCallbackInfo < v8 :: Value >& ); static void OnClose ( uv_handle_t * handle ); // handle\u961f\u5217 ListNode < HandleWrap > handle_wrap_queue_ ; // handle\u7684\u72b6\u6001 enum { kInitialized , kClosing , kClosed } state_ ; // \u6240\u6709handle\u7684\u57fa\u7c7b uv_handle_t * const handle_ ; }; 6.3.1 \u65b0\u5efahandle\u548c\u521d\u59cb\u5316 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Local < FunctionTemplate > HandleWrap :: GetConstructorTemplate ( Environment * env ) { Local < FunctionTemplate > tmpl = env -> handle_wrap_ctor_template (); if ( tmpl . IsEmpty ()) { tmpl = env -> NewFunctionTemplate ( nullptr ); tmpl -> SetClassName ( FIXED_ONE_BYTE_STRING ( env -> isolate (), \"HandleWrap\" )); tmpl -> Inherit ( AsyncWrap :: GetConstructorTemplate ( env )); env -> SetProtoMethod ( tmpl , \"close\" , HandleWrap :: Close ); env -> SetProtoMethodNoSideEffect ( tmpl , \"hasRef\" , HandleWrap :: HasRef ); env -> SetProtoMethod ( tmpl , \"ref\" , HandleWrap :: Ref ); env -> SetProtoMethod ( tmpl , \"unref\" , HandleWrap :: Unref ); env -> set_handle_wrap_ctor_template ( tmpl ); } return tmpl ; } /* object\u4e3aC++\u5c42\u4e3aJS\u5c42\u63d0\u4f9b\u7684\u5bf9\u8c61 handle\u4e3a\u5b50\u7c7b\u5177\u4f53\u7684handle\u7c7b\u578b\uff0c\u4e0d\u540c\u6a21\u5757\u4e0d\u4e00\u6837 */ HandleWrap :: HandleWrap ( Environment * env , Local < Object > object , uv_handle_t * handle , AsyncWrap :: ProviderType provider ) : AsyncWrap ( env , object , provider ), state_ ( kInitialized ), handle_ ( handle ) { // \u4fdd\u5b58Libuv handle\u548cC++\u5bf9\u8c61\u7684\u5173\u7cfb handle_ -> data = this ; HandleScope scope ( env -> isolate ()); CHECK ( env -> has_run_bootstrapping_code ()); // \u63d2\u5165handle\u961f\u5217 env -> handle_wrap_queue () -> PushBack ( this ); } HandleWrap\u7ee7\u627fBaseObject\u7c7b\uff0c\u521d\u59cb\u5316\u540e\u5173\u7cfb\u56fe\u5982\u56fe6-2\u6240\u793a\u3002 \u56fe6-2 6.3.2 \u5224\u65ad\u548c\u64cd\u4f5chandle\u72b6\u6001 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // \u4fee\u6539handle\u4e3a\u6d3b\u8dc3\u72b6\u6001 void HandleWrap::Ref ( const FunctionCallbackInfo < Value >& args ) { HandleWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder ()); if ( IsAlive ( wrap )) uv_ref ( wrap -> GetHandle ()); } // \u4fee\u6539hande\u4e3a\u4e0d\u6d3b\u8dc3\u72b6\u6001 void HandleWrap::Unref ( const FunctionCallbackInfo < Value >& args ) { HandleWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder ()); if ( IsAlive ( wrap )) uv_unref ( wrap -> GetHandle ()); } // \u5224\u65adhandle\u662f\u5426\u5904\u4e8e\u6d3b\u8dc3\u72b6\u6001 void HandleWrap::HasRef ( const FunctionCallbackInfo < Value >& args ) { HandleWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder ()); args . GetReturnValue (). Set ( HasRef ( wrap )); } 6.3.3 \u5173\u95edhandle \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // \u5173\u95edhandle\uff08JS\u5c42\u8c03\u7528\uff09\uff0c\u6210\u529f\u540e\u6267\u884c\u56de\u8c03 void HandleWrap::Close ( const FunctionCallbackInfo < Value >& args ) { HandleWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder ()); // \u4f20\u5165\u56de\u8c03 wrap -> Close ( args [ 0 ]); } // \u771f\u6b63\u5173\u95edhandle\u7684\u51fd\u6570 void HandleWrap::Close ( Local < Value > close_callback ) { // \u6b63\u5728\u5173\u95ed\u6216\u5df2\u7ecf\u5173\u95ed if ( state_ != kInitialized ) return ; // \u8c03\u7528Libuv\u51fd\u6570 uv_close ( handle_ , OnClose ); // \u5173\u95ed\u4e2d state_ = kClosing ; // \u4f20\u4e86\u56de\u8c03\u5219\u4fdd\u5b58\u8d77\u6765 if ( ! close_callback . IsEmpty () && close_callback -> IsFunction () && ! persistent (). IsEmpty ()) { object () -> Set ( env () -> context (), env () -> handle_onclose_symbol (), close_callback ). Check (); } } // \u5173\u95edhandle\u6210\u529f\u540e\u56de\u8c03 void HandleWrap::OnClose ( uv_handle_t * handle ) { BaseObjectPtr < HandleWrap > wrap { static_cast < HandleWrap *> ( handle -> data ) }; wrap -> Detach (); Environment * env = wrap -> env (); HandleScope scope ( env -> isolate ()); Context :: Scope context_scope ( env -> context ()); wrap -> state_ = kClosed ; wrap -> OnClose (); wrap -> handle_wrap_queue_ . Remove (); // \u6709onclose\u56de\u8c03\u5219\u6267\u884c if ( ! wrap -> persistent (). IsEmpty () && wrap -> object () -> Has ( env -> context (), env -> handle_onclose_symbol ()) . FromMaybe ( false )) { wrap -> MakeCallback ( env -> handle_onclose_symbol (), 0 , nullptr ); } } 6.4 ReqWrap \u00b6 ReqWrap\u8868\u793a\u901a\u8fc7Libuv\u5bf9handle\u7684\u4e00\u6b21\u8bf7\u6c42\u3002 6.4.1 ReqWrapBase \u00b6 1 2 3 4 5 6 7 8 9 10 11 class ReqWrapBase { public : explicit inline ReqWrapBase ( Environment * env ); virtual ~ ReqWrapBase () = default ; virtual void Cancel () = 0 ; virtual AsyncWrap * GetAsyncWrap () = 0 ; private : // \u4e00\u4e2a\u5e26\u524d\u540e\u6307\u9488\u7684\u8282\u70b9 ListNode < ReqWrapBase > req_wrap_queue_ ; }; ReqWrapBase\u4e3b\u8981\u662f\u5b9a\u4e49\u63a5\u53e3\u7684\u534f\u8bae\u3002\u6211\u4eec\u770b\u4e00\u4e0bReqWrapBase\u7684\u5b9e\u73b0 1 2 3 ReqWrapBase :: ReqWrapBase ( Environment * env ) { env -> req_wrap_queue () -> PushBack ( this ); } ReqWrapBase\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u4f1a\u628a\u81ea\u5df1\u52a0\u5230env\u5bf9\u8c61\u7684req\u961f\u5217\u4e2d\u3002 6.4.2 ReqWrap \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 template < typename T > class ReqWrap : public AsyncWrap , public ReqWrapBase { public : inline ReqWrap ( Environment * env , v8 :: Local < v8 :: Object > object , AsyncWrap :: ProviderType provider ); inline ~ ReqWrap () override ; inline void Dispatched (); inline void Reset (); T * req () { return & req_ ; } inline void Cancel () final ; inline AsyncWrap * GetAsyncWrap () override ; static ReqWrap * from_req ( T * req ); template < typename LibuvFunction , typename ... Args > // \u8c03\u7528Libuv inline int Dispatch ( LibuvFunction fn , Args ... args ); public : typedef void ( * callback_t )(); callback_t original_callback_ = nullptr ; protected : T req_ ; }; } \u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 template < typename T > ReqWrap < T >:: ReqWrap ( Environment * env , v8 :: Local < v8 :: Object > object , AsyncWrap :: ProviderType provider ) : AsyncWrap ( env , object , provider ), ReqWrapBase ( env ) { // \u521d\u59cb\u5316\u72b6\u6001 Reset (); } // \u4fdd\u5b58libuv\u6570\u636e\u7ed3\u6784\u548cReqWrap\u5b9e\u4f8b\u7684\u5173\u7cfb template < typename T > void ReqWrap < T >:: Dispatched () { req_ . data = this ; } // \u91cd\u7f6e\u5b57\u6bb5 template < typename T > void ReqWrap < T >:: Reset () { original_callback_ = nullptr ; req_ . data = nullptr ; } // \u901a\u8fc7req\u6210\u5458\u627e\u6240\u5c5e\u5bf9\u8c61\u7684\u5730\u5740 template < typename T > ReqWrap < T >* ReqWrap < T >:: from_req ( T * req ) { return ContainerOf ( & ReqWrap < T >:: req_ , req ); } // \u53d6\u6d88\u7ebf\u7a0b\u6c60\u4e2d\u7684\u8bf7\u6c42 template < typename T > void ReqWrap < T >:: Cancel () { if ( req_ . data == this ) uv_cancel ( reinterpret_cast < uv_req_t *> ( & req_ )); } template < typename T > AsyncWrap * ReqWrap < T >:: GetAsyncWrap () { return this ; } // \u8c03\u7528Libuv\u51fd\u6570 template < typename T > template < typename LibuvFunction , typename ... Args > int ReqWrap < T >:: Dispatch ( LibuvFunction fn , Args ... args ) { Dispatched (); int err = CallLibuvFunction < T , LibuvFunction >:: Call ( // Libuv\u51fd\u6570 fn , env () -> event_loop (), req (), MakeLibuvRequestCallback < T , Args >:: For ( this , args )...); if ( err >= 0 ) env () -> IncreaseWaitingRequestCounter (); return err ; } \u6211\u4eec\u770b\u5230ReqWrap\u62bd\u8c61\u4e86\u8bf7\u6c42Libuv\u7684\u8fc7\u7a0b\uff0c\u5177\u4f53\u8bbe\u8ba1\u7684\u6570\u636e\u7ed3\u6784\u7531\u5b50\u7c7b\u5b9e\u73b0\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u67d0\u4e2a\u5b50\u7c7b\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 // \u8bf7\u6c42Libuv\u65f6\uff0c\u6570\u636e\u7ed3\u6784\u662fuv_connect_t\uff0c\u8868\u793a\u4e00\u6b21\u8fde\u63a5\u8bf7\u6c42 class ConnectWrap : public ReqWrap < uv_connect_t > { public : ConnectWrap ( Environment * env , v8 :: Local < v8 :: Object > req_wrap_obj , AsyncWrap :: ProviderType provider ); }; 6.5 JS\u5982\u4f55\u4f7f\u7528C++ \u00b6 JS\u8c03\u7528C++\u6a21\u5757\u662fV8\u63d0\u4f9b\u7684\u80fd\u529b\uff0cNode.js\u662f\u4f7f\u7528\u4e86\u8fd9\u4e2a\u80fd\u529b\u3002\u8fd9\u6837\u6211\u4eec\u53ea\u9700\u8981\u9762\u5bf9JS\uff0c\u5269\u4e0b\u7684\u4e8b\u60c5\u4ea4\u7ed9Node.js\u5c31\u884c\u3002\u672c\u6587\u9996\u5148\u8bb2\u4e00\u4e0b\u5229\u7528V8\u5982\u4f55\u5b9e\u73b0JS\u8c03\u7528C++\uff0c\u7136\u540e\u518d\u8bb2\u4e00\u4e0bNode.js\u662f\u600e\u4e48\u505a\u7684\u3002 1 JS\u8c03\u7528C++ \u9996\u5148\u4ecb\u7ecd\u4e00\u4e0bV8\u4e2d\u4e24\u4e2a\u975e\u5e38\u6838\u5fc3\u7684\u7c7bFunctionTemplate\u548cObjectTemplate\u3002\u987e\u540d\u601d\u4e49\uff0c\u8fd9\u4e24\u4e2a\u7c7b\u662f\u5b9a\u4e49\u6a21\u677f\u7684\uff0c\u597d\u6bd4\u5efa\u623f\u5b50\u65f6\u7684\u8bbe\u8ba1\u56fe\u4e00\u6837\uff0c\u901a\u8fc7\u8bbe\u8ba1\u56fe\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u9020\u51fa\u5bf9\u5e94\u7684\u623f\u5b50\u3002V8\u4e5f\u662f\uff0c\u5b9a\u4e49\u67d0\u79cd\u6a21\u677f\uff0c\u5c31\u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e2a\u6a21\u677f\u521b\u5efa\u51fa\u5bf9\u5e94\u7684\u5b9e\u4f8b\u3002\u4e0b\u9762\u4ecb\u7ecd\u4e00\u4e0b\u8fd9\u4e9b\u6982\u5ff5\uff08\u4e3a\u4e86\u65b9\u4fbf\uff0c\u4e0b\u9762\u90fd\u662f\u4f2a\u4ee3\u7801)\u3002 1.1 \u5b9a\u4e49\u4e00\u4e2a\u51fd\u6570\u6a21\u677f 1 2 3 Local < FunctionTemplate > functionTemplate = v8 :: FunctionTemplate :: New ( isolate (), New ); // \u5b9a\u4e49\u51fd\u6570\u7684\u540d\u5b57 functionTemplate -> SetClassName ( \u2018 TCP \u2019 ) \u9996\u5148\u5b9a\u4e49\u4e00\u4e2aFunctionTemplate\u5bf9\u8c61\u3002\u6211\u4eec\u770b\u5230FunctionTemplate\u7684\u7b2c\u4e8c\u4e2a\u5165\u53c2\u662f\u4e00\u4e2a\u51fd\u6570\uff0c\u5f53\u6211\u4eec\u6267\u884c\u7531FunctionTemplate\u521b\u5efa\u7684\u51fd\u6570\u65f6\uff0cv8\u5c31\u4f1a\u6267\u884cNew\u51fd\u6570\u3002\u5f53\u7136\u6211\u4eec\u4e5f\u53ef\u4ee5\u4e0d\u4f20\u3002 1.2 \u5b9a\u4e49\u51fd\u6570\u6a21\u677f\u7684prototype\u5185\u5bb9 prototype\u5c31\u662fJS\u91cc\u7684function.prototype\u3002\u5982\u679c\u4f60\u7406\u89e3JS\u91cc\u7684\u77e5\u8bc6\uff0c\u5c31\u5f88\u5bb9\u6613\u7406\u89e3C++\u7684\u4ee3\u7801\u3002 1 2 3 4 v8 :: Local < v8 :: FunctionTemplate > t = v8 :: FunctionTemplate :: New ( isolate (), callback ); t -> SetClassName ( ' test ' ); // \u5728prototype\u4e0a\u5b9a\u4e49\u4e00\u4e2a\u5c5e\u6027 t -> PrototypeTemplate () -> Set ( ' hello ' , ' world ' ); 1.3 \u5b9a\u4e49\u51fd\u6570\u6a21\u677f\u5bf9\u5e94\u7684\u5b9e\u4f8b\u6a21\u677f\u7684\u5185\u5bb9 \u5b9e\u4f8b\u6a21\u677f\u5c31\u662f\u4e00\u4e2aObjectTemplate\u5bf9\u8c61\u3002\u5b83\u5b9a\u4e49\u4e86\uff0c\u5f53\u4ee5new\u7684\u65b9\u5f0f\u6267\u884c\u7531\u51fd\u6570\u6a21\u677f\u521b\u5efa\u51fa\u6765\u7684\u51fd\u6570\u65f6\uff0c\u8fd4\u56de\u503c\u6240\u5177\u6709\u7684\u5c5e\u6027\u3002 1 2 3 4 5 function A () { this . a = 1 ; this . b = 2 ; } new A (); \u5b9e\u4f8b\u6a21\u677f\u7c7b\u4f3c\u4e0a\u9762\u4ee3\u7801\u4e2dA\u51fd\u6570\u91cc\u9762\u7684\u4ee3\u7801\u3002\u6211\u4eec\u770b\u770b\u5728V8\u91cc\u600e\u4e48\u5b9a\u4e49\u3002 1 2 t -> InstanceTemplate () -> Set ( key , val ); t -> InstanceTemplate () -> SetInternalFieldCount ( 1 ); InstanceTemplate\u8fd4\u56de\u7684\u662f\u4e00\u4e2aObjectTemplate\u5bf9\u8c61\u3002SetInternalFieldCount\u8fd9\u4e2a\u51fd\u6570\u6bd4\u8f83\u7279\u6b8a\uff0c\u4e5f\u662f\u6bd4\u8f83\u91cd\u8981\u7684\u4e00\u4e2a\u5730\u65b9\uff0c\u6211\u4eec\u77e5\u9053\u5bf9\u8c61\u5c31\u662f\u4e00\u5757\u5185\u5b58\uff0c\u5bf9\u8c61\u6709\u5b83\u81ea\u5df1\u7684\u5185\u5b58\u5e03\u5c40\uff0c\u6211\u4eec\u77e5\u9053\u5728C++\u91cc\uff0c\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u7c7b\uff0c\u4e5f\u5c31\u5b9a\u4e49\u4e86\u5bf9\u8c61\u7684\u5e03\u5c40\u3002\u6bd4\u5982\u6211\u4eec\u6709\u4ee5\u4e0b\u5b9a\u4e49\u3002 1 2 3 4 5 6 class demo { private : int a ; int b ; }; \u5728\u5185\u5b58\u4e2d\u5e03\u5c40\u5982\u56fe6-3\u6240\u793a\u3002 \u56fe6-3 \u4e0a\u9762\u8fd9\u79cd\u65b9\u5f0f\u6709\u4e2a\u95ee\u9898\uff0c\u5c31\u662f\u7c7b\u5b9a\u4e49\u4e4b\u540e\uff0c\u5185\u5b58\u5e03\u5c40\u5c31\u56fa\u5b9a\u4e86\u3002\u800cV8\u662f\u81ea\u5df1\u53bb\u63a7\u5236\u5bf9\u8c61\u7684\u5185\u5b58\u5e03\u5c40\u7684\u3002\u5f53\u6211\u4eec\u5728V8\u4e2d\u5b9a\u4e49\u4e00\u4e2a\u7c7b\u7684\u65f6\u5019\uff0c\u662f\u6ca1\u6709\u4efb\u4f55\u5c5e\u6027\u7684\u3002\u6211\u4eec\u770b\u4e00\u4e0bV8\u4e2dHeapObject\u7c7b\u7684\u5b9a\u4e49\u3002 1 2 3 4 class HeapObject : public Object { static const int kMapOffset = Object :: kSize ; // Object::kSize\u662f0 static const int kSize = kMapOffset + kPointerSize ; }; \u8fd9\u65f6\u5019\u7684\u5185\u5b58\u5e03\u5c40\u5982\u4e0b\u3002 \u7136\u540e\u6211\u4eec\u518d\u770b\u4e00\u4e0bHeapObject\u5b50\u7c7bHeapNumber\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 class HeapNumber : public HeapObject { // kSize\u4e4b\u524d\u7684\u7a7a\u95f4\u5b58\u50a8map\u5bf9\u8c61\u7684\u6307\u9488 static const int kValueOffset = HeapObject :: kSize ; // kValueOffset - kSize\u4e4b\u95f4\u5b58\u50a8\u6570\u5b57\u7684\u503c static const int kSize = kValueOffset + kDoubleSize ; }; \u5185\u5b58\u5e03\u5c40\u5982\u56fe6-4\u6240\u793a\u3002 \u56fe6-4 \u6211\u4eec\u53d1\u73b0\u8fd9\u4e9b\u7c7b\u53ea\u6709\u51e0\u4e2a\u7c7b\u53d8\u91cf\uff0c\u7c7b\u53d8\u91cf\u662f\u4e0d\u4fdd\u5b58\u5728\u5bf9\u8c61\u5185\u5b58\u7a7a\u95f4\u7684\u3002\u8fd9\u4e9b\u7c7b\u53d8\u91cf\u5c31\u662f\u5b9a\u4e49\u4e86\u5bf9\u8c61\u6bcf\u4e2a\u57df\u6240\u5360\u5185\u5b58\u7a7a\u95f4\u7684\u4fe1\u606f\uff0c\u5f53\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2aHeapObject\u5bf9\u8c61\u7684\u65f6\u5019\uff0cV8\u9996\u5148\u7533\u8bf7\u4e00\u5757\u5185\u5b58\uff0c\u7136\u540e\u628a\u8fd9\u5757\u5185\u5b58\u9996\u5730\u5740\u5f3a\u884c\u8f6c\u6210\u5bf9\u5e94\u5bf9\u8c61\u7684\u6307\u9488\u3002\u7136\u540e\u901a\u8fc7\u7c7b\u53d8\u91cf\u5bf9\u5c5e\u6027\u7684\u5185\u5b58\u8fdb\u884c\u5b58\u53d6\u3002\u6211\u4eec\u770b\u770b\u5728V8\u91cc\u5982\u4f55\u7533\u8bf7\u4e00\u4e2aHeapNumber\u5bf9\u8c61 1 2 3 4 5 6 7 8 9 10 11 12 13 Object * Heap::AllocateHeapNumber ( double value , PretenureFlag pretenure ) { // \u5728\u54ea\u4e2a\u7a7a\u95f4\u5206\u914d\u5185\u5b58\uff0c\u6bd4\u5982\u65b0\u751f\u4ee3\uff0c\u8001\u751f\u4ee3 AllocationSpace space = ( pretenure == TENURED ) ? CODE_SPACE : NEW_SPACE ; // \u5728space\u4e0a\u5206\u914d\u4e00\u4e2aHeapNumber\u5bf9\u8c61\u5927\u5c0f\u7684\u5185\u5b58 Object * result = AllocateRaw ( HeapNumber :: kSize , space ); /* \u8f6c\u6210HeapObect\uff0c\u8bbe\u7f6emap\u5c5e\u6027\uff0cmap\u5c5e\u6027\u662f\u8868\u793a\u5bf9\u8c61\u7c7b\u578b\u3001\u5927\u5c0f\u7b49\u4fe1\u606f\u7684 */ HeapObject :: cast ( result ) -> set_map ( heap_number_map ()); // \u8f6c\u6210HeapNumber\u5bf9\u8c61 HeapNumber :: cast ( result ) -> set_value ( value ); return result ; } \u56de\u5230\u5bf9\u8c61\u6a21\u677f\u7684\u95ee\u9898\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5bf9\u8c61\u6a21\u677f\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 class TemplateInfo : public Struct { static const int kTagOffset = HeapObject :: kSize ; static const int kPropertyListOffset = kTagOffset + kPointerSize ; static const int kHeaderSize = kPropertyListOffset + kPointerSize ; }; class ObjectTemplateInfo : public TemplateInfo { static const int kConstructorOffset = TemplateInfo :: kHeaderSize ; static const int kInternalFieldCountOffset = kConstructorOffset + kPointerSize ; static const int kSize = kInternalFieldCountOffset + kHeaderSize ; }; \u5185\u5b58\u5e03\u5c40\u5982\u56fe6-5\u6240\u793a\u3002 \u56fe6-5 \u56de\u5230\u5bf9\u8c61\u6a21\u677f\u7684\u95ee\u9898\uff0c\u6211\u4eec\u770b\u770bSet(key, val)\u505a\u4e86\u4ec0\u4e48\u3002 1 2 3 4 5 6 7 8 9 void Template::Set ( v8 :: Handle < String > name , v8 :: Handle < Data > value , v8 :: PropertyAttribute attribute ) { // ... i :: Handle < i :: Object > list ( Utils :: OpenHandle ( this ) -> property_list ()); NeanderArray array ( list ); array . add ( Utils :: OpenHandle ( * name )); array . add ( Utils :: OpenHandle ( * value )); array . add ( Utils :: OpenHandle ( * v8 :: Integer :: New ( attribute ))); } \u4e0a\u9762\u7684\u4ee3\u7801\u5927\u81f4\u5c31\u662f\u7ed9\u4e00\u4e2alist\u540e\u9762\u8ffd\u52a0\u4e00\u4e9b\u5185\u5bb9\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2alist\u662f\u600e\u4e48\u6765\u7684\uff0c\u5373property_list\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 // \u8bfb\u53d6\u5bf9\u8c61\u4e2d\u67d0\u4e2a\u5c5e\u6027\u7684\u503c #define READ_FIELD(p, offset) (*reinterpret_cast<Object**>(FIELD_ADDR(p, offset)) static Object * cast ( Object * value ) { return value ; } Object * TemplateInfo::property_list () { return Object :: cast ( READ_FIELD ( this , kPropertyListOffset )); } \u4ece\u4e0a\u9762\u4ee3\u7801\u4e2d\u6211\u4eec\u77e5\u9053\uff0c\u5185\u90e8\u5e03\u5c40\u5982\u56fe6-6\u6240\u793a\u3002 \u56fe6-6 \u6839\u636e\u5185\u5b58\u5e03\u5c40\uff0c\u6211\u4eec\u77e5\u9053property_list\u7684\u503c\u662flist\u6307\u5411\u7684\u503c\u3002\u6240\u4ee5Set(key, val)\u64cd\u4f5c\u7684\u5185\u5b58\u5e76\u4e0d\u662f\u5bf9\u8c61\u672c\u8eab\u7684\u5185\u5b58\uff0c\u5bf9\u8c61\u5229\u7528\u4e00\u4e2a\u6307\u9488\u6307\u5411\u4e00\u5757\u5185\u5b58\u4fdd\u5b58Set(key, val)\u7684\u503c\u3002SetInternalFieldCount\u51fd\u6570\u5c31\u4e0d\u4e00\u6837\u4e86\uff0c\u5b83\u4f1a\u5f71\u54cd\uff08\u6269\u5f20\uff09\u5bf9\u8c61\u672c\u8eab\u7684\u5185\u5b58\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u5b83\u7684\u5b9e\u73b0\u3002 1 2 3 4 void ObjectTemplate::SetInternalFieldCount ( int value ) { // \u4fee\u6539\u7684\u662fkInternalFieldCountOffset\u5bf9\u5e94\u7684\u5185\u5b58\u7684\u503c Utils :: OpenHandle ( this ) -> set_internal_field_count ( i :: Smi :: FromInt ( value )); } \u6211\u4eec\u770b\u5230SetInternalFieldCount\u51fd\u6570\u7684\u5b9e\u73b0\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u5728\u5bf9\u8c61\u672c\u8eab\u7684\u5185\u5b58\u4e2d\u4fdd\u5b58\u4e00\u4e2a\u6570\u5b57\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u5b57\u6bb5\u7684\u4f7f\u7528\u3002\u540e\u9762\u4f1a\u8be6\u7ec6\u4ecb\u7ecd\u5b83\u7684\u7528\u5904\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Handle < JSFunction > Factory :: CreateApiFunction ( Handle < FunctionTemplateInfo > obj , bool is_global ) { int internal_field_count = 0 ; if ( ! obj -> instance_template () -> IsUndefined ()) { // \u83b7\u53d6\u51fd\u6570\u6a21\u677f\u7684\u5b9e\u4f8b\u6a21\u677f Handle < ObjectTemplateInfo > instance_template = Handle < ObjectTemplateInfo > ( ObjectTemplateInfo :: cast ( obj -> instance_template ())); // \u83b7\u53d6\u5b9e\u4f8b\u6a21\u677f\u7684internal_field_count\u5b57\u6bb5\u7684\u503c\uff08\u901a\u8fc7SetInternalFieldCount\u8bbe\u7f6e\u7684\u90a3\u4e2a\u503c\uff09 internal_field_count = Smi :: cast ( instance_template -> internal_field_count ()) -> value (); } // \u8ba1\u7b97\u65b0\u5efa\u5bf9\u8c61\u9700\u8981\u7684\u7a7a\u95f4\uff0c\u5982\u679c int instance_size = kPointerSize * internal_field_count ; if ( is_global ) { instance_size += JSGlobalObject :: kSize ; } else { instance_size += JSObject :: kHeaderSize ; } InstanceType type = is_global ? JS_GLOBAL_OBJECT_TYPE : JS_OBJECT_TYPE ; // \u65b0\u5efa\u4e00\u4e2a\u51fd\u6570\u5bf9\u8c61 Handle < JSFunction > result = Factory :: NewFunction ( Factory :: empty_symbol (), type , instance_size , code , true ); } \u6211\u4eec\u770b\u5230internal_field_count\u7684\u503c\u7684\u610f\u4e49\u662f\uff0c\u4f1a\u6269\u5f20\u5bf9\u8c61\u7684\u5185\u5b58\uff0c\u6bd4\u5982\u4e00\u4e2a\u5bf9\u8c61\u672c\u8eab\u53ea\u6709n\u5b57\u8282\uff0c\u5982\u679c\u5b9a\u4e49internal_field_count\u7684\u503c\u662f1\uff0c\u5bf9\u8c61\u7684\u5185\u5b58\u5c31\u4f1a\u53d8\u6210n+internal_field_count * \u4e00\u4e2a\u6307\u9488\u7684\u5b57\u8282\u6570\u3002\u5185\u5b58\u5e03\u5c40\u5982\u56fe6-7\u6240\u793a\u3002 \u56fe6-7 1.4 \u901a\u8fc7\u51fd\u6570\u6a21\u677f\u521b\u5efa\u4e00\u4e2a\u51fd\u6570 Local functionTemplate = v8::FunctionTemplate::New(isolate(), New); global->Set('demo', functionTemplate ->GetFunction()); \u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u5728JS\u91cc\u76f4\u63a5\u8c03\u7528demo\u8fd9\u4e2a\u53d8\u91cf\uff0c\u7136\u540e\u5bf9\u5e94\u7684\u51fd\u6570\u5c31\u4f1a\u88ab\u6267\u884c\u3002\u8fd9\u5c31\u662fJS\u8c03\u7528C++\u7684\u539f\u7406\u3002 2 Node.js\u662f\u5982\u4f55\u5904\u7406JS\u8c03\u7528C++\u95ee\u9898\u7684 \u6211\u4eec\u4ee5TCP\u6a21\u5757\u4e3a\u4f8b\u3002 1 2 const { TCP } = process . binding ( 'tcp_wrap' ); new TCP (...); Node.js\u901a\u8fc7\u5b9a\u4e49\u4e00\u4e2a\u5168\u5c40\u53d8\u91cfprocess\u7edf\u4e00\u5904\u7406C++\u6a21\u5757\u7684\u8c03\u7528\uff0c\u5177\u4f53\u53c2\u8003\u6a21\u5757\u52a0\u8f7d\u7ae0\u8282\u7684\u5185\u5bb9\u3002\u5728Node.js\u4e2d\uff0cC++\u6a21\u5757\uff08\u7c7b\uff09\u4e00\u822c\u53ea\u4f1a\u5b9a\u4e49\u5bf9\u5e94\u7684Libuv\u7ed3\u6784\u4f53\u548c\u4e00\u7cfb\u5217\u7c7b\u51fd\u6570\uff0c\u7136\u540e\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\u6a21\u7248\uff0c\u5e76\u4f20\u5165\u4e00\u4e2a\u56de\u8c03\uff0c\u63a5\u7740\u628a\u8fd9\u4e9b\u7c7b\u51fd\u6570\u6302\u8f7d\u5230\u51fd\u6570\u6a21\u677f\u4e2d,\u6700\u540e\u901a\u8fc7\u51fd\u6570\u6a21\u677f\u8fd4\u56de\u4e00\u4e2a\u51fd\u6570F\u7ed9JS\u5c42\u4f7f\u7528\uff0c\u7ffb\u8bd1\u6210JS\u5927\u81f4\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // Libuv function uv_tcp_connect ( uv_tcp_t , addr , cb ) { cb (); } // C++ class TCPWrap { uv_tcp_t = {}; static Connect ( cb ) { const tcpWrap = this [ 0 ]; uv_tcp_connect ( tcpWrap . uv_tcp_t , { ip : '127.0.0.1' , port : 80 }, () => { cb (); } ); } } function FunctionTemplate ( cb ) { function Tmp () { Object . assign ( this , map ); cb ( this ); } const map = {}; return { PrototypeTemplate : function () { return { set : function ( k , v ) { Tmp . prototype [ k ] = v ; } } }, InstanceTemplate : function () { return { set : function ( k , v ) { map [ k ] = v ; } } }, GetFunction () { return Tmp ; } } } const TCPFunctionTemplate = FunctionTemplate (( target ) => { target [ 0 ] = new TCPWrap (); }) TCPFunctionTemplate . PrototypeTemplate (). set ( 'connect' , TCPWrap . Connect ); TCPFunctionTemplate . InstanceTemplate (). set ( 'name' , 'hi' ); const TCP = TCPFunctionTemplate . GetFunction (); // js const tcp = new TCP (); tcp . connect (() => { console . log ( '\u8fde\u63a5\u6210\u529f' ); }); tcp . name ; \u6211\u4eec\u4eceC++\u7684\u5c42\u9762\u5206\u6790\u6267\u884cnew TCP()\u7684\u903b\u8f91\uff0c\u7136\u540e\u518d\u5206\u6790connect\u7684\u903b\u8f91\uff0c\u8fd9\u4e24\u4e2a\u903b\u8f91\u6d89\u53ca\u7684\u673a\u5236\u662f\u5176\u5b83C++\u6a21\u5757\u4e5f\u4f1a\u4f7f\u7528\u5230\u7684\u3002\u56e0\u4e3aTCP\u5bf9\u5e94\u7684\u51fd\u6570\u662fInitialize\u51fd\u6570\u91cc\u7684t->GetFunction()\u5bf9\u5e94\u7684\u503c\u3002\u6240\u4ee5new TCP()\u7684\u65f6\u5019\uff0cV8\u9996\u5148\u4f1a\u521b\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u7136\u540e\u6267\u884cNew\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void TCPWrap::New ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); int type_value = args [ 0 ]. As < Int32 > () -> Value (); TCPWrap :: SocketType type = static_cast < TCPWrap :: SocketType > ( type_value ); ProviderType provider ; switch ( type ) { case SOCKET : provider = PROVIDER_TCPWRAP ; break ; case SERVER : provider = PROVIDER_TCPSERVERWRAP ; break ; default : UNREACHABLE (); } /* args.This()\u4e3av8\u63d0\u4f9b\u7684\u4e00\u4e2aC++\u5bf9\u8c61\uff08\u7531Initialize\u51fd\u6570\u5b9a\u4e49\u7684\u6a21\u5757\u521b\u5efa\u7684\uff09 \u8c03\u7528\u8be5C++\u5bf9\u8c61\u7684SetAlignedPointerInInternalField(0,this)\u5173\u8054this\uff08new TCPWrap()\uff09, \u89c1HandleWrap */ new TCPWrap ( env , args . This (), provider ); } \u6211\u4eec\u6cbf\u7740TCPWrap\u7684\u7ee7\u627f\u5173\u7cfb\uff0c\u4e00\u76f4\u5230HandleWrap 1 2 3 4 5 6 7 8 9 10 11 12 13 HandleWrap :: HandleWrap ( Environment * env , Local < Object > object , uv_handle_t * handle , AsyncWrap :: ProviderType provider ) : AsyncWrap ( env , object , provider ), state_ ( kInitialized ), handle_ ( handle ) { // \u4fdd\u5b58Libuv handle\u548cC++\u5bf9\u8c61\u7684\u5173\u7cfb handle_ -> data = this ; HandleScope scope ( env -> isolate ()); // \u63d2\u5165handle\u961f\u5217 env -> handle_wrap_queue () -> PushBack ( this ); } HandleWrap\u9996\u5148\u4fdd\u5b58\u4e86Libuv\u7ed3\u6784\u4f53\u548cC++\u5bf9\u8c61\u7684\u5173\u7cfb\u3002\u7136\u540e\u6211\u4eec\u7ee7\u7eed\u6cbf\u7740AsyncWrap\u5206\u6790\uff0cAsyncWrap\u7ee7\u627fBaseObject\uff0c\u6211\u4eec\u76f4\u63a5\u770bBaseObject\u3002 1 2 3 4 5 6 7 8 // \u628a\u5bf9\u8c61\u5b58\u50a8\u5230persistent_handle_\u4e2d\uff0c\u5fc5\u8981\u7684\u65f6\u5019\u901a\u8fc7object()\u53d6\u51fa\u6765 BaseObject :: BaseObject ( Environment * env , v8 :: Local < v8 :: Object > object ) : persistent_handle_ ( env -> isolate (), object ), env_ ( env ) { // \u628athis\u5b58\u5230object\u4e2d object -> SetAlignedPointerInInternalField ( 0 , static_cast < void *> ( this )); env -> AddCleanupHook ( DeleteMe , static_cast < void *> ( this )); env -> modify_base_object_count ( 1 ); } \u6211\u4eec\u770bSetAlignedPointerInInternalField\u3002 1 2 3 4 5 6 7 8 9 10 11 12 void v8::Object::SetAlignedPointerInInternalField ( int index , void * value ) { i :: Handle < i :: JSReceiver > obj = Utils :: OpenHandle ( this ); i :: Handle < i :: JSObject >:: cast ( obj ) -> SetEmbedderField ( index , EncodeAlignedAsSmi ( value , location )); } void JSObject::SetEmbedderField ( int index , Smi * value ) { // GetHeaderSize\u4e3a\u5bf9\u8c61\u56fa\u5b9a\u5e03\u5c40\u7684\u5927\u5c0f\uff0ckPointerSize * index\u4e3a\u62d3\u5c55\u7684\u5185\u5b58\u5927\u5c0f\uff0c\u6839\u636e\u7d22\u5f15\u627e\u5230\u5bf9\u5e94\u4f4d\u7f6e int offset = GetHeaderSize () + ( kPointerSize * index ); // \u5199\u5bf9\u5e94\u4f4d\u7f6e\u7684\u5185\u5b58\uff0c\u5373\u4fdd\u5b58\u5bf9\u5e94\u7684\u5185\u5bb9\u5230\u5185\u5b58 WRITE_FIELD ( this , offset , value ); } SetAlignedPointerInInternalField\u51fd\u6570\u5c55\u5f00\u540e\uff0c\u505a\u7684\u4e8b\u60c5\u5c31\u662f\u628a\u4e00\u4e2a\u503c\u4fdd\u5b58\u5230V8 C++\u5bf9\u8c61\u7684\u5185\u5b58\u91cc\u3002\u90a3\u4fdd\u5b58\u7684\u8fd9\u4e2a\u503c\u662f\u5565\u5462\uff1fBaseObject\u7684\u5165\u53c2object\u662f\u7531\u51fd\u6570\u6a21\u677f\u521b\u5efa\u7684\u5bf9\u8c61\uff0cthis\u662f\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u3002\u6240\u4ee5SetAlignedPointerInInternalField\u51fd\u6570\u505a\u7684\u4e8b\u60c5\u5c31\u662f\u628a\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u4fdd\u5b58\u5230\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\u521b\u5efa\u7684\u5bf9\u8c61\u91cc\uff0c\u5982\u56fe6-8\u6240\u793a\u3002 \u56fe6-8 \u8fd9\u6709\u5565\u7528\u5462\uff1f\u6211\u4eec\u7ee7\u7eed\u5206\u6790\u3002\u8fd9\u65f6\u5019new TCP\u5c31\u6267\u884c\u5b8c\u6bd5\u4e86\u3002\u6211\u4eec\u770b\u770b\u8fd9\u65f6\u5019\u6267\u884ctcp.connect()\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 template < typename T > void TCPWrap :: Connect ( const FunctionCallbackInfo < Value >& args , std :: function < int ( const char * ip_address , T * addr ) > uv_ip_addr ) { Environment * env = Environment :: GetCurrent ( args ); TCPWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder (), args . GetReturnValue (). Set ( UV_EBADF )); // \u7701\u7565\u90e8\u5206\u4e0d\u76f8\u5173\u4ee3\u7801 args . GetReturnValue (). Set ( err ); } \u6211\u4eec\u53ea\u9700\u770b\u4e00\u4e0bASSIGN_OR_RETURN_UNWRAP\u5b8f\u7684\u903b\u8f91\u3002\u5176\u4e2dargs.Holder()\u8868\u793aConnect\u51fd\u6570\u7684\u5c5e\u4e3b\uff0c\u6839\u636e\u524d\u9762\u7684\u5206\u6790\u6211\u4eec\u77e5\u9053\u5c5e\u4e3b\u662fInitialize\u51fd\u6570\u5b9a\u4e49\u7684\u51fd\u6570\u6a21\u677f\u521b\u5efa\u51fa\u6765\u7684\u5bf9\u8c61\u3002\u8fd9\u4e2a\u5bf9\u8c61\u4fdd\u5b58\u4e86\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u3002ASSIGN_OR_RETURN_UNWRAP\u4e3b\u8981\u7684\u903b\u8f91\u662f\u628a\u5728C++\u5bf9\u8c61\u4e2d\u4fdd\u5b58\u7684\u90a3\u4e2aTCPWrap\u5bf9\u8c61\u53d6\u51fa\u6765\u3002\u7136\u540e\u5c31\u53ef\u4ee5\u4f7f\u7528TCPWrap\u5bf9\u8c61\u7684handle\u53bb\u8bf7\u6c42Libuv\u4e86\u3002 6.7 C++\u5c42\u8c03\u7528Libuv \u00b6 \u521a\u624d\u6211\u4eec\u5206\u6790\u4e86JS\u8c03\u7528C++\u5c42\u65f6\u662f\u5982\u4f55\u4e32\u8d77\u6765\u7684\uff0c\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bC++\u8c03\u7528Libuv\u548cLibuv\u56de\u8c03C++\u5c42\u53c8\u662f\u5982\u4f55\u4e32\u8d77\u6765\u7684\u3002\u6211\u4eec\u901a\u8fc7TCP\u6a21\u5757\u7684connect\u51fd\u6570\u7ee7\u7eed\u5206\u6790\u8be5\u8fc7\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 template < typename T > void TCPWrap :: Connect ( const FunctionCallbackInfo < Value >& args , std :: function < int ( const char * ip_address , T * addr ) > uv_ip_addr ) { Environment * env = Environment :: GetCurrent ( args ); TCPWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder (), args . GetReturnValue (). Set ( UV_EBADF )); // \u7b2c\u4e00\u4e2a\u53c2\u6570\u662fTCPConnectWrap\u5bf9\u8c61\uff0c\u89c1net\u6a21\u5757 Local < Object > req_wrap_obj = args [ 0 ]. As < Object > (); // \u7b2c\u4e8c\u4e2a\u662fip\u5730\u5740 node :: Utf8Value ip_address ( env -> isolate (), args [ 1 ]); T addr ; // \u628a\u7aef\u53e3\uff0cIP\u8bbe\u7f6e\u5230addr\u4e0a\uff0c\u7aef\u53e3\u4fe1\u606f\u5728uv_ip_addr\u4e0a\u4e0b\u6587\u91cc\u4e86 int err = uv_ip_addr ( * ip_address , & addr ); if ( err == 0 ) { ConnectWrap * req_wrap = new ConnectWrap ( env , req_wrap_obj , AsyncWrap :: PROVIDER_TCPCONNECTWRAP ); err = req_wrap -> Dispatch ( uv_tcp_connect , & wrap -> handle_ , reinterpret_cast < const sockaddr *> ( & addr ), AfterConnect ); if ( err ) delete req_wrap ; } args . GetReturnValue (). Set ( err ); } \u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bConnectWrap\u3002\u6211\u4eec\u77e5\u9053ConnectWrap\u662fReqWrap\u7684\u5b50\u7c7b\u3002req_wrap_obj\u662fJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002New ConnectWrap\u540e\u7ed3\u6784\u5982\u56fe6-9\u6240\u793a\u3002 \u56fe6-9 \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bDispatch\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // \u8c03\u7528Libuv\u51fd\u6570 template < typename T > template < typename LibuvFunction , typename ... Args > int ReqWrap < T >:: Dispatch ( LibuvFunction fn , Args ... args ) { // \u4fdd\u5b58Libuv\u7ed3\u6784\u4f53\u548cC++\u5c42\u5bf9\u8c61ConnectWrap\u7684\u5173\u7cfb req_ . data = this ; int err = CallLibuvFunction < T , LibuvFunction >:: Call ( fn , env () -> event_loop (), req (), MakeLibuvRequestCallback < T , Args >:: For ( this , args )...); if ( err >= 0 ) env () -> IncreaseWaitingRequestCounter (); return err ; } \u8c03\u7528Libuv\u4e4b\u524d\u7684\u7ed3\u6784\u5982\u56fe6-10\u6240\u793a\u3002 \u56fe6-10 \u63a5\u4e0b\u6765\u6211\u4eec\u5206\u6790\u8c03\u7528Libuv\u7684\u5177\u4f53\u8fc7\u7a0b\u3002\u6211\u4eec\u770b\u5230Dispatch\u51fd\u6570\u662f\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\u3002 \u9996\u5148\u770b\u4e00\u4e0bCallLibuvFunction\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 template < typename ReqT , typename T > struct CallLibuvFunction ; // Detect `int uv_foo(uv_loop_t* loop, uv_req_t* request, ...);`. template < typename ReqT , typename ... Args > struct CallLibuvFunction < ReqT , int ( * )( uv_loop_t * , ReqT * , Args ...) > { using T = int ( * )( uv_loop_t * , ReqT * , Args ...); template < typename ... PassedArgs > static int Call ( T fn , uv_loop_t * loop , ReqT * req , PassedArgs ... args ) { return fn ( loop , req , args ...); } }; // Detect `int uv_foo(uv_req_t* request, ...);`. template < typename ReqT , typename ... Args > struct CallLibuvFunction < ReqT , int ( * )( ReqT * , Args ...) > { using T = int ( * )( ReqT * , Args ...); template < typename ... PassedArgs > static int Call ( T fn , uv_loop_t * loop , ReqT * req , PassedArgs ... args ) { return fn ( req , args ...); } }; // Detect `void uv_foo(uv_req_t* request, ...);`. template < typename ReqT , typename ... Args > struct CallLibuvFunction < ReqT , void ( * )( ReqT * , Args ...) > { using T = void ( * )( ReqT * , Args ...); template < typename ... PassedArgs > static int Call ( T fn , uv_loop_t * loop , ReqT * req , PassedArgs ... args ) { fn ( req , args ...); return 0 ; } }; CallLibuvFunction\u7684\u5b9e\u73b0\u770b\u8d77\u6765\u975e\u5e38\u590d\u6742\uff0c\u90a3\u662f\u56e0\u4e3a\u7528\u4e86\u5927\u91cf\u7684\u6a21\u677f\u53c2\u6570\uff0cCallLibuvFunction\u672c\u8d28\u4e0a\u662f\u4e00\u4e2astruct\uff0c\u5728C++\u91cc\u548c\u7c7b\u4f5c\u7528\u7c7b\u4f3c\uff0c\u91cc\u9762\u53ea\u6709\u4e00\u4e2a\u7c7b\u51fd\u6570Call\uff0cNode.js\u4e3a\u4e86\u9002\u914dLibuv\u5c42\u5404\u79cd\u7c7b\u578b\u51fd\u6570\u7684\u8c03\u7528\uff0c\u6240\u4ee5\u5b9e\u73b0\u4e86\u4e09\u79cd\u7c7b\u578b\u7684CallLibuvFunction,\u5e76\u4e14\u4f7f\u7528\u4e86\u5927\u91cf\u7684\u6a21\u677f\u53c2\u6570\u3002\u6211\u4eec\u53ea\u9700\u8981\u5206\u6790\u4e00\u79cd\u5c31\u53ef\u4ee5\u4e86\u3002\u6211\u4eec\u6839\u636eTCP\u7684connect\u51fd\u6570\u5f00\u59cb\u5206\u6790\u3002\u6211\u4eec\u9996\u5148\u5177\u4f53\u4e0bDispatch\u51fd\u6570\u7684\u6a21\u677f\u53c2\u6570\u3002 1 2 template <typename T> template <typename LibuvFunction, typename... Args> T\u5bf9\u5e94ReqWrap\u7684\u7c7b\u578b\uff0cLibuvFunction\u5bf9\u5e94Libuv\u7684\u51fd\u6570\u7c7b\u578b\uff0c\u8fd9\u91cc\u662fint uv_tcp_connect(uv_connect_t* req, ...)\uff0c\u6240\u4ee5\u662f\u5bf9\u5e94LibuvFunction\u7684\u7b2c\u4e8c\u79cd\u60c5\u51b5\uff0cArgs\u662f\u6267\u884cDispatch\u65f6\u9664\u4e86\u7b2c\u4e00\u4e2a\u5b9e\u53c2\u5916\u7684\u5269\u4f59\u53c2\u6570\u3002\u4e0b\u9762\u6211\u4eec\u5177\u4f53\u5316Dispatch\u3002 1 2 3 4 5 6 7 8 9 10 int ReqWrap < uv_connect_t >:: Dispatch ( int ( * )( uv_connect_t * , Args ...), Args ... args ) { req_ . data = this ; int err = CallLibuvFunction < uv_connect_t , int ( * )( uv_connect_t * , Args ...) >:: Call ( fn , env () -> event_loop (), req (), MakeLibuvRequestCallback < T , Args >:: For ( this , args )...); return err ; } \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bMakeLibuvRequestCallback\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // \u900f\u4f20\u53c2\u6570\u7ed9Libuv template < typename ReqT , typename T > struct MakeLibuvRequestCallback { static T For ( ReqWrap < ReqT >* req_wrap , T v ) { static_assert ( ! is_callable < T >:: value , \"MakeLibuvRequestCallback missed a callback\" ); return v ; } }; template < typename ReqT , typename ... Args > struct MakeLibuvRequestCallback < ReqT , void ( * )( ReqT * , Args ...) > { using F = void ( * )( ReqT * req , Args ... args ); // Libuv\u56de\u8c03 static void Wrapper ( ReqT * req , Args ... args ) { // \u901a\u8fc7Libuv\u7ed3\u6784\u4f53\u62ff\u5230\u5bf9\u5e94\u7684C++\u5bf9\u8c61 ReqWrap < ReqT >* req_wrap = ReqWrap < ReqT >:: from_req ( req ); req_wrap -> env () -> DecreaseWaitingRequestCounter (); // \u62ff\u5230\u539f\u59cb\u7684\u56de\u8c03\u6267\u884c F original_callback = reinterpret_cast < F > ( req_wrap -> original_callback_ ); original_callback ( req , args ...); } static F For ( ReqWrap < ReqT >* req_wrap , F v ) { // \u4fdd\u5b58\u539f\u6765\u7684\u51fd\u6570 CHECK_NULL ( req_wrap -> original_callback_ ); req_wrap -> original_callback_ = reinterpret_cast < typename ReqWrap < ReqT >:: callback_t > ( v ); // \u8fd4\u56de\u5305\u88f9\u51fd\u6570 return Wrapper ; } }; MakeLibuvRequestCallback\u7684\u5b9e\u73b0\u6709\u4e24\u79cd\u60c5\u51b5\uff0c\u6a21\u7248\u53c2\u6570\u7684\u7b2c\u4e00\u4e2a\u4e00\u822c\u662fReqWrap\u5b50\u7c7b\uff0c\u7b2c\u4e8c\u4e2a\u4e00\u822c\u662fhandle\uff0c\u521d\u59cb\u5316ReqWrap\u7c7b\u7684\u65f6\u5019\uff0cenv\u4e2d\u4f1a\u8bb0\u5f55ReqWrap\u5b9e\u4f8b\u7684\u4e2a\u6570\uff0c\u4ece\u800c\u77e5\u9053\u6709\u591a\u5c11\u4e2a\u8bf7\u6c42\u6b63\u5728\u88abLibuv\u5904\u7406\uff0c\u6a21\u677f\u53c2\u6570\u7684\u7b2c\u4e8c\u4e2a\u5982\u679c\u662f\u51fd\u6570\u5219\u8bf4\u660e\u6ca1\u6709\u4f7f\u7528ReqWrap\u8bf7\u6c42Libuv\uff0c\u5219\u4f7f\u7528\u7b2c\u4e8c\u79cd\u5b9e\u73b0\uff0c\u52ab\u6301\u56de\u8c03\u4ece\u800c\u8bb0\u5f55\u6b63\u5728\u88abLibuv\u5904\u7406\u7684\u8bf7\u6c42\u6570\uff08\u5982GetAddrInfo\u7684\u5b9e\u73b0\uff09\u3002\u6240\u4ee5\u6211\u4eec\u8fd9\u91cc\u662f\u9002\u914d\u7b2c\u4e00\u79cd\u5b9e\u73b0\u3002\u900f\u4f20C++\u5c42\u53c2\u6570\u7ed9Libuv\u3002\u6211\u4eec\u518d\u6765\u770b\u4e00\u4e0b Dispatch 1 2 3 4 5 6 7 8 9 10 int ReqWrap < uv_connect_t >:: Dispatch ( int ( * )( uv_connect_t * , Args ...), Args ... args ) { req_ . data = this ; int err = CallLibuvFunction < uv_connect_t , int ( * )( uv_connect_t * , Args ...) >:: Call ( fn , env () -> event_loop (), req (), args ...); return err ; } \u518d\u8fdb\u4e00\u6b65\u5c55\u5f00\u3002 1 2 3 static int Call ( int ( * fn )( uv_connect_t * , Args ...), uv_loop_t * loop , uv_connect_t * req , PassedArgs ... args ) { return fn ( req , args ...); } \u6700\u540e\u5c55\u5f00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static int Call ( int ( * fn )( uv_connect_t * , Args ...), uv_loop_t * loop , uv_connect_t * req , PassedArgs ... args ) { return fn ( req , args ...); } Call ( uv_tcp_connect , env () -> event_loop (), req (), & wrap -> handle_ , AfterConnec ) uv_tcp_connect ( env () -> event_loop (), req (), & wrap -> handle_ , AfterConnect ); \u63a5\u7740\u6211\u4eec\u770b\u770buv_tcp_connect\u505a\u4e86\u4ec0\u4e48\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int uv_tcp_connect ( uv_connect_t * req , uv_tcp_t * handle , const struct sockaddr * addr , uv_connect_cb cb ) { // ... return uv__tcp_connect ( req , handle , addr , addrlen , cb ); } int uv__tcp_connect ( uv_connect_t * req , uv_tcp_t * handle , const struct sockaddr * addr , unsigned int addrlen , uv_connect_cb cb ) { int err ; int r ; // \u5173\u8054\u8d77\u6765 req -> handle = ( uv_stream_t * ) handle ; // ... } Libuv\u4e2d\u628areq\u548chandle\u505a\u4e86\u5173\u8054\uff0c\u5982\u56fe6-11\u6240\u793a\u3002 \u56fe6-11 \u5206\u6790\u5b8cC++\u8c03\u7528Libuv\u540e\uff0c\u6211\u4eec\u770b\u770bLibuv\u56de\u8c03C++\u548cC++\u56de\u8c03JS\u7684\u8fc7\u7a0b\u3002\u5f53Libuv\u5904\u7406\u5b8c\u8bf7\u6c42\u540e\u4f1a\u6267\u884cAfterConnect \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template < typename WrapType , typename UVType > void ConnectionWrap < WrapType , UVType >:: AfterConnect ( uv_connect_t * req , int status ) { // \u4eceLibuv\u7ed3\u6784\u4f53\u62ff\u5230C++\u7684\u8bf7\u6c42\u5bf9\u8c61 std :: unique_ptr < ConnectWrap > req_wrap ( static_cast < ConnectWrap *> ( req -> data )); // \u4eceC++\u5c42\u8bf7\u6c42\u5bf9\u8c61\u62ff\u5230\u5bf9\u5e94\u7684handle\u7ed3\u6784\u4f53\uff08Libuv\u91cc\u5173\u8054\u8d77\u6765\u7684\uff09\uff0c\u518d\u901a\u8fc7handle\u62ff\u5230\u5bf9\u5e94\u7684C++\u5c42handle\u5bf9\u8c61\uff08HandleWrap\u5173\u8054\u7684\uff09 WrapType * wrap = static_cast < WrapType *> ( req -> handle -> data ); Environment * env = wrap -> env (); ... Local < Value > argv [ 5 ] = { Integer :: New ( env -> isolate (), status ), wrap -> object (), req_wrap -> object (), Boolean :: New ( env -> isolate (), readable ), Boolean :: New ( env -> isolate (), writable ) }; // \u56de\u8c03JS\u5c42oncomplete req_wrap -> MakeCallback ( env -> oncomplete_string (), arraysize ( argv ), argv ); } 6.8 \u6d41\u5c01\u88c5 \u00b6 Node.js\u5728C++\u5c42\u5bf9\u6d41\u8fdb\u884c\u4e86\u975e\u5e38\u591a\u7684\u5c01\u88c5\uff0c\u5f88\u591a\u6a21\u5757\u90fd\u4f9d\u8d56C++\u5c42\u6d41\u7684\u673a\u5236\uff0c\u6d41\u673a\u5236\u7684\u8bbe\u8ba1\u4e2d\uff0c\u4e3b\u8981\u6709\u4e09\u4e2a\u6982\u5ff5 1 \u8d44\u6e90\uff0c\u8fd9\u662f\u6d41\u673a\u5236\u7684\u6838\u5fc3\uff08StreamResource\uff09, 2 \u5bf9\u6d41\u8fdb\u884c\u64cd\u4f5c\uff08StreamReq\uff09 3 \u6d41\u4e8b\u4ef6\u7684\u76d1\u542c\u8005\uff0c\u5f53\u5bf9\u6d41\u8fdb\u884c\u64cd\u4f5c\u6216\u6d41\u672c\u8eab\u6709\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u4f1a\u628a\u4e8b\u4ef6\u548c\u76f8\u5173\u7684\u4e0a\u4e0b\u6587\u4f20\u9012\u7ed9\u76d1\u542c\u8005\uff0c\u76d1\u542c\u8005\u5904\u7406\u5b8c\u540e\uff0c\u518d\u901a\u77e5\u6d41\uff08StreamListener\uff09\u3002 \u901a\u8fc7\u7ee7\u627f\u7684\u6a21\u5f0f\uff0c\u57fa\u7c7b\u5b9a\u4e49\u63a5\u53e3\uff0c\u5b50\u7c7b\u5b9e\u73b0\u63a5\u53e3\u7684\u65b9\u5f0f\u3002\u5bf9\u6d41\u7684\u64cd\u4f5c\u8fdb\u884c\u4e86\u62bd\u8c61\u548c\u5c01\u88c5\u3002\u4e09\u8005\u7684\u7c7b\u5173\u7cfb\u5982\u56fe6-12\u6240\u793a\u3002 \u56fe6-12 \u6211\u4eec\u770b\u4e00\u4e0b\u8bfb\u4e00\u4e2a\u6d41\u7684\u6570\u636e\u7684\u8fc7\u7a0b\uff0c\u5982\u56fe6-13\u6240\u793a\u3002 \u56fe6-13 \u518d\u770b\u4e00\u4e0b\u5199\u7684\u8fc7\u7a0b\uff0c\u5982\u56fe6-14\u6240\u793a\u3002 \u56fe6-14 6.8.1 StreamResource \u00b6 StreamResource\u5b9a\u4e49\u64cd\u4f5c\u6d41\u7684\u901a\u7528\u903b\u8f91\u548c\u64cd\u4f5c\u7ed3\u675f\u540e\u89e6\u53d1\u7684\u56de\u8c03\u3002\u4f46\u662fStreamResource\u4e0d\u5b9a\u4e49\u6d41\u7684\u7c7b\u578b\uff0c\u6d41\u7684\u7c7b\u578b\u7531\u5b50\u7c7b\u5b9a\u4e49\uff0c\u6211\u4eec\u53ef\u4ee5\u5728StreamResource\u4e0a\u6ce8\u518clistener\uff0c\u8868\u793a\u5bf9\u6d41\u611f\u5174\u8da3\uff0c\u5f53\u6d41\u4e0a\u6709\u6570\u636e\u53ef\u8bfb\u6216\u8005\u4e8b\u4ef6\u53d1\u751f\u65f6\uff0c\u5c31\u4f1a\u901a\u77e5listener\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class StreamResource { public: virtual ~StreamResource(); // \u6ce8\u518c/\u6ce8\u9500\u7b49\u5f85\u6d41\u53ef\u8bfb\u4e8b\u4ef6 virtual int ReadStart() = 0; virtual int ReadStop() = 0; // \u5173\u95ed\u6d41 virtual int DoShutdown(ShutdownWrap* req_wrap) = 0; // \u5199\u5165\u6d41 virtual int DoTryWrite(uv_buf_t** bufs, size_t* count); virtual int DoWrite(WriteWrap* w, uv_buf_t* bufs, size_t count, uv_stream_t* send_handle) = 0; // ...\u5ffd\u7565\u4e00\u4e9b // \u7ed9\u6d41\u589e\u52a0\u6216\u5220\u9664\u76d1\u542c\u8005 void PushStreamListener(StreamListener* listener); void RemoveStreamListener(StreamListener* listener); protected: uv_buf_t EmitAlloc(size_t suggested_size); void EmitRead(ssize_t nread, const uv_buf_t& buf = uv_buf_init(nullptr, 0)); // \u6d41\u7684\u76d1\u542c\u8005\uff0c\u5373\u6570\u636e\u6d88\u8d39\u8005 StreamListener* listener_ = nullptr; uint64_t bytes_read_ = 0; uint64_t bytes_written_ = 0; friend class StreamListener; }; StreamResource\u662f\u4e00\u4e2a\u57fa\u7c7b\uff0c\u5176\u4e2d\u6709\u4e00\u4e2a\u6210\u5458\u662fStreamListener\u7c7b\u7684\u5b9e\u4f8b\uff0c\u6211\u4eec\u540e\u9762\u5206\u6790\u3002\u6211\u4eec\u770b\u4e00\u4e0bStreamResource\u7684\u5b9e\u73b0\u3002 1\u589e\u52a0\u4e00\u4e2alistener 1 2 3 4 5 6 7 // \u589e\u52a0\u4e00\u4e2alistener inline void StreamResource::PushStreamListener(StreamListener* listener) { // \u5934\u63d2\u6cd5 listener->previous_listener_ = listener_; listener->stream_ = this; listener_ = listener; } \u6211\u4eec\u53ef\u4ee5\u5728\u4e00\u4e2a\u6d41\u4e0a\u6ce8\u518c\u591a\u4e2alistener\uff0c\u6d41\u7684listener_\u5b57\u6bb5\u7ef4\u62a4\u4e86\u6d41\u4e0a\u6240\u6709\u7684listener\u961f\u5217\u3002\u5173\u7cfb\u56fe\u5982\u56fe6-15\u6240\u793a\u3002 \u56fe6-15 2\u5220\u9664listener 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 inline void StreamResource::RemoveStreamListener(StreamListener* listener) { StreamListener* previous; StreamListener* current; // \u904d\u5386\u5355\u94fe\u8868 for (current = listener_, previous = nullptr; /* No loop condition because we want a crash if listener is not found */ ; previous = current, current = current->previous_listener_) { if (current == listener) { // \u975e\u7a7a\u8bf4\u660e\u9700\u8981\u5220\u9664\u7684\u4e0d\u662f\u7b2c\u4e00\u4e2a\u8282\u70b9 if (previous != nullptr) previous->previous_listener_ = current->previous_listener_; else // \u5220\u9664\u7684\u662f\u7b2c\u4e00\u4e2a\u8282\u70b9\uff0c\u66f4\u65b0\u5934\u6307\u9488\u5c31\u884c listener_ = listener->previous_listener_; break; } } // \u91cd\u7f6e\u88ab\u5220\u9664listener\u7684\u5b57\u6bb5 listener->stream_ = nullptr; listener->previous_listener_ = nullptr; } 3 \u7533\u8bf7\u5b58\u50a8\u6570\u636e 1 2 3 4 5 // \u7533\u8bf7\u4e00\u5757\u5185\u5b58 inline uv_buf_t StreamResource::EmitAlloc(size_t suggested_size) { DebugSealHandleScope handle_scope(v8::Isolate::GetCurrent()); return listener_->OnStreamAlloc(suggested_size); } StreamResource\u53ea\u662f\u5b9a\u4e49\u4e86\u64cd\u4f5c\u6d41\u7684\u901a\u7528\u903b\u8f91\uff0c\u6570\u636e\u5b58\u50a8\u548c\u6d88\u8d39\u7531listener\u5b9a\u4e49\u3002 4 \u6570\u636e\u53ef\u8bfb 1 2 3 4 5 6 inline void StreamResource::EmitRead(ssize_t nread, const uv_buf_t& buf) { if (nread > 0) // \u8bb0\u5f55\u4ece\u6d41\u4e2d\u8bfb\u53d6\u7684\u6570\u636e\u7684\u5b57\u8282\u5927\u5c0f bytes_read_ += static_cast<uint64_t>(nread); listener_->OnStreamRead(nread, buf); } 5 \u5199\u56de\u8c03 1 2 3 4 inline void StreamResource::EmitAfterWrite(WriteWrap* w, int status) { DebugSealHandleScope handle_scope(v8::Isolate::GetCurrent()); listener_->OnStreamAfterWrite(w, status); } 6 \u5173\u95ed\u6d41\u56de\u8c03 1 2 3 4 inline void StreamResource::EmitAfterShutdown(ShutdownWrap* w, int status) { DebugSealHandleScope handle_scope(v8::Isolate::GetCurrent()); listener_->OnStreamAfterShutdown(w, status); } 7 \u6d41\u9500\u6bc1\u56de\u8c03 1 2 3 4 5 6 7 8 inline StreamResource::~StreamResource() { while (listener_ != nullptr) { StreamListener* listener = listener_; listener->OnStreamDestroy(); if (listener == listener_) RemoveStreamListener(listener_); } } \u6d41\u9500\u6bc1\u540e\u9700\u8981\u901a\u77e5listener\uff0c\u5e76\u4e14\u89e3\u9664\u5173\u7cfb\u3002 6.8.2 StreamBase \u00b6 StreamBase\u662fStreamResource\u7684\u5b50\u7c7b\uff0c\u62d3\u5c55\u4e86StreamResource\u7684\u529f\u80fd\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class StreamBase : public StreamResource { public: static constexpr int kStreamBaseField = 1; static constexpr int kOnReadFunctionField = 2; static constexpr int kStreamBaseFieldCount = 3; // \u5b9a\u4e49\u4e00\u4e9b\u7edf\u4e00\u7684\u903b\u8f91 static void AddMethods(Environment* env, v8::Local<v8::FunctionTemplate> target); virtual bool IsAlive() = 0; virtual bool IsClosing() = 0; virtual bool IsIPCPipe(); virtual int GetFD(); // \u6267\u884cJS\u56de\u8c03 v8::MaybeLocal<v8::Value> CallJSOnreadMethod( ssize_t nread, v8::Local<v8::ArrayBuffer> ab, size_t offset = 0, StreamBaseJSChecks checks = DONT_SKIP_NREAD_CHECKS); Environment* stream_env() const; // \u5173\u95ed\u6d41 int Shutdown(v8::Local<v8::Object> req_wrap_obj = v8::Local<v8::Object>()); // \u5199\u5165\u6d41 StreamWriteResult Write( uv_buf_t* bufs, size_t count, uv_stream_t* send_handle = nullptr, v8::Local<v8::Object> req_wrap_obj = v8::Local<v8::Object>()); // \u521b\u5efa\u4e00\u4e2a\u5173\u95ed\u8bf7\u6c42 virtual ShutdownWrap* CreateShutdownWrap(v8::Local<v8::Object> object); // \u521b\u5efa\u4e00\u4e2a\u5199\u8bf7\u6c42 virtual WriteWrap* CreateWriteWrap(v8::Local<v8::Object> object); virtual AsyncWrap* GetAsyncWrap() = 0; virtual v8::Local<v8::Object> GetObject(); static StreamBase* FromObject(v8::Local<v8::Object> obj); protected: explicit StreamBase(Environment* env); // JS Methods int ReadStartJS(const v8::FunctionCallbackInfo<v8::Value>& args); // \u7701\u7565\u7cfb\u5217\u65b9\u6cd5 void AttachToObject(v8::Local<v8::Object> obj); template <int (StreamBase::*Method)( const v8::FunctionCallbackInfo<v8::Value>& args)> static void JSMethod(const v8::FunctionCallbackInfo<v8::Value>& args); private: Environment* env_; EmitToJSStreamListener default_listener_; void SetWriteResult(const StreamWriteResult& res); static void AddMethod(Environment* env, v8::Local<v8::Signature> sig, enum v8::PropertyAttribute attributes, v8::Local<v8::FunctionTemplate> t, JSMethodFunction* stream_method, v8::Local<v8::String> str); }; 1 \u521d\u59cb\u5316 1 2 3 inline StreamBase::StreamBase(Environment* env) : env_(env) { PushStreamListener(&default_listener_); } StreamBase\u521d\u59cb\u5316\u7684\u65f6\u5019\u4f1a\u9ed8\u8ba4\u8bbe\u7f6e\u4e00\u4e2alistener\u3002 2 \u5173\u95ed\u6d41 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // \u5173\u95ed\u4e00\u4e2a\u6d41\uff0creq_wrap_obj\u662fJS\u5c42\u4f20\u8fdb\u6765\u7684\u5bf9\u8c61 inline int StreamBase::Shutdown(v8::Local<v8::Object> req_wrap_obj) { Environment* env = stream_env(); HandleScope handle_scope(env->isolate()); AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap()); // \u521b\u5efa\u4e00\u4e2a\u7528\u4e8e\u8bf7\u6c42Libuv\u7684\u6570\u636e\u7ed3\u6784 ShutdownWrap* req_wrap = CreateShutdownWrap(req_wrap_obj); // \u5b50\u7c7b\u5b9e\u73b0\uff0c\u4e0d\u540c\u6d41\u5173\u95ed\u7684\u903b\u8f91\u4e0d\u4e00\u6837 int err = DoShutdown(req_wrap); // \u6267\u884c\u51fa\u9519\u5219\u9500\u6bc1JS\u5c42\u5bf9\u8c61 if (err != 0 && req_wrap != nullptr) { req_wrap->Dispose(); } const char* msg = Error(); if (msg != nullptr) { req_wrap_obj->Set( env->context(), env->error_string(), OneByteString(env->isolate(), msg)).Check(); ClearError(); } return err; } 3 \u5199 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // \u5199Buffer\uff0c\u652f\u6301\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 int StreamBase::WriteBuffer(const FunctionCallbackInfo<Value>& args) { Environment* env = Environment::GetCurrent(args); Local<Object> req_wrap_obj = args[0].As<Object>(); uv_buf_t buf; // \u6570\u636e\u5185\u5bb9\u548c\u957f\u5ea6 buf.base = Buffer::Data(args[1]); buf.len = Buffer::Length(args[1]); uv_stream_t* send_handle = nullptr; // \u662f\u5bf9\u8c61\u5e76\u4e14\u6d41\u652f\u6301\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 if (args[2]->IsObject() && IsIPCPipe()) { Local<Object> send_handle_obj = args[2].As<Object>(); HandleWrap* wrap; // \u4ece\u8fd4\u56dejs\u7684\u5bf9\u8c61\u4e2d\u83b7\u53d6internalField\u4e2d\u6307\u5411\u7684C++\u5c42\u5bf9\u8c61 ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL); // \u62ff\u5230Libuv\u5c42\u7684handle send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle()); // Reference LibuvStreamWrap instance to prevent it from being garbage // collected before `AfterWrite` is called. // \u8bbe\u7f6e\u5230JS\u5c42\u8bf7\u6c42\u5bf9\u8c61\u4e2d req_wrap_obj->Set(env->context(), env->handle_string(), send_handle_obj).Check(); } StreamWriteResult res = Write(&buf, 1, send_handle, req_wrap_obj); SetWriteResult(res); return res.err; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 inline StreamWriteResult StreamBase::Write( uv_buf_t* bufs, size_t count, uv_stream_t* send_handle, v8::Local<v8::Object> req_wrap_obj) { Environment* env = stream_env(); int err; size_t total_bytes = 0; // \u8ba1\u7b97\u9700\u8981\u5199\u5165\u7684\u6570\u636e\u5927\u5c0f for (size_t i = 0; i < count; ++i) total_bytes += bufs[i].len; // \u540c\u4e0a bytes_written_ += total_bytes; // \u662f\u5426\u9700\u8981\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u4e0d\u9700\u8981\u5219\u76f4\u63a5\u5199 if (send_handle == nullptr) { err = DoTryWrite(&bufs, &count); if (err != 0 || count == 0) { return StreamWriteResult { false, err, nullptr, total_bytes }; } } HandleScope handle_scope(env->isolate()); AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap()); // \u521b\u5efa\u4e00\u4e2a\u7528\u4e8e\u8bf7\u6c42Libuv\u7684\u5199\u8bf7\u6c42\u5bf9\u8c61 WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj); // \u6267\u884c\u5199\uff0c\u5b50\u7c7b\u5b9e\u73b0\uff0c\u4e0d\u540c\u6d41\u5199\u64cd\u4f5c\u4e0d\u4e00\u6837 err = DoWrite(req_wrap, bufs, count, send_handle); const char* msg = Error(); if (msg != nullptr) { req_wrap_obj->Set(env->context(), env->error_string(), OneByteString(env->isolate(), msg)).Check(); ClearError(); } return StreamWriteResult { async, err, req_wrap, total_bytes }; } 4 \u8bfb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // \u64cd\u4f5c\u6d41\uff0c\u542f\u52a8\u8bfb\u53d6 int StreamBase::ReadStartJS(const FunctionCallbackInfo<Value>& args) { return ReadStart(); } // \u64cd\u4f5c\u6d41\uff0c\u505c\u6b62\u8bfb\u53d6 int StreamBase::ReadStopJS(const FunctionCallbackInfo<Value>& args) { return ReadStop(); } // \u89e6\u53d1\u6d41\u4e8b\u4ef6\uff0c\u6709\u6570\u636e\u53ef\u8bfb MaybeLocal<Value> StreamBase::CallJSOnreadMethod(ssize_t nread, Local<ArrayBuffer> ab, size_t offset, StreamBaseJSChecks checks) { Environment* env = env_; env->stream_base_state()[kReadBytesOrError] = nread; env->stream_base_state()[kArrayBufferOffset] = offset; Local<Value> argv[] = { ab.IsEmpty() ? Undefined(env->isolate()).As<Value>() : ab.As<Value>() }; // GetAsyncWrap\u5728StreamBase\u5b50\u7c7b\u5b9e\u73b0\uff0c\u62ff\u5230StreamBase\u7c7b\u5bf9\u8c61 AsyncWrap* wrap = GetAsyncWrap(); // \u83b7\u53d6\u56de\u8c03\u6267\u884c Local<Value> onread = wrap->object()->GetInternalField(kOnReadFunctionField); return wrap->MakeCallback(onread.As<Function>(), arraysize(argv), argv); } 4 \u6d41\u901a\u7528\u65b9\u6cd5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 void StreamBase::AddMethod(Environment* env, Local<Signature> signature, enum PropertyAttribute attributes, Local<FunctionTemplate> t, JSMethodFunction* stream_method, Local<String> string) { // \u65b0\u5efa\u4e00\u4e2a\u51fd\u6570\u6a21\u677f Local<FunctionTemplate> templ = env->NewFunctionTemplate(stream_method, signature, v8::ConstructorBehavior::kThrow, v8::SideEffectType::kHasNoSideEffect); // \u8bbe\u7f6e\u539f\u578b\u5c5e\u6027 t->PrototypeTemplate()->SetAccessorProperty( string, templ, Local<FunctionTemplate>(), attributes); } void StreamBase::AddMethods(Environment* env, Local<FunctionTemplate> t) { HandleScope scope(env->isolate()); enum PropertyAttribute attributes = static_cast<PropertyAttribute>(ReadOnly | DontDelete | DontEnum); Local<Signature> sig = Signature::New(env->isolate(), t); // \u8bbe\u7f6e\u539f\u578b\u5c5e\u6027 AddMethod(env, sig, attributes, t, GetFD, env->fd_string()); // \u5ffd\u7565\u90e8\u5206 env->SetProtoMethod(t, \"readStart\", JSMethod<&StreamBase::ReadStartJS>); env->SetProtoMethod(t, \"readStop\", JSMethod<&StreamBase::ReadStopJS>); env->SetProtoMethod(t, \"shutdown\", JSMethod<&StreamBase::Shutdown>); env->SetProtoMethod(t, \"writev\", JSMethod<&StreamBase::Writev>); env->SetProtoMethod(t, \"writeBuffer\", JSMethod<&StreamBase::WriteBuffer>); env->SetProtoMethod( t, \"writeAsciiString\", JSMethod<&StreamBase::WriteString<ASCII>>); env->SetProtoMethod( t, \"writeUtf8String\", JSMethod<&StreamBase::WriteString<UTF8>>); t->PrototypeTemplate()->Set(FIXED_ONE_BYTE_STRING(env->isolate(), \"isStreamBase\"), True(env->isolate())); // \u8bbe\u7f6e\u8bbf\u95ee\u5668 t->PrototypeTemplate()->SetAccessor( // \u952e\u540d FIXED_ONE_BYTE_STRING(env->isolate(), \"onread\"), // getter BaseObject::InternalFieldGet<kOnReadFunctionField>, // setter\uff0cValue::IsFunction\u662fset\u4e4b\u524d\u7684\u6821\u9a8c\u51fd\u6570\uff0c\u89c1InternalFieldSet\uff08\u6a21\u677f\u51fd\u6570\uff09\u5b9a\u4e49 BaseObject::InternalFieldSet<kOnReadFunctionField, &Value::IsFunction>); } 5 \u5176\u5b83\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // \u9ed8\u8ba4false\uff0c\u5b50\u7c7b\u91cd\u5199 bool StreamBase::IsIPCPipe() { return false; } // \u5b50\u7c7b\u91cd\u5199 int StreamBase::GetFD() { return -1; } Local<Object> StreamBase::GetObject() { return GetAsyncWrap()->object(); } // \u5de5\u5177\u51fd\u6570\u548c\u5b9e\u4f8bthis\u65e0\u5173\uff0c\u548c\u5165\u53c2\u6709\u5173 void StreamBase::GetFD(const FunctionCallbackInfo<Value>& args) { // Mimic implementation of StreamBase::GetFD() and UDPWrap::GetFD(). // \u4eceJS\u5c42\u5bf9\u8c61\u83b7\u53d6\u5b83\u5173\u8054\u7684C++\u5bf9\u8c61\uff0c\u4e0d\u4e00\u5b9a\u662fthis StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>()); if (wrap == nullptr) return args.GetReturnValue().Set(UV_EINVAL); if (!wrap->IsAlive()) return args.GetReturnValue().Set(UV_EINVAL); args.GetReturnValue().Set(wrap->GetFD()); } void StreamBase::GetBytesRead(const FunctionCallbackInfo<Value>& args) { StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>()); if (wrap == nullptr) return args.GetReturnValue().Set(0); // uint64_t -> double. 53bits is enough for all real cases. args.GetReturnValue().Set(static_cast<double>(wrap->bytes_read_)); } 6.8.3 LibuvStreamWrap \u00b6 LibuvStreamWrap\u662fStreamBase\u7684\u5b50\u7c7b\u3002\u5b9e\u73b0\u4e86\u7236\u7c7b\u7684\u63a5\u53e3\uff0c\u4e5f\u62d3\u5c55\u4e86\u6d41\u7684\u80fd\u529b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class LibuvStreamWrap : public HandleWrap, public StreamBase { public: static void Initialize(v8::Local<v8::Object> target, v8::Local<v8::Value> unused, v8::Local<v8::Context> context, void* priv); int GetFD() override; bool IsAlive() override; bool IsClosing() override; bool IsIPCPipe() override; // JavaScript functions int ReadStart() override; int ReadStop() override; // Resource implementation int DoShutdown(ShutdownWrap* req_wrap) override; int DoTryWrite(uv_buf_t** bufs, size_t* count) override; int DoWrite(WriteWrap* w, uv_buf_t* bufs, size_t count, uv_stream_t* send_handle) override; inline uv_stream_t* stream() const { return stream_; } // \u662f\u5426\u662fUnix\u57df\u6216\u547d\u540d\u7ba1\u9053 inline bool is_named_pipe() const { return stream()->type == UV_NAMED_PIPE; } // \u662f\u5426\u662fUnix\u57df\u5e76\u4e14\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 inline bool is_named_pipe_ipc() const { return is_named_pipe() && reinterpret_cast<const uv_pipe_t*>(stream())->ipc != 0; } inline bool is_tcp() const { return stream()->type == UV_TCP; } // \u521b\u5efa\u8bf7\u6c42Libuv\u7684\u5bf9\u8c61 ShutdownWrap* CreateShutdownWrap(v8::Local<v8::Object> object) override; WriteWrap* CreateWriteWrap(v8::Local<v8::Object> object) override; // \u4eceJS\u5c42\u5bf9\u8c61\u83b7\u53d6\u5bf9\u4e8e\u7684C++\u5bf9\u8c61 static LibuvStreamWrap* From(Environment* env, v8::Local<v8::Object> object); protected: LibuvStreamWrap(Environment* env, v8::Local<v8::Object> object, uv_stream_t* stream, AsyncWrap::ProviderType provider); AsyncWrap* GetAsyncWrap() override; static v8::Local<v8::FunctionTemplate> GetConstructorTemplate( Environment* env); private: static void GetWriteQueueSize( const v8::FunctionCallbackInfo<v8::Value>& info); static void SetBlocking(const v8::FunctionCallbackInfo<v8::Value>& args); // Callbacks for libuv void OnUvAlloc(size_t suggested_size, uv_buf_t* buf); void OnUvRead(ssize_t nread, const uv_buf_t* buf); static void AfterUvWrite(uv_write_t* req, int status); static void AfterUvShutdown(uv_shutdown_t* req, int status); uv_stream_t* const stream_; }; 1 \u521d\u59cb\u5316 1 2 3 4 5 6 7 8 9 10 11 12 LibuvStreamWrap::LibuvStreamWrap(Environment* env, Local<Object> object, uv_stream_t* stream, AsyncWrap::ProviderType provider) : HandleWrap(env, object, reinterpret_cast<uv_handle_t*>(stream), provider), StreamBase(env), stream_(stream) { StreamBase::AttachToObject(object); } LibuvStreamWrap\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u4f1a\u628aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u7684\u5185\u90e8\u6307\u9488\u6307\u5411\u81ea\u5df1\uff0c\u89c1HandleWrap\u3002 2 \u5199\u64cd\u4f5c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 // \u5de5\u5177\u51fd\u6570\uff0c\u83b7\u53d6\u5f85\u5199\u6570\u636e\u5b57\u8282\u7684\u5927\u5c0f void LibuvStreamWrap::GetWriteQueueSize( const FunctionCallbackInfo<Value>& info) { LibuvStreamWrap* wrap; ASSIGN_OR_RETURN_UNWRAP(&wrap, info.This()); uint32_t write_queue_size = wrap->stream()->write_queue_size; info.GetReturnValue().Set(write_queue_size); } // \u8bbe\u7f6e\u975e\u963b\u585e void LibuvStreamWrap::SetBlocking(const FunctionCallbackInfo<Value>& args) { LibuvStreamWrap* wrap; ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); bool enable = args[0]->IsTrue(); args.GetReturnValue().Set(uv_stream_set_blocking(wrap->stream(), enable)); } // \u5b9a\u4e49\u4e00\u4e2a\u5173\u95ed\u7684\u8bf7\u6c42 typedef SimpleShutdownWrap<ReqWrap<uv_shutdown_t>> LibuvShutdownWrap; // \u5b9a\u4e49\u4e00\u4e2a\u5199\u8bf7\u6c42 typedef SimpleWriteWrap<ReqWrap<uv_write_t>> LibuvWriteWrap; ShutdownWrap* LibuvStreamWrap::CreateShutdownWrap(Local<Object> object) { return new LibuvShutdownWrap(this, object); } WriteWrap* LibuvStreamWrap::CreateWriteWrap(Local<Object> object) { return new LibuvWriteWrap(this, object); } // \u53d1\u8d77\u5173\u95ed\u8bf7\u6c42\uff0c\u7531\u7236\u7c7b\u8c03\u7528\uff0creq_wrap\u662fC++\u5c42\u521b\u5efa\u7684\u5bf9\u8c61 int LibuvStreamWrap::DoShutdown(ShutdownWrap* req_wrap_) { LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(req_wrap_); return req_wrap->Dispatch(uv_shutdown, stream(), AfterUvShutdown); } // \u5173\u95ed\u8bf7\u6c42\u7ed3\u675f\u540e\u6267\u884c\u8bf7\u6c42\u7684\u901a\u7528\u56de\u8c03Done void LibuvStreamWrap::AfterUvShutdown(uv_shutdown_t* req, int status) { LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>( LibuvShutdownWrap::from_req(req)); HandleScope scope(req_wrap->env()->isolate()); Context::Scope context_scope(req_wrap->env()->context()); req_wrap->Done(status); } int LibuvStreamWrap::DoTryWrite(uv_buf_t** bufs, size_t* count) { int err; size_t written; uv_buf_t* vbufs = *bufs; size_t vcount = *count; err = uv_try_write(stream(), vbufs, vcount); if (err == UV_ENOSYS || err == UV_EAGAIN) return 0; if (err < 0) return err; // \u5199\u6210\u529f\u7684\u5b57\u8282\u6570\uff0c\u66f4\u65b0\u6570\u636e written = err; for (; vcount > 0; vbufs++, vcount--) { // Slice if (vbufs[0].len > written) { vbufs[0].base += written; vbufs[0].len -= written; written = 0; break; // Discard } else { written -= vbufs[0].len; } } *bufs = vbufs; *count = vcount; return 0; } int LibuvStreamWrap::DoWrite(WriteWrap* req_wrap, uv_buf_t* bufs, size_t count, uv_stream_t* send_handle) { LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap); return w->Dispatch(uv_write2, stream(), bufs, count, send_handle, AfterUvWrite); } void LibuvStreamWrap::AfterUvWrite(uv_write_t* req, int status) { LibuvWriteWrap* req_wrap = static_cast<LibuvWriteWrap*>( LibuvWriteWrap::from_req(req)); HandleScope scope(req_wrap->env()->isolate()); Context::Scope context_scope(req_wrap->env()->context()); req_wrap->Done(status); } 3 \u8bfb\u64cd\u4f5c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // \u8c03\u7528Libuv\u5b9e\u73b0\u542f\u52a8\u8bfb\u903b\u8f91 int LibuvStreamWrap::ReadStart() { return uv_read_start(stream(), [](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) { static_cast<LibuvStreamWrap*>(handle->data)->OnUvAlloc(suggested_size, buf); }, [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) { static_cast<LibuvStreamWrap*>(stream->data)->OnUvRead(nread, buf); }); } // \u5b9e\u73b0\u505c\u6b62\u8bfb\u903b\u8f91 int LibuvStreamWrap::ReadStop() { return uv_read_stop(stream()); } // \u9700\u8981\u5206\u914d\u5185\u5b58\u65f6\u7684\u56de\u8c03\uff0c\u7531Libuv\u56de\u8c03\uff0c\u5177\u4f53\u5206\u914d\u5185\u5b58\u903b\u8f91\u7531listener\u5b9e\u73b0 void LibuvStreamWrap::OnUvAlloc(size_t suggested_size, uv_buf_t* buf) { HandleScope scope(env()->isolate()); Context::Scope context_scope(env()->context()); *buf = EmitAlloc(suggested_size); } // \u5904\u7406\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 template <class WrapType> static MaybeLocal<Object> AcceptHandle(Environment* env, LibuvStreamWrap* parent) { EscapableHandleScope scope(env->isolate()); Local<Object> wrap_obj; // \u6839\u636e\u7c7b\u578b\u521b\u5efa\u4e00\u4e2a\u8868\u793a\u5ba2\u6237\u7aef\u7684\u5bf9\u8c61\uff0c\u7136\u540e\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5176\u4e2d if (!WrapType::Instantiate(env, parent, WrapType::SOCKET).ToLocal(&wrap_obj)) return Local<Object>(); // \u89e3\u51faC++\u5c42\u5bf9\u8c61 HandleWrap* wrap = Unwrap<HandleWrap>(wrap_obj); CHECK_NOT_NULL(wrap); // \u62ff\u5230C++\u5bf9\u8c61\u4e2d\u5c01\u88c5\u7684handle uv_stream_t* stream = reinterpret_cast<uv_stream_t*>(wrap->GetHandle()); // \u4ece\u670d\u52a1\u5668\u6d41\u4e2d\u6458\u4e0b\u4e00\u4e2afd\u4fdd\u5b58\u5230steam if (uv_accept(parent->stream(), stream)) ABORT(); return scope.Escape(wrap_obj); } // \u5b9e\u73b0OnUvRead\uff0c\u6d41\u4e2d\u6709\u6570\u636e\u6216\u8bfb\u5230\u7ed3\u5c3e\u65f6\u7531Libuv\u56de\u8c03 void LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) { HandleScope scope(env()->isolate()); Context::Scope context_scope(env()->context()); uv_handle_type type = UV_UNKNOWN_HANDLE; // \u662f\u5426\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u5e76\u4e14\u6709\u5f85\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5219\u5224\u65ad\u6587\u4ef6\u63cf\u8ff0\u7b26\u7c7b\u578b if (is_named_pipe_ipc() && uv_pipe_pending_count(reinterpret_cast<uv_pipe_t*>(stream())) > 0) { type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream())); } // \u8bfb\u53d6\u6210\u529f if (nread > 0) { MaybeLocal<Object> pending_obj; // \u6839\u636e\u7c7b\u578b\u521b\u5efa\u4e00\u4e2a\u65b0\u7684C++\u5bf9\u8c61\u8868\u793a\u5ba2\u6237\u7aef\uff0c\u5e76\u4e14\u4ece\u670d\u52a1\u5668\u4e2d\u6458\u4e0b\u4e00\u4e2afd\u4fdd\u5b58\u5230\u5ba2\u6237\u7aef if (type == UV_TCP) { pending_obj = AcceptHandle<TCPWrap>(env(), this); } else if (type == UV_NAMED_PIPE) { pending_obj = AcceptHandle<PipeWrap>(env(), this); } else if (type == UV_UDP) { pending_obj = AcceptHandle<UDPWrap>(env(), this); } else { CHECK_EQ(type, UV_UNKNOWN_HANDLE); } // \u6709\u9700\u8981\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5219\u8bbe\u7f6e\u5230JS\u5c42\u5bf9\u8c61\u4e2d\uff0cJS\u5c42\u4f7f\u7528 if (!pending_obj.IsEmpty()) { object() ->Set(env()->context(), env()->pending_handle_string(), pending_obj.ToLocalChecked()) .Check(); } } // \u89e6\u53d1\u8bfb\u4e8b\u4ef6\uff0clistener\u5b9e\u73b0 EmitRead(nread, *buf); } \u8bfb\u64cd\u4f5c\u4e0d\u4ec5\u652f\u6301\u8bfb\u53d6\u4e00\u822c\u7684\u6570\u636e\uff0c\u8fd8\u53ef\u4ee5\u8bfb\u53d6\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cC++\u5c42\u4f1a\u65b0\u5efa\u4e00\u4e2a\u6d41\u5bf9\u8c61\u8868\u793a\u8be5\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u5728JS\u5c42\u53ef\u4ee5\u4f7f\u7528\u3002 6.8.4 ConnectionWrap \u00b6 ConnectionWrap\u662fLibuvStreamWrap\u5b50\u7c7b\uff0c\u62d3\u5c55\u4e86\u8fde\u63a5\u7684\u63a5\u53e3\u3002\u9002\u7528\u4e8e\u5e26\u6709\u8fde\u63a5\u5c5e\u6027\u7684\u6d41\uff0c\u6bd4\u5982Unix\u57df\u548cTCP\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // WrapType\u662fC++\u5c42\u7684\u7c7b\uff0cUVType\u662fLibuv\u7684\u7c7b\u578b template <typename WrapType, typename UVType> class ConnectionWrap : public LibuvStreamWrap { public: static void OnConnection(uv_stream_t* handle, int status); static void AfterConnect(uv_connect_t* req, int status); protected: ConnectionWrap(Environment* env, v8::Local<v8::Object> object, ProviderType provider); UVType handle_; }; 1 \u53d1\u8d77\u8fde\u63a5\u540e\u7684\u56de\u8c03 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 template <typename WrapType, typename UVType> void ConnectionWrap<WrapType, UVType>::AfterConnect(uv_connect_t* req, int status) { // \u901a\u8fc7Libuv\u7ed3\u6784\u4f53\u62ff\u5230\u5bf9\u5e94\u7684C++\u5bf9\u8c61 std::unique_ptr<ConnectWrap> req_wrap = (static_cast<ConnectWrap*>(req->data)); WrapType* wrap = static_cast<WrapType*>(req->handle->data); Environment* env = wrap->env(); HandleScope handle_scope(env->isolate()); Context::Scope context_scope(env->context()); bool readable, writable; // \u8fde\u63a5\u7ed3\u679c if (status) { readable = writable = false; } else { readable = uv_is_readable(req->handle) != 0; writable = uv_is_writable(req->handle) != 0; } Local<Value> argv[5] = { Integer::New(env->isolate(), status), wrap->object(), req_wrap->object(), Boolean::New(env->isolate(), readable), Boolean::New(env->isolate(), writable) }; // \u56de\u8c03js req_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv); } 2 \u8fde\u63a5\u5230\u6765\u65f6\u56de\u8c03 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // \u6709\u8fde\u63a5\u65f6\u89e6\u53d1\u7684\u56de\u8c03 template <typename WrapType, typename UVType> void ConnectionWrap<WrapType, UVType>::OnConnection(uv_stream_t* handle, int status) { // \u62ff\u5230Libuv\u7ed3\u6784\u4f53\u5bf9\u5e94\u7684C++\u5c42\u5bf9\u8c61 WrapType* wrap_data = static_cast<WrapType*>(handle->data); Environment* env = wrap_data->env(); HandleScope handle_scope(env->isolate()); Context::Scope context_scope(env->context()); // \u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5bf9\u8c61 Local<Value> client_handle; if (status == 0) { // Instantiate the client javascript object and handle. // \u65b0\u5efa\u4e00\u4e2aJS\u5c42\u4f7f\u7528\u5bf9\u8c61 Local<Object> client_obj; if (!WrapType::Instantiate(env, wrap_data, WrapType::SOCKET) .ToLocal(&client_obj)) return; // Unwrap the client javascript object. WrapType* wrap; // \u628aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61client_obj\u6240\u5bf9\u5e94\u7684C++\u5c42\u5bf9\u8c61\u5b58\u5230wrap\u4e2d ASSIGN_OR_RETURN_UNWRAP(&wrap, client_obj); // \u62ff\u5230\u5bf9\u5e94\u7684handle uv_stream_t* client = reinterpret_cast<uv_stream_t*>(&wrap->handle_); // \u4ecehandleaccpet\u5230\u7684fd\u4e2d\u62ff\u4e00\u4e2a\u4fdd\u5b58\u5230client\uff0cclient\u5c31\u53ef\u4ee5\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u4e86 if (uv_accept(handle, client)) return; client_handle = client_obj; } else { client_handle = Undefined(env->isolate()); } // \u56de\u8c03JS\uff0cclient_handle\u76f8\u5f53\u4e8e\u5728JS\u5c42\u6267\u884cnew TCP Local<Value> argv[] = { Integer::New(env->isolate(), status), client_handle }; wrap_data->MakeCallback(env->onconnection_string(), arraysize(argv), argv); } \u6211\u4eec\u770b\u4e00\u4e0bTCP\u7684Instantiate\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 MaybeLocal<Object> TCPWrap::Instantiate(Environment* env, AsyncWrap* parent, TCPWrap::SocketType type) { EscapableHandleScope handle_scope(env->isolate()); AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent); // \u62ff\u5230\u5bfc\u51fa\u5230JS\u5c42\u7684TCP\u6784\u9020\u51fd\u6570\uff0c\u7f13\u5b58\u5728env\u4e2d Local<Function> constructor = env->tcp_constructor_template() ->GetFunction(env->context()) .ToLocalChecked(); Local<Value> type_value = Int32::New(env->isolate(), type); // \u76f8\u5f53\u4e8e\u6211\u4eec\u5728JS\u5c42\u8c03\u7528new TCP()\u65f6\u62ff\u5230\u7684\u5bf9\u8c61 return handle_scope.EscapeMaybe( constructor->NewInstance(env->context(), 1, &type_value)); } 6.8.5 StreamReq \u00b6 StreamReq\u8868\u793a\u64cd\u4f5c\u6d41\u7684\u4e00\u6b21\u8bf7\u6c42\u3002\u4e3b\u8981\u4fdd\u5b58\u4e86\u8bf7\u6c42\u4e0a\u4e0b\u6587\u548c\u64cd\u4f5c\u7ed3\u675f\u540e\u7684\u901a\u7528\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // \u8bf7\u6c42Libuv\u7684\u57fa\u7c7b class StreamReq { public: // JS\u5c42\u4f20\u8fdb\u6765\u7684\u5bf9\u8c61\u7684internalField[1]\u4fdd\u5b58\u4e86StreamReq\u7c7b\u5bf9\u8c61 static constexpr int kStreamReqField = 1; // stream\u4e3a\u6240\u64cd\u4f5c\u7684\u6d41\uff0creq_wrap_obj\u4e3aJS\u5c42\u4f20\u8fdb\u6765\u7684\u5bf9\u8c61 explicit StreamReq(StreamBase* stream, v8::Local<v8::Object> req_wrap_obj) : stream_(stream) { // JS\u5c42\u5bf9\u8c61\u6307\u5411\u5f53\u524dStreamReq\u5bf9\u8c61 AttachToObject(req_wrap_obj); } // \u5b50\u7c7b\u5b9a\u4e49 virtual AsyncWrap* GetAsyncWrap() = 0; // \u83b7\u53d6\u76f8\u5173\u8054\u7684\u539f\u59cbjs\u5bf9\u8c61 v8::Local<v8::Object> object(); // \u8bf7\u6c42\u7ed3\u675f\u540e\u7684\u56de\u8c03\uff0c\u4f1a\u6267\u884c\u5b50\u7c7b\u7684onDone\uff0conDone\u7531\u5b50\u7c7b\u5b9e\u73b0 void Done(int status, const char* error_str = nullptr); // JS\u5c42\u5bf9\u8c61\u4e0d\u518d\u6267\u884cStreamReq\u5b9e\u4f8b void Dispose(); // \u83b7\u53d6\u6240\u64cd\u4f5c\u7684\u6d41 inline StreamBase* stream() const { return stream_; } // \u4eceJS\u5c42\u5bf9\u8c61\u83b7\u53d6StreamReq\u5bf9\u8c61 static StreamReq* FromObject(v8::Local<v8::Object> req_wrap_obj); // \u8bf7\u6c42JS\u5c42\u5bf9\u8c61\u7684internalField\u6240\u6709\u6307\u5411 static inline void ResetObject(v8::Local<v8::Object> req_wrap_obj); protected: // \u8bf7\u6c42\u7ed3\u675f\u540e\u56de\u8c03 virtual void OnDone(int status) = 0; void AttachToObject(v8::Local<v8::Object> req_wrap_obj); private: StreamBase* const stream_; }; StreamReq\u6709\u4e00\u4e2a\u6210\u5458\u4e3astream_\uff0c\u8868\u793aStreamReq\u8bf7\u6c42\u4e2d\u64cd\u4f5c\u7684\u6d41\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0\u3002 1 JS\u5c42\u8bf7\u6c42\u4e0a\u4e0b\u6587\u548cStreamReq\u7684\u5173\u7cfb\u7ba1\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 inline void StreamReq::AttachToObject(v8::Local<v8::Object> req_wrap_obj) { req_wrap_obj->SetAlignedPointerInInternalField(kStreamReqField, this); } inline StreamReq* StreamReq::FromObject(v8::Local<v8::Object> req_wrap_obj) { return static_cast<StreamReq*>( req_wrap_obj->GetAlignedPointerFromInternalField(kStreamReqField)); } inline void StreamReq::Dispose() { object()->SetAlignedPointerInInternalField(kStreamReqField, nullptr); delete this; } inline void StreamReq::ResetObject(v8::Local<v8::Object> obj) { obj->SetAlignedPointerInInternalField(0, nullptr); // BaseObject field. obj->SetAlignedPointerInInternalField(StreamReq::kStreamReqField, nullptr); } 2 \u83b7\u53d6\u539f\u59cbJS\u5c42\u8bf7\u6c42\u5bf9\u8c61 1 2 3 4 // \u83b7\u53d6\u548c\u8be5\u8bf7\u6c42\u76f8\u5173\u8054\u7684\u539f\u59cbjs\u5bf9\u8c61 inline v8::Local<v8::Object> StreamReq::object() { return GetAsyncWrap()->object(); } 3 \u8bf7\u6c42\u7ed3\u675f\u56de\u8c03 1 2 3 4 5 6 7 8 9 10 11 12 13 inline void StreamReq::Done(int status, const char* error_str) { AsyncWrap* async_wrap = GetAsyncWrap(); Environment* env = async_wrap->env(); if (error_str != nullptr) { async_wrap->object()->Set(env->context(), env->error_string(), OneByteString(env->isolate(), error_str)) .Check(); } // \u6267\u884c\u5b50\u7c7b\u7684OnDone OnDone(status); } \u6d41\u64cd\u4f5c\u8bf7\u6c42\u7ed3\u675f\u540e\u4f1a\u7edf\u4e00\u6267\u884cDone\uff0cDone\u4f1a\u6267\u884c\u5b50\u7c7b\u5b9e\u73b0\u7684OnDone\u51fd\u6570\u3002 6.8.6 ShutdownWrap \u00b6 ShutdownWrap\u662fStreamReq\u7684\u5b50\u7c7b\uff0c\u8868\u793a\u4e00\u6b21\u5173\u95ed\u6d41\u8bf7\u6c42\u3002 1 2 3 4 5 6 7 8 class ShutdownWrap : public StreamReq { public: ShutdownWrap(StreamBase* stream, v8::Local<v8::Object> req_wrap_obj) : StreamReq(stream, req_wrap_obj) { } void OnDone(int status) override; }; ShutdownWrap\u5b9e\u73b0\u4e86OnDone\u63a5\u53e3\uff0c\u5728\u5173\u95ed\u6d41\u7ed3\u675f\u540e\u88ab\u57fa\u7c7b\u6267\u884c\u3002 1 2 3 4 5 6 7 8 9 /* \u5173\u95ed\u7ed3\u675f\u65f6\u56de\u8c03\uff0c\u7531\u8bf7\u6c42\u7c7b\uff08ShutdownWrap\uff09\u8c03\u7528Libuv\uff0c \u6240\u4ee5Libuv\u64cd\u4f5c\u5b8c\u6210\u540e\uff0c\u9996\u5148\u6267\u884c\u8bf7\u6c42\u7c7b\u7684\u56de\u8c03\uff0c\u8bf7\u6c42\u7c7b\u901a\u77e5\u6d41\uff0c\u6d41\u89e6\u53d1 \u5bf9\u5e94\u7684\u4e8b\u4ef6\uff0c\u8fdb\u4e00\u6b65\u901a\u77e5listener */ inline void ShutdownWrap::OnDone(int status) { stream()->EmitAfterShutdown(this, status); Dispose(); } 6.8.7 SimpleShutdownWrap \u00b6 SimpleShutdownWrap\u662fShutdownWrap\u7684\u5b50\u7c7b\u3002\u5b9e\u73b0\u4e86GetAsyncWrap\u63a5\u53e3\u3002OtherBase\u53ef\u4ee5\u662fReqWrap\u6216\u8005AsyncWrap\u3002 1 2 3 4 5 6 7 8 template <typename OtherBase> class SimpleShutdownWrap : public ShutdownWrap, public OtherBase { public: SimpleShutdownWrap(StreamBase* stream, v8::Local<v8::Object> req_wrap_obj); AsyncWrap* GetAsyncWrap() override { return this; } }; 6.8.8 WriteWrap \u00b6 WriteWrap\u662fStreamReq\u7684\u5b50\u7c7b\uff0c\u8868\u793a\u4e00\u6b21\u5f80\u6d41\u5199\u5165\u6570\u636e\u7684\u8bf7\u6c42\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 class WriteWrap : public StreamReq { public: void SetAllocatedStorage(AllocatedBuffer&& storage); WriteWrap(StreamBase* stream, v8::Local<v8::Object> req_wrap_obj) : StreamReq(stream, req_wrap_obj) { } void OnDone(int status) override; private: AllocatedBuffer storage_; }; WriteWrap\u5b9e\u73b0\u4e86OnDone\u63a5\u53e3\uff0c\u5728\u5199\u7ed3\u675f\u65f6\u88ab\u57fa\u7c7b\u6267\u884c\u3002 1 2 3 4 inline void WriteWrap::OnDone(int status) { stream()->EmitAfterWrite(this, status); Dispose(); } \u8bf7\u6c42\u7ed3\u675f\u540e\u8c03\u7528\u6d41\u7684\u63a5\u53e3\u901a\u77e5\u6d41\u5199\u7ed3\u675f\u4e86\uff0c\u6d41\u4f1a\u901a\u77e5listener\uff0clistener\u4f1a\u8c03\u7528\u6d41\u7684\u63a5\u53e3\u901a\u77e5JS\u5c42\u3002 6.8.9 SimpleWriteWrap \u00b6 SimpleWriteWrap\u662fWriteWrap\u7684\u5b50\u7c7b\u3002\u5b9e\u73b0\u4e86GetAsyncWrap\u63a5\u53e3\u3002\u548cSimpleShutdownWrap\u7c7b\u578b\u3002 1 2 3 4 5 6 7 8 template <typename OtherBase> class SimpleWriteWrap : public WriteWrap, public OtherBase { public: SimpleWriteWrap(StreamBase* stream, v8::Local<v8::Object> req_wrap_obj); AsyncWrap* GetAsyncWrap() override { return this; } }; 6.8.10 StreamListener \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class StreamListener { public: virtual ~StreamListener(); // \u5206\u914d\u5b58\u50a8\u6570\u636e\u7684\u5185\u5b58 virtual uv_buf_t OnStreamAlloc(size_t suggested_size) = 0; // \u6709\u6570\u636e\u53ef\u8bfb\u65f6\u56de\u8c03\uff0c\u6d88\u8d39\u6570\u636e\u7684\u51fd\u6570 virtual void OnStreamRead(ssize_t nread, const uv_buf_t& buf) = 0; // \u6d41\u9500\u6bc1\u65f6\u56de\u8c03 virtual void OnStreamDestroy() {} // \u76d1\u542c\u8005\u6240\u5c5e\u6d41 inline StreamResource* stream() { return stream_; } protected: // \u6d41\u662f\u76d1\u542c\u8005\u662f\u4e00\u6761\u94fe\u8868\uff0c\u8be5\u51fd\u6570\u628a\u7ed3\u6784\u4f20\u9012\u7ed9\u4e0b\u4e00\u4e2a\u8282\u70b9 void PassReadErrorToPreviousListener(ssize_t nread); // \u76d1\u542c\u8005\u6240\u5c5e\u6d41 StreamResource* stream_ = nullptr; // \u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u5f62\u6210\u94fe\u8868 StreamListener* previous_listener_ = nullptr; friend class StreamResource; }; StreamListener\u662f\u7c7b\u4f3c\u4e00\u4e2a\u8ba2\u9605\u8005\uff0c\u5b83\u4f1a\u5bf9\u6d41\u7684\u72b6\u6001\u611f\u5174\u8da3\uff0c\u6bd4\u5982\u6570\u636e\u53ef\u8bfb\u3001\u53ef\u5199\u3001\u6d41\u5173\u95ed\u7b49\u3002\u4e00\u4e2a\u6d41\u53ef\u4ee5\u6ce8\u518c\u591a\u4e2alistener\uff0c\u591a\u4e2alistener\u5f62\u6210\u4e00\u4e2a\u94fe\u8868\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // \u4ecelisten\u6240\u5c5e\u7684\u6d41\u7684listener\u961f\u5217\u4e2d\u5220\u9664\u81ea\u5df1 inline StreamListener::~StreamListener() { if (stream_ != nullptr) stream_->RemoveStreamListener(this); } // \u8bfb\u51fa\u9519\uff0c\u628a\u4fe1\u606f\u4f20\u9012\u7ed9\u524d\u4e00\u4e2alistener inline void StreamListener::PassReadErrorToPreviousListener(ssize_t nread) { CHECK_NOT_NULL(previous_listener_); previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0)); } // \u5b9e\u73b0\u6d41\u5173\u95ed\u65f6\u7684\u5904\u7406\u903b\u8f91 inline void StreamListener::OnStreamAfterShutdown(ShutdownWrap* w, int status) { previous_listener_->OnStreamAfterShutdown(w, status); } // \u5b9e\u73b0\u5199\u7ed3\u675f\u65f6\u7684\u5904\u7406\u903b\u8f91 inline void StreamListener::OnStreamAfterWrite(WriteWrap* w, int status) { previous_listener_->OnStreamAfterWrite(w, status); } StreamListener\u7684\u903b\u8f91\u4e0d\u591a\uff0c\u5177\u4f53\u7684\u5b9e\u73b0\u5728\u5b50\u7c7b\u3002 6.8.11 ReportWritesToJSStreamListener \u00b6 ReportWritesToJSStreamListener\u662fStreamListener\u7684\u5b50\u7c7b\u3002\u8986\u76d6\u4e86\u90e8\u5206\u63a5\u53e3\u548c\u62d3\u5c55\u4e86\u4e00\u4e9b\u529f\u80fd\u3002 1 2 3 4 5 6 7 8 9 class ReportWritesToJSStreamListener : public StreamListener { public: // \u5b9e\u73b0\u7236\u7c7b\u7684\u8fd9\u4e24\u4e2a\u63a5\u53e3 void OnStreamAfterWrite(WriteWrap* w, int status) override; void OnStreamAfterShutdown(ShutdownWrap* w, int status) override; private: void OnStreamAfterReqFinished(StreamReq* req_wrap, int status); }; 1 OnStreamAfterReqFinished OnStreamAfterReqFinished\u662f\u8bf7\u6c42\u64cd\u4f5c\u6d41\u7ed3\u675f\u540e\u7684\u7edf\u4e00\u7684\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 void ReportWritesToJSStreamListener::OnStreamAfterWrite( WriteWrap* req_wrap, int status) { OnStreamAfterReqFinished(req_wrap, status); } void ReportWritesToJSStreamListener::OnStreamAfterShutdown( ShutdownWrap* req_wrap, int status) { OnStreamAfterReqFinished(req_wrap, status); } \u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void ReportWritesToJSStreamListener::OnStreamAfterReqFinished( StreamReq* req_wrap, int status) { // \u8bf7\u6c42\u6240\u64cd\u4f5c\u7684\u6d41 StreamBase* stream = static_cast<StreamBase*>(stream_); Environment* env = stream->stream_env(); AsyncWrap* async_wrap = req_wrap->GetAsyncWrap(); HandleScope handle_scope(env->isolate()); Context::Scope context_scope(env->context()); // \u83b7\u53d6\u539f\u59cb\u7684JS\u5c42\u5bf9\u8c61 Local<Object> req_wrap_obj = async_wrap->object(); Local<Value> argv[] = { Integer::New(env->isolate(), status), stream->GetObject(), Undefined(env->isolate()) }; const char* msg = stream->Error(); if (msg != nullptr) { argv[2] = OneByteString(env->isolate(), msg); stream->ClearError(); } // \u56de\u8c03JS\u5c42 if (req_wrap_obj->Has(env->context(), env->oncomplete_string()).FromJust()) async_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv); } OnStreamAfterReqFinished\u4f1a\u56de\u8c03JS\u5c42\u3002 6.8.12 EmitToJSStreamListener EmitToJSStreamListener\u662fReportWritesToJSStreamListener\u7684\u5b50\u7c7b 1 2 3 4 5 class EmitToJSStreamListener : public ReportWritesToJSStreamListener { public: uv_buf_t OnStreamAlloc(size_t suggested_size) override; void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override; }; \u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // \u5206\u914d\u4e00\u5757\u5185\u5b58 uv_buf_t EmitToJSStreamListener::OnStreamAlloc(size_t suggested_size) { Environment* env = static_cast<StreamBase*>(stream_)->stream_env(); return env->AllocateManaged(suggested_size).release(); } // \u8bfb\u53d6\u6570\u636e\u7ed3\u675f\u540e\u56de\u8c03 void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf_) { StreamBase* stream = static_cast<StreamBase*>(stream_); Environment* env = stream->stream_env(); HandleScope handle_scope(env->isolate()); Context::Scope context_scope(env->context()); AllocatedBuffer buf(env, buf_); // \u8bfb\u53d6\u5931\u8d25 if (nread <= 0) { if (nread < 0) stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>()); return; } buf.Resize(nread); // \u8bfb\u53d6\u6210\u529f\u56de\u8c03JS\u5c42 stream->CallJSOnreadMethod(nread, buf.ToArrayBuffer()); } \u6211\u4eec\u770b\u5230listener\u5904\u7406\u5b8c\u6570\u636e\u540e\u53c8\u4f1a\u56de\u8c03\u6d41\u7684\u63a5\u53e3\uff0c\u5177\u4f53\u7684\u903b\u8f91\u7531\u5b50\u7c7b\u5b9e\u73b0\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e2a\u5b50\u7c7b\u7684\u5b9e\u73b0\uff08\u6d41\u9ed8\u8ba4\u7684listener\uff09\u3002 1 2 3 4 5 class EmitToJSStreamListener : public ReportWritesToJSStreamListener { public: uv_buf_t OnStreamAlloc(size_t suggested_size) override; void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override; }; EmitToJSStreamListener\u4f1a\u5b9e\u73b0OnStreamRead\u7b49\u65b9\u6cd5\uff0c\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u521b\u5efa\u4e00\u4e2aC++\u5c42\u7684TCP\u5bf9\u8c61\u662f\u600e\u6837\u7684\u3002\u4e0b\u9762\u662fTCPWrap\u7684\u7ee7\u627f\u5173\u7cfb\u3002 1 2 3 4 5 class TCPWrap : public ConnectionWrap<TCPWrap, uv_tcp_t>{} // ConnectionWrap\u62d3\u5c55\u4e86\u5efa\u7acbTCP\u8fde\u63a5\u65f6\u7684\u903b\u8f91 class ConnectionWrap : public LibuvStreamWrap{} class LibuvStreamWrap : public HandleWrap, public StreamBase{} class StreamBase : public StreamResource {} \u6211\u4eec\u770b\u5230TCP\u6d41\u662f\u7ee7\u627f\u4e8eStreamResource\u7684\u3002\u65b0\u5efa\u4e00\u4e2aTCP\u7684C++\u7684\u5bf9\u8c61\u65f6\uff08tcp_wrap.cc\uff09\uff0c\u4f1a\u4e0d\u65ad\u5f80\u4e0a\u8c03\u7528\u7236\u7c7b\u7684\u6784\u9020\u51fd\u6570\uff0c\u5176\u4e2d\u5728StreamBase\u4e2d\u6709\u4e00\u4e2a\u5173\u952e\u7684\u64cd\u4f5c\u3002 1 2 3 4 5 inline StreamBase::StreamBase(Environment* env) : env_(env) { PushStreamListener(&default_listener_); } EmitToJSStreamListener default_listener_; StreamBase\u4f1a\u9ed8\u8ba4\u7ed9\u6d41\u6ce8\u518c\u4e00\u4e2alistener\u3002\u6211\u4eec\u770b\u4e0bEmitToJSStreamListener \u5177\u4f53\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class ReportWritesToJSStreamListener : public StreamListener { public: void OnStreamAfterWrite(WriteWrap* w, int status) override; void OnStreamAfterShutdown(ShutdownWrap* w, int status) override; private: void OnStreamAfterReqFinished(StreamReq* req_wrap, int status); }; class EmitToJSStreamListener : public ReportWritesToJSStreamListener { public: uv_buf_t OnStreamAlloc(size_t suggested_size) override; void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override; }; EmitToJSStreamListener\u7ee7\u627fStreamListener \uff0c\u5b9a\u4e49\u4e86\u5206\u914d\u5185\u5b58\u548c\u8bfb\u53d6\u63a5\u6536\u6570\u636e\u7684\u51fd\u6570\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bPushStreamListener\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002 1 2 3 4 5 6 inline void StreamResource::PushStreamListener(StreamListener* listener) { // \u5934\u63d2\u6cd5 listener->previous_listener_ = listener_; listener->stream_ = this; listener_ = listener; } PushStreamListener\u5c31\u662f\u6784\u9020\u51fa\u4e00\u4e2alistener\u94fe\u8868\u7ed3\u6784\u3002\u7136\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u5bf9\u4e8e\u6d41\u6765\u8bf4\uff0c\u8bfb\u53d6\u6570\u636e\u7684\u6574\u4e2a\u94fe\u8def\u3002\u9996\u5148\u662fJS\u5c42\u8c03\u7528readStart 1 2 3 4 5 6 7 8 9 10 11 function tryReadStart(socket) { socket._handle.reading = true; const err = socket._handle.readStart(); if (err) socket.destroy(errnoException(err, 'read')); } // \u6ce8\u518c\u7b49\u5f85\u8bfb\u4e8b\u4ef6 Socket.prototype._read = function(n) { tryReadStart(this); }; \u6211\u4eec\u770b\u770breadStart 1 2 3 4 5 6 7 8 9 int LibuvStreamWrap::ReadStart() { return uv_read_start(stream(), [](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) { static_cast<LibuvStreamWrap*>(handle->data)->OnUvAlloc(suggested_size, buf); }, [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) { static_cast<LibuvStreamWrap*>(stream->data)->OnUvRead(nread, buf); }); } ReadStart\u8c03\u7528Libuv\u7684uv_read_start\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u5e76\u4e14\u6ce8\u518c\u4e86\u4e24\u4e2a\u56de\u8c03\u51fd\u6570OnUvAlloc\u548cOnUvRead\u3002 1 2 3 4 5 6 7 8 9 10 void LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) { EmitRead(nread, *buf); } inline void StreamResource::EmitRead(ssize_t nread, const uv_buf_t& buf) { // bytes_read_\u8868\u793a\u5df2\u8bfb\u7684\u5b57\u8282\u6570 if (nread > 0) bytes_read_ += static_cast<uint64_t>(nread); listener_->OnStreamRead(nread, buf); } \u901a\u8fc7\u5c42\u5c42\u8c03\u7528\u6700\u540e\u4f1a\u8c03\u7528listener_\u7684OnStreamRead\u3002\u6211\u4eec\u770b\u770bTCP\u7684OnStreamRead 1 2 3 4 5 6 7 8 void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf_) { StreamBase* stream = static_cast<StreamBase*>(stream_); Environment* env = stream->stream_env(); HandleScope handle_scope(env->isolate()); Context::Scope context_scope(env->context()); AllocatedBuffer buf(env, buf_); stream->CallJSOnreadMethod(nread, buf.ToArrayBuffer()); } \u7ee7\u7eed\u56de\u8c03CallJSOnreadMethod 1 2 3 4 5 6 7 8 9 10 11 12 MaybeLocal<Value> StreamBase::CallJSOnreadMethod(ssize_t nread, Local<ArrayBuffer> ab, size_t offset, StreamBaseJSChecks checks) { Environment* env = env_; // ... AsyncWrap* wrap = GetAsyncWrap(); CHECK_NOT_NULL(wrap); Local<Value> onread = wrap->object()->GetInternalField(kOnReadFunctionField); CHECK(onread->IsFunction()); return wrap->MakeCallback(onread.As<Function>(), arraysize(argv), argv); } CallJSOnreadMethod\u4f1a\u56de\u8c03JS\u5c42\u7684onread\u56de\u8c03\u51fd\u6570\u3002onread\u4f1a\u628a\u6570\u636epush\u5230\u6d41\u4e2d\uff0c\u7136\u540e\u89e6\u53d1data\u4e8b\u4ef6\u3002","title":"06-C++\u5c42"},{"location":"chapter06-C%2B%2B%E5%B1%82/#61-baseobject","text":"BaseObject\u662fC++\u5c42\u5927\u591a\u6570\u7c7b\u7684\u57fa\u7c7b\u3002 1 2 3 4 5 6 7 8 9 class BaseObject : public MemoryRetainer { public : // \u2026 private : v8 :: Local < v8 :: Object > WrappedObject () const override ; // \u6307\u5411\u5c01\u88c5\u7684\u5bf9\u8c61 v8 :: Global < v8 :: Object > persistent_handle_ ; Environment * env_ ; }; BaseObject\u7684\u5b9e\u73b0\u5f88\u590d\u6742\uff0c\u8fd9\u91cc\u53ea\u4ecb\u7ecd\u5e38\u7528\u7684\u4e00\u4e9b\u5b9e\u73b0\u3002","title":"6.1 BaseObject"},{"location":"chapter06-C%2B%2B%E5%B1%82/#611","text":"1 2 3 4 5 6 7 8 // \u628a\u5bf9\u8c61\u5b58\u50a8\u5230persistent_handle_\u4e2d\uff0c\u5fc5\u8981\u7684\u65f6\u5019\u901a\u8fc7object()\u53d6\u51fa\u6765 BaseObject :: BaseObject ( Environment * env , v8 :: Local < v8 :: Object > object ) : persistent_handle_ ( env -> isolate (), object ), env_ ( env ) { // \u628athis\u5b58\u5230object\u4e2d object -> SetAlignedPointerInInternalField ( 0 , static_cast < void *> ( this )); } \u6784\u9020\u51fd\u6570\u7528\u4e8e\u4fdd\u5b58\u5bf9\u8c61\u95f4\u7684\u5173\u7cfb\uff08JS\u4f7f\u7528\u7684\u5bf9\u8c61\u548c\u4e0e\u5176\u5173\u7cfb\u7684C++\u5c42\u5bf9\u8c61\uff0c\u4e0b\u56fe\u4e2d\u7684\u5bf9\u8c61\u5373\u6211\u4eec\u5e73\u65f6\u5728JS\u5c42\u4f7f\u7528C++\u6a21\u5757\u521b\u5efa\u7684\u5bf9\u8c61\uff0c\u6bd4\u5982new TCP()\uff09\u3002\u540e\u9762\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u7528\u5904\uff0c\u5173\u7cfb\u5982\u56fe6-1\u6240\u793a\u3002 \u56fe6-1","title":"6.1.1 \u6784\u9020\u51fd\u6570"},{"location":"chapter06-C%2B%2B%E5%B1%82/#612","text":"1 2 3 4 v8 :: Local < v8 :: Object > BaseObject :: object () const { return PersistentToLocal :: Default ( env () -> isolate (), persistent_handle_ ); }","title":"6.1.2 \u83b7\u53d6\u5c01\u88c5\u7684\u5bf9\u8c61"},{"location":"chapter06-C%2B%2B%E5%B1%82/#613-baseobject","text":"1 2 3 4 5 6 7 8 9 // \u901a\u8fc7obj\u53d6\u51fa\u91cc\u9762\u4fdd\u5b58\u7684BaseObject\u5bf9\u8c61 BaseObject * BaseObject::FromJSObject ( v8 :: Local < v8 :: Object > obj ) { return static_cast < BaseObject *> ( obj -> GetAlignedPointerFromInternalField ( 0 )); } template < typename T > T * BaseObject :: FromJSObject ( v8 :: Local < v8 :: Object > object ) { return static_cast < T *> ( FromJSObject ( object )); }","title":"6.1.3 \u4ece\u5bf9\u8c61\u4e2d\u83b7\u53d6\u4fdd\u5b58\u7684BaseObject\u5bf9\u8c61"},{"location":"chapter06-C%2B%2B%E5%B1%82/#614","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 // \u4eceobj\u4e2d\u53d6\u51fa\u5bf9\u5e94\u7684BaseObject\u5bf9\u8c61 template < typename T > inline T * Unwrap ( v8 :: Local < v8 :: Object > obj ) { return BaseObject :: FromJSObject < T > ( obj ); } // \u4eceobj\u4e2d\u83b7\u53d6\u5bf9\u5e94\u7684BaseObject\u5bf9\u8c61\uff0c\u5982\u679c\u4e3a\u7a7a\u5219\u8fd4\u56de\u7b2c\u4e09\u4e2a\u53c2\u6570\u7684\u503c\uff08\u9ed8\u8ba4\u503c\uff09 #define ASSIGN_OR_RETURN_UNWRAP(ptr, obj, ...) \\ do { \\ * ptr = static_cast < typename std :: remove_reference < decltype ( * ptr ) >:: type > ( \\ BaseObject :: FromJSObject ( obj )); \\ if ( * ptr == nullptr ) \\ return __VA_ARGS__ ; \\ } while ( 0 )","title":"6.1.4 \u89e3\u5305"},{"location":"chapter06-C%2B%2B%E5%B1%82/#62-asyncwrap","text":"AsyncWrap\u5b9e\u73b0async_hook\u7684\u6a21\u5757\uff0c\u4e0d\u8fc7\u8fd9\u91cc\u6211\u4eec\u53ea\u5173\u6ce8\u5b83\u56de\u8c03JS\u7684\u529f\u80fd\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 inline v8 :: MaybeLocal < v8 :: Value > AsyncWrap :: MakeCallback ( const v8 :: Local < v8 :: Name > symbol , int argc , v8 :: Local < v8 :: Value >* argv ) { v8 :: Local < v8 :: Value > cb_v ; // \u6839\u636e\u5b57\u7b26\u4e32\u8868\u793a\u7684\u5c5e\u6027\u503c\uff0c\u4ece\u5bf9\u8c61\u4e2d\u53d6\u51fa\u8be5\u5c5e\u6027\u5bf9\u5e94\u7684\u503c\u3002\u662f\u4e2a\u51fd\u6570 if ( ! object () -> Get ( env () -> context (), symbol ). ToLocal ( & cb_v )) return v8 :: MaybeLocal < v8 :: Value > (); // \u662f\u4e2a\u51fd\u6570 if ( ! cb_v -> IsFunction ()) { return v8 :: MaybeLocal < v8 :: Value > (); } // \u56de\u8c03,\u89c1async_wrap.cc return MakeCallback ( cb_v . As < v8 :: Function > (), argc , argv ); } \u4ee5\u4e0a\u53ea\u662f\u5165\u53e3\u51fd\u6570\uff0c\u6211\u4eec\u770b\u770b\u771f\u6b63\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 MaybeLocal<Value> AsyncWrap::MakeCallback(const Local<Function> cb, int argc, Local<Value>* argv) { MaybeLocal<Value> ret = InternalMakeCallback(env(), object(), cb, argc, argv, context); return ret; } \u63a5\u7740\u770b\u4e00\u4e0bInternalMakeCallback 1 2 3 4 5 6 7 8 9 MaybeLocal<Value> InternalMakeCallback(Environment* env, Local<Object> recv, const Local<Function> callback, int argc, Local<Value> argv[], async_context asyncContext) { // \u2026\u7701\u7565\u5176\u4ed6\u4ee3\u7801 // \u6267\u884c\u56de\u8c03 callback->Call(env->context(), recv, argc, argv);}","title":"6.2 AsyncWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#63-handlewrap","text":"HandleWrap\u662f\u5bf9Libuv uv_handle_t\u7684\u5c01\u88c5,\u4e5f\u662f\u5f88\u591aC++\u7c7b\u7684\u57fa\u7c7b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class HandleWrap : public AsyncWrap { public : // \u64cd\u4f5c\u548c\u5224\u65adhandle\u72b6\u6001\u51fd\u6570\uff0c\u89c1Libuv static void Close ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static void Ref ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static void Unref ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static void HasRef ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static inline bool IsAlive ( const HandleWrap * wrap ) { return wrap != nullptr && wrap -> state_ != kClosed ; } static inline bool HasRef ( const HandleWrap * wrap ) { return IsAlive ( wrap ) && uv_has_ref ( wrap -> GetHandle ()); } // \u83b7\u53d6\u5c01\u88c5\u7684handle inline uv_handle_t * GetHandle () const { return handle_ ; } // \u5173\u95edhandle\uff0c\u5173\u95ed\u6210\u529f\u540e\u6267\u884c\u56de\u8c03 virtual void Close ( v8 :: Local < v8 :: Value > close_callback = v8 :: Local < v8 :: Value > ()); static v8 :: Local < v8 :: FunctionTemplate > GetConstructorTemplate ( Environment * env ); protected : HandleWrap ( Environment * env , v8 :: Local < v8 :: Object > object , uv_handle_t * handle , AsyncWrap :: ProviderType provider ); virtual void OnClose () {} // handle\u72b6\u6001 inline bool IsHandleClosing () const { return state_ == kClosing || state_ == kClosed ; } private : friend class Environment ; friend void GetActiveHandles ( const v8 :: FunctionCallbackInfo < v8 :: Value >& ); static void OnClose ( uv_handle_t * handle ); // handle\u961f\u5217 ListNode < HandleWrap > handle_wrap_queue_ ; // handle\u7684\u72b6\u6001 enum { kInitialized , kClosing , kClosed } state_ ; // \u6240\u6709handle\u7684\u57fa\u7c7b uv_handle_t * const handle_ ; };","title":"6.3 HandleWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#631-handle","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Local < FunctionTemplate > HandleWrap :: GetConstructorTemplate ( Environment * env ) { Local < FunctionTemplate > tmpl = env -> handle_wrap_ctor_template (); if ( tmpl . IsEmpty ()) { tmpl = env -> NewFunctionTemplate ( nullptr ); tmpl -> SetClassName ( FIXED_ONE_BYTE_STRING ( env -> isolate (), \"HandleWrap\" )); tmpl -> Inherit ( AsyncWrap :: GetConstructorTemplate ( env )); env -> SetProtoMethod ( tmpl , \"close\" , HandleWrap :: Close ); env -> SetProtoMethodNoSideEffect ( tmpl , \"hasRef\" , HandleWrap :: HasRef ); env -> SetProtoMethod ( tmpl , \"ref\" , HandleWrap :: Ref ); env -> SetProtoMethod ( tmpl , \"unref\" , HandleWrap :: Unref ); env -> set_handle_wrap_ctor_template ( tmpl ); } return tmpl ; } /* object\u4e3aC++\u5c42\u4e3aJS\u5c42\u63d0\u4f9b\u7684\u5bf9\u8c61 handle\u4e3a\u5b50\u7c7b\u5177\u4f53\u7684handle\u7c7b\u578b\uff0c\u4e0d\u540c\u6a21\u5757\u4e0d\u4e00\u6837 */ HandleWrap :: HandleWrap ( Environment * env , Local < Object > object , uv_handle_t * handle , AsyncWrap :: ProviderType provider ) : AsyncWrap ( env , object , provider ), state_ ( kInitialized ), handle_ ( handle ) { // \u4fdd\u5b58Libuv handle\u548cC++\u5bf9\u8c61\u7684\u5173\u7cfb handle_ -> data = this ; HandleScope scope ( env -> isolate ()); CHECK ( env -> has_run_bootstrapping_code ()); // \u63d2\u5165handle\u961f\u5217 env -> handle_wrap_queue () -> PushBack ( this ); } HandleWrap\u7ee7\u627fBaseObject\u7c7b\uff0c\u521d\u59cb\u5316\u540e\u5173\u7cfb\u56fe\u5982\u56fe6-2\u6240\u793a\u3002 \u56fe6-2","title":"6.3.1 \u65b0\u5efahandle\u548c\u521d\u59cb\u5316"},{"location":"chapter06-C%2B%2B%E5%B1%82/#632-handle","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // \u4fee\u6539handle\u4e3a\u6d3b\u8dc3\u72b6\u6001 void HandleWrap::Ref ( const FunctionCallbackInfo < Value >& args ) { HandleWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder ()); if ( IsAlive ( wrap )) uv_ref ( wrap -> GetHandle ()); } // \u4fee\u6539hande\u4e3a\u4e0d\u6d3b\u8dc3\u72b6\u6001 void HandleWrap::Unref ( const FunctionCallbackInfo < Value >& args ) { HandleWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder ()); if ( IsAlive ( wrap )) uv_unref ( wrap -> GetHandle ()); } // \u5224\u65adhandle\u662f\u5426\u5904\u4e8e\u6d3b\u8dc3\u72b6\u6001 void HandleWrap::HasRef ( const FunctionCallbackInfo < Value >& args ) { HandleWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder ()); args . GetReturnValue (). Set ( HasRef ( wrap )); }","title":"6.3.2 \u5224\u65ad\u548c\u64cd\u4f5chandle\u72b6\u6001"},{"location":"chapter06-C%2B%2B%E5%B1%82/#633-handle","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 // \u5173\u95edhandle\uff08JS\u5c42\u8c03\u7528\uff09\uff0c\u6210\u529f\u540e\u6267\u884c\u56de\u8c03 void HandleWrap::Close ( const FunctionCallbackInfo < Value >& args ) { HandleWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder ()); // \u4f20\u5165\u56de\u8c03 wrap -> Close ( args [ 0 ]); } // \u771f\u6b63\u5173\u95edhandle\u7684\u51fd\u6570 void HandleWrap::Close ( Local < Value > close_callback ) { // \u6b63\u5728\u5173\u95ed\u6216\u5df2\u7ecf\u5173\u95ed if ( state_ != kInitialized ) return ; // \u8c03\u7528Libuv\u51fd\u6570 uv_close ( handle_ , OnClose ); // \u5173\u95ed\u4e2d state_ = kClosing ; // \u4f20\u4e86\u56de\u8c03\u5219\u4fdd\u5b58\u8d77\u6765 if ( ! close_callback . IsEmpty () && close_callback -> IsFunction () && ! persistent (). IsEmpty ()) { object () -> Set ( env () -> context (), env () -> handle_onclose_symbol (), close_callback ). Check (); } } // \u5173\u95edhandle\u6210\u529f\u540e\u56de\u8c03 void HandleWrap::OnClose ( uv_handle_t * handle ) { BaseObjectPtr < HandleWrap > wrap { static_cast < HandleWrap *> ( handle -> data ) }; wrap -> Detach (); Environment * env = wrap -> env (); HandleScope scope ( env -> isolate ()); Context :: Scope context_scope ( env -> context ()); wrap -> state_ = kClosed ; wrap -> OnClose (); wrap -> handle_wrap_queue_ . Remove (); // \u6709onclose\u56de\u8c03\u5219\u6267\u884c if ( ! wrap -> persistent (). IsEmpty () && wrap -> object () -> Has ( env -> context (), env -> handle_onclose_symbol ()) . FromMaybe ( false )) { wrap -> MakeCallback ( env -> handle_onclose_symbol (), 0 , nullptr ); } }","title":"6.3.3 \u5173\u95edhandle"},{"location":"chapter06-C%2B%2B%E5%B1%82/#64-reqwrap","text":"ReqWrap\u8868\u793a\u901a\u8fc7Libuv\u5bf9handle\u7684\u4e00\u6b21\u8bf7\u6c42\u3002","title":"6.4 ReqWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#641-reqwrapbase","text":"1 2 3 4 5 6 7 8 9 10 11 class ReqWrapBase { public : explicit inline ReqWrapBase ( Environment * env ); virtual ~ ReqWrapBase () = default ; virtual void Cancel () = 0 ; virtual AsyncWrap * GetAsyncWrap () = 0 ; private : // \u4e00\u4e2a\u5e26\u524d\u540e\u6307\u9488\u7684\u8282\u70b9 ListNode < ReqWrapBase > req_wrap_queue_ ; }; ReqWrapBase\u4e3b\u8981\u662f\u5b9a\u4e49\u63a5\u53e3\u7684\u534f\u8bae\u3002\u6211\u4eec\u770b\u4e00\u4e0bReqWrapBase\u7684\u5b9e\u73b0 1 2 3 ReqWrapBase :: ReqWrapBase ( Environment * env ) { env -> req_wrap_queue () -> PushBack ( this ); } ReqWrapBase\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u4f1a\u628a\u81ea\u5df1\u52a0\u5230env\u5bf9\u8c61\u7684req\u961f\u5217\u4e2d\u3002","title":"6.4.1 ReqWrapBase"},{"location":"chapter06-C%2B%2B%E5%B1%82/#642-reqwrap","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 template < typename T > class ReqWrap : public AsyncWrap , public ReqWrapBase { public : inline ReqWrap ( Environment * env , v8 :: Local < v8 :: Object > object , AsyncWrap :: ProviderType provider ); inline ~ ReqWrap () override ; inline void Dispatched (); inline void Reset (); T * req () { return & req_ ; } inline void Cancel () final ; inline AsyncWrap * GetAsyncWrap () override ; static ReqWrap * from_req ( T * req ); template < typename LibuvFunction , typename ... Args > // \u8c03\u7528Libuv inline int Dispatch ( LibuvFunction fn , Args ... args ); public : typedef void ( * callback_t )(); callback_t original_callback_ = nullptr ; protected : T req_ ; }; } \u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 template < typename T > ReqWrap < T >:: ReqWrap ( Environment * env , v8 :: Local < v8 :: Object > object , AsyncWrap :: ProviderType provider ) : AsyncWrap ( env , object , provider ), ReqWrapBase ( env ) { // \u521d\u59cb\u5316\u72b6\u6001 Reset (); } // \u4fdd\u5b58libuv\u6570\u636e\u7ed3\u6784\u548cReqWrap\u5b9e\u4f8b\u7684\u5173\u7cfb template < typename T > void ReqWrap < T >:: Dispatched () { req_ . data = this ; } // \u91cd\u7f6e\u5b57\u6bb5 template < typename T > void ReqWrap < T >:: Reset () { original_callback_ = nullptr ; req_ . data = nullptr ; } // \u901a\u8fc7req\u6210\u5458\u627e\u6240\u5c5e\u5bf9\u8c61\u7684\u5730\u5740 template < typename T > ReqWrap < T >* ReqWrap < T >:: from_req ( T * req ) { return ContainerOf ( & ReqWrap < T >:: req_ , req ); } // \u53d6\u6d88\u7ebf\u7a0b\u6c60\u4e2d\u7684\u8bf7\u6c42 template < typename T > void ReqWrap < T >:: Cancel () { if ( req_ . data == this ) uv_cancel ( reinterpret_cast < uv_req_t *> ( & req_ )); } template < typename T > AsyncWrap * ReqWrap < T >:: GetAsyncWrap () { return this ; } // \u8c03\u7528Libuv\u51fd\u6570 template < typename T > template < typename LibuvFunction , typename ... Args > int ReqWrap < T >:: Dispatch ( LibuvFunction fn , Args ... args ) { Dispatched (); int err = CallLibuvFunction < T , LibuvFunction >:: Call ( // Libuv\u51fd\u6570 fn , env () -> event_loop (), req (), MakeLibuvRequestCallback < T , Args >:: For ( this , args )...); if ( err >= 0 ) env () -> IncreaseWaitingRequestCounter (); return err ; } \u6211\u4eec\u770b\u5230ReqWrap\u62bd\u8c61\u4e86\u8bf7\u6c42Libuv\u7684\u8fc7\u7a0b\uff0c\u5177\u4f53\u8bbe\u8ba1\u7684\u6570\u636e\u7ed3\u6784\u7531\u5b50\u7c7b\u5b9e\u73b0\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u67d0\u4e2a\u5b50\u7c7b\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 // \u8bf7\u6c42Libuv\u65f6\uff0c\u6570\u636e\u7ed3\u6784\u662fuv_connect_t\uff0c\u8868\u793a\u4e00\u6b21\u8fde\u63a5\u8bf7\u6c42 class ConnectWrap : public ReqWrap < uv_connect_t > { public : ConnectWrap ( Environment * env , v8 :: Local < v8 :: Object > req_wrap_obj , AsyncWrap :: ProviderType provider ); };","title":"6.4.2 ReqWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#65-jsc","text":"JS\u8c03\u7528C++\u6a21\u5757\u662fV8\u63d0\u4f9b\u7684\u80fd\u529b\uff0cNode.js\u662f\u4f7f\u7528\u4e86\u8fd9\u4e2a\u80fd\u529b\u3002\u8fd9\u6837\u6211\u4eec\u53ea\u9700\u8981\u9762\u5bf9JS\uff0c\u5269\u4e0b\u7684\u4e8b\u60c5\u4ea4\u7ed9Node.js\u5c31\u884c\u3002\u672c\u6587\u9996\u5148\u8bb2\u4e00\u4e0b\u5229\u7528V8\u5982\u4f55\u5b9e\u73b0JS\u8c03\u7528C++\uff0c\u7136\u540e\u518d\u8bb2\u4e00\u4e0bNode.js\u662f\u600e\u4e48\u505a\u7684\u3002 1 JS\u8c03\u7528C++ \u9996\u5148\u4ecb\u7ecd\u4e00\u4e0bV8\u4e2d\u4e24\u4e2a\u975e\u5e38\u6838\u5fc3\u7684\u7c7bFunctionTemplate\u548cObjectTemplate\u3002\u987e\u540d\u601d\u4e49\uff0c\u8fd9\u4e24\u4e2a\u7c7b\u662f\u5b9a\u4e49\u6a21\u677f\u7684\uff0c\u597d\u6bd4\u5efa\u623f\u5b50\u65f6\u7684\u8bbe\u8ba1\u56fe\u4e00\u6837\uff0c\u901a\u8fc7\u8bbe\u8ba1\u56fe\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u9020\u51fa\u5bf9\u5e94\u7684\u623f\u5b50\u3002V8\u4e5f\u662f\uff0c\u5b9a\u4e49\u67d0\u79cd\u6a21\u677f\uff0c\u5c31\u53ef\u4ee5\u901a\u8fc7\u8fd9\u4e2a\u6a21\u677f\u521b\u5efa\u51fa\u5bf9\u5e94\u7684\u5b9e\u4f8b\u3002\u4e0b\u9762\u4ecb\u7ecd\u4e00\u4e0b\u8fd9\u4e9b\u6982\u5ff5\uff08\u4e3a\u4e86\u65b9\u4fbf\uff0c\u4e0b\u9762\u90fd\u662f\u4f2a\u4ee3\u7801)\u3002 1.1 \u5b9a\u4e49\u4e00\u4e2a\u51fd\u6570\u6a21\u677f 1 2 3 Local < FunctionTemplate > functionTemplate = v8 :: FunctionTemplate :: New ( isolate (), New ); // \u5b9a\u4e49\u51fd\u6570\u7684\u540d\u5b57 functionTemplate -> SetClassName ( \u2018 TCP \u2019 ) \u9996\u5148\u5b9a\u4e49\u4e00\u4e2aFunctionTemplate\u5bf9\u8c61\u3002\u6211\u4eec\u770b\u5230FunctionTemplate\u7684\u7b2c\u4e8c\u4e2a\u5165\u53c2\u662f\u4e00\u4e2a\u51fd\u6570\uff0c\u5f53\u6211\u4eec\u6267\u884c\u7531FunctionTemplate\u521b\u5efa\u7684\u51fd\u6570\u65f6\uff0cv8\u5c31\u4f1a\u6267\u884cNew\u51fd\u6570\u3002\u5f53\u7136\u6211\u4eec\u4e5f\u53ef\u4ee5\u4e0d\u4f20\u3002 1.2 \u5b9a\u4e49\u51fd\u6570\u6a21\u677f\u7684prototype\u5185\u5bb9 prototype\u5c31\u662fJS\u91cc\u7684function.prototype\u3002\u5982\u679c\u4f60\u7406\u89e3JS\u91cc\u7684\u77e5\u8bc6\uff0c\u5c31\u5f88\u5bb9\u6613\u7406\u89e3C++\u7684\u4ee3\u7801\u3002 1 2 3 4 v8 :: Local < v8 :: FunctionTemplate > t = v8 :: FunctionTemplate :: New ( isolate (), callback ); t -> SetClassName ( ' test ' ); // \u5728prototype\u4e0a\u5b9a\u4e49\u4e00\u4e2a\u5c5e\u6027 t -> PrototypeTemplate () -> Set ( ' hello ' , ' world ' ); 1.3 \u5b9a\u4e49\u51fd\u6570\u6a21\u677f\u5bf9\u5e94\u7684\u5b9e\u4f8b\u6a21\u677f\u7684\u5185\u5bb9 \u5b9e\u4f8b\u6a21\u677f\u5c31\u662f\u4e00\u4e2aObjectTemplate\u5bf9\u8c61\u3002\u5b83\u5b9a\u4e49\u4e86\uff0c\u5f53\u4ee5new\u7684\u65b9\u5f0f\u6267\u884c\u7531\u51fd\u6570\u6a21\u677f\u521b\u5efa\u51fa\u6765\u7684\u51fd\u6570\u65f6\uff0c\u8fd4\u56de\u503c\u6240\u5177\u6709\u7684\u5c5e\u6027\u3002 1 2 3 4 5 function A () { this . a = 1 ; this . b = 2 ; } new A (); \u5b9e\u4f8b\u6a21\u677f\u7c7b\u4f3c\u4e0a\u9762\u4ee3\u7801\u4e2dA\u51fd\u6570\u91cc\u9762\u7684\u4ee3\u7801\u3002\u6211\u4eec\u770b\u770b\u5728V8\u91cc\u600e\u4e48\u5b9a\u4e49\u3002 1 2 t -> InstanceTemplate () -> Set ( key , val ); t -> InstanceTemplate () -> SetInternalFieldCount ( 1 ); InstanceTemplate\u8fd4\u56de\u7684\u662f\u4e00\u4e2aObjectTemplate\u5bf9\u8c61\u3002SetInternalFieldCount\u8fd9\u4e2a\u51fd\u6570\u6bd4\u8f83\u7279\u6b8a\uff0c\u4e5f\u662f\u6bd4\u8f83\u91cd\u8981\u7684\u4e00\u4e2a\u5730\u65b9\uff0c\u6211\u4eec\u77e5\u9053\u5bf9\u8c61\u5c31\u662f\u4e00\u5757\u5185\u5b58\uff0c\u5bf9\u8c61\u6709\u5b83\u81ea\u5df1\u7684\u5185\u5b58\u5e03\u5c40\uff0c\u6211\u4eec\u77e5\u9053\u5728C++\u91cc\uff0c\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2a\u7c7b\uff0c\u4e5f\u5c31\u5b9a\u4e49\u4e86\u5bf9\u8c61\u7684\u5e03\u5c40\u3002\u6bd4\u5982\u6211\u4eec\u6709\u4ee5\u4e0b\u5b9a\u4e49\u3002 1 2 3 4 5 6 class demo { private : int a ; int b ; }; \u5728\u5185\u5b58\u4e2d\u5e03\u5c40\u5982\u56fe6-3\u6240\u793a\u3002 \u56fe6-3 \u4e0a\u9762\u8fd9\u79cd\u65b9\u5f0f\u6709\u4e2a\u95ee\u9898\uff0c\u5c31\u662f\u7c7b\u5b9a\u4e49\u4e4b\u540e\uff0c\u5185\u5b58\u5e03\u5c40\u5c31\u56fa\u5b9a\u4e86\u3002\u800cV8\u662f\u81ea\u5df1\u53bb\u63a7\u5236\u5bf9\u8c61\u7684\u5185\u5b58\u5e03\u5c40\u7684\u3002\u5f53\u6211\u4eec\u5728V8\u4e2d\u5b9a\u4e49\u4e00\u4e2a\u7c7b\u7684\u65f6\u5019\uff0c\u662f\u6ca1\u6709\u4efb\u4f55\u5c5e\u6027\u7684\u3002\u6211\u4eec\u770b\u4e00\u4e0bV8\u4e2dHeapObject\u7c7b\u7684\u5b9a\u4e49\u3002 1 2 3 4 class HeapObject : public Object { static const int kMapOffset = Object :: kSize ; // Object::kSize\u662f0 static const int kSize = kMapOffset + kPointerSize ; }; \u8fd9\u65f6\u5019\u7684\u5185\u5b58\u5e03\u5c40\u5982\u4e0b\u3002 \u7136\u540e\u6211\u4eec\u518d\u770b\u4e00\u4e0bHeapObject\u5b50\u7c7bHeapNumber\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 class HeapNumber : public HeapObject { // kSize\u4e4b\u524d\u7684\u7a7a\u95f4\u5b58\u50a8map\u5bf9\u8c61\u7684\u6307\u9488 static const int kValueOffset = HeapObject :: kSize ; // kValueOffset - kSize\u4e4b\u95f4\u5b58\u50a8\u6570\u5b57\u7684\u503c static const int kSize = kValueOffset + kDoubleSize ; }; \u5185\u5b58\u5e03\u5c40\u5982\u56fe6-4\u6240\u793a\u3002 \u56fe6-4 \u6211\u4eec\u53d1\u73b0\u8fd9\u4e9b\u7c7b\u53ea\u6709\u51e0\u4e2a\u7c7b\u53d8\u91cf\uff0c\u7c7b\u53d8\u91cf\u662f\u4e0d\u4fdd\u5b58\u5728\u5bf9\u8c61\u5185\u5b58\u7a7a\u95f4\u7684\u3002\u8fd9\u4e9b\u7c7b\u53d8\u91cf\u5c31\u662f\u5b9a\u4e49\u4e86\u5bf9\u8c61\u6bcf\u4e2a\u57df\u6240\u5360\u5185\u5b58\u7a7a\u95f4\u7684\u4fe1\u606f\uff0c\u5f53\u6211\u4eec\u5b9a\u4e49\u4e00\u4e2aHeapObject\u5bf9\u8c61\u7684\u65f6\u5019\uff0cV8\u9996\u5148\u7533\u8bf7\u4e00\u5757\u5185\u5b58\uff0c\u7136\u540e\u628a\u8fd9\u5757\u5185\u5b58\u9996\u5730\u5740\u5f3a\u884c\u8f6c\u6210\u5bf9\u5e94\u5bf9\u8c61\u7684\u6307\u9488\u3002\u7136\u540e\u901a\u8fc7\u7c7b\u53d8\u91cf\u5bf9\u5c5e\u6027\u7684\u5185\u5b58\u8fdb\u884c\u5b58\u53d6\u3002\u6211\u4eec\u770b\u770b\u5728V8\u91cc\u5982\u4f55\u7533\u8bf7\u4e00\u4e2aHeapNumber\u5bf9\u8c61 1 2 3 4 5 6 7 8 9 10 11 12 13 Object * Heap::AllocateHeapNumber ( double value , PretenureFlag pretenure ) { // \u5728\u54ea\u4e2a\u7a7a\u95f4\u5206\u914d\u5185\u5b58\uff0c\u6bd4\u5982\u65b0\u751f\u4ee3\uff0c\u8001\u751f\u4ee3 AllocationSpace space = ( pretenure == TENURED ) ? CODE_SPACE : NEW_SPACE ; // \u5728space\u4e0a\u5206\u914d\u4e00\u4e2aHeapNumber\u5bf9\u8c61\u5927\u5c0f\u7684\u5185\u5b58 Object * result = AllocateRaw ( HeapNumber :: kSize , space ); /* \u8f6c\u6210HeapObect\uff0c\u8bbe\u7f6emap\u5c5e\u6027\uff0cmap\u5c5e\u6027\u662f\u8868\u793a\u5bf9\u8c61\u7c7b\u578b\u3001\u5927\u5c0f\u7b49\u4fe1\u606f\u7684 */ HeapObject :: cast ( result ) -> set_map ( heap_number_map ()); // \u8f6c\u6210HeapNumber\u5bf9\u8c61 HeapNumber :: cast ( result ) -> set_value ( value ); return result ; } \u56de\u5230\u5bf9\u8c61\u6a21\u677f\u7684\u95ee\u9898\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5bf9\u8c61\u6a21\u677f\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 class TemplateInfo : public Struct { static const int kTagOffset = HeapObject :: kSize ; static const int kPropertyListOffset = kTagOffset + kPointerSize ; static const int kHeaderSize = kPropertyListOffset + kPointerSize ; }; class ObjectTemplateInfo : public TemplateInfo { static const int kConstructorOffset = TemplateInfo :: kHeaderSize ; static const int kInternalFieldCountOffset = kConstructorOffset + kPointerSize ; static const int kSize = kInternalFieldCountOffset + kHeaderSize ; }; \u5185\u5b58\u5e03\u5c40\u5982\u56fe6-5\u6240\u793a\u3002 \u56fe6-5 \u56de\u5230\u5bf9\u8c61\u6a21\u677f\u7684\u95ee\u9898\uff0c\u6211\u4eec\u770b\u770bSet(key, val)\u505a\u4e86\u4ec0\u4e48\u3002 1 2 3 4 5 6 7 8 9 void Template::Set ( v8 :: Handle < String > name , v8 :: Handle < Data > value , v8 :: PropertyAttribute attribute ) { // ... i :: Handle < i :: Object > list ( Utils :: OpenHandle ( this ) -> property_list ()); NeanderArray array ( list ); array . add ( Utils :: OpenHandle ( * name )); array . add ( Utils :: OpenHandle ( * value )); array . add ( Utils :: OpenHandle ( * v8 :: Integer :: New ( attribute ))); } \u4e0a\u9762\u7684\u4ee3\u7801\u5927\u81f4\u5c31\u662f\u7ed9\u4e00\u4e2alist\u540e\u9762\u8ffd\u52a0\u4e00\u4e9b\u5185\u5bb9\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2alist\u662f\u600e\u4e48\u6765\u7684\uff0c\u5373property_list\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 // \u8bfb\u53d6\u5bf9\u8c61\u4e2d\u67d0\u4e2a\u5c5e\u6027\u7684\u503c #define READ_FIELD(p, offset) (*reinterpret_cast<Object**>(FIELD_ADDR(p, offset)) static Object * cast ( Object * value ) { return value ; } Object * TemplateInfo::property_list () { return Object :: cast ( READ_FIELD ( this , kPropertyListOffset )); } \u4ece\u4e0a\u9762\u4ee3\u7801\u4e2d\u6211\u4eec\u77e5\u9053\uff0c\u5185\u90e8\u5e03\u5c40\u5982\u56fe6-6\u6240\u793a\u3002 \u56fe6-6 \u6839\u636e\u5185\u5b58\u5e03\u5c40\uff0c\u6211\u4eec\u77e5\u9053property_list\u7684\u503c\u662flist\u6307\u5411\u7684\u503c\u3002\u6240\u4ee5Set(key, val)\u64cd\u4f5c\u7684\u5185\u5b58\u5e76\u4e0d\u662f\u5bf9\u8c61\u672c\u8eab\u7684\u5185\u5b58\uff0c\u5bf9\u8c61\u5229\u7528\u4e00\u4e2a\u6307\u9488\u6307\u5411\u4e00\u5757\u5185\u5b58\u4fdd\u5b58Set(key, val)\u7684\u503c\u3002SetInternalFieldCount\u51fd\u6570\u5c31\u4e0d\u4e00\u6837\u4e86\uff0c\u5b83\u4f1a\u5f71\u54cd\uff08\u6269\u5f20\uff09\u5bf9\u8c61\u672c\u8eab\u7684\u5185\u5b58\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u5b83\u7684\u5b9e\u73b0\u3002 1 2 3 4 void ObjectTemplate::SetInternalFieldCount ( int value ) { // \u4fee\u6539\u7684\u662fkInternalFieldCountOffset\u5bf9\u5e94\u7684\u5185\u5b58\u7684\u503c Utils :: OpenHandle ( this ) -> set_internal_field_count ( i :: Smi :: FromInt ( value )); } \u6211\u4eec\u770b\u5230SetInternalFieldCount\u51fd\u6570\u7684\u5b9e\u73b0\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u5728\u5bf9\u8c61\u672c\u8eab\u7684\u5185\u5b58\u4e2d\u4fdd\u5b58\u4e00\u4e2a\u6570\u5b57\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u5b57\u6bb5\u7684\u4f7f\u7528\u3002\u540e\u9762\u4f1a\u8be6\u7ec6\u4ecb\u7ecd\u5b83\u7684\u7528\u5904\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Handle < JSFunction > Factory :: CreateApiFunction ( Handle < FunctionTemplateInfo > obj , bool is_global ) { int internal_field_count = 0 ; if ( ! obj -> instance_template () -> IsUndefined ()) { // \u83b7\u53d6\u51fd\u6570\u6a21\u677f\u7684\u5b9e\u4f8b\u6a21\u677f Handle < ObjectTemplateInfo > instance_template = Handle < ObjectTemplateInfo > ( ObjectTemplateInfo :: cast ( obj -> instance_template ())); // \u83b7\u53d6\u5b9e\u4f8b\u6a21\u677f\u7684internal_field_count\u5b57\u6bb5\u7684\u503c\uff08\u901a\u8fc7SetInternalFieldCount\u8bbe\u7f6e\u7684\u90a3\u4e2a\u503c\uff09 internal_field_count = Smi :: cast ( instance_template -> internal_field_count ()) -> value (); } // \u8ba1\u7b97\u65b0\u5efa\u5bf9\u8c61\u9700\u8981\u7684\u7a7a\u95f4\uff0c\u5982\u679c int instance_size = kPointerSize * internal_field_count ; if ( is_global ) { instance_size += JSGlobalObject :: kSize ; } else { instance_size += JSObject :: kHeaderSize ; } InstanceType type = is_global ? JS_GLOBAL_OBJECT_TYPE : JS_OBJECT_TYPE ; // \u65b0\u5efa\u4e00\u4e2a\u51fd\u6570\u5bf9\u8c61 Handle < JSFunction > result = Factory :: NewFunction ( Factory :: empty_symbol (), type , instance_size , code , true ); } \u6211\u4eec\u770b\u5230internal_field_count\u7684\u503c\u7684\u610f\u4e49\u662f\uff0c\u4f1a\u6269\u5f20\u5bf9\u8c61\u7684\u5185\u5b58\uff0c\u6bd4\u5982\u4e00\u4e2a\u5bf9\u8c61\u672c\u8eab\u53ea\u6709n\u5b57\u8282\uff0c\u5982\u679c\u5b9a\u4e49internal_field_count\u7684\u503c\u662f1\uff0c\u5bf9\u8c61\u7684\u5185\u5b58\u5c31\u4f1a\u53d8\u6210n+internal_field_count * \u4e00\u4e2a\u6307\u9488\u7684\u5b57\u8282\u6570\u3002\u5185\u5b58\u5e03\u5c40\u5982\u56fe6-7\u6240\u793a\u3002 \u56fe6-7 1.4 \u901a\u8fc7\u51fd\u6570\u6a21\u677f\u521b\u5efa\u4e00\u4e2a\u51fd\u6570 Local functionTemplate = v8::FunctionTemplate::New(isolate(), New); global->Set('demo', functionTemplate ->GetFunction()); \u8fd9\u6837\u6211\u4eec\u5c31\u53ef\u4ee5\u5728JS\u91cc\u76f4\u63a5\u8c03\u7528demo\u8fd9\u4e2a\u53d8\u91cf\uff0c\u7136\u540e\u5bf9\u5e94\u7684\u51fd\u6570\u5c31\u4f1a\u88ab\u6267\u884c\u3002\u8fd9\u5c31\u662fJS\u8c03\u7528C++\u7684\u539f\u7406\u3002 2 Node.js\u662f\u5982\u4f55\u5904\u7406JS\u8c03\u7528C++\u95ee\u9898\u7684 \u6211\u4eec\u4ee5TCP\u6a21\u5757\u4e3a\u4f8b\u3002 1 2 const { TCP } = process . binding ( 'tcp_wrap' ); new TCP (...); Node.js\u901a\u8fc7\u5b9a\u4e49\u4e00\u4e2a\u5168\u5c40\u53d8\u91cfprocess\u7edf\u4e00\u5904\u7406C++\u6a21\u5757\u7684\u8c03\u7528\uff0c\u5177\u4f53\u53c2\u8003\u6a21\u5757\u52a0\u8f7d\u7ae0\u8282\u7684\u5185\u5bb9\u3002\u5728Node.js\u4e2d\uff0cC++\u6a21\u5757\uff08\u7c7b\uff09\u4e00\u822c\u53ea\u4f1a\u5b9a\u4e49\u5bf9\u5e94\u7684Libuv\u7ed3\u6784\u4f53\u548c\u4e00\u7cfb\u5217\u7c7b\u51fd\u6570\uff0c\u7136\u540e\u521b\u5efa\u4e00\u4e2a\u51fd\u6570\u6a21\u7248\uff0c\u5e76\u4f20\u5165\u4e00\u4e2a\u56de\u8c03\uff0c\u63a5\u7740\u628a\u8fd9\u4e9b\u7c7b\u51fd\u6570\u6302\u8f7d\u5230\u51fd\u6570\u6a21\u677f\u4e2d,\u6700\u540e\u901a\u8fc7\u51fd\u6570\u6a21\u677f\u8fd4\u56de\u4e00\u4e2a\u51fd\u6570F\u7ed9JS\u5c42\u4f7f\u7528\uff0c\u7ffb\u8bd1\u6210JS\u5927\u81f4\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // Libuv function uv_tcp_connect ( uv_tcp_t , addr , cb ) { cb (); } // C++ class TCPWrap { uv_tcp_t = {}; static Connect ( cb ) { const tcpWrap = this [ 0 ]; uv_tcp_connect ( tcpWrap . uv_tcp_t , { ip : '127.0.0.1' , port : 80 }, () => { cb (); } ); } } function FunctionTemplate ( cb ) { function Tmp () { Object . assign ( this , map ); cb ( this ); } const map = {}; return { PrototypeTemplate : function () { return { set : function ( k , v ) { Tmp . prototype [ k ] = v ; } } }, InstanceTemplate : function () { return { set : function ( k , v ) { map [ k ] = v ; } } }, GetFunction () { return Tmp ; } } } const TCPFunctionTemplate = FunctionTemplate (( target ) => { target [ 0 ] = new TCPWrap (); }) TCPFunctionTemplate . PrototypeTemplate (). set ( 'connect' , TCPWrap . Connect ); TCPFunctionTemplate . InstanceTemplate (). set ( 'name' , 'hi' ); const TCP = TCPFunctionTemplate . GetFunction (); // js const tcp = new TCP (); tcp . connect (() => { console . log ( '\u8fde\u63a5\u6210\u529f' ); }); tcp . name ; \u6211\u4eec\u4eceC++\u7684\u5c42\u9762\u5206\u6790\u6267\u884cnew TCP()\u7684\u903b\u8f91\uff0c\u7136\u540e\u518d\u5206\u6790connect\u7684\u903b\u8f91\uff0c\u8fd9\u4e24\u4e2a\u903b\u8f91\u6d89\u53ca\u7684\u673a\u5236\u662f\u5176\u5b83C++\u6a21\u5757\u4e5f\u4f1a\u4f7f\u7528\u5230\u7684\u3002\u56e0\u4e3aTCP\u5bf9\u5e94\u7684\u51fd\u6570\u662fInitialize\u51fd\u6570\u91cc\u7684t->GetFunction()\u5bf9\u5e94\u7684\u503c\u3002\u6240\u4ee5new TCP()\u7684\u65f6\u5019\uff0cV8\u9996\u5148\u4f1a\u521b\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u7136\u540e\u6267\u884cNew\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void TCPWrap::New ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); int type_value = args [ 0 ]. As < Int32 > () -> Value (); TCPWrap :: SocketType type = static_cast < TCPWrap :: SocketType > ( type_value ); ProviderType provider ; switch ( type ) { case SOCKET : provider = PROVIDER_TCPWRAP ; break ; case SERVER : provider = PROVIDER_TCPSERVERWRAP ; break ; default : UNREACHABLE (); } /* args.This()\u4e3av8\u63d0\u4f9b\u7684\u4e00\u4e2aC++\u5bf9\u8c61\uff08\u7531Initialize\u51fd\u6570\u5b9a\u4e49\u7684\u6a21\u5757\u521b\u5efa\u7684\uff09 \u8c03\u7528\u8be5C++\u5bf9\u8c61\u7684SetAlignedPointerInInternalField(0,this)\u5173\u8054this\uff08new TCPWrap()\uff09, \u89c1HandleWrap */ new TCPWrap ( env , args . This (), provider ); } \u6211\u4eec\u6cbf\u7740TCPWrap\u7684\u7ee7\u627f\u5173\u7cfb\uff0c\u4e00\u76f4\u5230HandleWrap 1 2 3 4 5 6 7 8 9 10 11 12 13 HandleWrap :: HandleWrap ( Environment * env , Local < Object > object , uv_handle_t * handle , AsyncWrap :: ProviderType provider ) : AsyncWrap ( env , object , provider ), state_ ( kInitialized ), handle_ ( handle ) { // \u4fdd\u5b58Libuv handle\u548cC++\u5bf9\u8c61\u7684\u5173\u7cfb handle_ -> data = this ; HandleScope scope ( env -> isolate ()); // \u63d2\u5165handle\u961f\u5217 env -> handle_wrap_queue () -> PushBack ( this ); } HandleWrap\u9996\u5148\u4fdd\u5b58\u4e86Libuv\u7ed3\u6784\u4f53\u548cC++\u5bf9\u8c61\u7684\u5173\u7cfb\u3002\u7136\u540e\u6211\u4eec\u7ee7\u7eed\u6cbf\u7740AsyncWrap\u5206\u6790\uff0cAsyncWrap\u7ee7\u627fBaseObject\uff0c\u6211\u4eec\u76f4\u63a5\u770bBaseObject\u3002 1 2 3 4 5 6 7 8 // \u628a\u5bf9\u8c61\u5b58\u50a8\u5230persistent_handle_\u4e2d\uff0c\u5fc5\u8981\u7684\u65f6\u5019\u901a\u8fc7object()\u53d6\u51fa\u6765 BaseObject :: BaseObject ( Environment * env , v8 :: Local < v8 :: Object > object ) : persistent_handle_ ( env -> isolate (), object ), env_ ( env ) { // \u628athis\u5b58\u5230object\u4e2d object -> SetAlignedPointerInInternalField ( 0 , static_cast < void *> ( this )); env -> AddCleanupHook ( DeleteMe , static_cast < void *> ( this )); env -> modify_base_object_count ( 1 ); } \u6211\u4eec\u770bSetAlignedPointerInInternalField\u3002 1 2 3 4 5 6 7 8 9 10 11 12 void v8::Object::SetAlignedPointerInInternalField ( int index , void * value ) { i :: Handle < i :: JSReceiver > obj = Utils :: OpenHandle ( this ); i :: Handle < i :: JSObject >:: cast ( obj ) -> SetEmbedderField ( index , EncodeAlignedAsSmi ( value , location )); } void JSObject::SetEmbedderField ( int index , Smi * value ) { // GetHeaderSize\u4e3a\u5bf9\u8c61\u56fa\u5b9a\u5e03\u5c40\u7684\u5927\u5c0f\uff0ckPointerSize * index\u4e3a\u62d3\u5c55\u7684\u5185\u5b58\u5927\u5c0f\uff0c\u6839\u636e\u7d22\u5f15\u627e\u5230\u5bf9\u5e94\u4f4d\u7f6e int offset = GetHeaderSize () + ( kPointerSize * index ); // \u5199\u5bf9\u5e94\u4f4d\u7f6e\u7684\u5185\u5b58\uff0c\u5373\u4fdd\u5b58\u5bf9\u5e94\u7684\u5185\u5bb9\u5230\u5185\u5b58 WRITE_FIELD ( this , offset , value ); } SetAlignedPointerInInternalField\u51fd\u6570\u5c55\u5f00\u540e\uff0c\u505a\u7684\u4e8b\u60c5\u5c31\u662f\u628a\u4e00\u4e2a\u503c\u4fdd\u5b58\u5230V8 C++\u5bf9\u8c61\u7684\u5185\u5b58\u91cc\u3002\u90a3\u4fdd\u5b58\u7684\u8fd9\u4e2a\u503c\u662f\u5565\u5462\uff1fBaseObject\u7684\u5165\u53c2object\u662f\u7531\u51fd\u6570\u6a21\u677f\u521b\u5efa\u7684\u5bf9\u8c61\uff0cthis\u662f\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u3002\u6240\u4ee5SetAlignedPointerInInternalField\u51fd\u6570\u505a\u7684\u4e8b\u60c5\u5c31\u662f\u628a\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u4fdd\u5b58\u5230\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\u521b\u5efa\u7684\u5bf9\u8c61\u91cc\uff0c\u5982\u56fe6-8\u6240\u793a\u3002 \u56fe6-8 \u8fd9\u6709\u5565\u7528\u5462\uff1f\u6211\u4eec\u7ee7\u7eed\u5206\u6790\u3002\u8fd9\u65f6\u5019new TCP\u5c31\u6267\u884c\u5b8c\u6bd5\u4e86\u3002\u6211\u4eec\u770b\u770b\u8fd9\u65f6\u5019\u6267\u884ctcp.connect()\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 template < typename T > void TCPWrap :: Connect ( const FunctionCallbackInfo < Value >& args , std :: function < int ( const char * ip_address , T * addr ) > uv_ip_addr ) { Environment * env = Environment :: GetCurrent ( args ); TCPWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder (), args . GetReturnValue (). Set ( UV_EBADF )); // \u7701\u7565\u90e8\u5206\u4e0d\u76f8\u5173\u4ee3\u7801 args . GetReturnValue (). Set ( err ); } \u6211\u4eec\u53ea\u9700\u770b\u4e00\u4e0bASSIGN_OR_RETURN_UNWRAP\u5b8f\u7684\u903b\u8f91\u3002\u5176\u4e2dargs.Holder()\u8868\u793aConnect\u51fd\u6570\u7684\u5c5e\u4e3b\uff0c\u6839\u636e\u524d\u9762\u7684\u5206\u6790\u6211\u4eec\u77e5\u9053\u5c5e\u4e3b\u662fInitialize\u51fd\u6570\u5b9a\u4e49\u7684\u51fd\u6570\u6a21\u677f\u521b\u5efa\u51fa\u6765\u7684\u5bf9\u8c61\u3002\u8fd9\u4e2a\u5bf9\u8c61\u4fdd\u5b58\u4e86\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u3002ASSIGN_OR_RETURN_UNWRAP\u4e3b\u8981\u7684\u903b\u8f91\u662f\u628a\u5728C++\u5bf9\u8c61\u4e2d\u4fdd\u5b58\u7684\u90a3\u4e2aTCPWrap\u5bf9\u8c61\u53d6\u51fa\u6765\u3002\u7136\u540e\u5c31\u53ef\u4ee5\u4f7f\u7528TCPWrap\u5bf9\u8c61\u7684handle\u53bb\u8bf7\u6c42Libuv\u4e86\u3002","title":"6.5 JS\u5982\u4f55\u4f7f\u7528C++"},{"location":"chapter06-C%2B%2B%E5%B1%82/#67-clibuv","text":"\u521a\u624d\u6211\u4eec\u5206\u6790\u4e86JS\u8c03\u7528C++\u5c42\u65f6\u662f\u5982\u4f55\u4e32\u8d77\u6765\u7684\uff0c\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bC++\u8c03\u7528Libuv\u548cLibuv\u56de\u8c03C++\u5c42\u53c8\u662f\u5982\u4f55\u4e32\u8d77\u6765\u7684\u3002\u6211\u4eec\u901a\u8fc7TCP\u6a21\u5757\u7684connect\u51fd\u6570\u7ee7\u7eed\u5206\u6790\u8be5\u8fc7\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 template < typename T > void TCPWrap :: Connect ( const FunctionCallbackInfo < Value >& args , std :: function < int ( const char * ip_address , T * addr ) > uv_ip_addr ) { Environment * env = Environment :: GetCurrent ( args ); TCPWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder (), args . GetReturnValue (). Set ( UV_EBADF )); // \u7b2c\u4e00\u4e2a\u53c2\u6570\u662fTCPConnectWrap\u5bf9\u8c61\uff0c\u89c1net\u6a21\u5757 Local < Object > req_wrap_obj = args [ 0 ]. As < Object > (); // \u7b2c\u4e8c\u4e2a\u662fip\u5730\u5740 node :: Utf8Value ip_address ( env -> isolate (), args [ 1 ]); T addr ; // \u628a\u7aef\u53e3\uff0cIP\u8bbe\u7f6e\u5230addr\u4e0a\uff0c\u7aef\u53e3\u4fe1\u606f\u5728uv_ip_addr\u4e0a\u4e0b\u6587\u91cc\u4e86 int err = uv_ip_addr ( * ip_address , & addr ); if ( err == 0 ) { ConnectWrap * req_wrap = new ConnectWrap ( env , req_wrap_obj , AsyncWrap :: PROVIDER_TCPCONNECTWRAP ); err = req_wrap -> Dispatch ( uv_tcp_connect , & wrap -> handle_ , reinterpret_cast < const sockaddr *> ( & addr ), AfterConnect ); if ( err ) delete req_wrap ; } args . GetReturnValue (). Set ( err ); } \u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bConnectWrap\u3002\u6211\u4eec\u77e5\u9053ConnectWrap\u662fReqWrap\u7684\u5b50\u7c7b\u3002req_wrap_obj\u662fJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002New ConnectWrap\u540e\u7ed3\u6784\u5982\u56fe6-9\u6240\u793a\u3002 \u56fe6-9 \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bDispatch\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // \u8c03\u7528Libuv\u51fd\u6570 template < typename T > template < typename LibuvFunction , typename ... Args > int ReqWrap < T >:: Dispatch ( LibuvFunction fn , Args ... args ) { // \u4fdd\u5b58Libuv\u7ed3\u6784\u4f53\u548cC++\u5c42\u5bf9\u8c61ConnectWrap\u7684\u5173\u7cfb req_ . data = this ; int err = CallLibuvFunction < T , LibuvFunction >:: Call ( fn , env () -> event_loop (), req (), MakeLibuvRequestCallback < T , Args >:: For ( this , args )...); if ( err >= 0 ) env () -> IncreaseWaitingRequestCounter (); return err ; } \u8c03\u7528Libuv\u4e4b\u524d\u7684\u7ed3\u6784\u5982\u56fe6-10\u6240\u793a\u3002 \u56fe6-10 \u63a5\u4e0b\u6765\u6211\u4eec\u5206\u6790\u8c03\u7528Libuv\u7684\u5177\u4f53\u8fc7\u7a0b\u3002\u6211\u4eec\u770b\u5230Dispatch\u51fd\u6570\u662f\u4e00\u4e2a\u51fd\u6570\u6a21\u677f\u3002 \u9996\u5148\u770b\u4e00\u4e0bCallLibuvFunction\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 template < typename ReqT , typename T > struct CallLibuvFunction ; // Detect `int uv_foo(uv_loop_t* loop, uv_req_t* request, ...);`. template < typename ReqT , typename ... Args > struct CallLibuvFunction < ReqT , int ( * )( uv_loop_t * , ReqT * , Args ...) > { using T = int ( * )( uv_loop_t * , ReqT * , Args ...); template < typename ... PassedArgs > static int Call ( T fn , uv_loop_t * loop , ReqT * req , PassedArgs ... args ) { return fn ( loop , req , args ...); } }; // Detect `int uv_foo(uv_req_t* request, ...);`. template < typename ReqT , typename ... Args > struct CallLibuvFunction < ReqT , int ( * )( ReqT * , Args ...) > { using T = int ( * )( ReqT * , Args ...); template < typename ... PassedArgs > static int Call ( T fn , uv_loop_t * loop , ReqT * req , PassedArgs ... args ) { return fn ( req , args ...); } }; // Detect `void uv_foo(uv_req_t* request, ...);`. template < typename ReqT , typename ... Args > struct CallLibuvFunction < ReqT , void ( * )( ReqT * , Args ...) > { using T = void ( * )( ReqT * , Args ...); template < typename ... PassedArgs > static int Call ( T fn , uv_loop_t * loop , ReqT * req , PassedArgs ... args ) { fn ( req , args ...); return 0 ; } }; CallLibuvFunction\u7684\u5b9e\u73b0\u770b\u8d77\u6765\u975e\u5e38\u590d\u6742\uff0c\u90a3\u662f\u56e0\u4e3a\u7528\u4e86\u5927\u91cf\u7684\u6a21\u677f\u53c2\u6570\uff0cCallLibuvFunction\u672c\u8d28\u4e0a\u662f\u4e00\u4e2astruct\uff0c\u5728C++\u91cc\u548c\u7c7b\u4f5c\u7528\u7c7b\u4f3c\uff0c\u91cc\u9762\u53ea\u6709\u4e00\u4e2a\u7c7b\u51fd\u6570Call\uff0cNode.js\u4e3a\u4e86\u9002\u914dLibuv\u5c42\u5404\u79cd\u7c7b\u578b\u51fd\u6570\u7684\u8c03\u7528\uff0c\u6240\u4ee5\u5b9e\u73b0\u4e86\u4e09\u79cd\u7c7b\u578b\u7684CallLibuvFunction,\u5e76\u4e14\u4f7f\u7528\u4e86\u5927\u91cf\u7684\u6a21\u677f\u53c2\u6570\u3002\u6211\u4eec\u53ea\u9700\u8981\u5206\u6790\u4e00\u79cd\u5c31\u53ef\u4ee5\u4e86\u3002\u6211\u4eec\u6839\u636eTCP\u7684connect\u51fd\u6570\u5f00\u59cb\u5206\u6790\u3002\u6211\u4eec\u9996\u5148\u5177\u4f53\u4e0bDispatch\u51fd\u6570\u7684\u6a21\u677f\u53c2\u6570\u3002 1 2 template <typename T> template <typename LibuvFunction, typename... Args> T\u5bf9\u5e94ReqWrap\u7684\u7c7b\u578b\uff0cLibuvFunction\u5bf9\u5e94Libuv\u7684\u51fd\u6570\u7c7b\u578b\uff0c\u8fd9\u91cc\u662fint uv_tcp_connect(uv_connect_t* req, ...)\uff0c\u6240\u4ee5\u662f\u5bf9\u5e94LibuvFunction\u7684\u7b2c\u4e8c\u79cd\u60c5\u51b5\uff0cArgs\u662f\u6267\u884cDispatch\u65f6\u9664\u4e86\u7b2c\u4e00\u4e2a\u5b9e\u53c2\u5916\u7684\u5269\u4f59\u53c2\u6570\u3002\u4e0b\u9762\u6211\u4eec\u5177\u4f53\u5316Dispatch\u3002 1 2 3 4 5 6 7 8 9 10 int ReqWrap < uv_connect_t >:: Dispatch ( int ( * )( uv_connect_t * , Args ...), Args ... args ) { req_ . data = this ; int err = CallLibuvFunction < uv_connect_t , int ( * )( uv_connect_t * , Args ...) >:: Call ( fn , env () -> event_loop (), req (), MakeLibuvRequestCallback < T , Args >:: For ( this , args )...); return err ; } \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bMakeLibuvRequestCallback\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // \u900f\u4f20\u53c2\u6570\u7ed9Libuv template < typename ReqT , typename T > struct MakeLibuvRequestCallback { static T For ( ReqWrap < ReqT >* req_wrap , T v ) { static_assert ( ! is_callable < T >:: value , \"MakeLibuvRequestCallback missed a callback\" ); return v ; } }; template < typename ReqT , typename ... Args > struct MakeLibuvRequestCallback < ReqT , void ( * )( ReqT * , Args ...) > { using F = void ( * )( ReqT * req , Args ... args ); // Libuv\u56de\u8c03 static void Wrapper ( ReqT * req , Args ... args ) { // \u901a\u8fc7Libuv\u7ed3\u6784\u4f53\u62ff\u5230\u5bf9\u5e94\u7684C++\u5bf9\u8c61 ReqWrap < ReqT >* req_wrap = ReqWrap < ReqT >:: from_req ( req ); req_wrap -> env () -> DecreaseWaitingRequestCounter (); // \u62ff\u5230\u539f\u59cb\u7684\u56de\u8c03\u6267\u884c F original_callback = reinterpret_cast < F > ( req_wrap -> original_callback_ ); original_callback ( req , args ...); } static F For ( ReqWrap < ReqT >* req_wrap , F v ) { // \u4fdd\u5b58\u539f\u6765\u7684\u51fd\u6570 CHECK_NULL ( req_wrap -> original_callback_ ); req_wrap -> original_callback_ = reinterpret_cast < typename ReqWrap < ReqT >:: callback_t > ( v ); // \u8fd4\u56de\u5305\u88f9\u51fd\u6570 return Wrapper ; } }; MakeLibuvRequestCallback\u7684\u5b9e\u73b0\u6709\u4e24\u79cd\u60c5\u51b5\uff0c\u6a21\u7248\u53c2\u6570\u7684\u7b2c\u4e00\u4e2a\u4e00\u822c\u662fReqWrap\u5b50\u7c7b\uff0c\u7b2c\u4e8c\u4e2a\u4e00\u822c\u662fhandle\uff0c\u521d\u59cb\u5316ReqWrap\u7c7b\u7684\u65f6\u5019\uff0cenv\u4e2d\u4f1a\u8bb0\u5f55ReqWrap\u5b9e\u4f8b\u7684\u4e2a\u6570\uff0c\u4ece\u800c\u77e5\u9053\u6709\u591a\u5c11\u4e2a\u8bf7\u6c42\u6b63\u5728\u88abLibuv\u5904\u7406\uff0c\u6a21\u677f\u53c2\u6570\u7684\u7b2c\u4e8c\u4e2a\u5982\u679c\u662f\u51fd\u6570\u5219\u8bf4\u660e\u6ca1\u6709\u4f7f\u7528ReqWrap\u8bf7\u6c42Libuv\uff0c\u5219\u4f7f\u7528\u7b2c\u4e8c\u79cd\u5b9e\u73b0\uff0c\u52ab\u6301\u56de\u8c03\u4ece\u800c\u8bb0\u5f55\u6b63\u5728\u88abLibuv\u5904\u7406\u7684\u8bf7\u6c42\u6570\uff08\u5982GetAddrInfo\u7684\u5b9e\u73b0\uff09\u3002\u6240\u4ee5\u6211\u4eec\u8fd9\u91cc\u662f\u9002\u914d\u7b2c\u4e00\u79cd\u5b9e\u73b0\u3002\u900f\u4f20C++\u5c42\u53c2\u6570\u7ed9Libuv\u3002\u6211\u4eec\u518d\u6765\u770b\u4e00\u4e0b Dispatch 1 2 3 4 5 6 7 8 9 10 int ReqWrap < uv_connect_t >:: Dispatch ( int ( * )( uv_connect_t * , Args ...), Args ... args ) { req_ . data = this ; int err = CallLibuvFunction < uv_connect_t , int ( * )( uv_connect_t * , Args ...) >:: Call ( fn , env () -> event_loop (), req (), args ...); return err ; } \u518d\u8fdb\u4e00\u6b65\u5c55\u5f00\u3002 1 2 3 static int Call ( int ( * fn )( uv_connect_t * , Args ...), uv_loop_t * loop , uv_connect_t * req , PassedArgs ... args ) { return fn ( req , args ...); } \u6700\u540e\u5c55\u5f00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static int Call ( int ( * fn )( uv_connect_t * , Args ...), uv_loop_t * loop , uv_connect_t * req , PassedArgs ... args ) { return fn ( req , args ...); } Call ( uv_tcp_connect , env () -> event_loop (), req (), & wrap -> handle_ , AfterConnec ) uv_tcp_connect ( env () -> event_loop (), req (), & wrap -> handle_ , AfterConnect ); \u63a5\u7740\u6211\u4eec\u770b\u770buv_tcp_connect\u505a\u4e86\u4ec0\u4e48\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int uv_tcp_connect ( uv_connect_t * req , uv_tcp_t * handle , const struct sockaddr * addr , uv_connect_cb cb ) { // ... return uv__tcp_connect ( req , handle , addr , addrlen , cb ); } int uv__tcp_connect ( uv_connect_t * req , uv_tcp_t * handle , const struct sockaddr * addr , unsigned int addrlen , uv_connect_cb cb ) { int err ; int r ; // \u5173\u8054\u8d77\u6765 req -> handle = ( uv_stream_t * ) handle ; // ... } Libuv\u4e2d\u628areq\u548chandle\u505a\u4e86\u5173\u8054\uff0c\u5982\u56fe6-11\u6240\u793a\u3002 \u56fe6-11 \u5206\u6790\u5b8cC++\u8c03\u7528Libuv\u540e\uff0c\u6211\u4eec\u770b\u770bLibuv\u56de\u8c03C++\u548cC++\u56de\u8c03JS\u7684\u8fc7\u7a0b\u3002\u5f53Libuv\u5904\u7406\u5b8c\u8bf7\u6c42\u540e\u4f1a\u6267\u884cAfterConnect \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template < typename WrapType , typename UVType > void ConnectionWrap < WrapType , UVType >:: AfterConnect ( uv_connect_t * req , int status ) { // \u4eceLibuv\u7ed3\u6784\u4f53\u62ff\u5230C++\u7684\u8bf7\u6c42\u5bf9\u8c61 std :: unique_ptr < ConnectWrap > req_wrap ( static_cast < ConnectWrap *> ( req -> data )); // \u4eceC++\u5c42\u8bf7\u6c42\u5bf9\u8c61\u62ff\u5230\u5bf9\u5e94\u7684handle\u7ed3\u6784\u4f53\uff08Libuv\u91cc\u5173\u8054\u8d77\u6765\u7684\uff09\uff0c\u518d\u901a\u8fc7handle\u62ff\u5230\u5bf9\u5e94\u7684C++\u5c42handle\u5bf9\u8c61\uff08HandleWrap\u5173\u8054\u7684\uff09 WrapType * wrap = static_cast < WrapType *> ( req -> handle -> data ); Environment * env = wrap -> env (); ... Local < Value > argv [ 5 ] = { Integer :: New ( env -> isolate (), status ), wrap -> object (), req_wrap -> object (), Boolean :: New ( env -> isolate (), readable ), Boolean :: New ( env -> isolate (), writable ) }; // \u56de\u8c03JS\u5c42oncomplete req_wrap -> MakeCallback ( env -> oncomplete_string (), arraysize ( argv ), argv ); }","title":"6.7 C++\u5c42\u8c03\u7528Libuv"},{"location":"chapter06-C%2B%2B%E5%B1%82/#68","text":"Node.js\u5728C++\u5c42\u5bf9\u6d41\u8fdb\u884c\u4e86\u975e\u5e38\u591a\u7684\u5c01\u88c5\uff0c\u5f88\u591a\u6a21\u5757\u90fd\u4f9d\u8d56C++\u5c42\u6d41\u7684\u673a\u5236\uff0c\u6d41\u673a\u5236\u7684\u8bbe\u8ba1\u4e2d\uff0c\u4e3b\u8981\u6709\u4e09\u4e2a\u6982\u5ff5 1 \u8d44\u6e90\uff0c\u8fd9\u662f\u6d41\u673a\u5236\u7684\u6838\u5fc3\uff08StreamResource\uff09, 2 \u5bf9\u6d41\u8fdb\u884c\u64cd\u4f5c\uff08StreamReq\uff09 3 \u6d41\u4e8b\u4ef6\u7684\u76d1\u542c\u8005\uff0c\u5f53\u5bf9\u6d41\u8fdb\u884c\u64cd\u4f5c\u6216\u6d41\u672c\u8eab\u6709\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u4f1a\u628a\u4e8b\u4ef6\u548c\u76f8\u5173\u7684\u4e0a\u4e0b\u6587\u4f20\u9012\u7ed9\u76d1\u542c\u8005\uff0c\u76d1\u542c\u8005\u5904\u7406\u5b8c\u540e\uff0c\u518d\u901a\u77e5\u6d41\uff08StreamListener\uff09\u3002 \u901a\u8fc7\u7ee7\u627f\u7684\u6a21\u5f0f\uff0c\u57fa\u7c7b\u5b9a\u4e49\u63a5\u53e3\uff0c\u5b50\u7c7b\u5b9e\u73b0\u63a5\u53e3\u7684\u65b9\u5f0f\u3002\u5bf9\u6d41\u7684\u64cd\u4f5c\u8fdb\u884c\u4e86\u62bd\u8c61\u548c\u5c01\u88c5\u3002\u4e09\u8005\u7684\u7c7b\u5173\u7cfb\u5982\u56fe6-12\u6240\u793a\u3002 \u56fe6-12 \u6211\u4eec\u770b\u4e00\u4e0b\u8bfb\u4e00\u4e2a\u6d41\u7684\u6570\u636e\u7684\u8fc7\u7a0b\uff0c\u5982\u56fe6-13\u6240\u793a\u3002 \u56fe6-13 \u518d\u770b\u4e00\u4e0b\u5199\u7684\u8fc7\u7a0b\uff0c\u5982\u56fe6-14\u6240\u793a\u3002 \u56fe6-14","title":"6.8 \u6d41\u5c01\u88c5"},{"location":"chapter06-C%2B%2B%E5%B1%82/#681-streamresource","text":"StreamResource\u5b9a\u4e49\u64cd\u4f5c\u6d41\u7684\u901a\u7528\u903b\u8f91\u548c\u64cd\u4f5c\u7ed3\u675f\u540e\u89e6\u53d1\u7684\u56de\u8c03\u3002\u4f46\u662fStreamResource\u4e0d\u5b9a\u4e49\u6d41\u7684\u7c7b\u578b\uff0c\u6d41\u7684\u7c7b\u578b\u7531\u5b50\u7c7b\u5b9a\u4e49\uff0c\u6211\u4eec\u53ef\u4ee5\u5728StreamResource\u4e0a\u6ce8\u518clistener\uff0c\u8868\u793a\u5bf9\u6d41\u611f\u5174\u8da3\uff0c\u5f53\u6d41\u4e0a\u6709\u6570\u636e\u53ef\u8bfb\u6216\u8005\u4e8b\u4ef6\u53d1\u751f\u65f6\uff0c\u5c31\u4f1a\u901a\u77e5listener\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class StreamResource { public: virtual ~StreamResource(); // \u6ce8\u518c/\u6ce8\u9500\u7b49\u5f85\u6d41\u53ef\u8bfb\u4e8b\u4ef6 virtual int ReadStart() = 0; virtual int ReadStop() = 0; // \u5173\u95ed\u6d41 virtual int DoShutdown(ShutdownWrap* req_wrap) = 0; // \u5199\u5165\u6d41 virtual int DoTryWrite(uv_buf_t** bufs, size_t* count); virtual int DoWrite(WriteWrap* w, uv_buf_t* bufs, size_t count, uv_stream_t* send_handle) = 0; // ...\u5ffd\u7565\u4e00\u4e9b // \u7ed9\u6d41\u589e\u52a0\u6216\u5220\u9664\u76d1\u542c\u8005 void PushStreamListener(StreamListener* listener); void RemoveStreamListener(StreamListener* listener); protected: uv_buf_t EmitAlloc(size_t suggested_size); void EmitRead(ssize_t nread, const uv_buf_t& buf = uv_buf_init(nullptr, 0)); // \u6d41\u7684\u76d1\u542c\u8005\uff0c\u5373\u6570\u636e\u6d88\u8d39\u8005 StreamListener* listener_ = nullptr; uint64_t bytes_read_ = 0; uint64_t bytes_written_ = 0; friend class StreamListener; }; StreamResource\u662f\u4e00\u4e2a\u57fa\u7c7b\uff0c\u5176\u4e2d\u6709\u4e00\u4e2a\u6210\u5458\u662fStreamListener\u7c7b\u7684\u5b9e\u4f8b\uff0c\u6211\u4eec\u540e\u9762\u5206\u6790\u3002\u6211\u4eec\u770b\u4e00\u4e0bStreamResource\u7684\u5b9e\u73b0\u3002 1\u589e\u52a0\u4e00\u4e2alistener 1 2 3 4 5 6 7 // \u589e\u52a0\u4e00\u4e2alistener inline void StreamResource::PushStreamListener(StreamListener* listener) { // \u5934\u63d2\u6cd5 listener->previous_listener_ = listener_; listener->stream_ = this; listener_ = listener; } \u6211\u4eec\u53ef\u4ee5\u5728\u4e00\u4e2a\u6d41\u4e0a\u6ce8\u518c\u591a\u4e2alistener\uff0c\u6d41\u7684listener_\u5b57\u6bb5\u7ef4\u62a4\u4e86\u6d41\u4e0a\u6240\u6709\u7684listener\u961f\u5217\u3002\u5173\u7cfb\u56fe\u5982\u56fe6-15\u6240\u793a\u3002 \u56fe6-15 2\u5220\u9664listener 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 inline void StreamResource::RemoveStreamListener(StreamListener* listener) { StreamListener* previous; StreamListener* current; // \u904d\u5386\u5355\u94fe\u8868 for (current = listener_, previous = nullptr; /* No loop condition because we want a crash if listener is not found */ ; previous = current, current = current->previous_listener_) { if (current == listener) { // \u975e\u7a7a\u8bf4\u660e\u9700\u8981\u5220\u9664\u7684\u4e0d\u662f\u7b2c\u4e00\u4e2a\u8282\u70b9 if (previous != nullptr) previous->previous_listener_ = current->previous_listener_; else // \u5220\u9664\u7684\u662f\u7b2c\u4e00\u4e2a\u8282\u70b9\uff0c\u66f4\u65b0\u5934\u6307\u9488\u5c31\u884c listener_ = listener->previous_listener_; break; } } // \u91cd\u7f6e\u88ab\u5220\u9664listener\u7684\u5b57\u6bb5 listener->stream_ = nullptr; listener->previous_listener_ = nullptr; } 3 \u7533\u8bf7\u5b58\u50a8\u6570\u636e 1 2 3 4 5 // \u7533\u8bf7\u4e00\u5757\u5185\u5b58 inline uv_buf_t StreamResource::EmitAlloc(size_t suggested_size) { DebugSealHandleScope handle_scope(v8::Isolate::GetCurrent()); return listener_->OnStreamAlloc(suggested_size); } StreamResource\u53ea\u662f\u5b9a\u4e49\u4e86\u64cd\u4f5c\u6d41\u7684\u901a\u7528\u903b\u8f91\uff0c\u6570\u636e\u5b58\u50a8\u548c\u6d88\u8d39\u7531listener\u5b9a\u4e49\u3002 4 \u6570\u636e\u53ef\u8bfb 1 2 3 4 5 6 inline void StreamResource::EmitRead(ssize_t nread, const uv_buf_t& buf) { if (nread > 0) // \u8bb0\u5f55\u4ece\u6d41\u4e2d\u8bfb\u53d6\u7684\u6570\u636e\u7684\u5b57\u8282\u5927\u5c0f bytes_read_ += static_cast<uint64_t>(nread); listener_->OnStreamRead(nread, buf); } 5 \u5199\u56de\u8c03 1 2 3 4 inline void StreamResource::EmitAfterWrite(WriteWrap* w, int status) { DebugSealHandleScope handle_scope(v8::Isolate::GetCurrent()); listener_->OnStreamAfterWrite(w, status); } 6 \u5173\u95ed\u6d41\u56de\u8c03 1 2 3 4 inline void StreamResource::EmitAfterShutdown(ShutdownWrap* w, int status) { DebugSealHandleScope handle_scope(v8::Isolate::GetCurrent()); listener_->OnStreamAfterShutdown(w, status); } 7 \u6d41\u9500\u6bc1\u56de\u8c03 1 2 3 4 5 6 7 8 inline StreamResource::~StreamResource() { while (listener_ != nullptr) { StreamListener* listener = listener_; listener->OnStreamDestroy(); if (listener == listener_) RemoveStreamListener(listener_); } } \u6d41\u9500\u6bc1\u540e\u9700\u8981\u901a\u77e5listener\uff0c\u5e76\u4e14\u89e3\u9664\u5173\u7cfb\u3002","title":"6.8.1 StreamResource"},{"location":"chapter06-C%2B%2B%E5%B1%82/#682-streambase","text":"StreamBase\u662fStreamResource\u7684\u5b50\u7c7b\uff0c\u62d3\u5c55\u4e86StreamResource\u7684\u529f\u80fd\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class StreamBase : public StreamResource { public: static constexpr int kStreamBaseField = 1; static constexpr int kOnReadFunctionField = 2; static constexpr int kStreamBaseFieldCount = 3; // \u5b9a\u4e49\u4e00\u4e9b\u7edf\u4e00\u7684\u903b\u8f91 static void AddMethods(Environment* env, v8::Local<v8::FunctionTemplate> target); virtual bool IsAlive() = 0; virtual bool IsClosing() = 0; virtual bool IsIPCPipe(); virtual int GetFD(); // \u6267\u884cJS\u56de\u8c03 v8::MaybeLocal<v8::Value> CallJSOnreadMethod( ssize_t nread, v8::Local<v8::ArrayBuffer> ab, size_t offset = 0, StreamBaseJSChecks checks = DONT_SKIP_NREAD_CHECKS); Environment* stream_env() const; // \u5173\u95ed\u6d41 int Shutdown(v8::Local<v8::Object> req_wrap_obj = v8::Local<v8::Object>()); // \u5199\u5165\u6d41 StreamWriteResult Write( uv_buf_t* bufs, size_t count, uv_stream_t* send_handle = nullptr, v8::Local<v8::Object> req_wrap_obj = v8::Local<v8::Object>()); // \u521b\u5efa\u4e00\u4e2a\u5173\u95ed\u8bf7\u6c42 virtual ShutdownWrap* CreateShutdownWrap(v8::Local<v8::Object> object); // \u521b\u5efa\u4e00\u4e2a\u5199\u8bf7\u6c42 virtual WriteWrap* CreateWriteWrap(v8::Local<v8::Object> object); virtual AsyncWrap* GetAsyncWrap() = 0; virtual v8::Local<v8::Object> GetObject(); static StreamBase* FromObject(v8::Local<v8::Object> obj); protected: explicit StreamBase(Environment* env); // JS Methods int ReadStartJS(const v8::FunctionCallbackInfo<v8::Value>& args); // \u7701\u7565\u7cfb\u5217\u65b9\u6cd5 void AttachToObject(v8::Local<v8::Object> obj); template <int (StreamBase::*Method)( const v8::FunctionCallbackInfo<v8::Value>& args)> static void JSMethod(const v8::FunctionCallbackInfo<v8::Value>& args); private: Environment* env_; EmitToJSStreamListener default_listener_; void SetWriteResult(const StreamWriteResult& res); static void AddMethod(Environment* env, v8::Local<v8::Signature> sig, enum v8::PropertyAttribute attributes, v8::Local<v8::FunctionTemplate> t, JSMethodFunction* stream_method, v8::Local<v8::String> str); }; 1 \u521d\u59cb\u5316 1 2 3 inline StreamBase::StreamBase(Environment* env) : env_(env) { PushStreamListener(&default_listener_); } StreamBase\u521d\u59cb\u5316\u7684\u65f6\u5019\u4f1a\u9ed8\u8ba4\u8bbe\u7f6e\u4e00\u4e2alistener\u3002 2 \u5173\u95ed\u6d41 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // \u5173\u95ed\u4e00\u4e2a\u6d41\uff0creq_wrap_obj\u662fJS\u5c42\u4f20\u8fdb\u6765\u7684\u5bf9\u8c61 inline int StreamBase::Shutdown(v8::Local<v8::Object> req_wrap_obj) { Environment* env = stream_env(); HandleScope handle_scope(env->isolate()); AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap()); // \u521b\u5efa\u4e00\u4e2a\u7528\u4e8e\u8bf7\u6c42Libuv\u7684\u6570\u636e\u7ed3\u6784 ShutdownWrap* req_wrap = CreateShutdownWrap(req_wrap_obj); // \u5b50\u7c7b\u5b9e\u73b0\uff0c\u4e0d\u540c\u6d41\u5173\u95ed\u7684\u903b\u8f91\u4e0d\u4e00\u6837 int err = DoShutdown(req_wrap); // \u6267\u884c\u51fa\u9519\u5219\u9500\u6bc1JS\u5c42\u5bf9\u8c61 if (err != 0 && req_wrap != nullptr) { req_wrap->Dispose(); } const char* msg = Error(); if (msg != nullptr) { req_wrap_obj->Set( env->context(), env->error_string(), OneByteString(env->isolate(), msg)).Check(); ClearError(); } return err; } 3 \u5199 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // \u5199Buffer\uff0c\u652f\u6301\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 int StreamBase::WriteBuffer(const FunctionCallbackInfo<Value>& args) { Environment* env = Environment::GetCurrent(args); Local<Object> req_wrap_obj = args[0].As<Object>(); uv_buf_t buf; // \u6570\u636e\u5185\u5bb9\u548c\u957f\u5ea6 buf.base = Buffer::Data(args[1]); buf.len = Buffer::Length(args[1]); uv_stream_t* send_handle = nullptr; // \u662f\u5bf9\u8c61\u5e76\u4e14\u6d41\u652f\u6301\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 if (args[2]->IsObject() && IsIPCPipe()) { Local<Object> send_handle_obj = args[2].As<Object>(); HandleWrap* wrap; // \u4ece\u8fd4\u56dejs\u7684\u5bf9\u8c61\u4e2d\u83b7\u53d6internalField\u4e2d\u6307\u5411\u7684C++\u5c42\u5bf9\u8c61 ASSIGN_OR_RETURN_UNWRAP(&wrap, send_handle_obj, UV_EINVAL); // \u62ff\u5230Libuv\u5c42\u7684handle send_handle = reinterpret_cast<uv_stream_t*>(wrap->GetHandle()); // Reference LibuvStreamWrap instance to prevent it from being garbage // collected before `AfterWrite` is called. // \u8bbe\u7f6e\u5230JS\u5c42\u8bf7\u6c42\u5bf9\u8c61\u4e2d req_wrap_obj->Set(env->context(), env->handle_string(), send_handle_obj).Check(); } StreamWriteResult res = Write(&buf, 1, send_handle, req_wrap_obj); SetWriteResult(res); return res.err; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 inline StreamWriteResult StreamBase::Write( uv_buf_t* bufs, size_t count, uv_stream_t* send_handle, v8::Local<v8::Object> req_wrap_obj) { Environment* env = stream_env(); int err; size_t total_bytes = 0; // \u8ba1\u7b97\u9700\u8981\u5199\u5165\u7684\u6570\u636e\u5927\u5c0f for (size_t i = 0; i < count; ++i) total_bytes += bufs[i].len; // \u540c\u4e0a bytes_written_ += total_bytes; // \u662f\u5426\u9700\u8981\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u4e0d\u9700\u8981\u5219\u76f4\u63a5\u5199 if (send_handle == nullptr) { err = DoTryWrite(&bufs, &count); if (err != 0 || count == 0) { return StreamWriteResult { false, err, nullptr, total_bytes }; } } HandleScope handle_scope(env->isolate()); AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(GetAsyncWrap()); // \u521b\u5efa\u4e00\u4e2a\u7528\u4e8e\u8bf7\u6c42Libuv\u7684\u5199\u8bf7\u6c42\u5bf9\u8c61 WriteWrap* req_wrap = CreateWriteWrap(req_wrap_obj); // \u6267\u884c\u5199\uff0c\u5b50\u7c7b\u5b9e\u73b0\uff0c\u4e0d\u540c\u6d41\u5199\u64cd\u4f5c\u4e0d\u4e00\u6837 err = DoWrite(req_wrap, bufs, count, send_handle); const char* msg = Error(); if (msg != nullptr) { req_wrap_obj->Set(env->context(), env->error_string(), OneByteString(env->isolate(), msg)).Check(); ClearError(); } return StreamWriteResult { async, err, req_wrap, total_bytes }; } 4 \u8bfb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // \u64cd\u4f5c\u6d41\uff0c\u542f\u52a8\u8bfb\u53d6 int StreamBase::ReadStartJS(const FunctionCallbackInfo<Value>& args) { return ReadStart(); } // \u64cd\u4f5c\u6d41\uff0c\u505c\u6b62\u8bfb\u53d6 int StreamBase::ReadStopJS(const FunctionCallbackInfo<Value>& args) { return ReadStop(); } // \u89e6\u53d1\u6d41\u4e8b\u4ef6\uff0c\u6709\u6570\u636e\u53ef\u8bfb MaybeLocal<Value> StreamBase::CallJSOnreadMethod(ssize_t nread, Local<ArrayBuffer> ab, size_t offset, StreamBaseJSChecks checks) { Environment* env = env_; env->stream_base_state()[kReadBytesOrError] = nread; env->stream_base_state()[kArrayBufferOffset] = offset; Local<Value> argv[] = { ab.IsEmpty() ? Undefined(env->isolate()).As<Value>() : ab.As<Value>() }; // GetAsyncWrap\u5728StreamBase\u5b50\u7c7b\u5b9e\u73b0\uff0c\u62ff\u5230StreamBase\u7c7b\u5bf9\u8c61 AsyncWrap* wrap = GetAsyncWrap(); // \u83b7\u53d6\u56de\u8c03\u6267\u884c Local<Value> onread = wrap->object()->GetInternalField(kOnReadFunctionField); return wrap->MakeCallback(onread.As<Function>(), arraysize(argv), argv); } 4 \u6d41\u901a\u7528\u65b9\u6cd5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 void StreamBase::AddMethod(Environment* env, Local<Signature> signature, enum PropertyAttribute attributes, Local<FunctionTemplate> t, JSMethodFunction* stream_method, Local<String> string) { // \u65b0\u5efa\u4e00\u4e2a\u51fd\u6570\u6a21\u677f Local<FunctionTemplate> templ = env->NewFunctionTemplate(stream_method, signature, v8::ConstructorBehavior::kThrow, v8::SideEffectType::kHasNoSideEffect); // \u8bbe\u7f6e\u539f\u578b\u5c5e\u6027 t->PrototypeTemplate()->SetAccessorProperty( string, templ, Local<FunctionTemplate>(), attributes); } void StreamBase::AddMethods(Environment* env, Local<FunctionTemplate> t) { HandleScope scope(env->isolate()); enum PropertyAttribute attributes = static_cast<PropertyAttribute>(ReadOnly | DontDelete | DontEnum); Local<Signature> sig = Signature::New(env->isolate(), t); // \u8bbe\u7f6e\u539f\u578b\u5c5e\u6027 AddMethod(env, sig, attributes, t, GetFD, env->fd_string()); // \u5ffd\u7565\u90e8\u5206 env->SetProtoMethod(t, \"readStart\", JSMethod<&StreamBase::ReadStartJS>); env->SetProtoMethod(t, \"readStop\", JSMethod<&StreamBase::ReadStopJS>); env->SetProtoMethod(t, \"shutdown\", JSMethod<&StreamBase::Shutdown>); env->SetProtoMethod(t, \"writev\", JSMethod<&StreamBase::Writev>); env->SetProtoMethod(t, \"writeBuffer\", JSMethod<&StreamBase::WriteBuffer>); env->SetProtoMethod( t, \"writeAsciiString\", JSMethod<&StreamBase::WriteString<ASCII>>); env->SetProtoMethod( t, \"writeUtf8String\", JSMethod<&StreamBase::WriteString<UTF8>>); t->PrototypeTemplate()->Set(FIXED_ONE_BYTE_STRING(env->isolate(), \"isStreamBase\"), True(env->isolate())); // \u8bbe\u7f6e\u8bbf\u95ee\u5668 t->PrototypeTemplate()->SetAccessor( // \u952e\u540d FIXED_ONE_BYTE_STRING(env->isolate(), \"onread\"), // getter BaseObject::InternalFieldGet<kOnReadFunctionField>, // setter\uff0cValue::IsFunction\u662fset\u4e4b\u524d\u7684\u6821\u9a8c\u51fd\u6570\uff0c\u89c1InternalFieldSet\uff08\u6a21\u677f\u51fd\u6570\uff09\u5b9a\u4e49 BaseObject::InternalFieldSet<kOnReadFunctionField, &Value::IsFunction>); } 5 \u5176\u5b83\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // \u9ed8\u8ba4false\uff0c\u5b50\u7c7b\u91cd\u5199 bool StreamBase::IsIPCPipe() { return false; } // \u5b50\u7c7b\u91cd\u5199 int StreamBase::GetFD() { return -1; } Local<Object> StreamBase::GetObject() { return GetAsyncWrap()->object(); } // \u5de5\u5177\u51fd\u6570\u548c\u5b9e\u4f8bthis\u65e0\u5173\uff0c\u548c\u5165\u53c2\u6709\u5173 void StreamBase::GetFD(const FunctionCallbackInfo<Value>& args) { // Mimic implementation of StreamBase::GetFD() and UDPWrap::GetFD(). // \u4eceJS\u5c42\u5bf9\u8c61\u83b7\u53d6\u5b83\u5173\u8054\u7684C++\u5bf9\u8c61\uff0c\u4e0d\u4e00\u5b9a\u662fthis StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>()); if (wrap == nullptr) return args.GetReturnValue().Set(UV_EINVAL); if (!wrap->IsAlive()) return args.GetReturnValue().Set(UV_EINVAL); args.GetReturnValue().Set(wrap->GetFD()); } void StreamBase::GetBytesRead(const FunctionCallbackInfo<Value>& args) { StreamBase* wrap = StreamBase::FromObject(args.This().As<Object>()); if (wrap == nullptr) return args.GetReturnValue().Set(0); // uint64_t -> double. 53bits is enough for all real cases. args.GetReturnValue().Set(static_cast<double>(wrap->bytes_read_)); }","title":"6.8.2 StreamBase"},{"location":"chapter06-C%2B%2B%E5%B1%82/#683-libuvstreamwrap","text":"LibuvStreamWrap\u662fStreamBase\u7684\u5b50\u7c7b\u3002\u5b9e\u73b0\u4e86\u7236\u7c7b\u7684\u63a5\u53e3\uff0c\u4e5f\u62d3\u5c55\u4e86\u6d41\u7684\u80fd\u529b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class LibuvStreamWrap : public HandleWrap, public StreamBase { public: static void Initialize(v8::Local<v8::Object> target, v8::Local<v8::Value> unused, v8::Local<v8::Context> context, void* priv); int GetFD() override; bool IsAlive() override; bool IsClosing() override; bool IsIPCPipe() override; // JavaScript functions int ReadStart() override; int ReadStop() override; // Resource implementation int DoShutdown(ShutdownWrap* req_wrap) override; int DoTryWrite(uv_buf_t** bufs, size_t* count) override; int DoWrite(WriteWrap* w, uv_buf_t* bufs, size_t count, uv_stream_t* send_handle) override; inline uv_stream_t* stream() const { return stream_; } // \u662f\u5426\u662fUnix\u57df\u6216\u547d\u540d\u7ba1\u9053 inline bool is_named_pipe() const { return stream()->type == UV_NAMED_PIPE; } // \u662f\u5426\u662fUnix\u57df\u5e76\u4e14\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 inline bool is_named_pipe_ipc() const { return is_named_pipe() && reinterpret_cast<const uv_pipe_t*>(stream())->ipc != 0; } inline bool is_tcp() const { return stream()->type == UV_TCP; } // \u521b\u5efa\u8bf7\u6c42Libuv\u7684\u5bf9\u8c61 ShutdownWrap* CreateShutdownWrap(v8::Local<v8::Object> object) override; WriteWrap* CreateWriteWrap(v8::Local<v8::Object> object) override; // \u4eceJS\u5c42\u5bf9\u8c61\u83b7\u53d6\u5bf9\u4e8e\u7684C++\u5bf9\u8c61 static LibuvStreamWrap* From(Environment* env, v8::Local<v8::Object> object); protected: LibuvStreamWrap(Environment* env, v8::Local<v8::Object> object, uv_stream_t* stream, AsyncWrap::ProviderType provider); AsyncWrap* GetAsyncWrap() override; static v8::Local<v8::FunctionTemplate> GetConstructorTemplate( Environment* env); private: static void GetWriteQueueSize( const v8::FunctionCallbackInfo<v8::Value>& info); static void SetBlocking(const v8::FunctionCallbackInfo<v8::Value>& args); // Callbacks for libuv void OnUvAlloc(size_t suggested_size, uv_buf_t* buf); void OnUvRead(ssize_t nread, const uv_buf_t* buf); static void AfterUvWrite(uv_write_t* req, int status); static void AfterUvShutdown(uv_shutdown_t* req, int status); uv_stream_t* const stream_; }; 1 \u521d\u59cb\u5316 1 2 3 4 5 6 7 8 9 10 11 12 LibuvStreamWrap::LibuvStreamWrap(Environment* env, Local<Object> object, uv_stream_t* stream, AsyncWrap::ProviderType provider) : HandleWrap(env, object, reinterpret_cast<uv_handle_t*>(stream), provider), StreamBase(env), stream_(stream) { StreamBase::AttachToObject(object); } LibuvStreamWrap\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u4f1a\u628aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u7684\u5185\u90e8\u6307\u9488\u6307\u5411\u81ea\u5df1\uff0c\u89c1HandleWrap\u3002 2 \u5199\u64cd\u4f5c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 // \u5de5\u5177\u51fd\u6570\uff0c\u83b7\u53d6\u5f85\u5199\u6570\u636e\u5b57\u8282\u7684\u5927\u5c0f void LibuvStreamWrap::GetWriteQueueSize( const FunctionCallbackInfo<Value>& info) { LibuvStreamWrap* wrap; ASSIGN_OR_RETURN_UNWRAP(&wrap, info.This()); uint32_t write_queue_size = wrap->stream()->write_queue_size; info.GetReturnValue().Set(write_queue_size); } // \u8bbe\u7f6e\u975e\u963b\u585e void LibuvStreamWrap::SetBlocking(const FunctionCallbackInfo<Value>& args) { LibuvStreamWrap* wrap; ASSIGN_OR_RETURN_UNWRAP(&wrap, args.Holder()); bool enable = args[0]->IsTrue(); args.GetReturnValue().Set(uv_stream_set_blocking(wrap->stream(), enable)); } // \u5b9a\u4e49\u4e00\u4e2a\u5173\u95ed\u7684\u8bf7\u6c42 typedef SimpleShutdownWrap<ReqWrap<uv_shutdown_t>> LibuvShutdownWrap; // \u5b9a\u4e49\u4e00\u4e2a\u5199\u8bf7\u6c42 typedef SimpleWriteWrap<ReqWrap<uv_write_t>> LibuvWriteWrap; ShutdownWrap* LibuvStreamWrap::CreateShutdownWrap(Local<Object> object) { return new LibuvShutdownWrap(this, object); } WriteWrap* LibuvStreamWrap::CreateWriteWrap(Local<Object> object) { return new LibuvWriteWrap(this, object); } // \u53d1\u8d77\u5173\u95ed\u8bf7\u6c42\uff0c\u7531\u7236\u7c7b\u8c03\u7528\uff0creq_wrap\u662fC++\u5c42\u521b\u5efa\u7684\u5bf9\u8c61 int LibuvStreamWrap::DoShutdown(ShutdownWrap* req_wrap_) { LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(req_wrap_); return req_wrap->Dispatch(uv_shutdown, stream(), AfterUvShutdown); } // \u5173\u95ed\u8bf7\u6c42\u7ed3\u675f\u540e\u6267\u884c\u8bf7\u6c42\u7684\u901a\u7528\u56de\u8c03Done void LibuvStreamWrap::AfterUvShutdown(uv_shutdown_t* req, int status) { LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>( LibuvShutdownWrap::from_req(req)); HandleScope scope(req_wrap->env()->isolate()); Context::Scope context_scope(req_wrap->env()->context()); req_wrap->Done(status); } int LibuvStreamWrap::DoTryWrite(uv_buf_t** bufs, size_t* count) { int err; size_t written; uv_buf_t* vbufs = *bufs; size_t vcount = *count; err = uv_try_write(stream(), vbufs, vcount); if (err == UV_ENOSYS || err == UV_EAGAIN) return 0; if (err < 0) return err; // \u5199\u6210\u529f\u7684\u5b57\u8282\u6570\uff0c\u66f4\u65b0\u6570\u636e written = err; for (; vcount > 0; vbufs++, vcount--) { // Slice if (vbufs[0].len > written) { vbufs[0].base += written; vbufs[0].len -= written; written = 0; break; // Discard } else { written -= vbufs[0].len; } } *bufs = vbufs; *count = vcount; return 0; } int LibuvStreamWrap::DoWrite(WriteWrap* req_wrap, uv_buf_t* bufs, size_t count, uv_stream_t* send_handle) { LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap); return w->Dispatch(uv_write2, stream(), bufs, count, send_handle, AfterUvWrite); } void LibuvStreamWrap::AfterUvWrite(uv_write_t* req, int status) { LibuvWriteWrap* req_wrap = static_cast<LibuvWriteWrap*>( LibuvWriteWrap::from_req(req)); HandleScope scope(req_wrap->env()->isolate()); Context::Scope context_scope(req_wrap->env()->context()); req_wrap->Done(status); } 3 \u8bfb\u64cd\u4f5c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // \u8c03\u7528Libuv\u5b9e\u73b0\u542f\u52a8\u8bfb\u903b\u8f91 int LibuvStreamWrap::ReadStart() { return uv_read_start(stream(), [](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) { static_cast<LibuvStreamWrap*>(handle->data)->OnUvAlloc(suggested_size, buf); }, [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) { static_cast<LibuvStreamWrap*>(stream->data)->OnUvRead(nread, buf); }); } // \u5b9e\u73b0\u505c\u6b62\u8bfb\u903b\u8f91 int LibuvStreamWrap::ReadStop() { return uv_read_stop(stream()); } // \u9700\u8981\u5206\u914d\u5185\u5b58\u65f6\u7684\u56de\u8c03\uff0c\u7531Libuv\u56de\u8c03\uff0c\u5177\u4f53\u5206\u914d\u5185\u5b58\u903b\u8f91\u7531listener\u5b9e\u73b0 void LibuvStreamWrap::OnUvAlloc(size_t suggested_size, uv_buf_t* buf) { HandleScope scope(env()->isolate()); Context::Scope context_scope(env()->context()); *buf = EmitAlloc(suggested_size); } // \u5904\u7406\u4f20\u9012\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 template <class WrapType> static MaybeLocal<Object> AcceptHandle(Environment* env, LibuvStreamWrap* parent) { EscapableHandleScope scope(env->isolate()); Local<Object> wrap_obj; // \u6839\u636e\u7c7b\u578b\u521b\u5efa\u4e00\u4e2a\u8868\u793a\u5ba2\u6237\u7aef\u7684\u5bf9\u8c61\uff0c\u7136\u540e\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5176\u4e2d if (!WrapType::Instantiate(env, parent, WrapType::SOCKET).ToLocal(&wrap_obj)) return Local<Object>(); // \u89e3\u51faC++\u5c42\u5bf9\u8c61 HandleWrap* wrap = Unwrap<HandleWrap>(wrap_obj); CHECK_NOT_NULL(wrap); // \u62ff\u5230C++\u5bf9\u8c61\u4e2d\u5c01\u88c5\u7684handle uv_stream_t* stream = reinterpret_cast<uv_stream_t*>(wrap->GetHandle()); // \u4ece\u670d\u52a1\u5668\u6d41\u4e2d\u6458\u4e0b\u4e00\u4e2afd\u4fdd\u5b58\u5230steam if (uv_accept(parent->stream(), stream)) ABORT(); return scope.Escape(wrap_obj); } // \u5b9e\u73b0OnUvRead\uff0c\u6d41\u4e2d\u6709\u6570\u636e\u6216\u8bfb\u5230\u7ed3\u5c3e\u65f6\u7531Libuv\u56de\u8c03 void LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) { HandleScope scope(env()->isolate()); Context::Scope context_scope(env()->context()); uv_handle_type type = UV_UNKNOWN_HANDLE; // \u662f\u5426\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u5e76\u4e14\u6709\u5f85\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5219\u5224\u65ad\u6587\u4ef6\u63cf\u8ff0\u7b26\u7c7b\u578b if (is_named_pipe_ipc() && uv_pipe_pending_count(reinterpret_cast<uv_pipe_t*>(stream())) > 0) { type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream())); } // \u8bfb\u53d6\u6210\u529f if (nread > 0) { MaybeLocal<Object> pending_obj; // \u6839\u636e\u7c7b\u578b\u521b\u5efa\u4e00\u4e2a\u65b0\u7684C++\u5bf9\u8c61\u8868\u793a\u5ba2\u6237\u7aef\uff0c\u5e76\u4e14\u4ece\u670d\u52a1\u5668\u4e2d\u6458\u4e0b\u4e00\u4e2afd\u4fdd\u5b58\u5230\u5ba2\u6237\u7aef if (type == UV_TCP) { pending_obj = AcceptHandle<TCPWrap>(env(), this); } else if (type == UV_NAMED_PIPE) { pending_obj = AcceptHandle<PipeWrap>(env(), this); } else if (type == UV_UDP) { pending_obj = AcceptHandle<UDPWrap>(env(), this); } else { CHECK_EQ(type, UV_UNKNOWN_HANDLE); } // \u6709\u9700\u8981\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5219\u8bbe\u7f6e\u5230JS\u5c42\u5bf9\u8c61\u4e2d\uff0cJS\u5c42\u4f7f\u7528 if (!pending_obj.IsEmpty()) { object() ->Set(env()->context(), env()->pending_handle_string(), pending_obj.ToLocalChecked()) .Check(); } } // \u89e6\u53d1\u8bfb\u4e8b\u4ef6\uff0clistener\u5b9e\u73b0 EmitRead(nread, *buf); } \u8bfb\u64cd\u4f5c\u4e0d\u4ec5\u652f\u6301\u8bfb\u53d6\u4e00\u822c\u7684\u6570\u636e\uff0c\u8fd8\u53ef\u4ee5\u8bfb\u53d6\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cC++\u5c42\u4f1a\u65b0\u5efa\u4e00\u4e2a\u6d41\u5bf9\u8c61\u8868\u793a\u8be5\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u5728JS\u5c42\u53ef\u4ee5\u4f7f\u7528\u3002","title":"6.8.3 LibuvStreamWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#684-connectionwrap","text":"ConnectionWrap\u662fLibuvStreamWrap\u5b50\u7c7b\uff0c\u62d3\u5c55\u4e86\u8fde\u63a5\u7684\u63a5\u53e3\u3002\u9002\u7528\u4e8e\u5e26\u6709\u8fde\u63a5\u5c5e\u6027\u7684\u6d41\uff0c\u6bd4\u5982Unix\u57df\u548cTCP\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // WrapType\u662fC++\u5c42\u7684\u7c7b\uff0cUVType\u662fLibuv\u7684\u7c7b\u578b template <typename WrapType, typename UVType> class ConnectionWrap : public LibuvStreamWrap { public: static void OnConnection(uv_stream_t* handle, int status); static void AfterConnect(uv_connect_t* req, int status); protected: ConnectionWrap(Environment* env, v8::Local<v8::Object> object, ProviderType provider); UVType handle_; }; 1 \u53d1\u8d77\u8fde\u63a5\u540e\u7684\u56de\u8c03 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 template <typename WrapType, typename UVType> void ConnectionWrap<WrapType, UVType>::AfterConnect(uv_connect_t* req, int status) { // \u901a\u8fc7Libuv\u7ed3\u6784\u4f53\u62ff\u5230\u5bf9\u5e94\u7684C++\u5bf9\u8c61 std::unique_ptr<ConnectWrap> req_wrap = (static_cast<ConnectWrap*>(req->data)); WrapType* wrap = static_cast<WrapType*>(req->handle->data); Environment* env = wrap->env(); HandleScope handle_scope(env->isolate()); Context::Scope context_scope(env->context()); bool readable, writable; // \u8fde\u63a5\u7ed3\u679c if (status) { readable = writable = false; } else { readable = uv_is_readable(req->handle) != 0; writable = uv_is_writable(req->handle) != 0; } Local<Value> argv[5] = { Integer::New(env->isolate(), status), wrap->object(), req_wrap->object(), Boolean::New(env->isolate(), readable), Boolean::New(env->isolate(), writable) }; // \u56de\u8c03js req_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv); } 2 \u8fde\u63a5\u5230\u6765\u65f6\u56de\u8c03 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // \u6709\u8fde\u63a5\u65f6\u89e6\u53d1\u7684\u56de\u8c03 template <typename WrapType, typename UVType> void ConnectionWrap<WrapType, UVType>::OnConnection(uv_stream_t* handle, int status) { // \u62ff\u5230Libuv\u7ed3\u6784\u4f53\u5bf9\u5e94\u7684C++\u5c42\u5bf9\u8c61 WrapType* wrap_data = static_cast<WrapType*>(handle->data); Environment* env = wrap_data->env(); HandleScope handle_scope(env->isolate()); Context::Scope context_scope(env->context()); // \u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5bf9\u8c61 Local<Value> client_handle; if (status == 0) { // Instantiate the client javascript object and handle. // \u65b0\u5efa\u4e00\u4e2aJS\u5c42\u4f7f\u7528\u5bf9\u8c61 Local<Object> client_obj; if (!WrapType::Instantiate(env, wrap_data, WrapType::SOCKET) .ToLocal(&client_obj)) return; // Unwrap the client javascript object. WrapType* wrap; // \u628aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61client_obj\u6240\u5bf9\u5e94\u7684C++\u5c42\u5bf9\u8c61\u5b58\u5230wrap\u4e2d ASSIGN_OR_RETURN_UNWRAP(&wrap, client_obj); // \u62ff\u5230\u5bf9\u5e94\u7684handle uv_stream_t* client = reinterpret_cast<uv_stream_t*>(&wrap->handle_); // \u4ecehandleaccpet\u5230\u7684fd\u4e2d\u62ff\u4e00\u4e2a\u4fdd\u5b58\u5230client\uff0cclient\u5c31\u53ef\u4ee5\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u4e86 if (uv_accept(handle, client)) return; client_handle = client_obj; } else { client_handle = Undefined(env->isolate()); } // \u56de\u8c03JS\uff0cclient_handle\u76f8\u5f53\u4e8e\u5728JS\u5c42\u6267\u884cnew TCP Local<Value> argv[] = { Integer::New(env->isolate(), status), client_handle }; wrap_data->MakeCallback(env->onconnection_string(), arraysize(argv), argv); } \u6211\u4eec\u770b\u4e00\u4e0bTCP\u7684Instantiate\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 MaybeLocal<Object> TCPWrap::Instantiate(Environment* env, AsyncWrap* parent, TCPWrap::SocketType type) { EscapableHandleScope handle_scope(env->isolate()); AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent); // \u62ff\u5230\u5bfc\u51fa\u5230JS\u5c42\u7684TCP\u6784\u9020\u51fd\u6570\uff0c\u7f13\u5b58\u5728env\u4e2d Local<Function> constructor = env->tcp_constructor_template() ->GetFunction(env->context()) .ToLocalChecked(); Local<Value> type_value = Int32::New(env->isolate(), type); // \u76f8\u5f53\u4e8e\u6211\u4eec\u5728JS\u5c42\u8c03\u7528new TCP()\u65f6\u62ff\u5230\u7684\u5bf9\u8c61 return handle_scope.EscapeMaybe( constructor->NewInstance(env->context(), 1, &type_value)); }","title":"6.8.4 ConnectionWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#685-streamreq","text":"StreamReq\u8868\u793a\u64cd\u4f5c\u6d41\u7684\u4e00\u6b21\u8bf7\u6c42\u3002\u4e3b\u8981\u4fdd\u5b58\u4e86\u8bf7\u6c42\u4e0a\u4e0b\u6587\u548c\u64cd\u4f5c\u7ed3\u675f\u540e\u7684\u901a\u7528\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // \u8bf7\u6c42Libuv\u7684\u57fa\u7c7b class StreamReq { public: // JS\u5c42\u4f20\u8fdb\u6765\u7684\u5bf9\u8c61\u7684internalField[1]\u4fdd\u5b58\u4e86StreamReq\u7c7b\u5bf9\u8c61 static constexpr int kStreamReqField = 1; // stream\u4e3a\u6240\u64cd\u4f5c\u7684\u6d41\uff0creq_wrap_obj\u4e3aJS\u5c42\u4f20\u8fdb\u6765\u7684\u5bf9\u8c61 explicit StreamReq(StreamBase* stream, v8::Local<v8::Object> req_wrap_obj) : stream_(stream) { // JS\u5c42\u5bf9\u8c61\u6307\u5411\u5f53\u524dStreamReq\u5bf9\u8c61 AttachToObject(req_wrap_obj); } // \u5b50\u7c7b\u5b9a\u4e49 virtual AsyncWrap* GetAsyncWrap() = 0; // \u83b7\u53d6\u76f8\u5173\u8054\u7684\u539f\u59cbjs\u5bf9\u8c61 v8::Local<v8::Object> object(); // \u8bf7\u6c42\u7ed3\u675f\u540e\u7684\u56de\u8c03\uff0c\u4f1a\u6267\u884c\u5b50\u7c7b\u7684onDone\uff0conDone\u7531\u5b50\u7c7b\u5b9e\u73b0 void Done(int status, const char* error_str = nullptr); // JS\u5c42\u5bf9\u8c61\u4e0d\u518d\u6267\u884cStreamReq\u5b9e\u4f8b void Dispose(); // \u83b7\u53d6\u6240\u64cd\u4f5c\u7684\u6d41 inline StreamBase* stream() const { return stream_; } // \u4eceJS\u5c42\u5bf9\u8c61\u83b7\u53d6StreamReq\u5bf9\u8c61 static StreamReq* FromObject(v8::Local<v8::Object> req_wrap_obj); // \u8bf7\u6c42JS\u5c42\u5bf9\u8c61\u7684internalField\u6240\u6709\u6307\u5411 static inline void ResetObject(v8::Local<v8::Object> req_wrap_obj); protected: // \u8bf7\u6c42\u7ed3\u675f\u540e\u56de\u8c03 virtual void OnDone(int status) = 0; void AttachToObject(v8::Local<v8::Object> req_wrap_obj); private: StreamBase* const stream_; }; StreamReq\u6709\u4e00\u4e2a\u6210\u5458\u4e3astream_\uff0c\u8868\u793aStreamReq\u8bf7\u6c42\u4e2d\u64cd\u4f5c\u7684\u6d41\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0\u3002 1 JS\u5c42\u8bf7\u6c42\u4e0a\u4e0b\u6587\u548cStreamReq\u7684\u5173\u7cfb\u7ba1\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 inline void StreamReq::AttachToObject(v8::Local<v8::Object> req_wrap_obj) { req_wrap_obj->SetAlignedPointerInInternalField(kStreamReqField, this); } inline StreamReq* StreamReq::FromObject(v8::Local<v8::Object> req_wrap_obj) { return static_cast<StreamReq*>( req_wrap_obj->GetAlignedPointerFromInternalField(kStreamReqField)); } inline void StreamReq::Dispose() { object()->SetAlignedPointerInInternalField(kStreamReqField, nullptr); delete this; } inline void StreamReq::ResetObject(v8::Local<v8::Object> obj) { obj->SetAlignedPointerInInternalField(0, nullptr); // BaseObject field. obj->SetAlignedPointerInInternalField(StreamReq::kStreamReqField, nullptr); } 2 \u83b7\u53d6\u539f\u59cbJS\u5c42\u8bf7\u6c42\u5bf9\u8c61 1 2 3 4 // \u83b7\u53d6\u548c\u8be5\u8bf7\u6c42\u76f8\u5173\u8054\u7684\u539f\u59cbjs\u5bf9\u8c61 inline v8::Local<v8::Object> StreamReq::object() { return GetAsyncWrap()->object(); } 3 \u8bf7\u6c42\u7ed3\u675f\u56de\u8c03 1 2 3 4 5 6 7 8 9 10 11 12 13 inline void StreamReq::Done(int status, const char* error_str) { AsyncWrap* async_wrap = GetAsyncWrap(); Environment* env = async_wrap->env(); if (error_str != nullptr) { async_wrap->object()->Set(env->context(), env->error_string(), OneByteString(env->isolate(), error_str)) .Check(); } // \u6267\u884c\u5b50\u7c7b\u7684OnDone OnDone(status); } \u6d41\u64cd\u4f5c\u8bf7\u6c42\u7ed3\u675f\u540e\u4f1a\u7edf\u4e00\u6267\u884cDone\uff0cDone\u4f1a\u6267\u884c\u5b50\u7c7b\u5b9e\u73b0\u7684OnDone\u51fd\u6570\u3002","title":"6.8.5 StreamReq"},{"location":"chapter06-C%2B%2B%E5%B1%82/#686-shutdownwrap","text":"ShutdownWrap\u662fStreamReq\u7684\u5b50\u7c7b\uff0c\u8868\u793a\u4e00\u6b21\u5173\u95ed\u6d41\u8bf7\u6c42\u3002 1 2 3 4 5 6 7 8 class ShutdownWrap : public StreamReq { public: ShutdownWrap(StreamBase* stream, v8::Local<v8::Object> req_wrap_obj) : StreamReq(stream, req_wrap_obj) { } void OnDone(int status) override; }; ShutdownWrap\u5b9e\u73b0\u4e86OnDone\u63a5\u53e3\uff0c\u5728\u5173\u95ed\u6d41\u7ed3\u675f\u540e\u88ab\u57fa\u7c7b\u6267\u884c\u3002 1 2 3 4 5 6 7 8 9 /* \u5173\u95ed\u7ed3\u675f\u65f6\u56de\u8c03\uff0c\u7531\u8bf7\u6c42\u7c7b\uff08ShutdownWrap\uff09\u8c03\u7528Libuv\uff0c \u6240\u4ee5Libuv\u64cd\u4f5c\u5b8c\u6210\u540e\uff0c\u9996\u5148\u6267\u884c\u8bf7\u6c42\u7c7b\u7684\u56de\u8c03\uff0c\u8bf7\u6c42\u7c7b\u901a\u77e5\u6d41\uff0c\u6d41\u89e6\u53d1 \u5bf9\u5e94\u7684\u4e8b\u4ef6\uff0c\u8fdb\u4e00\u6b65\u901a\u77e5listener */ inline void ShutdownWrap::OnDone(int status) { stream()->EmitAfterShutdown(this, status); Dispose(); }","title":"6.8.6 ShutdownWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#687-simpleshutdownwrap","text":"SimpleShutdownWrap\u662fShutdownWrap\u7684\u5b50\u7c7b\u3002\u5b9e\u73b0\u4e86GetAsyncWrap\u63a5\u53e3\u3002OtherBase\u53ef\u4ee5\u662fReqWrap\u6216\u8005AsyncWrap\u3002 1 2 3 4 5 6 7 8 template <typename OtherBase> class SimpleShutdownWrap : public ShutdownWrap, public OtherBase { public: SimpleShutdownWrap(StreamBase* stream, v8::Local<v8::Object> req_wrap_obj); AsyncWrap* GetAsyncWrap() override { return this; } };","title":"6.8.7 SimpleShutdownWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#688-writewrap","text":"WriteWrap\u662fStreamReq\u7684\u5b50\u7c7b\uff0c\u8868\u793a\u4e00\u6b21\u5f80\u6d41\u5199\u5165\u6570\u636e\u7684\u8bf7\u6c42\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 class WriteWrap : public StreamReq { public: void SetAllocatedStorage(AllocatedBuffer&& storage); WriteWrap(StreamBase* stream, v8::Local<v8::Object> req_wrap_obj) : StreamReq(stream, req_wrap_obj) { } void OnDone(int status) override; private: AllocatedBuffer storage_; }; WriteWrap\u5b9e\u73b0\u4e86OnDone\u63a5\u53e3\uff0c\u5728\u5199\u7ed3\u675f\u65f6\u88ab\u57fa\u7c7b\u6267\u884c\u3002 1 2 3 4 inline void WriteWrap::OnDone(int status) { stream()->EmitAfterWrite(this, status); Dispose(); } \u8bf7\u6c42\u7ed3\u675f\u540e\u8c03\u7528\u6d41\u7684\u63a5\u53e3\u901a\u77e5\u6d41\u5199\u7ed3\u675f\u4e86\uff0c\u6d41\u4f1a\u901a\u77e5listener\uff0clistener\u4f1a\u8c03\u7528\u6d41\u7684\u63a5\u53e3\u901a\u77e5JS\u5c42\u3002","title":"6.8.8 WriteWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#689-simplewritewrap","text":"SimpleWriteWrap\u662fWriteWrap\u7684\u5b50\u7c7b\u3002\u5b9e\u73b0\u4e86GetAsyncWrap\u63a5\u53e3\u3002\u548cSimpleShutdownWrap\u7c7b\u578b\u3002 1 2 3 4 5 6 7 8 template <typename OtherBase> class SimpleWriteWrap : public WriteWrap, public OtherBase { public: SimpleWriteWrap(StreamBase* stream, v8::Local<v8::Object> req_wrap_obj); AsyncWrap* GetAsyncWrap() override { return this; } };","title":"6.8.9 SimpleWriteWrap"},{"location":"chapter06-C%2B%2B%E5%B1%82/#6810-streamlistener","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class StreamListener { public: virtual ~StreamListener(); // \u5206\u914d\u5b58\u50a8\u6570\u636e\u7684\u5185\u5b58 virtual uv_buf_t OnStreamAlloc(size_t suggested_size) = 0; // \u6709\u6570\u636e\u53ef\u8bfb\u65f6\u56de\u8c03\uff0c\u6d88\u8d39\u6570\u636e\u7684\u51fd\u6570 virtual void OnStreamRead(ssize_t nread, const uv_buf_t& buf) = 0; // \u6d41\u9500\u6bc1\u65f6\u56de\u8c03 virtual void OnStreamDestroy() {} // \u76d1\u542c\u8005\u6240\u5c5e\u6d41 inline StreamResource* stream() { return stream_; } protected: // \u6d41\u662f\u76d1\u542c\u8005\u662f\u4e00\u6761\u94fe\u8868\uff0c\u8be5\u51fd\u6570\u628a\u7ed3\u6784\u4f20\u9012\u7ed9\u4e0b\u4e00\u4e2a\u8282\u70b9 void PassReadErrorToPreviousListener(ssize_t nread); // \u76d1\u542c\u8005\u6240\u5c5e\u6d41 StreamResource* stream_ = nullptr; // \u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u5f62\u6210\u94fe\u8868 StreamListener* previous_listener_ = nullptr; friend class StreamResource; }; StreamListener\u662f\u7c7b\u4f3c\u4e00\u4e2a\u8ba2\u9605\u8005\uff0c\u5b83\u4f1a\u5bf9\u6d41\u7684\u72b6\u6001\u611f\u5174\u8da3\uff0c\u6bd4\u5982\u6570\u636e\u53ef\u8bfb\u3001\u53ef\u5199\u3001\u6d41\u5173\u95ed\u7b49\u3002\u4e00\u4e2a\u6d41\u53ef\u4ee5\u6ce8\u518c\u591a\u4e2alistener\uff0c\u591a\u4e2alistener\u5f62\u6210\u4e00\u4e2a\u94fe\u8868\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // \u4ecelisten\u6240\u5c5e\u7684\u6d41\u7684listener\u961f\u5217\u4e2d\u5220\u9664\u81ea\u5df1 inline StreamListener::~StreamListener() { if (stream_ != nullptr) stream_->RemoveStreamListener(this); } // \u8bfb\u51fa\u9519\uff0c\u628a\u4fe1\u606f\u4f20\u9012\u7ed9\u524d\u4e00\u4e2alistener inline void StreamListener::PassReadErrorToPreviousListener(ssize_t nread) { CHECK_NOT_NULL(previous_listener_); previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0)); } // \u5b9e\u73b0\u6d41\u5173\u95ed\u65f6\u7684\u5904\u7406\u903b\u8f91 inline void StreamListener::OnStreamAfterShutdown(ShutdownWrap* w, int status) { previous_listener_->OnStreamAfterShutdown(w, status); } // \u5b9e\u73b0\u5199\u7ed3\u675f\u65f6\u7684\u5904\u7406\u903b\u8f91 inline void StreamListener::OnStreamAfterWrite(WriteWrap* w, int status) { previous_listener_->OnStreamAfterWrite(w, status); } StreamListener\u7684\u903b\u8f91\u4e0d\u591a\uff0c\u5177\u4f53\u7684\u5b9e\u73b0\u5728\u5b50\u7c7b\u3002","title":"6.8.10 StreamListener"},{"location":"chapter06-C%2B%2B%E5%B1%82/#6811-reportwritestojsstreamlistener","text":"ReportWritesToJSStreamListener\u662fStreamListener\u7684\u5b50\u7c7b\u3002\u8986\u76d6\u4e86\u90e8\u5206\u63a5\u53e3\u548c\u62d3\u5c55\u4e86\u4e00\u4e9b\u529f\u80fd\u3002 1 2 3 4 5 6 7 8 9 class ReportWritesToJSStreamListener : public StreamListener { public: // \u5b9e\u73b0\u7236\u7c7b\u7684\u8fd9\u4e24\u4e2a\u63a5\u53e3 void OnStreamAfterWrite(WriteWrap* w, int status) override; void OnStreamAfterShutdown(ShutdownWrap* w, int status) override; private: void OnStreamAfterReqFinished(StreamReq* req_wrap, int status); }; 1 OnStreamAfterReqFinished OnStreamAfterReqFinished\u662f\u8bf7\u6c42\u64cd\u4f5c\u6d41\u7ed3\u675f\u540e\u7684\u7edf\u4e00\u7684\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 void ReportWritesToJSStreamListener::OnStreamAfterWrite( WriteWrap* req_wrap, int status) { OnStreamAfterReqFinished(req_wrap, status); } void ReportWritesToJSStreamListener::OnStreamAfterShutdown( ShutdownWrap* req_wrap, int status) { OnStreamAfterReqFinished(req_wrap, status); } \u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void ReportWritesToJSStreamListener::OnStreamAfterReqFinished( StreamReq* req_wrap, int status) { // \u8bf7\u6c42\u6240\u64cd\u4f5c\u7684\u6d41 StreamBase* stream = static_cast<StreamBase*>(stream_); Environment* env = stream->stream_env(); AsyncWrap* async_wrap = req_wrap->GetAsyncWrap(); HandleScope handle_scope(env->isolate()); Context::Scope context_scope(env->context()); // \u83b7\u53d6\u539f\u59cb\u7684JS\u5c42\u5bf9\u8c61 Local<Object> req_wrap_obj = async_wrap->object(); Local<Value> argv[] = { Integer::New(env->isolate(), status), stream->GetObject(), Undefined(env->isolate()) }; const char* msg = stream->Error(); if (msg != nullptr) { argv[2] = OneByteString(env->isolate(), msg); stream->ClearError(); } // \u56de\u8c03JS\u5c42 if (req_wrap_obj->Has(env->context(), env->oncomplete_string()).FromJust()) async_wrap->MakeCallback(env->oncomplete_string(), arraysize(argv), argv); } OnStreamAfterReqFinished\u4f1a\u56de\u8c03JS\u5c42\u3002 6.8.12 EmitToJSStreamListener EmitToJSStreamListener\u662fReportWritesToJSStreamListener\u7684\u5b50\u7c7b 1 2 3 4 5 class EmitToJSStreamListener : public ReportWritesToJSStreamListener { public: uv_buf_t OnStreamAlloc(size_t suggested_size) override; void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override; }; \u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // \u5206\u914d\u4e00\u5757\u5185\u5b58 uv_buf_t EmitToJSStreamListener::OnStreamAlloc(size_t suggested_size) { Environment* env = static_cast<StreamBase*>(stream_)->stream_env(); return env->AllocateManaged(suggested_size).release(); } // \u8bfb\u53d6\u6570\u636e\u7ed3\u675f\u540e\u56de\u8c03 void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf_) { StreamBase* stream = static_cast<StreamBase*>(stream_); Environment* env = stream->stream_env(); HandleScope handle_scope(env->isolate()); Context::Scope context_scope(env->context()); AllocatedBuffer buf(env, buf_); // \u8bfb\u53d6\u5931\u8d25 if (nread <= 0) { if (nread < 0) stream->CallJSOnreadMethod(nread, Local<ArrayBuffer>()); return; } buf.Resize(nread); // \u8bfb\u53d6\u6210\u529f\u56de\u8c03JS\u5c42 stream->CallJSOnreadMethod(nread, buf.ToArrayBuffer()); } \u6211\u4eec\u770b\u5230listener\u5904\u7406\u5b8c\u6570\u636e\u540e\u53c8\u4f1a\u56de\u8c03\u6d41\u7684\u63a5\u53e3\uff0c\u5177\u4f53\u7684\u903b\u8f91\u7531\u5b50\u7c7b\u5b9e\u73b0\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e2a\u5b50\u7c7b\u7684\u5b9e\u73b0\uff08\u6d41\u9ed8\u8ba4\u7684listener\uff09\u3002 1 2 3 4 5 class EmitToJSStreamListener : public ReportWritesToJSStreamListener { public: uv_buf_t OnStreamAlloc(size_t suggested_size) override; void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override; }; EmitToJSStreamListener\u4f1a\u5b9e\u73b0OnStreamRead\u7b49\u65b9\u6cd5\uff0c\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u521b\u5efa\u4e00\u4e2aC++\u5c42\u7684TCP\u5bf9\u8c61\u662f\u600e\u6837\u7684\u3002\u4e0b\u9762\u662fTCPWrap\u7684\u7ee7\u627f\u5173\u7cfb\u3002 1 2 3 4 5 class TCPWrap : public ConnectionWrap<TCPWrap, uv_tcp_t>{} // ConnectionWrap\u62d3\u5c55\u4e86\u5efa\u7acbTCP\u8fde\u63a5\u65f6\u7684\u903b\u8f91 class ConnectionWrap : public LibuvStreamWrap{} class LibuvStreamWrap : public HandleWrap, public StreamBase{} class StreamBase : public StreamResource {} \u6211\u4eec\u770b\u5230TCP\u6d41\u662f\u7ee7\u627f\u4e8eStreamResource\u7684\u3002\u65b0\u5efa\u4e00\u4e2aTCP\u7684C++\u7684\u5bf9\u8c61\u65f6\uff08tcp_wrap.cc\uff09\uff0c\u4f1a\u4e0d\u65ad\u5f80\u4e0a\u8c03\u7528\u7236\u7c7b\u7684\u6784\u9020\u51fd\u6570\uff0c\u5176\u4e2d\u5728StreamBase\u4e2d\u6709\u4e00\u4e2a\u5173\u952e\u7684\u64cd\u4f5c\u3002 1 2 3 4 5 inline StreamBase::StreamBase(Environment* env) : env_(env) { PushStreamListener(&default_listener_); } EmitToJSStreamListener default_listener_; StreamBase\u4f1a\u9ed8\u8ba4\u7ed9\u6d41\u6ce8\u518c\u4e00\u4e2alistener\u3002\u6211\u4eec\u770b\u4e0bEmitToJSStreamListener \u5177\u4f53\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class ReportWritesToJSStreamListener : public StreamListener { public: void OnStreamAfterWrite(WriteWrap* w, int status) override; void OnStreamAfterShutdown(ShutdownWrap* w, int status) override; private: void OnStreamAfterReqFinished(StreamReq* req_wrap, int status); }; class EmitToJSStreamListener : public ReportWritesToJSStreamListener { public: uv_buf_t OnStreamAlloc(size_t suggested_size) override; void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override; }; EmitToJSStreamListener\u7ee7\u627fStreamListener \uff0c\u5b9a\u4e49\u4e86\u5206\u914d\u5185\u5b58\u548c\u8bfb\u53d6\u63a5\u6536\u6570\u636e\u7684\u51fd\u6570\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bPushStreamListener\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002 1 2 3 4 5 6 inline void StreamResource::PushStreamListener(StreamListener* listener) { // \u5934\u63d2\u6cd5 listener->previous_listener_ = listener_; listener->stream_ = this; listener_ = listener; } PushStreamListener\u5c31\u662f\u6784\u9020\u51fa\u4e00\u4e2alistener\u94fe\u8868\u7ed3\u6784\u3002\u7136\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u5bf9\u4e8e\u6d41\u6765\u8bf4\uff0c\u8bfb\u53d6\u6570\u636e\u7684\u6574\u4e2a\u94fe\u8def\u3002\u9996\u5148\u662fJS\u5c42\u8c03\u7528readStart 1 2 3 4 5 6 7 8 9 10 11 function tryReadStart(socket) { socket._handle.reading = true; const err = socket._handle.readStart(); if (err) socket.destroy(errnoException(err, 'read')); } // \u6ce8\u518c\u7b49\u5f85\u8bfb\u4e8b\u4ef6 Socket.prototype._read = function(n) { tryReadStart(this); }; \u6211\u4eec\u770b\u770breadStart 1 2 3 4 5 6 7 8 9 int LibuvStreamWrap::ReadStart() { return uv_read_start(stream(), [](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) { static_cast<LibuvStreamWrap*>(handle->data)->OnUvAlloc(suggested_size, buf); }, [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) { static_cast<LibuvStreamWrap*>(stream->data)->OnUvRead(nread, buf); }); } ReadStart\u8c03\u7528Libuv\u7684uv_read_start\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u5e76\u4e14\u6ce8\u518c\u4e86\u4e24\u4e2a\u56de\u8c03\u51fd\u6570OnUvAlloc\u548cOnUvRead\u3002 1 2 3 4 5 6 7 8 9 10 void LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) { EmitRead(nread, *buf); } inline void StreamResource::EmitRead(ssize_t nread, const uv_buf_t& buf) { // bytes_read_\u8868\u793a\u5df2\u8bfb\u7684\u5b57\u8282\u6570 if (nread > 0) bytes_read_ += static_cast<uint64_t>(nread); listener_->OnStreamRead(nread, buf); } \u901a\u8fc7\u5c42\u5c42\u8c03\u7528\u6700\u540e\u4f1a\u8c03\u7528listener_\u7684OnStreamRead\u3002\u6211\u4eec\u770b\u770bTCP\u7684OnStreamRead 1 2 3 4 5 6 7 8 void EmitToJSStreamListener::OnStreamRead(ssize_t nread, const uv_buf_t& buf_) { StreamBase* stream = static_cast<StreamBase*>(stream_); Environment* env = stream->stream_env(); HandleScope handle_scope(env->isolate()); Context::Scope context_scope(env->context()); AllocatedBuffer buf(env, buf_); stream->CallJSOnreadMethod(nread, buf.ToArrayBuffer()); } \u7ee7\u7eed\u56de\u8c03CallJSOnreadMethod 1 2 3 4 5 6 7 8 9 10 11 12 MaybeLocal<Value> StreamBase::CallJSOnreadMethod(ssize_t nread, Local<ArrayBuffer> ab, size_t offset, StreamBaseJSChecks checks) { Environment* env = env_; // ... AsyncWrap* wrap = GetAsyncWrap(); CHECK_NOT_NULL(wrap); Local<Value> onread = wrap->object()->GetInternalField(kOnReadFunctionField); CHECK(onread->IsFunction()); return wrap->MakeCallback(onread.As<Function>(), arraysize(argv), argv); } CallJSOnreadMethod\u4f1a\u56de\u8c03JS\u5c42\u7684onread\u56de\u8c03\u51fd\u6570\u3002onread\u4f1a\u628a\u6570\u636epush\u5230\u6d41\u4e2d\uff0c\u7136\u540e\u89e6\u53d1data\u4e8b\u4ef6\u3002","title":"6.8.11 ReportWritesToJSStreamListener"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/","text":"7.1 \u4fe1\u53f7\u7684\u6982\u5ff5\u548c\u5b9e\u73b0\u539f\u7406 \u00b6 \u4fe1\u53f7\u662f\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u4e00\u79cd\u7b80\u5355\u7684\u65b9\u5f0f\uff0c\u6211\u4eec\u9996\u5148\u4e86\u89e3\u4e00\u4e0b\u4fe1\u53f7\u7684\u6982\u5ff5\u548c\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u5b9e\u73b0\u539f\u7406\u3002\u5728\u64cd\u4f5c\u7cfb\u7edf\u5185\u6838\u7684\u5b9e\u73b0\u4e2d\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u5bf9\u5e94\u4e00\u4e2atask_struct\u7ed3\u6784\u4f53\uff08PCB\uff09\uff0cPCB\u4e2d\u6709\u4e00\u4e2a\u5b57\u6bb5\u8bb0\u5f55\u4e86\u8fdb\u7a0b\u6536\u5230\u7684\u4fe1\u53f7\uff08\u6bcf\u4e00\u4e2a\u6bd4\u7279\u4ee3\u8868\u4e00\u79cd\u4fe1\u53f7\uff09\u548c\u4fe1\u53f7\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\u3002\u8fd9\u4e2a\u548c\u8ba2\u9605\u8005/\u53d1\u5e03\u8005\u6a21\u5f0f\u975e\u5e38\u76f8\u4f3c\uff0c\u6211\u4eec\u770b\u4e00\u4e0bPCB\u4e2d\u4fe1\u53f7\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct task_struct { // \u6536\u5230\u7684\u4fe1\u53f7 long signal ; // \u5904\u7406\u4fe1\u53f7\u8fc7\u7a0b\u4e2d\u5c4f\u853d\u7684\u4fe1\u606f long blocked ; // \u4fe1\u53f7\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570 struct sigaction sigaction [ 32 ]; ... }; struct sigaction { // \u4fe1\u53f7\u5904\u7406\u51fd\u6570 void ( * sa_handler )( int ); // \u5904\u7406\u4fe1\u53f7\u65f6\u5c4f\u853d\u54ea\u4e9b\u4fe1\u606f\uff0c\u548cPCB\u7684block\u5b57\u6bb5\u5bf9\u5e94 sigset_t sa_mask ; // \u4e00\u4e9b\u6807\u8bb0\uff0c\u6bd4\u5982\u5904\u7406\u51fd\u6570\u53ea\u6267\u884c\u4e00\u6b21\uff0c\u7c7b\u4f3cevents\u6a21\u5757\u7684once int sa_flags ; // \u6e05\u9664\u8c03\u7528\u6808\u4fe1\u606f\uff0cglibc\u4f7f\u7528 void ( * sa_restorer )( void ); }; Linux\u4e0b\u652f\u6301\u591a\u79cd\u4fe1\u53f7\uff0c\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u4e86\u9ed8\u8ba4\u5904\u7406\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u663e\u5f0f\u6ce8\u518c\u5904\u7406\u4fe1\u53f7\u7684\u51fd\u6570\uff0c\u4f46\u662f\u6709\u4e9b\u4fe1\u53f7\u4f1a\u5bfc\u81f4\u8fdb\u7a0b\u9000\u51fa\uff0c\u8fd9\u662f\u6211\u4eec\u65e0\u6cd5\u63a7\u5236\u7684\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u5728Linux\u4e0b\u4fe1\u53f7\u4f7f\u7528\u7684\u4f8b\u5b50\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <stdio.h> #include <unistd.h> #include <stdlib.h> #include <signal.h> void handler ( int ); int main () { signal ( SIGINT , handler ); while ( 1 ); return ( 0 ); } void sighandler ( int signum ) { printf ( \"\u6536\u5230\u4fe1\u53f7%d\" , signum ); } \u6211\u4eec\u6ce8\u518c\u4e86\u4e00\u4e2a\u4fe1\u53f7\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff0c\u7136\u540e\u8fdb\u5165while\u5faa\u73af\u4fdd\u8bc1\u8fdb\u7a0b\u4e0d\u4f1a\u9000\u51fa\uff0c\u8fd9\u65f6\u5019\uff0c\u5982\u679c\u6211\u4eec\u7ed9\u8fd9\u4e2a\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2aSIGINT\u4fe1\u53f7\uff08ctrl+c\u6216\u8005kill -2 pid\uff09\u3002\u5219\u8fdb\u7a0b\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\uff0c\u7136\u540e\u8f93\u51fa\uff1a\u6536\u5230\u4fe1\u53f72\u3002\u4e86\u89e3\u4e86\u4fe1\u53f7\u7684\u57fa\u672c\u539f\u7406\u540e\uff0c\u6211\u4eec\u770b\u4e00\u4e0bLibuv\u4e2d\u5173\u4e8e\u4fe1\u53f7\u7684\u8bbe\u8ba1\u548c\u5b9e\u73b0\u3002 7.2 Libuv\u4fe1\u53f7\u5904\u7406\u7684\u8bbe\u8ba1\u601d\u60f3 \u00b6 \u7531\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u5b9e\u73b0\u7684\u9650\u5236\uff0c\u6211\u4eec\u65e0\u6cd5\u7ed9\u4e00\u4e2a\u4fe1\u53f7\u6ce8\u518c\u591a\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u5bf9\u4e8e\u540c\u4e00\u4e2a\u4fe1\u53f7\uff0c\u5982\u679c\u6211\u4eec\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63a5\u53e3\u591a\u6b21\uff0c\u540e\u9762\u7684\u5c31\u4f1a\u8986\u76d6\u524d\u9762\u8bbe\u7f6e\u7684\u503c\u3002\u60f3\u8981\u5b9e\u73b0\u4e00\u4e2a\u4fe1\u53f7\u88ab\u591a\u4e2a\u51fd\u6570\u5904\u7406\uff0c\u6211\u4eec\u53ea\u80fd\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e4b\u4e0a\u518d\u5c01\u88c5\u4e00\u5c42\uff0cLibuv\u6b63\u662f\u8fd9\u6837\u505a\u7684\u3002Libuv\u4e2d\u5173\u4e8e\u4fe1\u53f7\u5904\u7406\u7684\u5c01\u88c5\u548c\u8ba2\u9605\u8005/\u53d1\u5e03\u8005\u6a21\u5f0f\u5f88\u76f8\u4f3c\u3002\u7528\u6237\u8c03\u7528Libuv\u7684\u63a5\u53e3\u6ce8\u518c\u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0cLibuv\u518d\u5411\u64cd\u4f5c\u7cfb\u7edf\u6ce8\u518c\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff0c\u7b49\u5f85\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230\u4fe1\u53f7\u65f6\uff0c\u4f1a\u89e6\u53d1Libuv\u7684\u56de\u8c03\uff0cLibuv\u7684\u56de\u8c03\u4f1a\u901a\u8fc7\u7ba1\u9053\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\u6536\u5230\u7684\u4fe1\u53f7\u548c\u5bf9\u5e94\u7684\u4e0a\u4e0b\u6587\uff0c\u63a5\u7740\u4e8b\u4ef6\u5faa\u73af\u5728Poll IO\u9636\u6bb5\u5c31\u4f1a\u5904\u7406\u6536\u5230\u6240\u6709\u4fe1\u53f7\u4ee5\u53ca\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\u3002\u6574\u4f53\u67b6\u6784\u5982\u56fe7-1\u6240\u793a \u56fe7-1 \u4e0b\u9762\u6211\u4eec\u5177\u4f53\u5206\u6790Libuv\u4e2d\u4fe1\u53f7\u5904\u7406\u7684\u5b9e\u73b0\u3002 7.3 \u901a\u4fe1\u673a\u5236\u7684\u5b9e\u73b0 \u00b6 \u5f53\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\uff0c\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u9700\u8981\u901a\u77e5Libuv\u4e8b\u4ef6\u5faa\u73af\uff0c\u4ece\u800c\u5728\u4e8b\u4ef6\u5faa\u73af\u4e2d\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\uff0c\u5b9e\u73b0\u51fd\u6570\u662fuv__signal_loop_once_init\uff0c\u6211\u4eec\u770b\u4e00\u4e0buv__signal_loop_once_init\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 static int uv__signal_loop_once_init ( uv_loop_t * loop ) { /* \u7533\u8bf7\u4e00\u4e2a\u7ba1\u9053\u7528\u4e8e\u548c\u4e8b\u4ef6\u5faa\u73af\u901a\u4fe1\uff0c\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u6536\u5230\u4fe1\u53f7\uff0c \u5e76\u8bbe\u7f6e\u975e\u963b\u585e\u6807\u8bb0 */ uv__make_pipe ( loop -> signal_pipefd , UV__F_NONBLOCK ); /* \u8bbe\u7f6e\u4fe1\u53f7IO\u89c2\u5bdf\u8005\u7684\u5904\u7406\u51fd\u6570\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c Libuv\u5728Poll IO\u65f6\uff0c\u53d1\u73b0\u7ba1\u9053\u8bfb\u7aefloop->signal_pipefd[0]\u53ef\u8bfb\uff0c \u5219\u6267\u884cuv__signal_event */ uv__io_init ( & loop -> signal_io_watcher , uv__signal_event , loop -> signal_pipefd [ 0 ]); /* \u63d2\u5165Libuv\u7684IO\u89c2\u5bdf\u8005\u961f\u5217\uff0c\u5e76\u6ce8\u518c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u4e3a\u53ef\u8bfb */ uv__io_start ( loop , & loop -> signal_io_watcher , POLLIN ); return 0 ; } uv__signal_loop_once_init\u9996\u5148\u7533\u8bf7\u4e00\u4e2a\u7ba1\u9053\uff0c\u7528\u4e8e\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u6536\u5230\u4fe1\u53f7\u3002\u7136\u540e\u5f80Libuv\u7684IO\u89c2\u5bdf\u8005\u961f\u5217\u6ce8\u518c\u4e00\u4e2a\u89c2\u5bdf\u8005\uff0cLibuv\u5728Poll IO\u9636\u6bb5\u4f1a\u628a\u89c2\u5bdf\u8005\u52a0\u5230epoll\u4e2d\u3002IO\u89c2\u5bdf\u8005\u91cc\u4fdd\u5b58\u4e86\u7ba1\u9053\u8bfb\u7aef\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26loop->signal_pipefd[0]\u548c\u56de\u8c03\u51fd\u6570uv__signal_event\u3002uv__signal_event\u662f\u6536\u5230\u4efb\u610f\u4fe1\u53f7\u65f6\u7684\u56de\u8c03\uff0c\u5b83\u4f1a\u7ee7\u7eed\u6839\u636e\u6536\u5230\u7684\u4fe1\u53f7\u8fdb\u884c\u903b\u8f91\u5206\u53d1\u3002\u6267\u884c\u5b8c\u7684\u67b6\u6784\u5982\u56fe7-2\u6240\u793a\u3002 \u56fe7-2 7.4 \u4fe1\u53f7\u7ed3\u6784\u4f53\u7684\u521d\u59cb\u5316 \u00b6 Libuv\u4e2d\u4fe1\u53f7\u4f7f\u7528uv_signal_t\u8868\u793a\u3002 1 2 3 4 5 6 7 8 9 10 int uv_signal_init ( uv_loop_t * loop , uv_signal_t * handle ) { // \u7533\u8bf7\u548cLibuv\u7684\u901a\u4fe1\u7ba1\u9053\u5e76\u4e14\u6ce8\u518cIO\u89c2\u5bdf\u8005 uv__signal_loop_once_init ( loop ); uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_SIGNAL ); handle -> signum = 0 ; handle -> caught_signals = 0 ; handle -> dispatched_signals = 0 ; return 0 ; } \u4e0a\u9762\u7684\u4ee3\u7801\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u53ea\u662f\u521d\u59cb\u5316uv_signal_t\u7ed3\u6784\u4f53\u7684\u4e00\u4e9b\u5b57\u6bb5\u3002 7.5 \u4fe1\u53f7\u5904\u7406\u7684\u6ce8\u518c \u00b6 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7uv_signal_start\u6ce8\u518c\u4e00\u4e2a\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u903b\u8f91 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 static int uv__signal_start ( uv_signal_t * handle , uv_signal_cb signal_cb , int signum , int oneshot ) { sigset_t saved_sigmask ; int err ; uv_signal_t * first_handle ; // \u6ce8\u518c\u8fc7\u4e86\uff0c\u91cd\u65b0\u8bbe\u7f6e\u5904\u7406\u51fd\u6570\u5c31\u884c if ( signum == handle -> signum ) { handle -> signal_cb = signal_cb ; return 0 ; } // \u8fd9\u4e2ahandle\u4e4b\u524d\u5df2\u7ecf\u8bbe\u7f6e\u4e86\u5176\u5b83\u4fe1\u53f7\u548c\u5904\u7406\u51fd\u6570\uff0c\u5219\u5148\u89e3\u9664 if ( handle -> signum != 0 ) { uv__signal_stop ( handle ); } // \u5c4f\u853d\u6240\u6709\u4fe1\u53f7 uv__signal_block_and_lock ( & saved_sigmask ); /* \u67e5\u627e\u6ce8\u518c\u4e86\u8be5\u4fe1\u53f7\u7684\u7b2c\u4e00\u4e2ahandle\uff0c \u4f18\u5148\u8fd4\u56de\u8bbe\u7f6e\u4e86UV_SIGNAL_ONE_SHOT flag\u7684\uff0c \u89c1compare\u51fd\u6570 */ first_handle = uv__signal_first_handle ( signum ); /* 1 \u4e4b\u524d\u6ca1\u6709\u6ce8\u518c\u8fc7\u8be5\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570\u5219\u76f4\u63a5\u8bbe\u7f6e 2 \u4e4b\u524d\u8bbe\u7f6e\u8fc7\uff0c\u4f46\u662f\u662fone shot\uff0c\u4f46\u662f\u73b0\u5728\u9700\u8981 \u8bbe\u7f6e\u7684\u89c4\u5219\u4e0d\u662fone shot\uff0c\u9700\u8981\u4fee\u6539\u3002\u5426\u5219\u7b2c \u4e8c\u6b21\u4e0d\u4f1a\u4e0d\u4f1a\u89e6\u53d1\u3002\u56e0\u4e3a\u4e00\u4e2a\u4fe1\u53f7\u53ea\u80fd\u5bf9\u5e94\u4e00 \u4e2a\u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0c\u6240\u4ee5\uff0c\u4ee5\u89c4\u5219\u5bbd\u7684\u4e3a\u51c6\uff0c\u5728\u56de\u8c03 \u91cc\u518d\u6839\u636eflags\u5224\u65ad\u662f\u4e0d\u662f\u771f\u7684\u9700\u8981\u6267\u884c 3 \u5982\u679c\u6ce8\u518c\u8fc7\u4fe1\u53f7\u548c\u5904\u7406\u51fd\u6570\uff0c\u5219\u76f4\u63a5\u63d2\u5165\u7ea2\u9ed1\u6811\u5c31\u884c\u3002 */ if ( first_handle == NULL || ( ! oneshot && ( first_handle -> flags & UV_SIGNAL_ONE_SHOT )) ) { // \u6ce8\u518c\u4fe1\u53f7\u548c\u5904\u7406\u51fd\u6570 err = uv__signal_register_handler ( signum , oneshot ); if ( err ) { uv__signal_unlock_and_unblock ( & saved_sigmask ); return err ; } } // \u8bb0\u5f55\u611f\u5174\u8da3\u7684\u4fe1\u53f7 handle -> signum = signum ; // \u53ea\u5904\u7406\u8be5\u4fe1\u53f7\u4e00\u6b21 if ( oneshot ) handle -> flags |= UV_SIGNAL_ONE_SHOT ; // \u63d2\u5165\u7ea2\u9ed1\u6811 RB_INSERT ( uv__signal_tree_s , & uv__signal_tree , handle ); uv__signal_unlock_and_unblock ( & saved_sigmask ); // \u4fe1\u53f7\u89e6\u53d1\u65f6\u7684\u4e1a\u52a1\u5c42\u56de\u8c03 handle -> signal_cb = signal_cb ; uv__handle_start ( handle ); return 0 ; } \u4e0a\u9762\u7684\u4ee3\u7801\u6bd4\u8f83\u591a\uff0c\u5927\u81f4\u7684\u903b\u8f91\u5982\u4e0b. 1 \u5224\u65ad\u662f\u5426\u9700\u8981\u5411\u64cd\u4f5c\u7cfb\u7edf\u6ce8\u518c\u4e00\u4e2a\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570\u3002\u4e3b\u8981\u662f\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u51fd\u6570\u6765\u5904\u7406\u7684\uff0c\u4ee3\u7801\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // \u7ed9\u5f53\u524d\u8fdb\u7a0b\u6ce8\u518c\u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0c\u4f1a\u8986\u76d6\u4e4b\u524d\u8bbe\u7f6e\u7684signum\u7684\u5904\u7406\u51fd\u6570 static int uv__signal_register_handler ( int signum , int oneshot ) { struct sigaction sa ; memset ( & sa , 0 , sizeof ( sa )); // \u5168\u7f6e\u4e00\uff0c\u8bf4\u660e\u6536\u5230signum\u4fe1\u53f7\u7684\u65f6\u5019\uff0c\u6682\u65f6\u5c4f\u853d\u5176\u5b83\u4fe1\u53f7 if ( sigfillset ( & sa . sa_mask )) abort (); // \u6240\u6709\u4fe1\u53f7\u90fd\u7531\u8be5\u51fd\u6570\u5904\u7406 sa . sa_handler = uv__signal_handler ; sa . sa_flags = SA_RESTART ; // \u8bbe\u7f6e\u4e86oneshot\uff0c\u8bf4\u660e\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u53ea\u6267\u884c\u4e00\u6b21\uff0c\u7136\u540e\u88ab\u6062\u590d\u4e3a\u7cfb\u7edf\u7684\u9ed8\u8ba4\u5904\u7406\u51fd\u6570 if ( oneshot ) sa . sa_flags |= SA_RESETHAND ; // \u6ce8\u518c if ( sigaction ( signum , & sa , NULL )) return UV__ERR ( errno ); return 0 ; } \u6211\u4eec\u770b\u5230\u6240\u6709\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570\u90fd\u662fuv__signal_handler\uff0c\u6211\u4eec\u4e00\u4f1a\u4f1a\u5206\u6790uv__signal_handler\u7684\u5b9e\u73b0\u3002 2\u8fdb\u7a0b\u6ce8\u518c\u7684\u4fe1\u53f7\u548c\u56de\u8c03\u662f\u5728\u4e00\u68f5\u7ea2\u9ed1\u6811\u7ba1\u7406\u7684\uff0c\u6bcf\u6b21\u6ce8\u518c\u7684\u65f6\u5019\u4f1a\u5f80\u7ea2\u9ed1\u6811\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\u3002Libuv\u7528\u9ed1\u7ea2\u6811\u7ef4\u62a4\u4fe1\u53f7\u7684\u4e0a\u4e0b\u6587\uff0c\u63d2\u5165\u7684\u89c4\u5219\u662f\u6839\u636e\u4fe1\u53f7\u7684\u5927\u5c0f\u548cflags\u7b49\u4fe1\u606f\u3002 RB_INSERT\u5b9e\u73b0\u4e86\u5f80\u7ea2\u9ed1\u6811\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u7ea2\u9ed1\u6811\u4e2d\u7684\u8282\u70b9\u662f\u7236\u8282\u70b9\u7684\u503c\u6bd4\u5de6\u5b69\u5b50\u5927\uff0c\u6bd4\u53f3\u5b69\u5b50\u5c0f\u7684\u3002\u6267\u884c\u5b8cRB_INSERT\u540e\u7684\u67b6\u6784\u5982\u56fe7-3\u6240\u793a\u3002 \u56fe7-3 \u6211\u4eec\u770b\u5230\uff0c\u5f53\u6211\u4eec\u6bcf\u6b21\u63d2\u5165\u4e0d\u540c\u7684\u4fe1\u53f7\u7684\u65f6\u5019\uff0cLibuv\u4f1a\u5728\u64cd\u4f5c\u7cfb\u7edf\u548c\u7ea2\u9ed1\u6811\u4e2d\u4fee\u6539\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u3002\u90a3\u4e48\u5982\u679c\u6211\u4eec\u63d2\u5165\u91cd\u590d\u7684\u4fe1\u53f7\u5462\uff1f\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u63d2\u5165\u91cd\u590d\u7684\u4fe1\u53f7\u65f6\uff0c\u5982\u679c\u5728\u64cd\u4f5c\u7cfb\u7edf\u6ce8\u518c\u8fc7\uff0c\u5e76\u4e14\u5f53\u524d\u63d2\u5165\u7684\u4fe1\u53f7flags\u662fone shot\uff0c\u800c\u4e4b\u524d\u662f\u975eone shot\u65f6\uff0cLibuv\u4f1a\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u63a5\u53e3\u53bb\u4fee\u6539\u914d\u7f6e\u3002\u90a3\u4e48\u5bf9\u4e8e\u7ea2\u9ed1\u6811\u6765\u8bf4\uff0c\u63d2\u5165\u91cd\u590d\u4fe1\u53f7\u4f1a\u5982\u4f55\u5904\u7406\u5462\uff1f\u4ece\u521a\u624dRB_INSERT\u7684\u4ee3\u7801\u4e2d\u6211\u4eec\u770b\u5230\u6bcf\u6b21\u63d2\u5165\u7ea2\u9ed1\u6811\u65f6\uff0c\u7ea2\u9ed1\u6811\u4f1a\u5148\u5224\u65ad\u662f\u5426\u5b58\u5728\u76f8\u540c\u503c\u7684\u8282\u70b9\uff0c\u5982\u679c\u662f\u7684\u8bdd\u76f4\u63a5\u8fd4\u56de\uff0c\u4e0d\u8fdb\u884c\u63d2\u5165\u3002\u8fd9\u4e48\u770b\u8d77\u6765\u6211\u4eec\u65e0\u6cd5\u7ed9\u4e00\u4e2a\u4fe1\u53f7\u6ce8\u518c\u591a\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u4f46\u5176\u5b9e\u662f\u53ef\u4ee5\u7684\uff0c\u91cd\u70b9\u5728\u6bd4\u8f83\u5927\u5c0f\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u770b\u8be5\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static int uv__signal_compare ( uv_signal_t * w1 , uv_signal_t * w2 ) { int f1 ; int f2 ; // \u8fd4\u56de\u4fe1\u53f7\u503c\u5927\u7684 if ( w1 -> signum < w2 -> signum ) return -1 ; if ( w1 -> signum > w2 -> signum ) return 1 ; // \u8bbe\u7f6e\u4e86UV_SIGNAL_ONE_SHOT\u7684\u5927 f1 = w1 -> flags & UV_SIGNAL_ONE_SHOT ; f2 = w2 -> flags & UV_SIGNAL_ONE_SHOT ; if ( f1 < f2 ) return -1 ; if ( f1 > f2 ) return 1 ; // \u5730\u5740\u5927\u7684\u503c\u5c31\u5927 if ( w1 -> loop < w2 -> loop ) return -1 ; if ( w1 -> loop > w2 -> loop ) return 1 ; if ( w1 < w2 ) return -1 ; if ( w1 > w2 ) return 1 ; return 0 ; } \u6211\u4eec\u770b\u5230Libuv\u6bd4\u8f83\u7684\u4e0d\u4ec5\u662f\u4fe1\u53f7\u7684\u5927\u5c0f\uff0c\u5728\u4fe1\u53f7\u4e00\u6837\u7684\u60c5\u51b5\u4e0b\uff0cLibuv\u8fd8\u4f1a\u6bd4\u8f83\u5176\u5b83\u7684\u56e0\u5b50\uff0c\u9664\u975e\u4e24\u4e2auv_signal_t\u6307\u9488\u6307\u5411\u7684\u662f\u540c\u4e00\u4e2auv_signal_t\u7ed3\u6784\u4f53\uff0c\u5426\u5219\u5b83\u4eec\u662f\u4e0d\u4f1a\u88ab\u8ba4\u4e3a\u91cd\u590d\u7684\uff0c\u6240\u4ee5\u7ea2\u9ed1\u6811\u4e2d\u4f1a\u5b58\u7740\u4fe1\u53f7\u4e00\u6837\u7684\u8282\u70b9\u3002\u5047\u8bbe\u6211\u4eec\u6309\u71671\uff08flags\u4e3aone shot\uff09\uff0c2\uff08flags\u4e3a\u975eone shot\uff09,3\uff08flags\u4e3aone shot\uff09\u7684\u987a\u5e8f\u63d2\u5165\u7ea2\u9ed1\u6811\uff0c\u5e76\u4e14\u8282\u70b93\u6bd4\u8282\u70b91\u7684\u5730\u5740\u5927\u3002\u6240\u5f62\u6210\u7684\u7ed3\u6784\u5982\u56fe7-4\u6240\u793a\u3002 \u56fe7-4 7.6 \u4fe1\u53f7\u7684\u5904\u7406 \u00b6 \u6211\u4eec\u4e0a\u4e00\u8282\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4e0d\u7ba1\u6ce8\u518c\u4ec0\u4e48\u4fe1\u53f7\uff0c\u5b83\u7684\u5904\u7406\u51fd\u6570\u90fd\u662f\u8fd9\u4e2auv__signal_handler\u51fd\u6570\u3002\u6211\u4eec\u81ea\u5df1\u7684\u4e1a\u52a1\u56de\u8c03\u51fd\u6570\uff0c\u662f\u4fdd\u5b58\u5728handle\u91cc\u7684\u3002\u800cLibuv\u7ef4\u62a4\u4e86\u4e00\u68f5\u7ea2\u9ed1\u6811\uff0c\u8bb0\u5f55\u4e86\u6bcf\u4e2ahandle\u6ce8\u518c\u7684\u4fe1\u53f7\u548c\u56de\u8c03\u51fd\u6570\uff0c\u90a3\u4e48\u5f53\u4efb\u610f\u4fe1\u53f7\u5230\u6765\u7684\u65f6\u5019\u3002uv__signal_handler\u5c31\u4f1a\u88ab\u8c03\u7528\u3002\u4e0b\u9762\u6211\u4eec\u770b\u770buv__signal_handler\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* \u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0csignum\u4e3a\u6536\u5230\u7684\u4fe1\u53f7\uff0c \u6bcf\u4e2a\u5b50\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\u90fd\u7531\u8be5\u51fd\u6570\u5904\u7406\uff0c \u7136\u540e\u901a\u8fc7\u7ba1\u9053\u901a\u77e5Libuv */ static void uv__signal_handler ( int signum ) { uv__signal_msg_t msg ; uv_signal_t * handle ; int saved_errno ; // \u4fdd\u6301\u4e0a\u4e00\u4e2a\u7cfb\u7edf\u8c03\u7528\u7684\u9519\u8bef\u7801 saved_errno = errno ; memset ( & msg , 0 , sizeof msg ); if ( uv__signal_lock ()) { errno = saved_errno ; return ; } // \u627e\u5230\u8be5\u4fe1\u53f7\u5bf9\u5e94\u7684\u6240\u6709handle for ( handle = uv__signal_first_handle ( signum ); handle != NULL && handle -> signum == signum ; handle = RB_NEXT ( uv__signal_tree_s , & uv__signal_tree , handle )) { int r ; // \u8bb0\u5f55\u4e0a\u4e0b\u6587 msg . signum = signum ; msg . handle = handle ; do { // \u901a\u77e5Libuv\uff0c\u54ea\u4e9bhandle\u9700\u8981\u5904\u7406\u8be5\u4fe1\u53f7\uff0c \u5728 Poll IO\u9636\u6bb5\u5904\u7406 r = write ( handle -> loop -> signal_pipefd [ 1 ], & msg , sizeof msg ); } while ( r == -1 && errno == EINTR ); // \u8be5handle\u6536\u5230\u4fe1\u53f7\u7684\u6b21\u6570 if ( r != -1 ) handle -> caught_signals ++ ; } uv__signal_unlock (); errno = saved_errno ; } uv__signal_handler\u51fd\u6570\u4f1a\u8c03\u7528uv__signal_first_handle\u904d\u5386\u7ea2\u9ed1\u6811\uff0c\u627e\u5230\u6ce8\u518c\u4e86\u8be5\u4fe1\u53f7\u7684\u6240\u6709handle\uff0c\u6211\u4eec\u770b\u4e00\u4e0buv__signal_first_handle\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 static uv_signal_t * uv__signal_first_handle ( int signum ) { uv_signal_t lookup ; uv_signal_t * handle ; lookup . signum = signum ; lookup . flags = 0 ; lookup . loop = NULL ; handle = RB_NFIND ( uv__signal_tree_s , & uv__signal_tree , & lookup ); if ( handle != NULL && handle -> signum == signum ) return handle ; return NULL ; } uv__signal_first_handle\u51fd\u6570\u901a\u8fc7RB_NFIND\u5b9e\u73b0\u7ea2\u9ed1\u6811\u7684\u67e5\u627e\uff0cRB_NFIND\u662f\u4e00\u4e2a\u5b8f\u3002 1 #define RB_NFIND(name, x, y) name##_RB_NFIND(x, y) \u6211\u4eec\u770b\u770bname##_RB_NFIND\u5373uv__signal_tree_s_RB_NFIND\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static struct uv_signal_t * uv__signal_tree_s_RB_NFIND ( struct uv__signal_tree_s * head , struct uv_signal_t * elm ) { struct uv_signal_t * tmp = RB_ROOT ( head ); struct uv_signal_t * res = NULL ; int comp ; while ( tmp ) { comp = cmp ( elm , tmp ); /* elm\u5c0f\u4e8e\u5f53\u524d\u8282\u70b9\u5219\u5f80\u5de6\u5b50\u6811\u627e\uff0c\u5927\u4e8e\u5219\u5f80\u53f3\u5b50\u6811\u627e\uff0c \u7b49\u4e8e\u5219\u8fd4\u56de */ if ( comp < 0 ) { // \u8bb0\u5f55\u7236\u8282\u70b9 res = tmp ; tmp = RB_LEFT ( tmp , field ); } else if ( comp > 0 ) tmp = RB_RIGHT ( tmp , field ); else return ( tmp ); } return ( res ); } uv__signal_tree_s_RB_NFIND\u7684\u903b\u8f91\u5c31\u662f\u6839\u636e\u7ea2\u9ed1\u6811\u7684\u7279\u70b9\u8fdb\u884c\u641c\u7d22\uff0c\u8fd9\u91cc\u7684\u91cd\u70b9\u662fcmp\u51fd\u6570\u3002\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7cmp\u7684\u903b\u8f91\u3002\u8fd9\u91cc\u4f1a\u9996\u5148\u67e5\u627e\u6ca1\u6709\u8bbe\u7f6eone shot\u6807\u8bb0\u7684handle\uff08\u56e0\u4e3a\u5b83\u7684\u503c\u5c0f\uff09\uff0c\u7136\u540e\u518d\u67e5\u627e\u8bbe\u7f6e\u4e86one shot\u7684handle\uff0c\u4e00\u65e6\u9047\u5230\u8bbe\u7f6e\u4e86one shot\u7684handle\uff0c\u5219\u8bf4\u660e\u540e\u9762\u88ab\u5339\u914d\u7684handle\u4e5f\u662f\u8bbe\u7f6e\u4e86one shot\u6807\u8bb0\u7684\u3002\u6bcf\u6b21\u627e\u5230\u4e00\u4e2ahandle\uff0c\u5c31\u4f1a\u5c01\u88c5\u4e00\u4e2amsg\u5199\u5165\u7ba1\u9053\uff08\u5373\u548cLibuv\u901a\u4fe1\u7684\u7ba1\u9053\uff09\u3002\u4fe1\u53f7\u7684\u5904\u7406\u5c31\u5b8c\u6210\u4e86\u3002\u63a5\u4e0b\u6765\u5728Libuv\u7684Poll IO\u9636\u6bb5\u624d\u505a\u771f\u6b63\u7684\u5904\u7406\u3002\u6211\u4eec\u77e5\u9053\u5728Poll IO\u9636\u6bb5\u3002epoll\u4f1a\u68c0\u6d4b\u5230\u7ba1\u9053loop->signal_pipefd[0]\u53ef\u8bfb\uff0c\u7136\u540e\u4f1a\u6267\u884cuv__signal_event\u51fd\u6570\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // \u5982\u679c\u6536\u5230\u4fe1\u53f7,Libuv Poll IO\u9636\u6bb5,\u4f1a\u6267\u884c\u8be5\u51fd\u6570 static void uv__signal_event ( uv_loop_t * loop , uv__io_t * w , unsigned int events ) { uv__signal_msg_t * msg ; uv_signal_t * handle ; char buf [ sizeof ( uv__signal_msg_t ) * 32 ]; size_t bytes , end , i ; int r ; bytes = 0 ; end = 0 ; // \u8ba1\u7b97\u51fa\u6570\u636e\u7684\u5927\u5c0f do { // \u8bfb\u51fa\u6240\u6709\u7684uv__signal_msg_t r = read ( loop -> signal_pipefd [ 0 ], buf + bytes , sizeof ( buf ) - bytes ); if ( r == -1 && errno == EINTR ) continue ; if ( r == -1 && ( errno == EAGAIN || errno == EWOULDBLOCK )) { if ( bytes > 0 ) continue ; return ; } if ( r == -1 ) abort (); bytes += r ; /* \u6839\u636e\u6536\u5230\u7684\u5b57\u8282\u6570\u7b97\u51fa\u6709\u591a\u5c11\u4e2auv__signal_msg_t\u7ed3\u6784\u4f53\uff0c \u4ece\u800c\u7b97\u51fa\u7ed3\u675f\u4f4d\u7f6e */ end = ( bytes / sizeof ( uv__signal_msg_t )) * sizeof ( uv__signal_msg_t ); // \u5faa\u73af\u5904\u7406\u6bcf\u4e00\u4e2amsg for ( i = 0 ; i < end ; i += sizeof ( uv__signal_msg_t )) { msg = ( uv__signal_msg_t * ) ( buf + i ); // \u53d6\u51fa\u4e0a\u4e0b\u6587 handle = msg -> handle ; // \u6536\u5230\u7684\u4fe1\u53f7\u548chandle\u611f\u5174\u8da3\u7684\u4fe1\u53f7\u4e00\u81f4\uff0c\u6267\u884c\u56de\u8c03 if ( msg -> signum == handle -> signum ) { handle -> signal_cb ( handle , handle -> signum ); } // \u5904\u7406\u4fe1\u53f7\u4e2a\u6570\uff0c\u548c\u6536\u5230\u7684\u4e2a\u6570\u5bf9\u5e94 handle -> dispatched_signals ++ ; // \u53ea\u6267\u884c\u4e00\u6b21\uff0c\u6062\u590d\u7cfb\u7edf\u9ed8\u8ba4\u7684\u5904\u7406\u51fd\u6570 if ( handle -> flags & UV_SIGNAL_ONE_SHOT ) uv__signal_stop ( handle ); /* \u5904\u7406\u5b8c\u6240\u6709\u6536\u5230\u7684\u4fe1\u53f7\u624d\u80fd\u5173\u95eduv_signal_t\uff0c \u89c1uv_close\u6216uv__signal_close */ if (( handle -> flags & UV_HANDLE_CLOSING ) && ( handle -> caught_signals == handle -> dispatched_signals )) { uv__make_close_pending (( uv_handle_t * ) handle ); } } bytes -= end ; if ( bytes ) { memmove ( buf , buf + end , bytes ); continue ; } } while ( end == sizeof buf ); } uv__signal_event\u51fd\u6570\u7684\u903b\u8f91\u5982\u4e0b 1 \u8bfb\u51fa\u7ba1\u9053\u91cc\u7684\u6570\u636e\uff0c\u8ba1\u7b97\u51famsg\u7684\u4e2a\u6570\u3002 2 \u904d\u5386\u6536\u5230\u7684\u6570\u636e\uff0c\u89e3\u6790\u51fa\u4e00\u4e2a\u4e2amsg\u3002 3 \u4ecemsg\u4e2d\u53d6\u51fa\u4e0a\u4e0b\u6587\uff08handle\u548c\u4fe1\u53f7\uff09\uff0c\u6267\u884c\u4e0a\u5c42\u56de\u8c03\u3002 4 \u5982\u679chandle\u8bbe\u7f6e\u4e86one shot\u5219\u9700\u8981\u6267\u884cuv__signal_stop\uff08\u6211\u4eec\u63a5\u4e0b\u6765\u5206\u6790\uff09\u3002 5 \u5982\u679chandle\u8bbe\u7f6e\u4e86closing\u6807\u8bb0\uff0c\u5219\u5224\u65ad\u6240\u6709\u6536\u5230\u7684\u4fe1\u53f7\u662f\u5426\u5df2\u7ecf\u5904\u7406\u5b8c\u3002\u5373\u6536\u5230\u7684\u4e2a\u6570\u548c\u5904\u7406\u7684\u4e2a\u6570\u662f\u5426\u4e00\u81f4\u3002\u9700\u8981\u5904\u7406\u5b8c\u6240\u6709\u6536\u5230\u7684\u4fe1\u53f7\u624d\u80fd\u5173\u95eduv_signal_t\u3002 7.7 \u53d6\u6d88/\u5173\u95ed\u4fe1\u53f7\u5904\u7406 \u00b6 \u5f53\u4e00\u4e2a\u4fe1\u53f7\u5bf9\u5e94\u7684handle\u8bbe\u7f6e\u4e86one shot\u6807\u8bb0\uff0c\u5728\u6536\u5230\u4fe1\u53f7\u5e76\u4e14\u6267\u884c\u5b8c\u56de\u8c03\u540e\uff0cLibuv\u4f1a\u8c03\u7528uv__signal_stop\u5173\u95ed\u8be5handle\u5e76\u4e14\u4ece\u7ea2\u9ed1\u6811\u4e2d\u79fb\u9664\u8be5handle\u3002\u53e6\u5916\u6211\u4eec\u4e5f\u53ef\u4ee5\u663e\u5f0f\u5730\u8c03\u7528uv_close\uff08\u4f1a\u8c03\u7528uv__signal_stop\uff09\u5173\u95ed\u6216\u53d6\u6d88\u4fe1\u53f7\u7684\u5904\u7406\u3002\u4e0b\u9762\u6211\u4eec\u770b\u770buv__signal_stop\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 static void uv__signal_stop ( uv_signal_t * handle ) { uv_signal_t * removed_handle ; sigset_t saved_sigmask ; uv_signal_t * first_handle ; int rem_oneshot ; int first_oneshot ; int ret ; /* If the watcher wasn't started, this is a no-op. */ // \u6ca1\u6709\u6ce8\u518c\u8fc7\u4fe1\u53f7\uff0c\u5219\u4e0d\u9700\u8981\u5904\u7406 if ( handle -> signum == 0 ) return ; // \u5c4f\u853d\u6240\u6709\u4fe1\u53f7 uv__signal_block_and_lock ( & saved_sigmask ); // \u79fb\u51fa\u7ea2\u9ed1\u6811 removed_handle = RB_REMOVE ( uv__signal_tree_s , & uv__signal_tree , handle ); // \u5224\u65ad\u8be5\u4fe1\u53f7\u662f\u5426\u8fd8\u6709\u5bf9\u5e94\u7684handle first_handle = uv__signal_first_handle ( handle -> signum ); // \u4e3a\u7a7a\u8bf4\u660e\u6ca1\u6709handle\u4f1a\u5904\u7406\u8be5\u4fe1\u53f7\u4e86\uff0c\u89e3\u9664\u8be5\u4fe1\u53f7\u7684\u8bbe\u7f6e if ( first_handle == NULL ) { uv__signal_unregister_handler ( handle -> signum ); } else { // \u88ab\u5904\u7406\u7684handle\u662f\u5426\u8bbe\u7f6e\u4e86one shot rem_oneshot = handle -> flags & UV_SIGNAL_ONE_SHOT ; /* \u5269\u4e0b\u7684\u7b2c\u4e00\u4e2ahandle\u662f\u5426\u8bbe\u7f6e\u4e86one shot\uff0c \u5982\u679c\u662f\u5219\u8bf4\u660e\u8be5\u4fe1\u53f7\u5bf9\u5e94\u7684\u6240\u6709\u5269\u4e0b\u7684handle\u90fd\u662fone shot */ first_oneshot = first_handle -> flags & UV_SIGNAL_ONE_SHOT ; /* \u88ab\u79fb\u9664\u7684handle\u6ca1\u6709\u8bbe\u7f6eoneshot\u4f46\u662f\u5f53\u524d\u7684\u7b2c\u4e00\u4e2ahandle\u8bbe\u7f6e\u4e86 one shot\uff0c\u5219\u9700\u8981\u4fee\u6539\u8be5\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u4e3aone shot\uff0c\u9632\u6b62\u6536\u5230\u591a\u6b21\u4fe1 \u53f7\uff0c\u6267\u884c\u591a\u6b21\u56de\u8c03 */ if ( first_oneshot && ! rem_oneshot ) { ret = uv__signal_register_handler ( handle -> signum , 1 ); assert ( ret == 0 ); } } uv__signal_unlock_and_unblock ( & saved_sigmask ); handle -> signum = 0 ; uv__handle_stop ( handle ); } 7.8 \u4fe1\u53f7\u5728Node.js\u4e2d\u7684\u4f7f\u7528 \u00b6 \u5206\u6790\u5b8cLibuv\u7684\u5b9e\u73b0\u540e\uff0c\u6211\u4eec\u770b\u770bNode.js\u4e0a\u5c42\u662f\u5982\u4f55\u4f7f\u7528\u4fe1\u53f7\u7684\uff0c\u9996\u5148\u6211\u4eec\u770b\u4e00\u4e0bC++\u5c42\u5173\u4e8e\u4fe1\u53f7\u6a21\u5757\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 static void Initialize ( Local < Object > target , Local < Value > unused , Local < Context > context , void * priv ) { Environment * env = Environment :: GetCurrent ( context ); Local < FunctionTemplate > constructor = env -> NewFunctionTemplate ( New ); constructor -> InstanceTemplate () -> SetInternalFieldCount ( 1 ); // \u5bfc\u51fa\u7684\u7c7b\u540d Local < String > signalString = FIXED_ONE_BYTE_STRING ( env -> isolate (), \"Signal\" ); constructor -> SetClassName ( signalString ); constructor -> Inherit ( HandleWrap :: GetConstructorTemplate ( env )); // \u7ed9Signal\u521b\u5efa\u7684\u5bf9\u8c61\u6ce8\u5165\u4e24\u4e2a\u51fd\u6570 env -> SetProtoMethod ( constructor , \"start\" , Start ); env -> SetProtoMethod ( constructor , \"stop\" , Stop ); target -> Set ( env -> context (), signalString , constructor -> GetFunction ( env -> context ()). ToLocalChecked ()). Check (); } \u5f53\u6211\u4eec\u5728JS\u4e2dnew Signal\u7684\u65f6\u5019\uff0c\u9996\u5148\u4f1a\u521b\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u7136\u540e\u4f5c\u4e3a\u5165\u53c2\u6267\u884cNew\u51fd\u6570\u3002 1 2 3 4 5 static void New ( const FunctionCallbackInfo < Value >& args ) { CHECK ( args . IsConstructCall ()); Environment * env = Environment :: GetCurrent ( args ); new SignalWrap ( env , args . This ()); } \u5f53\u6211\u4eec\u5728JS\u5c42\u64cd\u4f5cSignal\u5b9e\u4f8b\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884cC++\u5c42\u5bf9\u5e94\u7684\u65b9\u6cd5\u3002\u4e3b\u8981\u7684\u65b9\u6cd5\u662f\u6ce8\u518c\u548c\u5220\u9664\u4fe1\u53f7\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 static void Start ( const FunctionCallbackInfo < Value >& args ) { SignalWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder ()); Environment * env = wrap -> env (); int signum ; if ( ! args [ 0 ] -> Int32Value ( env -> context ()). To ( & signum )) return ; int err = uv_signal_start ( & wrap -> handle_ , // \u4fe1\u53f7\u4ea7\u751f\u65f6\u6267\u884c\u7684\u56de\u8c03 []( uv_signal_t * handle , int signum ) { SignalWrap * wrap = ContainerOf ( & SignalWrap :: handle_ , handle ); Environment * env = wrap -> env (); HandleScope handle_scope ( env -> isolate ()); Context :: Scope context_scope ( env -> context ()); Local < Value > arg = Integer :: New ( env -> isolate (), signum ); // \u89e6\u53d1JS\u5c42onsignal\u51fd\u6570 wrap -> MakeCallback ( env -> onsignal_string (), 1 , & arg ); }, signum ); if ( err == 0 ) { CHECK ( ! wrap -> active_ ); wrap -> active_ = true ; Mutex :: ScopedLock lock ( handled_signals_mutex ); handled_signals [ signum ] ++ ; } args . GetReturnValue (). Set ( err ); } static void Stop ( const FunctionCallbackInfo < Value >& args ) { SignalWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder ()); if ( wrap -> active_ ) { wrap -> active_ = false ; DecreaseSignalHandlerCount ( wrap -> handle_ . signum ); } int err = uv_signal_stop ( & wrap -> handle_ ); args . GetReturnValue (). Set ( err ); } \u63a5\u7740\u6211\u4eec\u770b\u5728JS\u5c42\u5982\u4f55\u4f7f\u7528\u3002Node.js\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u5728is_main_thread.js\u4e2d\u6267\u884c\u4e86\u3002 1 2 process . on ( 'newListener' , startListeningIfSignal ); process . on ( 'removeListener' , stopListeningIfSignal ) newListener\u548cremoveListener\u4e8b\u4ef6\u5728\u6ce8\u518c\u548c\u5220\u9664\u4e8b\u4ef6\u7684\u65f6\u5019\u90fd\u4f1a\u88ab\u89e6\u53d1\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e24\u4e2a\u51fd\u6570\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* { SIGINT: 2, ... } */ const { signals } = internalBinding ( 'constants' ). os ; let Signal ; const signalWraps = new Map (); function isSignal ( event ) { return typeof event === 'string' && signals [ event ] !== undefined ; } function startListeningIfSignal ( type ) { if ( isSignal ( type ) && ! signalWraps . has ( type )) { if ( Signal === undefined ) Signal = internalBinding ( 'signal_wrap' ). Signal ; const wrap = new Signal (); // \u4e0d\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa wrap . unref (); // \u6302\u8f7d\u4fe1\u53f7\u5904\u7406\u51fd\u6570 wrap . onsignal = process . emit . bind ( process , type , type ); // \u901a\u8fc7\u5b57\u7b26\u62ff\u5230\u6570\u5b57 const signum = signals [ type ]; // \u6ce8\u518c\u4fe1\u53f7 const err = wrap . start ( signum ); if ( err ) { wrap . close (); throw errnoException ( err , 'uv_signal_start' ); } // \u8be5\u4fe1\u53f7\u5df2\u7ecf\u6ce8\u518c\uff0c\u4e0d\u9700\u8981\u5f80\u5e95\u5c42\u518d\u6ce8\u518c\u4e86 signalWraps . set ( type , wrap ); } } startListeningIfSignal\u51fd\u6570\u7684\u903b\u8f91\u5206\u4e3a\u4e00\u4e0b\u51e0\u4e2a 1 \u5224\u65ad\u8be5\u4fe1\u53f7\u662f\u5426\u6ce8\u518c\u8fc7\u4e86\uff0c\u5982\u679c\u6ce8\u518c\u8fc7\u4e86\u5219\u4e0d\u9700\u8981\u518d\u6ce8\u518c\u3002Libuv\u672c\u8eab\u652f\u6301\u5728\u540c\u4e00\u4e2a\u4fe1\u53f7\u4e0a\u6ce8\u518c\u591a\u4e2a\u5904\u7406\u51fd\u6570\uff0cNode.js\u7684JS\u5c42\u4e5f\u505a\u4e86\u8fd9\u4e2a\u5904\u7406\u3002 2 \u8c03\u7528unref\uff0c\u4fe1\u53f7\u7684\u6ce8\u518c\u4e0d\u5e94\u8be5\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa 3 \u6302\u8f7d\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\uff0c\u5f53\u4fe1\u53f7\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u6267\u884c\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff08\u4e00\u4e2a\u6216\u591a\u4e2a\uff09\u3002 4 \u5f80\u5e95\u5c42\u6ce8\u518c\u4fe1\u53f7\u5e76\u8bbe\u7f6e\u8be5\u4fe1\u53f7\u5df2\u7ecf\u6ce8\u518c\u7684\u6807\u8bb0 \u6211\u4eec\u518d\u6765\u770b\u4e00\u4e0bstopListeningIfSignal\u3002 1 2 3 4 5 6 7 function stopListeningIfSignal ( type ) { const wrap = signalWraps . get ( type ); if ( wrap !== undefined && process . listenerCount ( type ) === 0 ) { wrap . close (); signalWraps . delete ( type ); } } \u53ea\u6709\u5f53\u4fe1\u53f7\u88ab\u6ce8\u518c\u8fc7\u5e76\u4e14\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u4e2a\u6570\u4e3a0\uff0c\u624d\u505a\u771f\u6b63\u7684\u5220\u9664\u3002","title":"07-\u4fe1\u53f7\u5904\u7406"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/#71","text":"\u4fe1\u53f7\u662f\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u4e00\u79cd\u7b80\u5355\u7684\u65b9\u5f0f\uff0c\u6211\u4eec\u9996\u5148\u4e86\u89e3\u4e00\u4e0b\u4fe1\u53f7\u7684\u6982\u5ff5\u548c\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u5b9e\u73b0\u539f\u7406\u3002\u5728\u64cd\u4f5c\u7cfb\u7edf\u5185\u6838\u7684\u5b9e\u73b0\u4e2d\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u5bf9\u5e94\u4e00\u4e2atask_struct\u7ed3\u6784\u4f53\uff08PCB\uff09\uff0cPCB\u4e2d\u6709\u4e00\u4e2a\u5b57\u6bb5\u8bb0\u5f55\u4e86\u8fdb\u7a0b\u6536\u5230\u7684\u4fe1\u53f7\uff08\u6bcf\u4e00\u4e2a\u6bd4\u7279\u4ee3\u8868\u4e00\u79cd\u4fe1\u53f7\uff09\u548c\u4fe1\u53f7\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\u3002\u8fd9\u4e2a\u548c\u8ba2\u9605\u8005/\u53d1\u5e03\u8005\u6a21\u5f0f\u975e\u5e38\u76f8\u4f3c\uff0c\u6211\u4eec\u770b\u4e00\u4e0bPCB\u4e2d\u4fe1\u53f7\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct task_struct { // \u6536\u5230\u7684\u4fe1\u53f7 long signal ; // \u5904\u7406\u4fe1\u53f7\u8fc7\u7a0b\u4e2d\u5c4f\u853d\u7684\u4fe1\u606f long blocked ; // \u4fe1\u53f7\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570 struct sigaction sigaction [ 32 ]; ... }; struct sigaction { // \u4fe1\u53f7\u5904\u7406\u51fd\u6570 void ( * sa_handler )( int ); // \u5904\u7406\u4fe1\u53f7\u65f6\u5c4f\u853d\u54ea\u4e9b\u4fe1\u606f\uff0c\u548cPCB\u7684block\u5b57\u6bb5\u5bf9\u5e94 sigset_t sa_mask ; // \u4e00\u4e9b\u6807\u8bb0\uff0c\u6bd4\u5982\u5904\u7406\u51fd\u6570\u53ea\u6267\u884c\u4e00\u6b21\uff0c\u7c7b\u4f3cevents\u6a21\u5757\u7684once int sa_flags ; // \u6e05\u9664\u8c03\u7528\u6808\u4fe1\u606f\uff0cglibc\u4f7f\u7528 void ( * sa_restorer )( void ); }; Linux\u4e0b\u652f\u6301\u591a\u79cd\u4fe1\u53f7\uff0c\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u4e86\u9ed8\u8ba4\u5904\u7406\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u663e\u5f0f\u6ce8\u518c\u5904\u7406\u4fe1\u53f7\u7684\u51fd\u6570\uff0c\u4f46\u662f\u6709\u4e9b\u4fe1\u53f7\u4f1a\u5bfc\u81f4\u8fdb\u7a0b\u9000\u51fa\uff0c\u8fd9\u662f\u6211\u4eec\u65e0\u6cd5\u63a7\u5236\u7684\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u5728Linux\u4e0b\u4fe1\u53f7\u4f7f\u7528\u7684\u4f8b\u5b50\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <stdio.h> #include <unistd.h> #include <stdlib.h> #include <signal.h> void handler ( int ); int main () { signal ( SIGINT , handler ); while ( 1 ); return ( 0 ); } void sighandler ( int signum ) { printf ( \"\u6536\u5230\u4fe1\u53f7%d\" , signum ); } \u6211\u4eec\u6ce8\u518c\u4e86\u4e00\u4e2a\u4fe1\u53f7\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff0c\u7136\u540e\u8fdb\u5165while\u5faa\u73af\u4fdd\u8bc1\u8fdb\u7a0b\u4e0d\u4f1a\u9000\u51fa\uff0c\u8fd9\u65f6\u5019\uff0c\u5982\u679c\u6211\u4eec\u7ed9\u8fd9\u4e2a\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2aSIGINT\u4fe1\u53f7\uff08ctrl+c\u6216\u8005kill -2 pid\uff09\u3002\u5219\u8fdb\u7a0b\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\uff0c\u7136\u540e\u8f93\u51fa\uff1a\u6536\u5230\u4fe1\u53f72\u3002\u4e86\u89e3\u4e86\u4fe1\u53f7\u7684\u57fa\u672c\u539f\u7406\u540e\uff0c\u6211\u4eec\u770b\u4e00\u4e0bLibuv\u4e2d\u5173\u4e8e\u4fe1\u53f7\u7684\u8bbe\u8ba1\u548c\u5b9e\u73b0\u3002","title":"7.1 \u4fe1\u53f7\u7684\u6982\u5ff5\u548c\u5b9e\u73b0\u539f\u7406"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/#72-libuv","text":"\u7531\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u5b9e\u73b0\u7684\u9650\u5236\uff0c\u6211\u4eec\u65e0\u6cd5\u7ed9\u4e00\u4e2a\u4fe1\u53f7\u6ce8\u518c\u591a\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u5bf9\u4e8e\u540c\u4e00\u4e2a\u4fe1\u53f7\uff0c\u5982\u679c\u6211\u4eec\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63a5\u53e3\u591a\u6b21\uff0c\u540e\u9762\u7684\u5c31\u4f1a\u8986\u76d6\u524d\u9762\u8bbe\u7f6e\u7684\u503c\u3002\u60f3\u8981\u5b9e\u73b0\u4e00\u4e2a\u4fe1\u53f7\u88ab\u591a\u4e2a\u51fd\u6570\u5904\u7406\uff0c\u6211\u4eec\u53ea\u80fd\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e4b\u4e0a\u518d\u5c01\u88c5\u4e00\u5c42\uff0cLibuv\u6b63\u662f\u8fd9\u6837\u505a\u7684\u3002Libuv\u4e2d\u5173\u4e8e\u4fe1\u53f7\u5904\u7406\u7684\u5c01\u88c5\u548c\u8ba2\u9605\u8005/\u53d1\u5e03\u8005\u6a21\u5f0f\u5f88\u76f8\u4f3c\u3002\u7528\u6237\u8c03\u7528Libuv\u7684\u63a5\u53e3\u6ce8\u518c\u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0cLibuv\u518d\u5411\u64cd\u4f5c\u7cfb\u7edf\u6ce8\u518c\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff0c\u7b49\u5f85\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230\u4fe1\u53f7\u65f6\uff0c\u4f1a\u89e6\u53d1Libuv\u7684\u56de\u8c03\uff0cLibuv\u7684\u56de\u8c03\u4f1a\u901a\u8fc7\u7ba1\u9053\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\u6536\u5230\u7684\u4fe1\u53f7\u548c\u5bf9\u5e94\u7684\u4e0a\u4e0b\u6587\uff0c\u63a5\u7740\u4e8b\u4ef6\u5faa\u73af\u5728Poll IO\u9636\u6bb5\u5c31\u4f1a\u5904\u7406\u6536\u5230\u6240\u6709\u4fe1\u53f7\u4ee5\u53ca\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\u3002\u6574\u4f53\u67b6\u6784\u5982\u56fe7-1\u6240\u793a \u56fe7-1 \u4e0b\u9762\u6211\u4eec\u5177\u4f53\u5206\u6790Libuv\u4e2d\u4fe1\u53f7\u5904\u7406\u7684\u5b9e\u73b0\u3002","title":"7.2 Libuv\u4fe1\u53f7\u5904\u7406\u7684\u8bbe\u8ba1\u601d\u60f3"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/#73","text":"\u5f53\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\uff0c\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u9700\u8981\u901a\u77e5Libuv\u4e8b\u4ef6\u5faa\u73af\uff0c\u4ece\u800c\u5728\u4e8b\u4ef6\u5faa\u73af\u4e2d\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\uff0c\u5b9e\u73b0\u51fd\u6570\u662fuv__signal_loop_once_init\uff0c\u6211\u4eec\u770b\u4e00\u4e0buv__signal_loop_once_init\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 static int uv__signal_loop_once_init ( uv_loop_t * loop ) { /* \u7533\u8bf7\u4e00\u4e2a\u7ba1\u9053\u7528\u4e8e\u548c\u4e8b\u4ef6\u5faa\u73af\u901a\u4fe1\uff0c\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u6536\u5230\u4fe1\u53f7\uff0c \u5e76\u8bbe\u7f6e\u975e\u963b\u585e\u6807\u8bb0 */ uv__make_pipe ( loop -> signal_pipefd , UV__F_NONBLOCK ); /* \u8bbe\u7f6e\u4fe1\u53f7IO\u89c2\u5bdf\u8005\u7684\u5904\u7406\u51fd\u6570\u548c\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c Libuv\u5728Poll IO\u65f6\uff0c\u53d1\u73b0\u7ba1\u9053\u8bfb\u7aefloop->signal_pipefd[0]\u53ef\u8bfb\uff0c \u5219\u6267\u884cuv__signal_event */ uv__io_init ( & loop -> signal_io_watcher , uv__signal_event , loop -> signal_pipefd [ 0 ]); /* \u63d2\u5165Libuv\u7684IO\u89c2\u5bdf\u8005\u961f\u5217\uff0c\u5e76\u6ce8\u518c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u4e3a\u53ef\u8bfb */ uv__io_start ( loop , & loop -> signal_io_watcher , POLLIN ); return 0 ; } uv__signal_loop_once_init\u9996\u5148\u7533\u8bf7\u4e00\u4e2a\u7ba1\u9053\uff0c\u7528\u4e8e\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\u662f\u5426\u6536\u5230\u4fe1\u53f7\u3002\u7136\u540e\u5f80Libuv\u7684IO\u89c2\u5bdf\u8005\u961f\u5217\u6ce8\u518c\u4e00\u4e2a\u89c2\u5bdf\u8005\uff0cLibuv\u5728Poll IO\u9636\u6bb5\u4f1a\u628a\u89c2\u5bdf\u8005\u52a0\u5230epoll\u4e2d\u3002IO\u89c2\u5bdf\u8005\u91cc\u4fdd\u5b58\u4e86\u7ba1\u9053\u8bfb\u7aef\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26loop->signal_pipefd[0]\u548c\u56de\u8c03\u51fd\u6570uv__signal_event\u3002uv__signal_event\u662f\u6536\u5230\u4efb\u610f\u4fe1\u53f7\u65f6\u7684\u56de\u8c03\uff0c\u5b83\u4f1a\u7ee7\u7eed\u6839\u636e\u6536\u5230\u7684\u4fe1\u53f7\u8fdb\u884c\u903b\u8f91\u5206\u53d1\u3002\u6267\u884c\u5b8c\u7684\u67b6\u6784\u5982\u56fe7-2\u6240\u793a\u3002 \u56fe7-2","title":"7.3 \u901a\u4fe1\u673a\u5236\u7684\u5b9e\u73b0"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/#74","text":"Libuv\u4e2d\u4fe1\u53f7\u4f7f\u7528uv_signal_t\u8868\u793a\u3002 1 2 3 4 5 6 7 8 9 10 int uv_signal_init ( uv_loop_t * loop , uv_signal_t * handle ) { // \u7533\u8bf7\u548cLibuv\u7684\u901a\u4fe1\u7ba1\u9053\u5e76\u4e14\u6ce8\u518cIO\u89c2\u5bdf\u8005 uv__signal_loop_once_init ( loop ); uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_SIGNAL ); handle -> signum = 0 ; handle -> caught_signals = 0 ; handle -> dispatched_signals = 0 ; return 0 ; } \u4e0a\u9762\u7684\u4ee3\u7801\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u53ea\u662f\u521d\u59cb\u5316uv_signal_t\u7ed3\u6784\u4f53\u7684\u4e00\u4e9b\u5b57\u6bb5\u3002","title":"7.4 \u4fe1\u53f7\u7ed3\u6784\u4f53\u7684\u521d\u59cb\u5316"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/#75","text":"\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7uv_signal_start\u6ce8\u518c\u4e00\u4e2a\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u903b\u8f91 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 static int uv__signal_start ( uv_signal_t * handle , uv_signal_cb signal_cb , int signum , int oneshot ) { sigset_t saved_sigmask ; int err ; uv_signal_t * first_handle ; // \u6ce8\u518c\u8fc7\u4e86\uff0c\u91cd\u65b0\u8bbe\u7f6e\u5904\u7406\u51fd\u6570\u5c31\u884c if ( signum == handle -> signum ) { handle -> signal_cb = signal_cb ; return 0 ; } // \u8fd9\u4e2ahandle\u4e4b\u524d\u5df2\u7ecf\u8bbe\u7f6e\u4e86\u5176\u5b83\u4fe1\u53f7\u548c\u5904\u7406\u51fd\u6570\uff0c\u5219\u5148\u89e3\u9664 if ( handle -> signum != 0 ) { uv__signal_stop ( handle ); } // \u5c4f\u853d\u6240\u6709\u4fe1\u53f7 uv__signal_block_and_lock ( & saved_sigmask ); /* \u67e5\u627e\u6ce8\u518c\u4e86\u8be5\u4fe1\u53f7\u7684\u7b2c\u4e00\u4e2ahandle\uff0c \u4f18\u5148\u8fd4\u56de\u8bbe\u7f6e\u4e86UV_SIGNAL_ONE_SHOT flag\u7684\uff0c \u89c1compare\u51fd\u6570 */ first_handle = uv__signal_first_handle ( signum ); /* 1 \u4e4b\u524d\u6ca1\u6709\u6ce8\u518c\u8fc7\u8be5\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570\u5219\u76f4\u63a5\u8bbe\u7f6e 2 \u4e4b\u524d\u8bbe\u7f6e\u8fc7\uff0c\u4f46\u662f\u662fone shot\uff0c\u4f46\u662f\u73b0\u5728\u9700\u8981 \u8bbe\u7f6e\u7684\u89c4\u5219\u4e0d\u662fone shot\uff0c\u9700\u8981\u4fee\u6539\u3002\u5426\u5219\u7b2c \u4e8c\u6b21\u4e0d\u4f1a\u4e0d\u4f1a\u89e6\u53d1\u3002\u56e0\u4e3a\u4e00\u4e2a\u4fe1\u53f7\u53ea\u80fd\u5bf9\u5e94\u4e00 \u4e2a\u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0c\u6240\u4ee5\uff0c\u4ee5\u89c4\u5219\u5bbd\u7684\u4e3a\u51c6\uff0c\u5728\u56de\u8c03 \u91cc\u518d\u6839\u636eflags\u5224\u65ad\u662f\u4e0d\u662f\u771f\u7684\u9700\u8981\u6267\u884c 3 \u5982\u679c\u6ce8\u518c\u8fc7\u4fe1\u53f7\u548c\u5904\u7406\u51fd\u6570\uff0c\u5219\u76f4\u63a5\u63d2\u5165\u7ea2\u9ed1\u6811\u5c31\u884c\u3002 */ if ( first_handle == NULL || ( ! oneshot && ( first_handle -> flags & UV_SIGNAL_ONE_SHOT )) ) { // \u6ce8\u518c\u4fe1\u53f7\u548c\u5904\u7406\u51fd\u6570 err = uv__signal_register_handler ( signum , oneshot ); if ( err ) { uv__signal_unlock_and_unblock ( & saved_sigmask ); return err ; } } // \u8bb0\u5f55\u611f\u5174\u8da3\u7684\u4fe1\u53f7 handle -> signum = signum ; // \u53ea\u5904\u7406\u8be5\u4fe1\u53f7\u4e00\u6b21 if ( oneshot ) handle -> flags |= UV_SIGNAL_ONE_SHOT ; // \u63d2\u5165\u7ea2\u9ed1\u6811 RB_INSERT ( uv__signal_tree_s , & uv__signal_tree , handle ); uv__signal_unlock_and_unblock ( & saved_sigmask ); // \u4fe1\u53f7\u89e6\u53d1\u65f6\u7684\u4e1a\u52a1\u5c42\u56de\u8c03 handle -> signal_cb = signal_cb ; uv__handle_start ( handle ); return 0 ; } \u4e0a\u9762\u7684\u4ee3\u7801\u6bd4\u8f83\u591a\uff0c\u5927\u81f4\u7684\u903b\u8f91\u5982\u4e0b. 1 \u5224\u65ad\u662f\u5426\u9700\u8981\u5411\u64cd\u4f5c\u7cfb\u7edf\u6ce8\u518c\u4e00\u4e2a\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570\u3002\u4e3b\u8981\u662f\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u51fd\u6570\u6765\u5904\u7406\u7684\uff0c\u4ee3\u7801\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // \u7ed9\u5f53\u524d\u8fdb\u7a0b\u6ce8\u518c\u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0c\u4f1a\u8986\u76d6\u4e4b\u524d\u8bbe\u7f6e\u7684signum\u7684\u5904\u7406\u51fd\u6570 static int uv__signal_register_handler ( int signum , int oneshot ) { struct sigaction sa ; memset ( & sa , 0 , sizeof ( sa )); // \u5168\u7f6e\u4e00\uff0c\u8bf4\u660e\u6536\u5230signum\u4fe1\u53f7\u7684\u65f6\u5019\uff0c\u6682\u65f6\u5c4f\u853d\u5176\u5b83\u4fe1\u53f7 if ( sigfillset ( & sa . sa_mask )) abort (); // \u6240\u6709\u4fe1\u53f7\u90fd\u7531\u8be5\u51fd\u6570\u5904\u7406 sa . sa_handler = uv__signal_handler ; sa . sa_flags = SA_RESTART ; // \u8bbe\u7f6e\u4e86oneshot\uff0c\u8bf4\u660e\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u53ea\u6267\u884c\u4e00\u6b21\uff0c\u7136\u540e\u88ab\u6062\u590d\u4e3a\u7cfb\u7edf\u7684\u9ed8\u8ba4\u5904\u7406\u51fd\u6570 if ( oneshot ) sa . sa_flags |= SA_RESETHAND ; // \u6ce8\u518c if ( sigaction ( signum , & sa , NULL )) return UV__ERR ( errno ); return 0 ; } \u6211\u4eec\u770b\u5230\u6240\u6709\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570\u90fd\u662fuv__signal_handler\uff0c\u6211\u4eec\u4e00\u4f1a\u4f1a\u5206\u6790uv__signal_handler\u7684\u5b9e\u73b0\u3002 2\u8fdb\u7a0b\u6ce8\u518c\u7684\u4fe1\u53f7\u548c\u56de\u8c03\u662f\u5728\u4e00\u68f5\u7ea2\u9ed1\u6811\u7ba1\u7406\u7684\uff0c\u6bcf\u6b21\u6ce8\u518c\u7684\u65f6\u5019\u4f1a\u5f80\u7ea2\u9ed1\u6811\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\u3002Libuv\u7528\u9ed1\u7ea2\u6811\u7ef4\u62a4\u4fe1\u53f7\u7684\u4e0a\u4e0b\u6587\uff0c\u63d2\u5165\u7684\u89c4\u5219\u662f\u6839\u636e\u4fe1\u53f7\u7684\u5927\u5c0f\u548cflags\u7b49\u4fe1\u606f\u3002 RB_INSERT\u5b9e\u73b0\u4e86\u5f80\u7ea2\u9ed1\u6811\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u7ea2\u9ed1\u6811\u4e2d\u7684\u8282\u70b9\u662f\u7236\u8282\u70b9\u7684\u503c\u6bd4\u5de6\u5b69\u5b50\u5927\uff0c\u6bd4\u53f3\u5b69\u5b50\u5c0f\u7684\u3002\u6267\u884c\u5b8cRB_INSERT\u540e\u7684\u67b6\u6784\u5982\u56fe7-3\u6240\u793a\u3002 \u56fe7-3 \u6211\u4eec\u770b\u5230\uff0c\u5f53\u6211\u4eec\u6bcf\u6b21\u63d2\u5165\u4e0d\u540c\u7684\u4fe1\u53f7\u7684\u65f6\u5019\uff0cLibuv\u4f1a\u5728\u64cd\u4f5c\u7cfb\u7edf\u548c\u7ea2\u9ed1\u6811\u4e2d\u4fee\u6539\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u3002\u90a3\u4e48\u5982\u679c\u6211\u4eec\u63d2\u5165\u91cd\u590d\u7684\u4fe1\u53f7\u5462\uff1f\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u63d2\u5165\u91cd\u590d\u7684\u4fe1\u53f7\u65f6\uff0c\u5982\u679c\u5728\u64cd\u4f5c\u7cfb\u7edf\u6ce8\u518c\u8fc7\uff0c\u5e76\u4e14\u5f53\u524d\u63d2\u5165\u7684\u4fe1\u53f7flags\u662fone shot\uff0c\u800c\u4e4b\u524d\u662f\u975eone shot\u65f6\uff0cLibuv\u4f1a\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u63a5\u53e3\u53bb\u4fee\u6539\u914d\u7f6e\u3002\u90a3\u4e48\u5bf9\u4e8e\u7ea2\u9ed1\u6811\u6765\u8bf4\uff0c\u63d2\u5165\u91cd\u590d\u4fe1\u53f7\u4f1a\u5982\u4f55\u5904\u7406\u5462\uff1f\u4ece\u521a\u624dRB_INSERT\u7684\u4ee3\u7801\u4e2d\u6211\u4eec\u770b\u5230\u6bcf\u6b21\u63d2\u5165\u7ea2\u9ed1\u6811\u65f6\uff0c\u7ea2\u9ed1\u6811\u4f1a\u5148\u5224\u65ad\u662f\u5426\u5b58\u5728\u76f8\u540c\u503c\u7684\u8282\u70b9\uff0c\u5982\u679c\u662f\u7684\u8bdd\u76f4\u63a5\u8fd4\u56de\uff0c\u4e0d\u8fdb\u884c\u63d2\u5165\u3002\u8fd9\u4e48\u770b\u8d77\u6765\u6211\u4eec\u65e0\u6cd5\u7ed9\u4e00\u4e2a\u4fe1\u53f7\u6ce8\u518c\u591a\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u4f46\u5176\u5b9e\u662f\u53ef\u4ee5\u7684\uff0c\u91cd\u70b9\u5728\u6bd4\u8f83\u5927\u5c0f\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u770b\u8be5\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static int uv__signal_compare ( uv_signal_t * w1 , uv_signal_t * w2 ) { int f1 ; int f2 ; // \u8fd4\u56de\u4fe1\u53f7\u503c\u5927\u7684 if ( w1 -> signum < w2 -> signum ) return -1 ; if ( w1 -> signum > w2 -> signum ) return 1 ; // \u8bbe\u7f6e\u4e86UV_SIGNAL_ONE_SHOT\u7684\u5927 f1 = w1 -> flags & UV_SIGNAL_ONE_SHOT ; f2 = w2 -> flags & UV_SIGNAL_ONE_SHOT ; if ( f1 < f2 ) return -1 ; if ( f1 > f2 ) return 1 ; // \u5730\u5740\u5927\u7684\u503c\u5c31\u5927 if ( w1 -> loop < w2 -> loop ) return -1 ; if ( w1 -> loop > w2 -> loop ) return 1 ; if ( w1 < w2 ) return -1 ; if ( w1 > w2 ) return 1 ; return 0 ; } \u6211\u4eec\u770b\u5230Libuv\u6bd4\u8f83\u7684\u4e0d\u4ec5\u662f\u4fe1\u53f7\u7684\u5927\u5c0f\uff0c\u5728\u4fe1\u53f7\u4e00\u6837\u7684\u60c5\u51b5\u4e0b\uff0cLibuv\u8fd8\u4f1a\u6bd4\u8f83\u5176\u5b83\u7684\u56e0\u5b50\uff0c\u9664\u975e\u4e24\u4e2auv_signal_t\u6307\u9488\u6307\u5411\u7684\u662f\u540c\u4e00\u4e2auv_signal_t\u7ed3\u6784\u4f53\uff0c\u5426\u5219\u5b83\u4eec\u662f\u4e0d\u4f1a\u88ab\u8ba4\u4e3a\u91cd\u590d\u7684\uff0c\u6240\u4ee5\u7ea2\u9ed1\u6811\u4e2d\u4f1a\u5b58\u7740\u4fe1\u53f7\u4e00\u6837\u7684\u8282\u70b9\u3002\u5047\u8bbe\u6211\u4eec\u6309\u71671\uff08flags\u4e3aone shot\uff09\uff0c2\uff08flags\u4e3a\u975eone shot\uff09,3\uff08flags\u4e3aone shot\uff09\u7684\u987a\u5e8f\u63d2\u5165\u7ea2\u9ed1\u6811\uff0c\u5e76\u4e14\u8282\u70b93\u6bd4\u8282\u70b91\u7684\u5730\u5740\u5927\u3002\u6240\u5f62\u6210\u7684\u7ed3\u6784\u5982\u56fe7-4\u6240\u793a\u3002 \u56fe7-4","title":"7.5 \u4fe1\u53f7\u5904\u7406\u7684\u6ce8\u518c"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/#76","text":"\u6211\u4eec\u4e0a\u4e00\u8282\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4e0d\u7ba1\u6ce8\u518c\u4ec0\u4e48\u4fe1\u53f7\uff0c\u5b83\u7684\u5904\u7406\u51fd\u6570\u90fd\u662f\u8fd9\u4e2auv__signal_handler\u51fd\u6570\u3002\u6211\u4eec\u81ea\u5df1\u7684\u4e1a\u52a1\u56de\u8c03\u51fd\u6570\uff0c\u662f\u4fdd\u5b58\u5728handle\u91cc\u7684\u3002\u800cLibuv\u7ef4\u62a4\u4e86\u4e00\u68f5\u7ea2\u9ed1\u6811\uff0c\u8bb0\u5f55\u4e86\u6bcf\u4e2ahandle\u6ce8\u518c\u7684\u4fe1\u53f7\u548c\u56de\u8c03\u51fd\u6570\uff0c\u90a3\u4e48\u5f53\u4efb\u610f\u4fe1\u53f7\u5230\u6765\u7684\u65f6\u5019\u3002uv__signal_handler\u5c31\u4f1a\u88ab\u8c03\u7528\u3002\u4e0b\u9762\u6211\u4eec\u770b\u770buv__signal_handler\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 /* \u4fe1\u53f7\u5904\u7406\u51fd\u6570\uff0csignum\u4e3a\u6536\u5230\u7684\u4fe1\u53f7\uff0c \u6bcf\u4e2a\u5b50\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u7684\u65f6\u5019\u90fd\u7531\u8be5\u51fd\u6570\u5904\u7406\uff0c \u7136\u540e\u901a\u8fc7\u7ba1\u9053\u901a\u77e5Libuv */ static void uv__signal_handler ( int signum ) { uv__signal_msg_t msg ; uv_signal_t * handle ; int saved_errno ; // \u4fdd\u6301\u4e0a\u4e00\u4e2a\u7cfb\u7edf\u8c03\u7528\u7684\u9519\u8bef\u7801 saved_errno = errno ; memset ( & msg , 0 , sizeof msg ); if ( uv__signal_lock ()) { errno = saved_errno ; return ; } // \u627e\u5230\u8be5\u4fe1\u53f7\u5bf9\u5e94\u7684\u6240\u6709handle for ( handle = uv__signal_first_handle ( signum ); handle != NULL && handle -> signum == signum ; handle = RB_NEXT ( uv__signal_tree_s , & uv__signal_tree , handle )) { int r ; // \u8bb0\u5f55\u4e0a\u4e0b\u6587 msg . signum = signum ; msg . handle = handle ; do { // \u901a\u77e5Libuv\uff0c\u54ea\u4e9bhandle\u9700\u8981\u5904\u7406\u8be5\u4fe1\u53f7\uff0c \u5728 Poll IO\u9636\u6bb5\u5904\u7406 r = write ( handle -> loop -> signal_pipefd [ 1 ], & msg , sizeof msg ); } while ( r == -1 && errno == EINTR ); // \u8be5handle\u6536\u5230\u4fe1\u53f7\u7684\u6b21\u6570 if ( r != -1 ) handle -> caught_signals ++ ; } uv__signal_unlock (); errno = saved_errno ; } uv__signal_handler\u51fd\u6570\u4f1a\u8c03\u7528uv__signal_first_handle\u904d\u5386\u7ea2\u9ed1\u6811\uff0c\u627e\u5230\u6ce8\u518c\u4e86\u8be5\u4fe1\u53f7\u7684\u6240\u6709handle\uff0c\u6211\u4eec\u770b\u4e00\u4e0buv__signal_first_handle\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 static uv_signal_t * uv__signal_first_handle ( int signum ) { uv_signal_t lookup ; uv_signal_t * handle ; lookup . signum = signum ; lookup . flags = 0 ; lookup . loop = NULL ; handle = RB_NFIND ( uv__signal_tree_s , & uv__signal_tree , & lookup ); if ( handle != NULL && handle -> signum == signum ) return handle ; return NULL ; } uv__signal_first_handle\u51fd\u6570\u901a\u8fc7RB_NFIND\u5b9e\u73b0\u7ea2\u9ed1\u6811\u7684\u67e5\u627e\uff0cRB_NFIND\u662f\u4e00\u4e2a\u5b8f\u3002 1 #define RB_NFIND(name, x, y) name##_RB_NFIND(x, y) \u6211\u4eec\u770b\u770bname##_RB_NFIND\u5373uv__signal_tree_s_RB_NFIND\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static struct uv_signal_t * uv__signal_tree_s_RB_NFIND ( struct uv__signal_tree_s * head , struct uv_signal_t * elm ) { struct uv_signal_t * tmp = RB_ROOT ( head ); struct uv_signal_t * res = NULL ; int comp ; while ( tmp ) { comp = cmp ( elm , tmp ); /* elm\u5c0f\u4e8e\u5f53\u524d\u8282\u70b9\u5219\u5f80\u5de6\u5b50\u6811\u627e\uff0c\u5927\u4e8e\u5219\u5f80\u53f3\u5b50\u6811\u627e\uff0c \u7b49\u4e8e\u5219\u8fd4\u56de */ if ( comp < 0 ) { // \u8bb0\u5f55\u7236\u8282\u70b9 res = tmp ; tmp = RB_LEFT ( tmp , field ); } else if ( comp > 0 ) tmp = RB_RIGHT ( tmp , field ); else return ( tmp ); } return ( res ); } uv__signal_tree_s_RB_NFIND\u7684\u903b\u8f91\u5c31\u662f\u6839\u636e\u7ea2\u9ed1\u6811\u7684\u7279\u70b9\u8fdb\u884c\u641c\u7d22\uff0c\u8fd9\u91cc\u7684\u91cd\u70b9\u662fcmp\u51fd\u6570\u3002\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7cmp\u7684\u903b\u8f91\u3002\u8fd9\u91cc\u4f1a\u9996\u5148\u67e5\u627e\u6ca1\u6709\u8bbe\u7f6eone shot\u6807\u8bb0\u7684handle\uff08\u56e0\u4e3a\u5b83\u7684\u503c\u5c0f\uff09\uff0c\u7136\u540e\u518d\u67e5\u627e\u8bbe\u7f6e\u4e86one shot\u7684handle\uff0c\u4e00\u65e6\u9047\u5230\u8bbe\u7f6e\u4e86one shot\u7684handle\uff0c\u5219\u8bf4\u660e\u540e\u9762\u88ab\u5339\u914d\u7684handle\u4e5f\u662f\u8bbe\u7f6e\u4e86one shot\u6807\u8bb0\u7684\u3002\u6bcf\u6b21\u627e\u5230\u4e00\u4e2ahandle\uff0c\u5c31\u4f1a\u5c01\u88c5\u4e00\u4e2amsg\u5199\u5165\u7ba1\u9053\uff08\u5373\u548cLibuv\u901a\u4fe1\u7684\u7ba1\u9053\uff09\u3002\u4fe1\u53f7\u7684\u5904\u7406\u5c31\u5b8c\u6210\u4e86\u3002\u63a5\u4e0b\u6765\u5728Libuv\u7684Poll IO\u9636\u6bb5\u624d\u505a\u771f\u6b63\u7684\u5904\u7406\u3002\u6211\u4eec\u77e5\u9053\u5728Poll IO\u9636\u6bb5\u3002epoll\u4f1a\u68c0\u6d4b\u5230\u7ba1\u9053loop->signal_pipefd[0]\u53ef\u8bfb\uff0c\u7136\u540e\u4f1a\u6267\u884cuv__signal_event\u51fd\u6570\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // \u5982\u679c\u6536\u5230\u4fe1\u53f7,Libuv Poll IO\u9636\u6bb5,\u4f1a\u6267\u884c\u8be5\u51fd\u6570 static void uv__signal_event ( uv_loop_t * loop , uv__io_t * w , unsigned int events ) { uv__signal_msg_t * msg ; uv_signal_t * handle ; char buf [ sizeof ( uv__signal_msg_t ) * 32 ]; size_t bytes , end , i ; int r ; bytes = 0 ; end = 0 ; // \u8ba1\u7b97\u51fa\u6570\u636e\u7684\u5927\u5c0f do { // \u8bfb\u51fa\u6240\u6709\u7684uv__signal_msg_t r = read ( loop -> signal_pipefd [ 0 ], buf + bytes , sizeof ( buf ) - bytes ); if ( r == -1 && errno == EINTR ) continue ; if ( r == -1 && ( errno == EAGAIN || errno == EWOULDBLOCK )) { if ( bytes > 0 ) continue ; return ; } if ( r == -1 ) abort (); bytes += r ; /* \u6839\u636e\u6536\u5230\u7684\u5b57\u8282\u6570\u7b97\u51fa\u6709\u591a\u5c11\u4e2auv__signal_msg_t\u7ed3\u6784\u4f53\uff0c \u4ece\u800c\u7b97\u51fa\u7ed3\u675f\u4f4d\u7f6e */ end = ( bytes / sizeof ( uv__signal_msg_t )) * sizeof ( uv__signal_msg_t ); // \u5faa\u73af\u5904\u7406\u6bcf\u4e00\u4e2amsg for ( i = 0 ; i < end ; i += sizeof ( uv__signal_msg_t )) { msg = ( uv__signal_msg_t * ) ( buf + i ); // \u53d6\u51fa\u4e0a\u4e0b\u6587 handle = msg -> handle ; // \u6536\u5230\u7684\u4fe1\u53f7\u548chandle\u611f\u5174\u8da3\u7684\u4fe1\u53f7\u4e00\u81f4\uff0c\u6267\u884c\u56de\u8c03 if ( msg -> signum == handle -> signum ) { handle -> signal_cb ( handle , handle -> signum ); } // \u5904\u7406\u4fe1\u53f7\u4e2a\u6570\uff0c\u548c\u6536\u5230\u7684\u4e2a\u6570\u5bf9\u5e94 handle -> dispatched_signals ++ ; // \u53ea\u6267\u884c\u4e00\u6b21\uff0c\u6062\u590d\u7cfb\u7edf\u9ed8\u8ba4\u7684\u5904\u7406\u51fd\u6570 if ( handle -> flags & UV_SIGNAL_ONE_SHOT ) uv__signal_stop ( handle ); /* \u5904\u7406\u5b8c\u6240\u6709\u6536\u5230\u7684\u4fe1\u53f7\u624d\u80fd\u5173\u95eduv_signal_t\uff0c \u89c1uv_close\u6216uv__signal_close */ if (( handle -> flags & UV_HANDLE_CLOSING ) && ( handle -> caught_signals == handle -> dispatched_signals )) { uv__make_close_pending (( uv_handle_t * ) handle ); } } bytes -= end ; if ( bytes ) { memmove ( buf , buf + end , bytes ); continue ; } } while ( end == sizeof buf ); } uv__signal_event\u51fd\u6570\u7684\u903b\u8f91\u5982\u4e0b 1 \u8bfb\u51fa\u7ba1\u9053\u91cc\u7684\u6570\u636e\uff0c\u8ba1\u7b97\u51famsg\u7684\u4e2a\u6570\u3002 2 \u904d\u5386\u6536\u5230\u7684\u6570\u636e\uff0c\u89e3\u6790\u51fa\u4e00\u4e2a\u4e2amsg\u3002 3 \u4ecemsg\u4e2d\u53d6\u51fa\u4e0a\u4e0b\u6587\uff08handle\u548c\u4fe1\u53f7\uff09\uff0c\u6267\u884c\u4e0a\u5c42\u56de\u8c03\u3002 4 \u5982\u679chandle\u8bbe\u7f6e\u4e86one shot\u5219\u9700\u8981\u6267\u884cuv__signal_stop\uff08\u6211\u4eec\u63a5\u4e0b\u6765\u5206\u6790\uff09\u3002 5 \u5982\u679chandle\u8bbe\u7f6e\u4e86closing\u6807\u8bb0\uff0c\u5219\u5224\u65ad\u6240\u6709\u6536\u5230\u7684\u4fe1\u53f7\u662f\u5426\u5df2\u7ecf\u5904\u7406\u5b8c\u3002\u5373\u6536\u5230\u7684\u4e2a\u6570\u548c\u5904\u7406\u7684\u4e2a\u6570\u662f\u5426\u4e00\u81f4\u3002\u9700\u8981\u5904\u7406\u5b8c\u6240\u6709\u6536\u5230\u7684\u4fe1\u53f7\u624d\u80fd\u5173\u95eduv_signal_t\u3002","title":"7.6 \u4fe1\u53f7\u7684\u5904\u7406"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/#77","text":"\u5f53\u4e00\u4e2a\u4fe1\u53f7\u5bf9\u5e94\u7684handle\u8bbe\u7f6e\u4e86one shot\u6807\u8bb0\uff0c\u5728\u6536\u5230\u4fe1\u53f7\u5e76\u4e14\u6267\u884c\u5b8c\u56de\u8c03\u540e\uff0cLibuv\u4f1a\u8c03\u7528uv__signal_stop\u5173\u95ed\u8be5handle\u5e76\u4e14\u4ece\u7ea2\u9ed1\u6811\u4e2d\u79fb\u9664\u8be5handle\u3002\u53e6\u5916\u6211\u4eec\u4e5f\u53ef\u4ee5\u663e\u5f0f\u5730\u8c03\u7528uv_close\uff08\u4f1a\u8c03\u7528uv__signal_stop\uff09\u5173\u95ed\u6216\u53d6\u6d88\u4fe1\u53f7\u7684\u5904\u7406\u3002\u4e0b\u9762\u6211\u4eec\u770b\u770buv__signal_stop\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 static void uv__signal_stop ( uv_signal_t * handle ) { uv_signal_t * removed_handle ; sigset_t saved_sigmask ; uv_signal_t * first_handle ; int rem_oneshot ; int first_oneshot ; int ret ; /* If the watcher wasn't started, this is a no-op. */ // \u6ca1\u6709\u6ce8\u518c\u8fc7\u4fe1\u53f7\uff0c\u5219\u4e0d\u9700\u8981\u5904\u7406 if ( handle -> signum == 0 ) return ; // \u5c4f\u853d\u6240\u6709\u4fe1\u53f7 uv__signal_block_and_lock ( & saved_sigmask ); // \u79fb\u51fa\u7ea2\u9ed1\u6811 removed_handle = RB_REMOVE ( uv__signal_tree_s , & uv__signal_tree , handle ); // \u5224\u65ad\u8be5\u4fe1\u53f7\u662f\u5426\u8fd8\u6709\u5bf9\u5e94\u7684handle first_handle = uv__signal_first_handle ( handle -> signum ); // \u4e3a\u7a7a\u8bf4\u660e\u6ca1\u6709handle\u4f1a\u5904\u7406\u8be5\u4fe1\u53f7\u4e86\uff0c\u89e3\u9664\u8be5\u4fe1\u53f7\u7684\u8bbe\u7f6e if ( first_handle == NULL ) { uv__signal_unregister_handler ( handle -> signum ); } else { // \u88ab\u5904\u7406\u7684handle\u662f\u5426\u8bbe\u7f6e\u4e86one shot rem_oneshot = handle -> flags & UV_SIGNAL_ONE_SHOT ; /* \u5269\u4e0b\u7684\u7b2c\u4e00\u4e2ahandle\u662f\u5426\u8bbe\u7f6e\u4e86one shot\uff0c \u5982\u679c\u662f\u5219\u8bf4\u660e\u8be5\u4fe1\u53f7\u5bf9\u5e94\u7684\u6240\u6709\u5269\u4e0b\u7684handle\u90fd\u662fone shot */ first_oneshot = first_handle -> flags & UV_SIGNAL_ONE_SHOT ; /* \u88ab\u79fb\u9664\u7684handle\u6ca1\u6709\u8bbe\u7f6eoneshot\u4f46\u662f\u5f53\u524d\u7684\u7b2c\u4e00\u4e2ahandle\u8bbe\u7f6e\u4e86 one shot\uff0c\u5219\u9700\u8981\u4fee\u6539\u8be5\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u4e3aone shot\uff0c\u9632\u6b62\u6536\u5230\u591a\u6b21\u4fe1 \u53f7\uff0c\u6267\u884c\u591a\u6b21\u56de\u8c03 */ if ( first_oneshot && ! rem_oneshot ) { ret = uv__signal_register_handler ( handle -> signum , 1 ); assert ( ret == 0 ); } } uv__signal_unlock_and_unblock ( & saved_sigmask ); handle -> signum = 0 ; uv__handle_stop ( handle ); }","title":"7.7 \u53d6\u6d88/\u5173\u95ed\u4fe1\u53f7\u5904\u7406"},{"location":"chapter07-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/#78-nodejs","text":"\u5206\u6790\u5b8cLibuv\u7684\u5b9e\u73b0\u540e\uff0c\u6211\u4eec\u770b\u770bNode.js\u4e0a\u5c42\u662f\u5982\u4f55\u4f7f\u7528\u4fe1\u53f7\u7684\uff0c\u9996\u5148\u6211\u4eec\u770b\u4e00\u4e0bC++\u5c42\u5173\u4e8e\u4fe1\u53f7\u6a21\u5757\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 static void Initialize ( Local < Object > target , Local < Value > unused , Local < Context > context , void * priv ) { Environment * env = Environment :: GetCurrent ( context ); Local < FunctionTemplate > constructor = env -> NewFunctionTemplate ( New ); constructor -> InstanceTemplate () -> SetInternalFieldCount ( 1 ); // \u5bfc\u51fa\u7684\u7c7b\u540d Local < String > signalString = FIXED_ONE_BYTE_STRING ( env -> isolate (), \"Signal\" ); constructor -> SetClassName ( signalString ); constructor -> Inherit ( HandleWrap :: GetConstructorTemplate ( env )); // \u7ed9Signal\u521b\u5efa\u7684\u5bf9\u8c61\u6ce8\u5165\u4e24\u4e2a\u51fd\u6570 env -> SetProtoMethod ( constructor , \"start\" , Start ); env -> SetProtoMethod ( constructor , \"stop\" , Stop ); target -> Set ( env -> context (), signalString , constructor -> GetFunction ( env -> context ()). ToLocalChecked ()). Check (); } \u5f53\u6211\u4eec\u5728JS\u4e2dnew Signal\u7684\u65f6\u5019\uff0c\u9996\u5148\u4f1a\u521b\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u7136\u540e\u4f5c\u4e3a\u5165\u53c2\u6267\u884cNew\u51fd\u6570\u3002 1 2 3 4 5 static void New ( const FunctionCallbackInfo < Value >& args ) { CHECK ( args . IsConstructCall ()); Environment * env = Environment :: GetCurrent ( args ); new SignalWrap ( env , args . This ()); } \u5f53\u6211\u4eec\u5728JS\u5c42\u64cd\u4f5cSignal\u5b9e\u4f8b\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884cC++\u5c42\u5bf9\u5e94\u7684\u65b9\u6cd5\u3002\u4e3b\u8981\u7684\u65b9\u6cd5\u662f\u6ce8\u518c\u548c\u5220\u9664\u4fe1\u53f7\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 static void Start ( const FunctionCallbackInfo < Value >& args ) { SignalWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder ()); Environment * env = wrap -> env (); int signum ; if ( ! args [ 0 ] -> Int32Value ( env -> context ()). To ( & signum )) return ; int err = uv_signal_start ( & wrap -> handle_ , // \u4fe1\u53f7\u4ea7\u751f\u65f6\u6267\u884c\u7684\u56de\u8c03 []( uv_signal_t * handle , int signum ) { SignalWrap * wrap = ContainerOf ( & SignalWrap :: handle_ , handle ); Environment * env = wrap -> env (); HandleScope handle_scope ( env -> isolate ()); Context :: Scope context_scope ( env -> context ()); Local < Value > arg = Integer :: New ( env -> isolate (), signum ); // \u89e6\u53d1JS\u5c42onsignal\u51fd\u6570 wrap -> MakeCallback ( env -> onsignal_string (), 1 , & arg ); }, signum ); if ( err == 0 ) { CHECK ( ! wrap -> active_ ); wrap -> active_ = true ; Mutex :: ScopedLock lock ( handled_signals_mutex ); handled_signals [ signum ] ++ ; } args . GetReturnValue (). Set ( err ); } static void Stop ( const FunctionCallbackInfo < Value >& args ) { SignalWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder ()); if ( wrap -> active_ ) { wrap -> active_ = false ; DecreaseSignalHandlerCount ( wrap -> handle_ . signum ); } int err = uv_signal_stop ( & wrap -> handle_ ); args . GetReturnValue (). Set ( err ); } \u63a5\u7740\u6211\u4eec\u770b\u5728JS\u5c42\u5982\u4f55\u4f7f\u7528\u3002Node.js\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u5728is_main_thread.js\u4e2d\u6267\u884c\u4e86\u3002 1 2 process . on ( 'newListener' , startListeningIfSignal ); process . on ( 'removeListener' , stopListeningIfSignal ) newListener\u548cremoveListener\u4e8b\u4ef6\u5728\u6ce8\u518c\u548c\u5220\u9664\u4e8b\u4ef6\u7684\u65f6\u5019\u90fd\u4f1a\u88ab\u89e6\u53d1\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e24\u4e2a\u51fd\u6570\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* { SIGINT: 2, ... } */ const { signals } = internalBinding ( 'constants' ). os ; let Signal ; const signalWraps = new Map (); function isSignal ( event ) { return typeof event === 'string' && signals [ event ] !== undefined ; } function startListeningIfSignal ( type ) { if ( isSignal ( type ) && ! signalWraps . has ( type )) { if ( Signal === undefined ) Signal = internalBinding ( 'signal_wrap' ). Signal ; const wrap = new Signal (); // \u4e0d\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa wrap . unref (); // \u6302\u8f7d\u4fe1\u53f7\u5904\u7406\u51fd\u6570 wrap . onsignal = process . emit . bind ( process , type , type ); // \u901a\u8fc7\u5b57\u7b26\u62ff\u5230\u6570\u5b57 const signum = signals [ type ]; // \u6ce8\u518c\u4fe1\u53f7 const err = wrap . start ( signum ); if ( err ) { wrap . close (); throw errnoException ( err , 'uv_signal_start' ); } // \u8be5\u4fe1\u53f7\u5df2\u7ecf\u6ce8\u518c\uff0c\u4e0d\u9700\u8981\u5f80\u5e95\u5c42\u518d\u6ce8\u518c\u4e86 signalWraps . set ( type , wrap ); } } startListeningIfSignal\u51fd\u6570\u7684\u903b\u8f91\u5206\u4e3a\u4e00\u4e0b\u51e0\u4e2a 1 \u5224\u65ad\u8be5\u4fe1\u53f7\u662f\u5426\u6ce8\u518c\u8fc7\u4e86\uff0c\u5982\u679c\u6ce8\u518c\u8fc7\u4e86\u5219\u4e0d\u9700\u8981\u518d\u6ce8\u518c\u3002Libuv\u672c\u8eab\u652f\u6301\u5728\u540c\u4e00\u4e2a\u4fe1\u53f7\u4e0a\u6ce8\u518c\u591a\u4e2a\u5904\u7406\u51fd\u6570\uff0cNode.js\u7684JS\u5c42\u4e5f\u505a\u4e86\u8fd9\u4e2a\u5904\u7406\u3002 2 \u8c03\u7528unref\uff0c\u4fe1\u53f7\u7684\u6ce8\u518c\u4e0d\u5e94\u8be5\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa 3 \u6302\u8f7d\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\uff0c\u5f53\u4fe1\u53f7\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u6267\u884c\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff08\u4e00\u4e2a\u6216\u591a\u4e2a\uff09\u3002 4 \u5f80\u5e95\u5c42\u6ce8\u518c\u4fe1\u53f7\u5e76\u8bbe\u7f6e\u8be5\u4fe1\u53f7\u5df2\u7ecf\u6ce8\u518c\u7684\u6807\u8bb0 \u6211\u4eec\u518d\u6765\u770b\u4e00\u4e0bstopListeningIfSignal\u3002 1 2 3 4 5 6 7 function stopListeningIfSignal ( type ) { const wrap = signalWraps . get ( type ); if ( wrap !== undefined && process . listenerCount ( type ) === 0 ) { wrap . close (); signalWraps . delete ( type ); } } \u53ea\u6709\u5f53\u4fe1\u53f7\u88ab\u6ce8\u518c\u8fc7\u5e76\u4e14\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u4e2a\u6570\u4e3a0\uff0c\u624d\u505a\u771f\u6b63\u7684\u5220\u9664\u3002","title":"7.8 \u4fe1\u53f7\u5728Node.js\u4e2d\u7684\u4f7f\u7528"},{"location":"chapter08-DNS/","text":"Node.js\u7684DNS\u6a21\u5757\u4f7f\u7528\u4e86cares\u5e93\u548cLibuv\u7684\u7ebf\u7a0b\u6c60\u5b9e\u73b0\u3002cares\u662f\u4e00\u4e2a\u5f02\u6b65DNS\u89e3\u6790\u5e93\uff0c\u5b83\u81ea\u5df1\u5b9e\u73b0\u4e86DNS\u534f\u8bae\u7684\u5c01\u5305\u548c\u89e3\u6790\uff0c\u914d\u5408Libuv\u4e8b\u4ef6\u9a71\u52a8\u673a\u5236\uff0c\u5728Node.js\u4e2d\u5b9e\u73b0\u5f02\u6b65\u7684DNS\u89e3\u6790\u3002\u53e6\u5916\u901a\u8fc7IP\u67e5\u8be2\u57df\u540d\u6216\u8005\u57df\u540d\u67e5\u8be2IP\u662f\u76f4\u63a5\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\u63a5\u53e3\u5b9e\u73b0\u7684\uff0c\u56e0\u4e3a\u8fd9\u4e24\u4e2a\u51fd\u6570\u662f\u963b\u585e\u5f0f\u7684API\uff0c\u6240\u4ee5Node.js\u662f\u901a\u8fc7Libuv\u7684\u7ebf\u7a0b\u6c60\u5b9e\u73b0\u5f02\u6b65\u67e5\u8be2\u3002\u9664\u4e86\u63d0\u4f9b\u76f4\u63a5\u7684DNS\u67e5\u8be2\u5916\uff0cNode.js\u8fd8\u63d0\u4f9b\u4e86\u8bbe\u7f6eDNS\u670d\u52a1\u5668\u3001\u65b0\u5efa\u4e00\u4e2aDNS\u89e3\u6790\u5b9e\u4f8b\uff08Resolver\uff09\u7b49\u529f\u80fd\u3002\u8fd9\u4e9b\u529f\u80fd\u662f\u4f7f\u7528cares\u5b9e\u73b0\u7684\u3002\u4e0b\u9762\u6211\u4eec\u5f00\u59cb\u5206\u6790DNS\u6a21\u5757\u7684\u539f\u7406\u548c\u5b9e\u73b0\u3002 8.1 \u901a\u8fc7\u57df\u540d\u627eIP \u00b6 \u6211\u4eec\u770b\u4e00\u4e0b\u5728Node.js\u4e2d\u5982\u4f55\u67e5\u8be2\u4e00\u4e2a\u57df\u540d\u5bf9\u4e8e\u7684IP\u7684\u4fe1\u606f 1 2 3 dns . lookup ( 'www.a.com' , function ( err , address , family ) { console . log ( address ); }); DNS\u529f\u80fd\u7684JS\u5c42\u5b9e\u73b0\u5728dns.js\u4e2d 1 2 3 4 5 6 7 8 9 const req = new GetAddrInfoReqWrap (); req . callback = callback ; req . family = family ; req . hostname = hostname ; req . oncomplete = all ? onlookupall : onlookup ; const err = cares . getaddrinfo ( req , toASCII ( hostname ), family , hints , verbatim ); Node.js\u8bbe\u7f6e\u4e86\u4e00\u4e9b\u53c2\u6570\u540e\uff0c\u8c03\u7528cares_wrap.cc\u7684getaddrinfo\u65b9\u6cd5\uff0c\u5728care_wrap.cc\u7684\u521d\u59cb\u5316\u51fd\u6570\u4e2d\u6211\u4eec\u770b\u5230\uff0c getaddrinfo\u51fd\u6570\u5bf9\u5e94\u7684\u51fd\u6570\u662fGetAddrInfo\u3002 1 2 3 4 5 6 7 void Initialize ( Local < Object > target , Local < Value > unused , Local < Context > context ) { Environment * env = Environment :: GetCurrent ( context ); env -> SetMethod ( target , \"getaddrinfo\" , GetAddrInfo ); ... } GetAddrInfo\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 auto req_wrap = new GetAddrInfoReqWrap ( env , req_wrap_obj , args [ 4 ] -> IsTrue ()); struct addrinfo hints ; memset ( & hints , 0 , sizeof ( struct addrinfo )); hints . ai_family = family ; hints . ai_socktype = SOCK_STREAM ; hints . ai_flags = flags ; int err = uv_getaddrinfo ( env -> event_loop (), req_wrap -> req (), AfterGetAddrInfo , * hostname , nullptr , & hints ); GetAddrInfo\u662f\u5bf9uv_getaddrinfo\u7684\u5c01\u88c5\uff0c\u56de\u8c03\u51fd\u6570\u662fAfterGetAddrInfo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 int uv_getaddrinfo ( uv_loop_t * loop , // \u4e0a\u5c42\u4f20\u8fdb\u6765\u7684req uv_getaddrinfo_t * req , // \u89e3\u6790\u5b8c\u540e\u7684\u4e0a\u5c42\u56de\u8c03 uv_getaddrinfo_cb cb , // \u9700\u8981\u89e3\u6790\u7684\u540d\u5b57 const char * hostname , /* \u67e5\u8be2\u7684\u8fc7\u6ee4\u6761\u4ef6\uff1a\u670d\u52a1\u540d\u3002\u6bd4\u5982 http smtp\u3002\u4e5f\u53ef\u4ee5\u662f\u4e00\u4e2a\u7aef\u53e3\u3002 \u89c1\u4e0b\u9762\u6ce8\u91ca */ const char * service , // \u5176\u5b83\u67e5\u8be2\u8fc7\u6ee4\u6761\u4ef6 const struct addrinfo * hints ) { size_t hostname_len ; size_t service_len ; size_t hints_len ; size_t len ; char * buf ; hostname_len = hostname ? strlen ( hostname ) + 1 : 0 ; service_len = service ? strlen ( service ) + 1 : 0 ; hints_len = hints ? sizeof ( * hints ) : 0 ; buf = uv__malloc ( hostname_len + service_len + hints_len ); uv__req_init ( loop , req , UV_GETADDRINFO ); req -> loop = loop ; // \u8bbe\u7f6e\u8bf7\u6c42\u7684\u56de\u8c03 req -> cb = cb ; req -> addrinfo = NULL ; req -> hints = NULL ; req -> service = NULL ; req -> hostname = NULL ; req -> retcode = 0 ; len = 0 ; if ( hints ) { req -> hints = memcpy ( buf + len , hints , sizeof ( * hints )); len += sizeof ( * hints ); } if ( service ) { req -> service = memcpy ( buf + len , service , service_len ); len += service_len ; } if ( hostname ) req -> hostname = memcpy ( buf + len , hostname , hostname_len ); // \u4f20\u4e86cb\u5219\u662f\u5f02\u6b65 if ( cb ) { uv__work_submit ( loop , & req -> work_req , UV__WORK_SLOW_IO , uv__getaddrinfo_work , uv__getaddrinfo_done ); return 0 ; } else { // \u963b\u585e\u5f0f\u67e5\u8be2\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03 uv__getaddrinfo_work ( & req -> work_req ); uv__getaddrinfo_done ( & req -> work_req , 0 ); return req -> retcode ; } } \u6211\u4eec\u770b\u5230\u8fd9\u4e2a\u51fd\u6570\u9996\u5148\u662f\u5bf9\u4e00\u4e2arequest\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u7136\u540e\u6839\u636e\u662f\u5426\u4f20\u4e86\u56de\u8c03\uff0c\u51b3\u5b9a\u8d70\u5f02\u6b65\u8fd8\u662f\u540c\u6b65\u7684\u6a21\u5f0f\u3002\u540c\u6b65\u7684\u65b9\u5f0f\u6bd4\u8f83\u7b80\u5355\uff0c\u5c31\u662f\u76f4\u63a5\u963b\u585eLibuv\u4e8b\u4ef6\u5faa\u73af\uff0c\u76f4\u5230\u89e3\u6790\u5b8c\u6210\u3002\u5982\u679c\u662f\u5f02\u6b65\uff0c\u5219\u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4e00\u4e2a\u6162IO\u7684\u4efb\u52a1\u3002\u5176\u4e2d\u5de5\u4f5c\u51fd\u6570\u662fuv__getaddrinfo_work\u3002\u56de\u8c03\u662fuv__getaddrinfo_done\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e24\u4e2a\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 // \u89e3\u6790\u7684\u5de5\u4f5c\u51fd\u6570 static void uv__getaddrinfo_work ( struct uv__work * w ) { uv_getaddrinfo_t * req ; int err ; // \u6839\u636e\u7ed3\u6784\u4f53\u7684\u5b57\u6bb5\u83b7\u53d6\u7ed3\u6784\u4f53\u9996\u5730\u5740 req = container_of ( w , uv_getaddrinfo_t , work_req ); // \u963b\u585e\u5728\u8fd9 err = getaddrinfo ( req -> hostname , req -> service , req -> hints , & req -> addrinfo ); req -> retcode = uv__getaddrinfo_translate_error ( err ); } uv__getaddrinfo_work\u51fd\u6570\u4e3b\u8981\u662f\u8c03\u7528\u4e86\u7cfb\u7edf\u63d0\u4f9b\u7684getaddrinfo\u53bb\u505a\u89e3\u6790\u3002\u8be5\u51fd\u6570\u4f1a\u5bfc\u81f4\u8fdb\u7a0b\u963b\u585e\u3002\u7ed3\u679c\u8fd4\u56de\u540e\uff0c\u6267\u884cuv__getaddrinfo_done\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 static void uv__getaddrinfo_done ( struct uv__work * w , int status ) { uv_getaddrinfo_t * req ; req = container_of ( w , uv_getaddrinfo_t , work_req ); uv__req_unregister ( req -> loop , req ); // \u91ca\u653e\u521d\u59cb\u5316\u65f6\u7533\u8bf7\u7684\u5185\u5b58 if ( req -> hints ) uv__free ( req -> hints ); else if ( req -> service ) uv__free ( req -> service ); else if ( req -> hostname ) uv__free ( req -> hostname ); else assert ( 0 ); req -> hints = NULL ; req -> service = NULL ; req -> hostname = NULL ; // \u89e3\u6790\u8bf7\u6c42\u88ab\u7528\u6237\u53d6\u6d88\u4e86 if ( status == UV_ECANCELED ) { assert ( req -> retcode == 0 ); req -> retcode = UV_EAI_CANCELED ; } // \u6267\u884c\u4e0a\u5c42\u56de\u8c03 if ( req -> cb ) req -> cb ( req , req -> retcode , req -> addrinfo ); } uv__getaddrinfo_done\u4f1a\u6267\u884cC++\u5c42\u7684\u56de\u8c03\uff0c\u4ece\u800c\u6267\u884cJS\u5c42\u7684\u56de\u8c03\u3002 8.2 cares \u00b6 \u9664\u4e86\u901a\u8fc7IP\u67e5\u8be2\u57df\u540d\u548c\u57df\u540d\u67e5\u8be2IP\u5916\uff0c\u5176\u4f59\u7684DNS\u529f\u80fd\u90fd\u7531cares\u5b9e\u73b0\uff0c\u6211\u4eec\u770b\u4e00\u4e0bcares\u7684\u57fa\u672c\u7528\u6cd5\u3002 8.2.1 cares\u4f7f\u7528\u548c\u539f\u7406 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // channel\u662fcares\u7684\u6838\u5fc3\u7ed3\u6784\u4f53 ares_channel channel ; struct ares_options options ; // \u521d\u59cb\u5316channel status = ares_init_options ( & channel , & options , optmask ); // \u628a argv\u7684\u6570\u636e\u5b58\u5230addr ares_inet_pton ( AF_INET , * argv , & addr4 ); // \u628aaddr\u6570\u636e\u5b58\u5230channel\u5e76\u53d1\u8d77DNS\u67e5\u8be2 ares_gethostbyaddr ( channel , & addr4 , sizeof ( addr4 ), AF_INET , callback , * argv ); for (;;) { int res ; FD_ZERO ( & read_fds ); FD_ZERO ( & write_fds ); // \u628achannel\u5bf9\u5e94\u7684fd\u5b58\u5230read_fd\u548cwrite_fds nfds = ares_fds ( channel , & read_fds , & write_fds ); if ( nfds == 0 ) break ; // \u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4 tvp = ares_timeout ( channel , NULL , & tv ); // \u963b\u585e\u5728select\uff0c\u7b49\u5f85DNS\u56de\u5305 res = select ( nfds , & read_fds , & write_fds , NULL , tvp ); if ( -1 == res ) break ; // \u5904\u7406DNS\u76f8\u5e94 ares_process ( channel , & read_fds , & write_fds ); } \u4e0a\u9762\u662f\u4e00\u4e2a\u5178\u578b\u7684\u4e8b\u4ef6\u9a71\u52a8\u6a21\u578b\uff0c\u9996\u5148\u521d\u59cb\u5316\u4e00\u4e9b\u4fe1\u606f\uff0c\u7136\u540e\u53d1\u8d77\u4e00\u4e2a\u975e\u963b\u585e\u7684\u8bf7\u6c42\uff0c\u63a5\u7740\u963b\u585e\u5728\u591a\u8def\u590d\u7528API\uff0c\u8be5API\u8fd4\u56de\u540e\uff0c\u6267\u884c\u89e6\u53d1\u4e86\u4e8b\u4ef6\u7684\u56de\u8c03\u3002 8.2.2 cares_wrap.cc\u7684\u901a\u7528\u903b\u8f91 \u00b6 \u5728Node.js\u4e2d\uff0cNode.js\u548ccares\u7684\u6574\u4f53\u4ea4\u4e92\u5982\u56fe8-1\u6240\u793a\u3002 \u56fe8-1. \u6211\u4eec\u901a\u8fc7cares_wrap.cc\u5206\u6790\u5176\u4e2d\u7684\u539f\u7406\u3002\u6211\u4eec\u4eceDNS\u6a21\u5757\u63d0\u4f9b\u7684resolveCname\u51fd\u6570\u5f00\u59cb\u3002resolveCname\u51fd\u6570\u7531\u4ee5\u4e0b\u4ee3\u7801\u5bfc\u51fa\uff08dns.js\uff09\u3002 1 bindDefaultResolver ( module . exports , getDefaultResolver ()) \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e24\u4e2a\u51fd\u6570\uff08dns/utils.js\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Resolver { constructor () { this . _handle = new ChannelWrap (); } // ... } let defaultResolver = new Resolver (); function getDefaultResolver () { return defaultResolver ; } function resolver ( bindingName ) { function query ( name , /* options, */ callback ) { let options ; const req = new QueryReqWrap (); req . bindingName = bindingName ; req . callback = callback ; req . hostname = name ; req . oncomplete = onresolve ; req . ttl = !! ( options && options . ttl ); const err = this . _handle [ bindingName ]( req , toASCII ( name )); if ( err ) throw dnsException ( err , bindingName , name ); return req ; } ObjectDefineProperty ( query , 'name' , { value : bindingName }); return query ; } // \u7ed9\u539f\u578b\u94fe\u6ce8\u5165\u4e00\u4e2a\u65b0\u7684\u5c5e\u6027\uff0cdefaultResolver\u4e2d\u4e5f\u751f\u6548 Resolver . prototype . resolveCname = resolveMap . CNAME = resolver ( 'queryCname' ); getDefaultResolver\u5bfc\u51fa\u7684\u662f\u4e00\u4e2aResolve\u5bf9\u8c61\uff0c\u91cc\u9762\u6709resolveCname\u7b49\u4e00\u7cfb\u5217\u65b9\u6cd5\u3002\u63a5\u7740\u770b\u4e00\u4e0bbindDefaultResolver\uff0c\u6211\u4eec\u4e00\u4f1a\u518d\u770bChannelWrap\u3002 1 2 3 4 5 6 7 8 9 const resolverKeys = [ 'resolveCname ' , // \u2026 ] function bindDefaultResolver ( target , source ) { resolverKeys . forEach (( key ) => { target [ key ] = source [ key ]. bind ( defaultResolver ); }); } \u770b\u8d77\u6765\u5f88\u7ed5\uff0c\u5176\u5b9e\u5c31\u662f\u628aResolve\u5bf9\u8c61\u7684\u65b9\u6cd5\u5bfc\u51fa\u5230DNS\u6a21\u5757\u3002\u8fd9\u6837\u7528\u6237\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e86\u3002\u6211\u4eec\u770b\u5230resolveCname\u662f\u7531resolver\u51fd\u6570\u751f\u6210\u7684\uff0cresolver\u51fd\u6570\u5bf9cares\u7cfb\u5217\u51fd\u6570\u8fdb\u884c\u4e86\u5c01\u88c5\uff0c\u6700\u7ec8\u8c03\u7528\u7684\u662fthis._handle.queryCname\u51fd\u6570\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u8fd9\u4e2ahandle\uff08ChannelWrap\u7c7b\u5bf9\u8c61\uff09\u7684\u5b9e\u73b0\uff08cares_wrap.cc\uff09\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bcares_wrap.cc\u6a21\u5757\u5bfc\u51fa\u7684API\u3002 1 2 3 4 5 6 7 8 9 10 11 12 Local < FunctionTemplate > channel_wrap = env -> NewFunctionTemplate ( ChannelWrap :: New ); channel_wrap -> InstanceTemplate () -> SetInternalFieldCount ( 1 ); channel_wrap -> Inherit ( AsyncWrap :: GetConstructorTemplate ( env )); // Query\u662fC++\u51fd\u6570\u6a21\u677f env -> SetProtoMethod ( channel_wrap , \"queryCname\" , Query < QueryCnameWrap > ); // ... Local < String > channelWrapString = FIXED_ONE_BYTE_STRING ( env -> isolate (), \"ChannelWrap\" ); channel_wrap -> SetClassName ( channelWrapString ); target -> Set ( env -> context (), channelWrapString , channel_wrap -> GetFunction ( context ). ToLocalChecked ()). Check (); handle\u5bf9\u5e94\u7684\u5c31\u662f\u4ee5\u4e0a\u4ee3\u7801\u5bfc\u51fa\u7684\u5bf9\u8c61\u3002\u5f53\u6211\u4eec\u5728JS\u5c42\u6267\u884cnew ChannelWrap\u7684\u65f6\u5019\u3002 \u6700\u7ec8\u4f1a\u8c03\u7528C++\u5c42\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5e76\u4e14\u6267\u884cChannelWrap::New\u3002 1 2 3 4 void ChannelWrap::New ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); new ChannelWrap ( env , args . This ()); } \u6211\u4eec\u770b\u4e00\u4e0b\u7c7bChannelWrap\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ChannelWrap : public AsyncWrap { public : // ... private : // \u8d85\u65f6\u7ba1\u7406 uv_timer_t * timer_handle_ ; // cares\u6570\u636e\u7c7b\u578b ares_channel channel_ ; // \u6807\u8bb0\u67e5\u8be2\u7ed3\u679c bool query_last_ok_ ; // \u4f7f\u7528\u7684DNS\u670d\u52a1\u5668 bool is_servers_default_ ; // \u662f\u5426\u5df2\u7ecf\u521d\u59cb\u5316cares\u5e93 bool library_inited_ ; // \u6b63\u5728\u53d1\u8d77\u7684\u67e5\u8be2\u4e2a\u6570 int active_query_count_ ; // \u53d1\u8d77\u67e5\u8be2\u7684\u4efb\u52a1\u961f\u5217 node_ares_task_list task_list_ ; }; \u63a5\u7740\u6211\u4eec\u770b\u770bChannelWrap\u6784\u9020\u51fd\u6570\u7684\u4ee3\u7801\u3002 1 2 3 ChannelWrap :: ChannelWrap (...) { Setup (); } ChannelWrap\u91cc\u76f4\u63a5\u8c03\u7528\u4e86Setup 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void ChannelWrap::Setup () { struct ares_options options ; memset ( & options , 0 , sizeof ( options )); options . flags = ARES_FLAG_NOCHECKRESP ; /* caresd socket\u72b6\u6001\uff08\u8bfb\u5199\uff09\u53d1\u751f\u53d8\u66f4\u65f6\uff0c\u6267\u884c\u7684\u51fd\u6570\uff0c \u7b2c\u4e00\u4e2a\u5165\u53c2\u662fsock_state_cb_data */ options . sock_state_cb = ares_sockstate_cb ; options . sock_state_cb_data = this ; // \u8fd8\u6ca1\u521d\u59cb\u5316\u5219\u521d\u59cb\u5316 if ( ! library_inited_ ) { Mutex :: ScopedLock lock ( ares_library_mutex ); // \u521d\u59cb\u5316cares\u5e93 ares_library_init ( ARES_LIB_INIT_ALL ); } // \u8bbe\u7f6e\u4f7f\u7528cares\u7684\u914d\u7f6e ares_init_options ( & channel_ , & options , ARES_OPT_FLAGS | ARES_OPT_SOCK_STATE_CB ); library_inited_ = true ; } \u6211\u4eec\u770b\u5230\uff0cNode.js\u5728\u8fd9\u91cc\u521d\u59cb\u5316cares\u76f8\u5173\u7684\u903b\u8f91\u3002\u5176\u4e2d\u6700\u91cd\u8981\u7684\u5c31\u662f\u8bbe\u7f6e\u4e86cares socket\u72b6\u6001\u53d8\u66f4\u65f6\u6267\u884c\u7684\u56de\u8c03ares_sockstate_cb\uff08\u6bd4\u5982socket\u9700\u8981\u8bfb\u53d6\u6570\u636e\u6216\u8005\u5199\u5165\u6570\u636e\uff09\u3002\u524d\u9762\u7684cares\u4f7f\u7528\u4f8b\u5b50\u4e2d\u8bb2\u5230\u4e86cares\u548c\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u7684\u914d\u5408\u4f7f\u7528\uff0c\u90a3\u4e48cares\u548cLibuv\u662f\u5982\u4f55\u914d\u5408\u7684\u5462\uff1fcares\u63d0\u4f9b\u4e86\u4e00\u79cd\u673a\u5236\uff0c\u5c31\u662fsocket\u72b6\u6001\u53d8\u66f4\u65f6\u901a\u77e5\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u3002DNS\u89e3\u6790\u672c\u8d28\u4e0a\u4e5f\u662f\u7f51\u7edcIO\uff0c\u6240\u4ee5\u53d1\u8d77\u4e00\u4e2aDNS\u67e5\u8be2\u4e5f\u5c31\u662f\u5bf9\u5e94\u4e00\u4e2asocket\u3002DNS\u67e5\u8be2\u662f\u7531cares\u53d1\u8d77\u7684\uff0c\u8fd9\u5c31\u610f\u5473\u7740socket\u662f\u5728cares\u4e2d\u7ef4\u62a4\u7684\uff0c\u90a3Libuv\u600e\u4e48\u77e5\u9053\u5462\uff1f\u6b63\u662fcares\u63d0\u4f9b\u7684\u901a\u77e5\u673a\u5236\uff0c\u4f7f\u5f97Libuv\u77e5\u9053\u53d1\u8d77DNS\u67e5\u8be2\u5bf9\u5e94\u7684socket\uff0c\u4ece\u800c\u6ce8\u518c\u5230Libuv\u4e2d\uff0c\u7b49\u5230\u4e8b\u4ef6\u89e6\u53d1\u540e\uff0c\u518d\u901a\u77e5cares\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u4ece\u53d1\u8d77\u4e00\u4e2acname\u67e5\u8be2\u5f00\u59cb\u5206\u6790\u3002\u9996\u5148\u56de\u987e\u4e00\u4e0bcares_wrap\u6a21\u5757\u5bfc\u51fa\u7684cname\u67e5\u8be2\u51fd\u6570\uff0c env->SetProtoMethod(channel_wrap, \"queryCname\", Query );Query\u662fC++\u6a21\u677f\u51fd\u6570\uff0cQueryCnameWrap\u662fC++\u7c7b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 template < class Wrap > static void Query ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); ChannelWrap * channel ; // Holder\u4e2d\u4fdd\u5b58\u4e86ChannelWrap\u5bf9\u8c61\uff0c\u89e3\u5305\u51fa\u6765 ASSIGN_OR_RETURN_UNWRAP ( & channel , args . Holder ()); Local < Object > req_wrap_obj = args [ 0 ]. As < Object > (); Local < String > string = args [ 1 ]. As < String > (); /* \u6839\u636e\u53c2\u6570\u65b0\u5efa\u4e00\u4e2a\u5bf9\u8c61\uff0c\u8fd9\u91cc\u662fQueryCnameWrap\uff0c \u5e76\u4e14\u4fdd\u5b58\u5bf9\u5e94\u7684ChannelWrap\u5bf9\u8c61\u548c\u64cd\u4f5c\u76f8\u5173\u7684\u5bf9\u8c61 */ Wrap * wrap = new Wrap ( channel , req_wrap_obj ); node :: Utf8Value name ( env -> isolate (), string ); // \u53d1\u8d77\u8bf7\u6c42\u6570\u52a0\u4e00 channel -> ModifyActivityQueryCount ( 1 ); // \u8c03\u7528Send\u51fd\u6570\u53d1\u8d77\u67e5\u8be2 int err = wrap -> Send ( * name ); if ( err ) { channel -> ModifyActivityQueryCount ( -1 ); delete wrap ; } args . GetReturnValue (). Set ( err ); } Query\u53ea\u5b9e\u73b0\u4e86\u4e00\u4e9b\u901a\u7528\u7684\u903b\u8f91\uff0c\u7136\u540e\u8c03\u7528Send\u51fd\u6570\uff0c\u5177\u4f53\u7684Send\u51fd\u6570\u903b\u8f91\u7531\u5404\u4e2a\u5177\u4f53\u7684\u7c7b\u5b9e\u73b0\u3002 8.2.3 \u5177\u4f53\u5b9e\u73b0 \u00b6 \u6211\u4eec\u770b\u4e00\u4e0bQueryCnameWrap\u7c7b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class QueryCnameWrap : public QueryWrap { public : QueryCnameWrap ( ChannelWrap * channel , Local < Object > req_wrap_obj ) : QueryWrap ( channel , req_wrap_obj , \"resolveCname\" ) { } int Send ( const char * name ) override { AresQuery ( name , ns_c_in , ns_t_cname ); return 0 ; } protected : void Parse ( unsigned char * buf , int len ) override { HandleScope handle_scope ( env () -> isolate ()); Context :: Scope context_scope ( env () -> context ()); Local < Array > ret = Array :: New ( env () -> isolate ()); int type = ns_t_cname ; int status = ParseGeneralReply ( env (), buf , len , & type , ret ); if ( status != ARES_SUCCESS ) { ParseError ( status ); return ; } this -> CallOnComplete ( ret ); } }; \u6211\u4eec\u770b\u5230QueryCnameWrap\u7c7b\u7684\u5b9e\u73b0\u975e\u5e38\u7b80\u5355\uff0c\u4e3b\u8981\u5b9a\u4e49Send\u548cParse\u7684\u5b9e\u73b0\uff0c\u6700\u7ec8\u8fd8\u662f\u4f1a\u8c03\u7528\u57fa\u7c7b\u5bf9\u5e94\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u57fa\u7c7bQueryWrap\u4e2dAresQuery\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 void AresQuery ( const char * name , int dnsclass , int type ) { ares_query ( channel_ -> cares_channel (), name , dnsclass , type , Callback , static_cast < void *> ( this )); } AresQuery\u51fd\u6570\u63d0\u4f9b\u7edf\u4e00\u53d1\u9001\u67e5\u8be2\u64cd\u4f5c\u3002\u67e5\u8be2\u5b8c\u6210\u540e\u6267\u884cCallback\u56de\u8c03\u3002\u63a5\u4e0b\u6765\u5c31\u6d89\u53ca\u5230cares\u548cNode.js\u7684\u5177\u4f53\u4ea4\u4e92\u4e86\u3002Node.js\u628a\u4e00\u4e2a\u4efb\u52a1\u4ea4\u7ed9cares\u540e\uff0ccares\u4f1a\u65b0\u5efa\u4e00\u4e2asocket\uff0c\u63a5\u7740cares\u4f1a\u901a\u8fc7Node.js\u8bbe\u7f6e\u7684\u56de\u8c03ares_sockstate_cb\u901a\u77e5Node.js\u3002\u6211\u4eec\u770b\u4e00\u4e0bares_query\u7684\u5173\u952e\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void ares_query ( ares_channel channel , const char * name , int dnsclass , int type , ares_callback callback , void * arg ) { struct qquery * qquery ; unsigned char * qbuf ; int qlen , rd , status ; qquery = ares_malloc ( sizeof ( struct qquery )); // \u4fdd\u5b58Node.js\u7684\u56de\u8c03\uff0c\u67e5\u8be2\u5b8c\u6210\u65f6\u56de\u8c03 qquery -> callback = callback ; qquery -> arg = arg ; ares_send ( channel , qbuf , qlen , qcallback , qquery ); } static void qcallback ( void * arg , int status , int timeouts , unsigned char * abuf , int alen ) { struct qquery * qquery = ( struct qquery * ) arg ; unsigned int ancount ; int rcode ; if ( status != ARES_SUCCESS ) qquery -> callback ( qquery -> arg , status , timeouts , abuf , alen ); else { // ... // \u6267\u884cNode.js\u56de\u8c03 qquery -> callback ( qquery -> arg , status , timeouts , abuf , alen ); } ares_free ( qquery ); } ares_query\u4fdd\u5b58\u4e86Node.js\u7684\u56de\u8c03\uff0c\u5e76\u4e14\u8bbe\u7f6e\u56de\u8c03qcallback\uff0c\u67e5\u8be2\u6210\u529f\u540e\u4f1a\u56de\u8c03qcallback\uff0cqcallback\u518d\u56de\u8c03Node.js\u3002\u63a5\u7740\u6267\u884cares_send\uff0cares_send\u4f1a\u8c03\u7528ares__send_query\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void ares__send_query ( ares_channel channel , struct query * query , struct timeval * now ) { struct server_state * server = & channel -> servers [ query -> server ]; if ( server -> udp_socket == ARES_SOCKET_BAD ) { // \u7533\u8bf7\u4e00\u4e2asocket if ( open_udp_socket ( channel , server ) == -1 ) { skip_server ( channel , query , query -> server ); next_server ( channel , query , now ); return ; } } // \u53d1\u9001DNS\u67e5\u8be2 if ( socket_write ( channel , server -> udp_socket , query -> qbuf , query -> qlen ) == -1 ) { skip_server ( channel , query , query -> server ); next_server ( channel , query , now ); return ; } } ares__send_query\u9996\u5148\u7533\u8bf7\u4e00\u4e2asocket\uff0c\u7136\u540e\u53d1\u9001\u6570\u636e\u3002\u56e0\u4e3aUDP\u4e0d\u662f\u9762\u5411\u8fde\u63a5\u7684\uff0c\u53ef\u4ee5\u76f4\u63a5\u53d1\u9001\u3002\u6211\u4eec\u770b\u4e00\u4e0bopen_udp_socket\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 static int open_udp_socket ( ares_channel channel , struct server_state * server ) { ares_socket_t s ; ares_socklen_t salen ; union { struct sockaddr_in sa4 ; struct sockaddr_in6 sa6 ; } saddr ; struct sockaddr * sa ; // \u7533\u8bf7\u4e00\u4e2asocket s = open_socket ( channel , server -> addr . family , SOCK_DGRAM , 0 ); // \u7ed1\u5b9a\u670d\u52a1\u5668\u5730\u5740 connect_socket ( channel , s , sa , salen ) // \u901a\u77e5Node.js\uff0c1,0\u8868\u793a\u5bf9socket\u7684\u8bfb\u4e8b\u4ef6\u611f\u5174\u8da3\uff0c\u56e0\u4e3a\u53d1\u9001\u4e86\u8bf7\u6c42\uff0c\u7b49\u5f85\u54cd\u5e94 SOCK_STATE_CALLBACK ( channel , s , 1 , 0 ); // \u4fdd\u5b58socket server -> udp_socket = s ; return 0 ; } #define SOCK_STATE_CALLBACK(c, s, r, w) \\ do { \\ if (( c ) -> sock_state_cb ) \\ ( c ) -> sock_state_cb (( c ) -> sock_state_cb_data , ( s ), ( r ), ( w )); \\ } WHILE_FALSE ares__send_query\u51fd\u6570\u505a\u4e86\u4e09\u4ef6\u4e8b 1 \u7533\u8bf7\u4e86socket\uff0c 2 \u901a\u77e5Node.js 3 \u53d1\u9001\u4e86DNS\u67e5\u8be2\u8bf7\u6c42 \u8fd9\u65f6\u5019\u6d41\u7a0b\u8d70\u5230\u4e86Node.js\uff0c\u6211\u4eec\u770b\u4e00\u4e0bcares\u56de\u8c03Node.js\u7684\u65f6\u5019\uff0cNode.js\u600e\u4e48\u5904\u7406\u7684 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 struct node_ares_task : public MemoryRetainer { ChannelWrap * channel ; // \u5173\u8054\u7684socket ares_socket_t sock ; // IO\u89c2\u5bdf\u8005\u548c\u56de\u8c03 uv_poll_t poll_watcher ; }; void ares_sockstate_cb ( void * data , ares_socket_t sock , int read , int write ) { ChannelWrap * channel = static_cast < ChannelWrap *> ( data ); node_ares_task * task ; // \u4efb\u52a1 node_ares_task lookup_task ; lookup_task . sock = sock ; // \u8be5\u4efb\u52a1\u662f\u5426\u5df2\u7ecf\u5b58\u5728 auto it = channel -> task_list () -> find ( & lookup_task ); task = ( it == channel -> task_list () -> end ()) ? nullptr : * it ; if ( read || write ) { if ( ! task ) { // \u5f00\u542f\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u540e\u901a\u77e5cares channel -> StartTimer (); // \u521b\u5efa\u4e00\u4e2a\u4efb\u52a1 task = ares_task_create ( channel , sock ); // \u4fdd\u5b58\u5230\u4efb\u52a1\u5217\u8868 channel -> task_list () -> insert ( task ); } // \u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230epoll\uff0c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u6839\u636ecares\u4f20\u7684\u8fdb\u884c\u8bbe\u7f6e\uff0c\u6709\u4e8b\u4ef6\u89e6\u53d1\u540e\u6267\u884c\u56de\u8c03ares_poll_cb uv_poll_start ( & task -> poll_watcher , ( read ? UV_READABLE : 0 ) | ( write ? UV_WRITABLE : 0 ), ares_poll_cb ); } else { // socket\u5173\u95ed\u4e86\uff0c\u5220\u9664\u4efb\u52a1 channel -> task_list () -> erase ( it ); // \u5173\u95ed\u8be5\u4efb\u52a1\u5bf9\u5e94\u89c2\u5bdf\u8005io\uff0c\u7136\u540e\u5220\u9664\u5220\u9664\u8be5\u4efb\u52a1 channel -> env () -> CloseHandle ( & task -> poll_watcher , ares_poll_close_cb ); // \u6ca1\u6709\u4efb\u52a1\u4e86\uff0c\u5173\u95ed\u5b9a\u65f6\u5668 if ( channel -> task_list () -> empty ()) { channel -> CloseTimer (); } } } \u6bcf\u4e00\u4e2aDNS\u67e5\u8be2\u7684\u4efb\u52a1\uff0c\u5728Node.js\u4e2d\u7528node_ares_task \u7ba1\u7406\u3002\u5b83\u5c01\u88c5\u4e86\u8bf7\u6c42\u5bf9\u5e94\u7684channel\u3001\u67e5\u8be2\u8bf7\u6c42\u5bf9\u5e94\u7684socket\u548cuv_poll_t\u3002\u6211\u4eec\u770b\u4e00\u4e0bares_task_create 1 2 3 4 5 6 7 8 9 10 11 12 13 node_ares_task * ares_task_create ( ChannelWrap * channel , ares_socket_t sock ) { auto task = new node_ares_task (); task -> channel = channel ; task -> sock = sock ; // \u521d\u59cb\u5316uv_poll_t\uff0c\u4fdd\u5b58\u6587\u4ef6\u63cf\u8ff0\u7b26sock\u5230uv_poll_t if ( uv_poll_init_socket ( channel -> env () -> event_loop (), & task -> poll_watcher , sock ) < 0 ) { delete task ; return nullptr ; } return task ; } \u9996\u5148\u521b\u5efa\u4e00\u4e2anode_ares_task\u5bf9\u8c61\u3002\u7136\u540e\u521d\u59cb\u5316uv_poll_t\u5e76\u4e14\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5230uv_poll_t\u3002uv_poll_t\u662f\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u56de\u8c03\u3001IO\u89c2\u5bdf\u8005\u7684\u5c01\u88c5\u3002\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u4f1a\u6267\u884cIO\u89c2\u5bdf\u8005\u7684\u56de\u8c03\uff0c\u4ece\u800c\u6267\u884cuv_poll_t\u4fdd\u5b58\u7684\u56de\u8c03\u3002\u6211\u4eec\u7ee7\u7eed\u56de\u5230ares_sockstate_cb\uff0c\u5f53cares\u901a\u77e5Node.js socket\u72b6\u6001\u53d8\u66f4\u7684\u65f6\u5019\uff0cNode.js\u5c31\u4f1a\u4fee\u6539epoll\u8282\u70b9\u7684\u914d\u7f6e\uff08\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff09\u3002\u5f53\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884cares_poll_cb\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8be5\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 void ares_poll_cb ( uv_poll_t * watcher , int status , int events ) { node_ares_task * task = ContainerOf ( & node_ares_task :: poll_watcher , watcher ); ChannelWrap * channel = task -> channel ; // \u6709\u4e8b\u4ef6\u89e6\u53d1\uff0c\u91cd\u7f6e\u8d85\u65f6\u65f6\u95f4 uv_timer_again ( channel -> timer_handle ()); // \u901a\u77e5cares\u5904\u7406\u54cd\u5e94 ares_process_fd ( channel -> cares_channel (), events & UV_READABLE ? task -> sock : ARES_SOCKET_BAD , events & UV_WRITABLE ? task -> sock : ARES_SOCKET_BAD ); } \u5f53socket\u4e0a\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0cNode.js\u8c03ares_process_fd\u5904\u7406\u3002\u771f\u6b63\u7684\u5904\u7406\u51fd\u6570\u662fprocessfds\u3002 1 2 3 4 5 6 7 8 9 10 11 12 static void processfds ( ares_channel channel , fd_set * read_fds , ares_socket_t read_fd , fd_set * write_fds , ares_socket_t write_fd ) { struct timeval now = ares__tvnow (); write_tcp_data ( channel , write_fds , write_fd , & now ); read_tcp_data ( channel , read_fds , read_fd , & now ); read_udp_packets ( channel , read_fds , read_fd , & now ); process_timeouts ( channel , & now ); process_broken_connections ( channel , & now ); } processfds\u662f\u7edf\u4e00\u7684\u5904\u7406\u51fd\u6570\uff0c\u5728\u5404\u81ea\u51fd\u6570\u5185\u4f1a\u505a\u76f8\u5e94\u7684\u5224\u65ad\u548c\u5904\u7406\u3002\u6211\u4eec\u8fd9\u91cc\u662f\u6536\u5230\u4e86UDP\u54cd\u5e94\u3002\u5219\u4f1a\u6267\u884cread_udp_packets 1 2 3 4 5 6 7 static void read_udp_packets ( ares_channel channel , fd_set * read_fds , ares_socket_t read_fd , struct timeval * now ){ // \u8bfb\u53d6\u54cd\u5e94 count = socket_recvfrom ( channel , server -> udp_socket , ( void * ) buf , sizeof ( buf ), 0 , & from . sa , & fromlen ); // \u5904\u7406\u54cd\u5e94\uff0c\u6700\u7ec8\u8c03\u7528query->callback\u56de\u8c03Node.js process_answer ( channel , buf , ( int ) count , i , 0 , now ); } Cares\u8bfb\u53d6\u54cd\u5e94\u7136\u540e\u89e3\u6790\u54cd\u5e94\uff0c\u6700\u540e\u56de\u8c03Node.js\u3002Node.js\u8bbe\u7f6e\u7684\u56de\u8c03\u51fd\u6570\u662fCallback 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 static void Callback ( void * arg , int status , int timeouts , unsigned char * answer_buf , int answer_len ) { QueryWrap * wrap = FromCallbackPointer ( arg ); unsigned char * buf_copy = nullptr ; if ( status == ARES_SUCCESS ) { buf_copy = node :: Malloc < unsigned char > ( answer_len ); memcpy ( buf_copy , answer_buf , answer_len ); } wrap -> response_data_ = std :: make_unique < ResponseData > (); ResponseData * data = wrap -> response_data_ . get (); data -> status = status ; data -> is_host = false ; data -> buf = MallocedBuffer < unsigned char > ( buf_copy , answer_len ); // \u6267\u884cQueueResponseCallback wrap -> QueueResponseCallback ( status ); } void QueueResponseCallback ( int status ) { BaseObjectPtr < QueryWrap > strong_ref { this }; // \u4ea7\u751f\u4e00\u4e2anative immediate\u4efb\u52a1\uff0c\u5728check\u9636\u6bb5\u6267\u884c env () -> SetImmediate ([ this , strong_ref ]( Environment * ) { // check\u9636\u6bb5\u6267\u884c AfterResponse (); // Delete once strong_ref goes out of scope. Detach (); }); channel_ -> set_query_last_ok ( status != ARES_ECONNREFUSED ); channel_ -> ModifyActivityQueryCount ( -1 ); } void AfterResponse () { const int status = response_data_ -> status ; // \u8c03\u7528\u5bf9\u5e94\u7684\u5b50\u7c7b\u7684Parse if ( status != ARES_SUCCESS ) { ParseError ( status ); } else if ( ! response_data_ -> is_host ) { Parse ( response_data_ -> buf . data , response_data_ -> buf . size ); } else { Parse ( response_data_ -> host . get ()); } } \u4efb\u52a1\u5b8c\u6210\u540e\uff0cNode.js\u4f1a\u5728check\u9636\u6bb5\uff08Node.js v10\u662f\u4f7f\u7528async handle\u901a\u77e5Libuv\uff09\u52a0\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u7136\u540echeck\u9636\u6bb5\u7684\u65f6\u5019\u6267\u884c\u5bf9\u5e94\u5b50\u7c7b\u7684Parse\u51fd\u6570\uff0c\u8fd9\u91cc\u4ee5QueryCnameWrap\u7684Parse\u4e3a\u4f8b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void Parse ( unsigned char * buf , int len ) override { HandleScope handle_scope ( env () -> isolate ()); Context :: Scope context_scope ( env () -> context ()); Local < Array > ret = Array :: New ( env () -> isolate ()); int type = ns_t_cname ; int status = ParseGeneralReply ( env (), buf , len , & type , ret ); if ( status != ARES_SUCCESS ) { ParseError ( status ); return ; } this -> CallOnComplete ( ret ); } \u6536\u5230DNS\u56de\u590d\u540e\uff0c\u8c03\u7528ParseGeneralReply\u89e3\u6790\u56de\u5305\uff0c\u7136\u540e\u6267\u884cJS\u5c42DNS\u6a21\u5757\u7684\u56de\u8c03\u3002\u4ece\u800c\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 12 void CallOnComplete ( Local < Value > answer , Local < Value > extra = Local < Value > ()) { HandleScope handle_scope ( env () -> isolate ()); Context :: Scope context_scope ( env () -> context ()); Local < Value > argv [] = { Integer :: New ( env () -> isolate (), 0 ), answer , extra }; const int argc = arraysize ( argv ) - extra . IsEmpty (); MakeCallback ( env () -> oncomplete_string (), argc , argv ); }","title":"08-DNS"},{"location":"chapter08-DNS/#81-ip","text":"\u6211\u4eec\u770b\u4e00\u4e0b\u5728Node.js\u4e2d\u5982\u4f55\u67e5\u8be2\u4e00\u4e2a\u57df\u540d\u5bf9\u4e8e\u7684IP\u7684\u4fe1\u606f 1 2 3 dns . lookup ( 'www.a.com' , function ( err , address , family ) { console . log ( address ); }); DNS\u529f\u80fd\u7684JS\u5c42\u5b9e\u73b0\u5728dns.js\u4e2d 1 2 3 4 5 6 7 8 9 const req = new GetAddrInfoReqWrap (); req . callback = callback ; req . family = family ; req . hostname = hostname ; req . oncomplete = all ? onlookupall : onlookup ; const err = cares . getaddrinfo ( req , toASCII ( hostname ), family , hints , verbatim ); Node.js\u8bbe\u7f6e\u4e86\u4e00\u4e9b\u53c2\u6570\u540e\uff0c\u8c03\u7528cares_wrap.cc\u7684getaddrinfo\u65b9\u6cd5\uff0c\u5728care_wrap.cc\u7684\u521d\u59cb\u5316\u51fd\u6570\u4e2d\u6211\u4eec\u770b\u5230\uff0c getaddrinfo\u51fd\u6570\u5bf9\u5e94\u7684\u51fd\u6570\u662fGetAddrInfo\u3002 1 2 3 4 5 6 7 void Initialize ( Local < Object > target , Local < Value > unused , Local < Context > context ) { Environment * env = Environment :: GetCurrent ( context ); env -> SetMethod ( target , \"getaddrinfo\" , GetAddrInfo ); ... } GetAddrInfo\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 auto req_wrap = new GetAddrInfoReqWrap ( env , req_wrap_obj , args [ 4 ] -> IsTrue ()); struct addrinfo hints ; memset ( & hints , 0 , sizeof ( struct addrinfo )); hints . ai_family = family ; hints . ai_socktype = SOCK_STREAM ; hints . ai_flags = flags ; int err = uv_getaddrinfo ( env -> event_loop (), req_wrap -> req (), AfterGetAddrInfo , * hostname , nullptr , & hints ); GetAddrInfo\u662f\u5bf9uv_getaddrinfo\u7684\u5c01\u88c5\uff0c\u56de\u8c03\u51fd\u6570\u662fAfterGetAddrInfo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 int uv_getaddrinfo ( uv_loop_t * loop , // \u4e0a\u5c42\u4f20\u8fdb\u6765\u7684req uv_getaddrinfo_t * req , // \u89e3\u6790\u5b8c\u540e\u7684\u4e0a\u5c42\u56de\u8c03 uv_getaddrinfo_cb cb , // \u9700\u8981\u89e3\u6790\u7684\u540d\u5b57 const char * hostname , /* \u67e5\u8be2\u7684\u8fc7\u6ee4\u6761\u4ef6\uff1a\u670d\u52a1\u540d\u3002\u6bd4\u5982 http smtp\u3002\u4e5f\u53ef\u4ee5\u662f\u4e00\u4e2a\u7aef\u53e3\u3002 \u89c1\u4e0b\u9762\u6ce8\u91ca */ const char * service , // \u5176\u5b83\u67e5\u8be2\u8fc7\u6ee4\u6761\u4ef6 const struct addrinfo * hints ) { size_t hostname_len ; size_t service_len ; size_t hints_len ; size_t len ; char * buf ; hostname_len = hostname ? strlen ( hostname ) + 1 : 0 ; service_len = service ? strlen ( service ) + 1 : 0 ; hints_len = hints ? sizeof ( * hints ) : 0 ; buf = uv__malloc ( hostname_len + service_len + hints_len ); uv__req_init ( loop , req , UV_GETADDRINFO ); req -> loop = loop ; // \u8bbe\u7f6e\u8bf7\u6c42\u7684\u56de\u8c03 req -> cb = cb ; req -> addrinfo = NULL ; req -> hints = NULL ; req -> service = NULL ; req -> hostname = NULL ; req -> retcode = 0 ; len = 0 ; if ( hints ) { req -> hints = memcpy ( buf + len , hints , sizeof ( * hints )); len += sizeof ( * hints ); } if ( service ) { req -> service = memcpy ( buf + len , service , service_len ); len += service_len ; } if ( hostname ) req -> hostname = memcpy ( buf + len , hostname , hostname_len ); // \u4f20\u4e86cb\u5219\u662f\u5f02\u6b65 if ( cb ) { uv__work_submit ( loop , & req -> work_req , UV__WORK_SLOW_IO , uv__getaddrinfo_work , uv__getaddrinfo_done ); return 0 ; } else { // \u963b\u585e\u5f0f\u67e5\u8be2\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03 uv__getaddrinfo_work ( & req -> work_req ); uv__getaddrinfo_done ( & req -> work_req , 0 ); return req -> retcode ; } } \u6211\u4eec\u770b\u5230\u8fd9\u4e2a\u51fd\u6570\u9996\u5148\u662f\u5bf9\u4e00\u4e2arequest\u8fdb\u884c\u521d\u59cb\u5316\uff0c\u7136\u540e\u6839\u636e\u662f\u5426\u4f20\u4e86\u56de\u8c03\uff0c\u51b3\u5b9a\u8d70\u5f02\u6b65\u8fd8\u662f\u540c\u6b65\u7684\u6a21\u5f0f\u3002\u540c\u6b65\u7684\u65b9\u5f0f\u6bd4\u8f83\u7b80\u5355\uff0c\u5c31\u662f\u76f4\u63a5\u963b\u585eLibuv\u4e8b\u4ef6\u5faa\u73af\uff0c\u76f4\u5230\u89e3\u6790\u5b8c\u6210\u3002\u5982\u679c\u662f\u5f02\u6b65\uff0c\u5219\u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4e00\u4e2a\u6162IO\u7684\u4efb\u52a1\u3002\u5176\u4e2d\u5de5\u4f5c\u51fd\u6570\u662fuv__getaddrinfo_work\u3002\u56de\u8c03\u662fuv__getaddrinfo_done\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e24\u4e2a\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 // \u89e3\u6790\u7684\u5de5\u4f5c\u51fd\u6570 static void uv__getaddrinfo_work ( struct uv__work * w ) { uv_getaddrinfo_t * req ; int err ; // \u6839\u636e\u7ed3\u6784\u4f53\u7684\u5b57\u6bb5\u83b7\u53d6\u7ed3\u6784\u4f53\u9996\u5730\u5740 req = container_of ( w , uv_getaddrinfo_t , work_req ); // \u963b\u585e\u5728\u8fd9 err = getaddrinfo ( req -> hostname , req -> service , req -> hints , & req -> addrinfo ); req -> retcode = uv__getaddrinfo_translate_error ( err ); } uv__getaddrinfo_work\u51fd\u6570\u4e3b\u8981\u662f\u8c03\u7528\u4e86\u7cfb\u7edf\u63d0\u4f9b\u7684getaddrinfo\u53bb\u505a\u89e3\u6790\u3002\u8be5\u51fd\u6570\u4f1a\u5bfc\u81f4\u8fdb\u7a0b\u963b\u585e\u3002\u7ed3\u679c\u8fd4\u56de\u540e\uff0c\u6267\u884cuv__getaddrinfo_done\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 static void uv__getaddrinfo_done ( struct uv__work * w , int status ) { uv_getaddrinfo_t * req ; req = container_of ( w , uv_getaddrinfo_t , work_req ); uv__req_unregister ( req -> loop , req ); // \u91ca\u653e\u521d\u59cb\u5316\u65f6\u7533\u8bf7\u7684\u5185\u5b58 if ( req -> hints ) uv__free ( req -> hints ); else if ( req -> service ) uv__free ( req -> service ); else if ( req -> hostname ) uv__free ( req -> hostname ); else assert ( 0 ); req -> hints = NULL ; req -> service = NULL ; req -> hostname = NULL ; // \u89e3\u6790\u8bf7\u6c42\u88ab\u7528\u6237\u53d6\u6d88\u4e86 if ( status == UV_ECANCELED ) { assert ( req -> retcode == 0 ); req -> retcode = UV_EAI_CANCELED ; } // \u6267\u884c\u4e0a\u5c42\u56de\u8c03 if ( req -> cb ) req -> cb ( req , req -> retcode , req -> addrinfo ); } uv__getaddrinfo_done\u4f1a\u6267\u884cC++\u5c42\u7684\u56de\u8c03\uff0c\u4ece\u800c\u6267\u884cJS\u5c42\u7684\u56de\u8c03\u3002","title":"8.1 \u901a\u8fc7\u57df\u540d\u627eIP"},{"location":"chapter08-DNS/#82-cares","text":"\u9664\u4e86\u901a\u8fc7IP\u67e5\u8be2\u57df\u540d\u548c\u57df\u540d\u67e5\u8be2IP\u5916\uff0c\u5176\u4f59\u7684DNS\u529f\u80fd\u90fd\u7531cares\u5b9e\u73b0\uff0c\u6211\u4eec\u770b\u4e00\u4e0bcares\u7684\u57fa\u672c\u7528\u6cd5\u3002","title":"8.2 cares"},{"location":"chapter08-DNS/#821-cares","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // channel\u662fcares\u7684\u6838\u5fc3\u7ed3\u6784\u4f53 ares_channel channel ; struct ares_options options ; // \u521d\u59cb\u5316channel status = ares_init_options ( & channel , & options , optmask ); // \u628a argv\u7684\u6570\u636e\u5b58\u5230addr ares_inet_pton ( AF_INET , * argv , & addr4 ); // \u628aaddr\u6570\u636e\u5b58\u5230channel\u5e76\u53d1\u8d77DNS\u67e5\u8be2 ares_gethostbyaddr ( channel , & addr4 , sizeof ( addr4 ), AF_INET , callback , * argv ); for (;;) { int res ; FD_ZERO ( & read_fds ); FD_ZERO ( & write_fds ); // \u628achannel\u5bf9\u5e94\u7684fd\u5b58\u5230read_fd\u548cwrite_fds nfds = ares_fds ( channel , & read_fds , & write_fds ); if ( nfds == 0 ) break ; // \u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4 tvp = ares_timeout ( channel , NULL , & tv ); // \u963b\u585e\u5728select\uff0c\u7b49\u5f85DNS\u56de\u5305 res = select ( nfds , & read_fds , & write_fds , NULL , tvp ); if ( -1 == res ) break ; // \u5904\u7406DNS\u76f8\u5e94 ares_process ( channel , & read_fds , & write_fds ); } \u4e0a\u9762\u662f\u4e00\u4e2a\u5178\u578b\u7684\u4e8b\u4ef6\u9a71\u52a8\u6a21\u578b\uff0c\u9996\u5148\u521d\u59cb\u5316\u4e00\u4e9b\u4fe1\u606f\uff0c\u7136\u540e\u53d1\u8d77\u4e00\u4e2a\u975e\u963b\u585e\u7684\u8bf7\u6c42\uff0c\u63a5\u7740\u963b\u585e\u5728\u591a\u8def\u590d\u7528API\uff0c\u8be5API\u8fd4\u56de\u540e\uff0c\u6267\u884c\u89e6\u53d1\u4e86\u4e8b\u4ef6\u7684\u56de\u8c03\u3002","title":"8.2.1 cares\u4f7f\u7528\u548c\u539f\u7406"},{"location":"chapter08-DNS/#822-cares_wrapcc","text":"\u5728Node.js\u4e2d\uff0cNode.js\u548ccares\u7684\u6574\u4f53\u4ea4\u4e92\u5982\u56fe8-1\u6240\u793a\u3002 \u56fe8-1. \u6211\u4eec\u901a\u8fc7cares_wrap.cc\u5206\u6790\u5176\u4e2d\u7684\u539f\u7406\u3002\u6211\u4eec\u4eceDNS\u6a21\u5757\u63d0\u4f9b\u7684resolveCname\u51fd\u6570\u5f00\u59cb\u3002resolveCname\u51fd\u6570\u7531\u4ee5\u4e0b\u4ee3\u7801\u5bfc\u51fa\uff08dns.js\uff09\u3002 1 bindDefaultResolver ( module . exports , getDefaultResolver ()) \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e24\u4e2a\u51fd\u6570\uff08dns/utils.js\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Resolver { constructor () { this . _handle = new ChannelWrap (); } // ... } let defaultResolver = new Resolver (); function getDefaultResolver () { return defaultResolver ; } function resolver ( bindingName ) { function query ( name , /* options, */ callback ) { let options ; const req = new QueryReqWrap (); req . bindingName = bindingName ; req . callback = callback ; req . hostname = name ; req . oncomplete = onresolve ; req . ttl = !! ( options && options . ttl ); const err = this . _handle [ bindingName ]( req , toASCII ( name )); if ( err ) throw dnsException ( err , bindingName , name ); return req ; } ObjectDefineProperty ( query , 'name' , { value : bindingName }); return query ; } // \u7ed9\u539f\u578b\u94fe\u6ce8\u5165\u4e00\u4e2a\u65b0\u7684\u5c5e\u6027\uff0cdefaultResolver\u4e2d\u4e5f\u751f\u6548 Resolver . prototype . resolveCname = resolveMap . CNAME = resolver ( 'queryCname' ); getDefaultResolver\u5bfc\u51fa\u7684\u662f\u4e00\u4e2aResolve\u5bf9\u8c61\uff0c\u91cc\u9762\u6709resolveCname\u7b49\u4e00\u7cfb\u5217\u65b9\u6cd5\u3002\u63a5\u7740\u770b\u4e00\u4e0bbindDefaultResolver\uff0c\u6211\u4eec\u4e00\u4f1a\u518d\u770bChannelWrap\u3002 1 2 3 4 5 6 7 8 9 const resolverKeys = [ 'resolveCname ' , // \u2026 ] function bindDefaultResolver ( target , source ) { resolverKeys . forEach (( key ) => { target [ key ] = source [ key ]. bind ( defaultResolver ); }); } \u770b\u8d77\u6765\u5f88\u7ed5\uff0c\u5176\u5b9e\u5c31\u662f\u628aResolve\u5bf9\u8c61\u7684\u65b9\u6cd5\u5bfc\u51fa\u5230DNS\u6a21\u5757\u3002\u8fd9\u6837\u7528\u6237\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e86\u3002\u6211\u4eec\u770b\u5230resolveCname\u662f\u7531resolver\u51fd\u6570\u751f\u6210\u7684\uff0cresolver\u51fd\u6570\u5bf9cares\u7cfb\u5217\u51fd\u6570\u8fdb\u884c\u4e86\u5c01\u88c5\uff0c\u6700\u7ec8\u8c03\u7528\u7684\u662fthis._handle.queryCname\u51fd\u6570\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u8fd9\u4e2ahandle\uff08ChannelWrap\u7c7b\u5bf9\u8c61\uff09\u7684\u5b9e\u73b0\uff08cares_wrap.cc\uff09\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bcares_wrap.cc\u6a21\u5757\u5bfc\u51fa\u7684API\u3002 1 2 3 4 5 6 7 8 9 10 11 12 Local < FunctionTemplate > channel_wrap = env -> NewFunctionTemplate ( ChannelWrap :: New ); channel_wrap -> InstanceTemplate () -> SetInternalFieldCount ( 1 ); channel_wrap -> Inherit ( AsyncWrap :: GetConstructorTemplate ( env )); // Query\u662fC++\u51fd\u6570\u6a21\u677f env -> SetProtoMethod ( channel_wrap , \"queryCname\" , Query < QueryCnameWrap > ); // ... Local < String > channelWrapString = FIXED_ONE_BYTE_STRING ( env -> isolate (), \"ChannelWrap\" ); channel_wrap -> SetClassName ( channelWrapString ); target -> Set ( env -> context (), channelWrapString , channel_wrap -> GetFunction ( context ). ToLocalChecked ()). Check (); handle\u5bf9\u5e94\u7684\u5c31\u662f\u4ee5\u4e0a\u4ee3\u7801\u5bfc\u51fa\u7684\u5bf9\u8c61\u3002\u5f53\u6211\u4eec\u5728JS\u5c42\u6267\u884cnew ChannelWrap\u7684\u65f6\u5019\u3002 \u6700\u7ec8\u4f1a\u8c03\u7528C++\u5c42\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5e76\u4e14\u6267\u884cChannelWrap::New\u3002 1 2 3 4 void ChannelWrap::New ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); new ChannelWrap ( env , args . This ()); } \u6211\u4eec\u770b\u4e00\u4e0b\u7c7bChannelWrap\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ChannelWrap : public AsyncWrap { public : // ... private : // \u8d85\u65f6\u7ba1\u7406 uv_timer_t * timer_handle_ ; // cares\u6570\u636e\u7c7b\u578b ares_channel channel_ ; // \u6807\u8bb0\u67e5\u8be2\u7ed3\u679c bool query_last_ok_ ; // \u4f7f\u7528\u7684DNS\u670d\u52a1\u5668 bool is_servers_default_ ; // \u662f\u5426\u5df2\u7ecf\u521d\u59cb\u5316cares\u5e93 bool library_inited_ ; // \u6b63\u5728\u53d1\u8d77\u7684\u67e5\u8be2\u4e2a\u6570 int active_query_count_ ; // \u53d1\u8d77\u67e5\u8be2\u7684\u4efb\u52a1\u961f\u5217 node_ares_task_list task_list_ ; }; \u63a5\u7740\u6211\u4eec\u770b\u770bChannelWrap\u6784\u9020\u51fd\u6570\u7684\u4ee3\u7801\u3002 1 2 3 ChannelWrap :: ChannelWrap (...) { Setup (); } ChannelWrap\u91cc\u76f4\u63a5\u8c03\u7528\u4e86Setup 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void ChannelWrap::Setup () { struct ares_options options ; memset ( & options , 0 , sizeof ( options )); options . flags = ARES_FLAG_NOCHECKRESP ; /* caresd socket\u72b6\u6001\uff08\u8bfb\u5199\uff09\u53d1\u751f\u53d8\u66f4\u65f6\uff0c\u6267\u884c\u7684\u51fd\u6570\uff0c \u7b2c\u4e00\u4e2a\u5165\u53c2\u662fsock_state_cb_data */ options . sock_state_cb = ares_sockstate_cb ; options . sock_state_cb_data = this ; // \u8fd8\u6ca1\u521d\u59cb\u5316\u5219\u521d\u59cb\u5316 if ( ! library_inited_ ) { Mutex :: ScopedLock lock ( ares_library_mutex ); // \u521d\u59cb\u5316cares\u5e93 ares_library_init ( ARES_LIB_INIT_ALL ); } // \u8bbe\u7f6e\u4f7f\u7528cares\u7684\u914d\u7f6e ares_init_options ( & channel_ , & options , ARES_OPT_FLAGS | ARES_OPT_SOCK_STATE_CB ); library_inited_ = true ; } \u6211\u4eec\u770b\u5230\uff0cNode.js\u5728\u8fd9\u91cc\u521d\u59cb\u5316cares\u76f8\u5173\u7684\u903b\u8f91\u3002\u5176\u4e2d\u6700\u91cd\u8981\u7684\u5c31\u662f\u8bbe\u7f6e\u4e86cares socket\u72b6\u6001\u53d8\u66f4\u65f6\u6267\u884c\u7684\u56de\u8c03ares_sockstate_cb\uff08\u6bd4\u5982socket\u9700\u8981\u8bfb\u53d6\u6570\u636e\u6216\u8005\u5199\u5165\u6570\u636e\uff09\u3002\u524d\u9762\u7684cares\u4f7f\u7528\u4f8b\u5b50\u4e2d\u8bb2\u5230\u4e86cares\u548c\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u7684\u914d\u5408\u4f7f\u7528\uff0c\u90a3\u4e48cares\u548cLibuv\u662f\u5982\u4f55\u914d\u5408\u7684\u5462\uff1fcares\u63d0\u4f9b\u4e86\u4e00\u79cd\u673a\u5236\uff0c\u5c31\u662fsocket\u72b6\u6001\u53d8\u66f4\u65f6\u901a\u77e5\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u3002DNS\u89e3\u6790\u672c\u8d28\u4e0a\u4e5f\u662f\u7f51\u7edcIO\uff0c\u6240\u4ee5\u53d1\u8d77\u4e00\u4e2aDNS\u67e5\u8be2\u4e5f\u5c31\u662f\u5bf9\u5e94\u4e00\u4e2asocket\u3002DNS\u67e5\u8be2\u662f\u7531cares\u53d1\u8d77\u7684\uff0c\u8fd9\u5c31\u610f\u5473\u7740socket\u662f\u5728cares\u4e2d\u7ef4\u62a4\u7684\uff0c\u90a3Libuv\u600e\u4e48\u77e5\u9053\u5462\uff1f\u6b63\u662fcares\u63d0\u4f9b\u7684\u901a\u77e5\u673a\u5236\uff0c\u4f7f\u5f97Libuv\u77e5\u9053\u53d1\u8d77DNS\u67e5\u8be2\u5bf9\u5e94\u7684socket\uff0c\u4ece\u800c\u6ce8\u518c\u5230Libuv\u4e2d\uff0c\u7b49\u5230\u4e8b\u4ef6\u89e6\u53d1\u540e\uff0c\u518d\u901a\u77e5cares\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u4ece\u53d1\u8d77\u4e00\u4e2acname\u67e5\u8be2\u5f00\u59cb\u5206\u6790\u3002\u9996\u5148\u56de\u987e\u4e00\u4e0bcares_wrap\u6a21\u5757\u5bfc\u51fa\u7684cname\u67e5\u8be2\u51fd\u6570\uff0c env->SetProtoMethod(channel_wrap, \"queryCname\", Query );Query\u662fC++\u6a21\u677f\u51fd\u6570\uff0cQueryCnameWrap\u662fC++\u7c7b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 template < class Wrap > static void Query ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); ChannelWrap * channel ; // Holder\u4e2d\u4fdd\u5b58\u4e86ChannelWrap\u5bf9\u8c61\uff0c\u89e3\u5305\u51fa\u6765 ASSIGN_OR_RETURN_UNWRAP ( & channel , args . Holder ()); Local < Object > req_wrap_obj = args [ 0 ]. As < Object > (); Local < String > string = args [ 1 ]. As < String > (); /* \u6839\u636e\u53c2\u6570\u65b0\u5efa\u4e00\u4e2a\u5bf9\u8c61\uff0c\u8fd9\u91cc\u662fQueryCnameWrap\uff0c \u5e76\u4e14\u4fdd\u5b58\u5bf9\u5e94\u7684ChannelWrap\u5bf9\u8c61\u548c\u64cd\u4f5c\u76f8\u5173\u7684\u5bf9\u8c61 */ Wrap * wrap = new Wrap ( channel , req_wrap_obj ); node :: Utf8Value name ( env -> isolate (), string ); // \u53d1\u8d77\u8bf7\u6c42\u6570\u52a0\u4e00 channel -> ModifyActivityQueryCount ( 1 ); // \u8c03\u7528Send\u51fd\u6570\u53d1\u8d77\u67e5\u8be2 int err = wrap -> Send ( * name ); if ( err ) { channel -> ModifyActivityQueryCount ( -1 ); delete wrap ; } args . GetReturnValue (). Set ( err ); } Query\u53ea\u5b9e\u73b0\u4e86\u4e00\u4e9b\u901a\u7528\u7684\u903b\u8f91\uff0c\u7136\u540e\u8c03\u7528Send\u51fd\u6570\uff0c\u5177\u4f53\u7684Send\u51fd\u6570\u903b\u8f91\u7531\u5404\u4e2a\u5177\u4f53\u7684\u7c7b\u5b9e\u73b0\u3002","title":"8.2.2 cares_wrap.cc\u7684\u901a\u7528\u903b\u8f91"},{"location":"chapter08-DNS/#823","text":"\u6211\u4eec\u770b\u4e00\u4e0bQueryCnameWrap\u7c7b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class QueryCnameWrap : public QueryWrap { public : QueryCnameWrap ( ChannelWrap * channel , Local < Object > req_wrap_obj ) : QueryWrap ( channel , req_wrap_obj , \"resolveCname\" ) { } int Send ( const char * name ) override { AresQuery ( name , ns_c_in , ns_t_cname ); return 0 ; } protected : void Parse ( unsigned char * buf , int len ) override { HandleScope handle_scope ( env () -> isolate ()); Context :: Scope context_scope ( env () -> context ()); Local < Array > ret = Array :: New ( env () -> isolate ()); int type = ns_t_cname ; int status = ParseGeneralReply ( env (), buf , len , & type , ret ); if ( status != ARES_SUCCESS ) { ParseError ( status ); return ; } this -> CallOnComplete ( ret ); } }; \u6211\u4eec\u770b\u5230QueryCnameWrap\u7c7b\u7684\u5b9e\u73b0\u975e\u5e38\u7b80\u5355\uff0c\u4e3b\u8981\u5b9a\u4e49Send\u548cParse\u7684\u5b9e\u73b0\uff0c\u6700\u7ec8\u8fd8\u662f\u4f1a\u8c03\u7528\u57fa\u7c7b\u5bf9\u5e94\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u57fa\u7c7bQueryWrap\u4e2dAresQuery\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 void AresQuery ( const char * name , int dnsclass , int type ) { ares_query ( channel_ -> cares_channel (), name , dnsclass , type , Callback , static_cast < void *> ( this )); } AresQuery\u51fd\u6570\u63d0\u4f9b\u7edf\u4e00\u53d1\u9001\u67e5\u8be2\u64cd\u4f5c\u3002\u67e5\u8be2\u5b8c\u6210\u540e\u6267\u884cCallback\u56de\u8c03\u3002\u63a5\u4e0b\u6765\u5c31\u6d89\u53ca\u5230cares\u548cNode.js\u7684\u5177\u4f53\u4ea4\u4e92\u4e86\u3002Node.js\u628a\u4e00\u4e2a\u4efb\u52a1\u4ea4\u7ed9cares\u540e\uff0ccares\u4f1a\u65b0\u5efa\u4e00\u4e2asocket\uff0c\u63a5\u7740cares\u4f1a\u901a\u8fc7Node.js\u8bbe\u7f6e\u7684\u56de\u8c03ares_sockstate_cb\u901a\u77e5Node.js\u3002\u6211\u4eec\u770b\u4e00\u4e0bares_query\u7684\u5173\u952e\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 void ares_query ( ares_channel channel , const char * name , int dnsclass , int type , ares_callback callback , void * arg ) { struct qquery * qquery ; unsigned char * qbuf ; int qlen , rd , status ; qquery = ares_malloc ( sizeof ( struct qquery )); // \u4fdd\u5b58Node.js\u7684\u56de\u8c03\uff0c\u67e5\u8be2\u5b8c\u6210\u65f6\u56de\u8c03 qquery -> callback = callback ; qquery -> arg = arg ; ares_send ( channel , qbuf , qlen , qcallback , qquery ); } static void qcallback ( void * arg , int status , int timeouts , unsigned char * abuf , int alen ) { struct qquery * qquery = ( struct qquery * ) arg ; unsigned int ancount ; int rcode ; if ( status != ARES_SUCCESS ) qquery -> callback ( qquery -> arg , status , timeouts , abuf , alen ); else { // ... // \u6267\u884cNode.js\u56de\u8c03 qquery -> callback ( qquery -> arg , status , timeouts , abuf , alen ); } ares_free ( qquery ); } ares_query\u4fdd\u5b58\u4e86Node.js\u7684\u56de\u8c03\uff0c\u5e76\u4e14\u8bbe\u7f6e\u56de\u8c03qcallback\uff0c\u67e5\u8be2\u6210\u529f\u540e\u4f1a\u56de\u8c03qcallback\uff0cqcallback\u518d\u56de\u8c03Node.js\u3002\u63a5\u7740\u6267\u884cares_send\uff0cares_send\u4f1a\u8c03\u7528ares__send_query\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void ares__send_query ( ares_channel channel , struct query * query , struct timeval * now ) { struct server_state * server = & channel -> servers [ query -> server ]; if ( server -> udp_socket == ARES_SOCKET_BAD ) { // \u7533\u8bf7\u4e00\u4e2asocket if ( open_udp_socket ( channel , server ) == -1 ) { skip_server ( channel , query , query -> server ); next_server ( channel , query , now ); return ; } } // \u53d1\u9001DNS\u67e5\u8be2 if ( socket_write ( channel , server -> udp_socket , query -> qbuf , query -> qlen ) == -1 ) { skip_server ( channel , query , query -> server ); next_server ( channel , query , now ); return ; } } ares__send_query\u9996\u5148\u7533\u8bf7\u4e00\u4e2asocket\uff0c\u7136\u540e\u53d1\u9001\u6570\u636e\u3002\u56e0\u4e3aUDP\u4e0d\u662f\u9762\u5411\u8fde\u63a5\u7684\uff0c\u53ef\u4ee5\u76f4\u63a5\u53d1\u9001\u3002\u6211\u4eec\u770b\u4e00\u4e0bopen_udp_socket\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 static int open_udp_socket ( ares_channel channel , struct server_state * server ) { ares_socket_t s ; ares_socklen_t salen ; union { struct sockaddr_in sa4 ; struct sockaddr_in6 sa6 ; } saddr ; struct sockaddr * sa ; // \u7533\u8bf7\u4e00\u4e2asocket s = open_socket ( channel , server -> addr . family , SOCK_DGRAM , 0 ); // \u7ed1\u5b9a\u670d\u52a1\u5668\u5730\u5740 connect_socket ( channel , s , sa , salen ) // \u901a\u77e5Node.js\uff0c1,0\u8868\u793a\u5bf9socket\u7684\u8bfb\u4e8b\u4ef6\u611f\u5174\u8da3\uff0c\u56e0\u4e3a\u53d1\u9001\u4e86\u8bf7\u6c42\uff0c\u7b49\u5f85\u54cd\u5e94 SOCK_STATE_CALLBACK ( channel , s , 1 , 0 ); // \u4fdd\u5b58socket server -> udp_socket = s ; return 0 ; } #define SOCK_STATE_CALLBACK(c, s, r, w) \\ do { \\ if (( c ) -> sock_state_cb ) \\ ( c ) -> sock_state_cb (( c ) -> sock_state_cb_data , ( s ), ( r ), ( w )); \\ } WHILE_FALSE ares__send_query\u51fd\u6570\u505a\u4e86\u4e09\u4ef6\u4e8b 1 \u7533\u8bf7\u4e86socket\uff0c 2 \u901a\u77e5Node.js 3 \u53d1\u9001\u4e86DNS\u67e5\u8be2\u8bf7\u6c42 \u8fd9\u65f6\u5019\u6d41\u7a0b\u8d70\u5230\u4e86Node.js\uff0c\u6211\u4eec\u770b\u4e00\u4e0bcares\u56de\u8c03Node.js\u7684\u65f6\u5019\uff0cNode.js\u600e\u4e48\u5904\u7406\u7684 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 struct node_ares_task : public MemoryRetainer { ChannelWrap * channel ; // \u5173\u8054\u7684socket ares_socket_t sock ; // IO\u89c2\u5bdf\u8005\u548c\u56de\u8c03 uv_poll_t poll_watcher ; }; void ares_sockstate_cb ( void * data , ares_socket_t sock , int read , int write ) { ChannelWrap * channel = static_cast < ChannelWrap *> ( data ); node_ares_task * task ; // \u4efb\u52a1 node_ares_task lookup_task ; lookup_task . sock = sock ; // \u8be5\u4efb\u52a1\u662f\u5426\u5df2\u7ecf\u5b58\u5728 auto it = channel -> task_list () -> find ( & lookup_task ); task = ( it == channel -> task_list () -> end ()) ? nullptr : * it ; if ( read || write ) { if ( ! task ) { // \u5f00\u542f\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u540e\u901a\u77e5cares channel -> StartTimer (); // \u521b\u5efa\u4e00\u4e2a\u4efb\u52a1 task = ares_task_create ( channel , sock ); // \u4fdd\u5b58\u5230\u4efb\u52a1\u5217\u8868 channel -> task_list () -> insert ( task ); } // \u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230epoll\uff0c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u6839\u636ecares\u4f20\u7684\u8fdb\u884c\u8bbe\u7f6e\uff0c\u6709\u4e8b\u4ef6\u89e6\u53d1\u540e\u6267\u884c\u56de\u8c03ares_poll_cb uv_poll_start ( & task -> poll_watcher , ( read ? UV_READABLE : 0 ) | ( write ? UV_WRITABLE : 0 ), ares_poll_cb ); } else { // socket\u5173\u95ed\u4e86\uff0c\u5220\u9664\u4efb\u52a1 channel -> task_list () -> erase ( it ); // \u5173\u95ed\u8be5\u4efb\u52a1\u5bf9\u5e94\u89c2\u5bdf\u8005io\uff0c\u7136\u540e\u5220\u9664\u5220\u9664\u8be5\u4efb\u52a1 channel -> env () -> CloseHandle ( & task -> poll_watcher , ares_poll_close_cb ); // \u6ca1\u6709\u4efb\u52a1\u4e86\uff0c\u5173\u95ed\u5b9a\u65f6\u5668 if ( channel -> task_list () -> empty ()) { channel -> CloseTimer (); } } } \u6bcf\u4e00\u4e2aDNS\u67e5\u8be2\u7684\u4efb\u52a1\uff0c\u5728Node.js\u4e2d\u7528node_ares_task \u7ba1\u7406\u3002\u5b83\u5c01\u88c5\u4e86\u8bf7\u6c42\u5bf9\u5e94\u7684channel\u3001\u67e5\u8be2\u8bf7\u6c42\u5bf9\u5e94\u7684socket\u548cuv_poll_t\u3002\u6211\u4eec\u770b\u4e00\u4e0bares_task_create 1 2 3 4 5 6 7 8 9 10 11 12 13 node_ares_task * ares_task_create ( ChannelWrap * channel , ares_socket_t sock ) { auto task = new node_ares_task (); task -> channel = channel ; task -> sock = sock ; // \u521d\u59cb\u5316uv_poll_t\uff0c\u4fdd\u5b58\u6587\u4ef6\u63cf\u8ff0\u7b26sock\u5230uv_poll_t if ( uv_poll_init_socket ( channel -> env () -> event_loop (), & task -> poll_watcher , sock ) < 0 ) { delete task ; return nullptr ; } return task ; } \u9996\u5148\u521b\u5efa\u4e00\u4e2anode_ares_task\u5bf9\u8c61\u3002\u7136\u540e\u521d\u59cb\u5316uv_poll_t\u5e76\u4e14\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5230uv_poll_t\u3002uv_poll_t\u662f\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u56de\u8c03\u3001IO\u89c2\u5bdf\u8005\u7684\u5c01\u88c5\u3002\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u4f1a\u6267\u884cIO\u89c2\u5bdf\u8005\u7684\u56de\u8c03\uff0c\u4ece\u800c\u6267\u884cuv_poll_t\u4fdd\u5b58\u7684\u56de\u8c03\u3002\u6211\u4eec\u7ee7\u7eed\u56de\u5230ares_sockstate_cb\uff0c\u5f53cares\u901a\u77e5Node.js socket\u72b6\u6001\u53d8\u66f4\u7684\u65f6\u5019\uff0cNode.js\u5c31\u4f1a\u4fee\u6539epoll\u8282\u70b9\u7684\u914d\u7f6e\uff08\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\uff09\u3002\u5f53\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884cares_poll_cb\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8be5\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 void ares_poll_cb ( uv_poll_t * watcher , int status , int events ) { node_ares_task * task = ContainerOf ( & node_ares_task :: poll_watcher , watcher ); ChannelWrap * channel = task -> channel ; // \u6709\u4e8b\u4ef6\u89e6\u53d1\uff0c\u91cd\u7f6e\u8d85\u65f6\u65f6\u95f4 uv_timer_again ( channel -> timer_handle ()); // \u901a\u77e5cares\u5904\u7406\u54cd\u5e94 ares_process_fd ( channel -> cares_channel (), events & UV_READABLE ? task -> sock : ARES_SOCKET_BAD , events & UV_WRITABLE ? task -> sock : ARES_SOCKET_BAD ); } \u5f53socket\u4e0a\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0cNode.js\u8c03ares_process_fd\u5904\u7406\u3002\u771f\u6b63\u7684\u5904\u7406\u51fd\u6570\u662fprocessfds\u3002 1 2 3 4 5 6 7 8 9 10 11 12 static void processfds ( ares_channel channel , fd_set * read_fds , ares_socket_t read_fd , fd_set * write_fds , ares_socket_t write_fd ) { struct timeval now = ares__tvnow (); write_tcp_data ( channel , write_fds , write_fd , & now ); read_tcp_data ( channel , read_fds , read_fd , & now ); read_udp_packets ( channel , read_fds , read_fd , & now ); process_timeouts ( channel , & now ); process_broken_connections ( channel , & now ); } processfds\u662f\u7edf\u4e00\u7684\u5904\u7406\u51fd\u6570\uff0c\u5728\u5404\u81ea\u51fd\u6570\u5185\u4f1a\u505a\u76f8\u5e94\u7684\u5224\u65ad\u548c\u5904\u7406\u3002\u6211\u4eec\u8fd9\u91cc\u662f\u6536\u5230\u4e86UDP\u54cd\u5e94\u3002\u5219\u4f1a\u6267\u884cread_udp_packets 1 2 3 4 5 6 7 static void read_udp_packets ( ares_channel channel , fd_set * read_fds , ares_socket_t read_fd , struct timeval * now ){ // \u8bfb\u53d6\u54cd\u5e94 count = socket_recvfrom ( channel , server -> udp_socket , ( void * ) buf , sizeof ( buf ), 0 , & from . sa , & fromlen ); // \u5904\u7406\u54cd\u5e94\uff0c\u6700\u7ec8\u8c03\u7528query->callback\u56de\u8c03Node.js process_answer ( channel , buf , ( int ) count , i , 0 , now ); } Cares\u8bfb\u53d6\u54cd\u5e94\u7136\u540e\u89e3\u6790\u54cd\u5e94\uff0c\u6700\u540e\u56de\u8c03Node.js\u3002Node.js\u8bbe\u7f6e\u7684\u56de\u8c03\u51fd\u6570\u662fCallback 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 static void Callback ( void * arg , int status , int timeouts , unsigned char * answer_buf , int answer_len ) { QueryWrap * wrap = FromCallbackPointer ( arg ); unsigned char * buf_copy = nullptr ; if ( status == ARES_SUCCESS ) { buf_copy = node :: Malloc < unsigned char > ( answer_len ); memcpy ( buf_copy , answer_buf , answer_len ); } wrap -> response_data_ = std :: make_unique < ResponseData > (); ResponseData * data = wrap -> response_data_ . get (); data -> status = status ; data -> is_host = false ; data -> buf = MallocedBuffer < unsigned char > ( buf_copy , answer_len ); // \u6267\u884cQueueResponseCallback wrap -> QueueResponseCallback ( status ); } void QueueResponseCallback ( int status ) { BaseObjectPtr < QueryWrap > strong_ref { this }; // \u4ea7\u751f\u4e00\u4e2anative immediate\u4efb\u52a1\uff0c\u5728check\u9636\u6bb5\u6267\u884c env () -> SetImmediate ([ this , strong_ref ]( Environment * ) { // check\u9636\u6bb5\u6267\u884c AfterResponse (); // Delete once strong_ref goes out of scope. Detach (); }); channel_ -> set_query_last_ok ( status != ARES_ECONNREFUSED ); channel_ -> ModifyActivityQueryCount ( -1 ); } void AfterResponse () { const int status = response_data_ -> status ; // \u8c03\u7528\u5bf9\u5e94\u7684\u5b50\u7c7b\u7684Parse if ( status != ARES_SUCCESS ) { ParseError ( status ); } else if ( ! response_data_ -> is_host ) { Parse ( response_data_ -> buf . data , response_data_ -> buf . size ); } else { Parse ( response_data_ -> host . get ()); } } \u4efb\u52a1\u5b8c\u6210\u540e\uff0cNode.js\u4f1a\u5728check\u9636\u6bb5\uff08Node.js v10\u662f\u4f7f\u7528async handle\u901a\u77e5Libuv\uff09\u52a0\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u7136\u540echeck\u9636\u6bb5\u7684\u65f6\u5019\u6267\u884c\u5bf9\u5e94\u5b50\u7c7b\u7684Parse\u51fd\u6570\uff0c\u8fd9\u91cc\u4ee5QueryCnameWrap\u7684Parse\u4e3a\u4f8b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void Parse ( unsigned char * buf , int len ) override { HandleScope handle_scope ( env () -> isolate ()); Context :: Scope context_scope ( env () -> context ()); Local < Array > ret = Array :: New ( env () -> isolate ()); int type = ns_t_cname ; int status = ParseGeneralReply ( env (), buf , len , & type , ret ); if ( status != ARES_SUCCESS ) { ParseError ( status ); return ; } this -> CallOnComplete ( ret ); } \u6536\u5230DNS\u56de\u590d\u540e\uff0c\u8c03\u7528ParseGeneralReply\u89e3\u6790\u56de\u5305\uff0c\u7136\u540e\u6267\u884cJS\u5c42DNS\u6a21\u5757\u7684\u56de\u8c03\u3002\u4ece\u800c\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 12 void CallOnComplete ( Local < Value > answer , Local < Value > extra = Local < Value > ()) { HandleScope handle_scope ( env () -> isolate ()); Context :: Scope context_scope ( env () -> context ()); Local < Value > argv [] = { Integer :: New ( env () -> isolate (), 0 ), answer , extra }; const int argc = arraysize ( argv ) - extra . IsEmpty (); MakeCallback ( env () -> oncomplete_string (), argc , argv ); }","title":"8.2.3 \u5177\u4f53\u5b9e\u73b0"},{"location":"chapter09-Unix%E5%9F%9F/","text":"Unix\u57df\u4e00\u79cd\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u65b9\u5f0f\uff0cUnix\u57df\u4e0d\u4ec5\u652f\u6301\u6ca1\u6709\u7ee7\u627f\u5173\u7cfb\u7684\u8fdb\u7a0b\u95f4\u8fdb\u884c\u901a\u4fe1\uff0c\u800c\u4e14\u652f\u6301\u8fdb\u7a0b\u95f4\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002Unix\u57df\u662fNode.js\u4e2d\u6838\u5fc3\u7684\u529f\u80fd\uff0c\u5b83\u662f\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u5e95\u5c42\u57fa\u7840\uff0cchild_process\u548ccluster\u6a21\u5757\u90fd\u4f9d\u8d56Unix\u57df\u7684\u80fd\u529b\u3002\u4ece\u5b9e\u73b0\u548c\u4f7f\u7528\u4e0a\u6765\u770b\uff0cUnix\u57df\u7c7b\u4f3cTCP\uff0c\u4f46\u662f\u56e0\u4e3a\u5b83\u662f\u57fa\u4e8e\u540c\u4e3b\u673a\u8fdb\u7a0b\u7684\uff0c\u4e0d\u50cfTCP\u9700\u8981\u9762\u4e34\u590d\u6742\u7684\u7f51\u7edc\u7684\u95ee\u9898\uff0c\u6240\u4ee5\u5b9e\u73b0\u4e5f\u6ca1\u6709TCP\u90a3\u4e48\u590d\u6742\u3002Unix\u57df\u548c\u4f20\u7edf\u7684socket\u901a\u4fe1\u4e00\u6837\uff0c\u9075\u5faa\u7f51\u7edc\u7f16\u7a0b\u7684\u90a3\u4e00\u5957\u6d41\u7a0b\uff0c\u7531\u4e8e\u5728\u540c\u4e3b\u673a\u5185\uff0c\u5c31\u4e0d\u5fc5\u8981\u4f7f\u7528IP\u548c\u7aef\u53e3\u7684\u65b9\u5f0f\u3002Node.js\u4e2d\uff0cUnix\u57df\u91c7\u7528\u7684\u662f\u4e00\u4e2a\u6587\u4ef6\u4f5c\u4e3a\u6807\u8bb0\u3002\u5927\u81f4\u539f\u7406\u5982\u4e0b\u3002 1 \u670d\u52a1\u5668\u9996\u5148\u62ff\u5230\u4e00\u4e2asocket\u3002 2 \u670d\u52a1\u5668bind\u4e00\u4e2a\u6587\u4ef6\uff0c\u7c7b\u4f3cbind\u4e00\u4e2aIP\u548c\u7aef\u53e3\u4e00\u6837\uff0c\u5bf9\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u6765\u8bf4\uff0c\u5c31\u662f\u65b0\u5efa\u4e00\u4e2a\u6587\u4ef6\uff08\u4e0d\u4e00\u5b9a\u662f\u5728\u786c\u76d8\u4e2d\u521b\u5efa\uff0c\u53ef\u4ee5\u8bbe\u7f6e\u62bd\u8c61\u8def\u5f84\u540d\uff09\uff0c\u7136\u540e\u628a\u6587\u4ef6\u8def\u5f84\u4fe1\u606f\u5b58\u5728socket\u4e2d\u3002 3 \u8c03\u7528listen\u4fee\u6539socket\u72b6\u6001\u4e3a\u76d1\u542c\u72b6\u6001\u3002 4 \u5ba2\u6237\u7aef\u901a\u8fc7\u540c\u6837\u7684\u6587\u4ef6\u8def\u5f84\u8c03\u7528connect\u53bb\u8fde\u63a5\u670d\u52a1\u5668\u3002\u8fd9\u65f6\u5019\u7528\u4e8e\u8868\u793a\u5ba2\u6237\u7aef\u7684\u7ed3\u6784\u4f53\u63d2\u5165\u670d\u52a1\u5668\u7684\u8fde\u63a5\u961f\u5217\uff0c\u7b49\u5f85\u5904\u7406\u3002 5 \u670d\u52a1\u5668\u8c03\u7528accept\u6458\u53d6\u961f\u5217\u7684\u8282\u70b9\uff0c\u7136\u540e\u65b0\u5efa\u4e00\u4e2a\u901a\u4fe1socket\u548c\u5ba2\u6237\u7aef\u8fdb\u884c\u901a\u4fe1\u3002 Unix\u57df\u901a\u4fe1\u672c\u8d28\u8fd8\u662f\u57fa\u4e8e\u5185\u5b58\u4e4b\u95f4\u7684\u901a\u4fe1\uff0c\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u90fd\u7ef4\u62a4\u4e00\u5757\u5185\u5b58\uff0c\u8fd9\u5757\u5185\u5b58\u5206\u4e3a\u8bfb\u7f13\u51b2\u533a\u548c\u5199\u7f13\u51b2\u533a\u3002\u4ece\u800c\u5b9e\u73b0\u5168\u53cc\u5de5\u901a\u4fe1\uff0c\u800cUnix\u57df\u7684\u6587\u4ef6\u8def\u5f84\uff0c\u53ea\u4e0d\u8fc7\u662f\u4e3a\u4e86\u8ba9\u5ba2\u6237\u7aef\u8fdb\u7a0b\u53ef\u4ee5\u627e\u5230\u670d\u52a1\u7aef\u8fdb\u7a0b\uff0c\u540e\u7eed\u5c31\u53ef\u4ee5\u4e92\u76f8\u5f80\u5bf9\u65b9\u7ef4\u62a4\u7684\u5185\u5b58\u91cc\u5199\u6570\u636e\uff0c\u4ece\u800c\u5b9e\u73b0\u8fdb\u7a0b\u95f4\u901a\u4fe1\u3002 9.1 Unix\u57df\u5728Libuv\u4e2d\u7684\u4f7f\u7528 \u00b6 \u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0b\u5728Libuv\u4e2d\u5173\u4e8eUnix\u57df\u7684\u5b9e\u73b0\u548c\u4f7f\u7528\u3002 9.1.1 \u521d\u59cb\u5316 \u00b6 Unix\u57df\u4f7f\u7528uv_pipe_t\u7ed3\u6784\u4f53\u8868\u793a\uff0c\u4f7f\u7528\u4e4b\u524d\u9996\u5148\u9700\u8981\u521d\u59cb\u5316uv_pipe_t\u3002\u4e0b\u9762\u770b\u4e00\u4e0b\u5b83\u7684\u5b9e\u73b0\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 int uv_pipe_init ( uv_loop_t * loop , uv_pipe_t * handle , int ipc ) { uv__stream_init ( loop , ( uv_stream_t * ) handle , UV_NAMED_PIPE ); handle -> shutdown_req = NULL ; handle -> connect_req = NULL ; handle -> pipe_fname = NULL ; handle -> ipc = ipc ; return 0 ; } uv_pipe_init\u903b\u8f91\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u521d\u59cb\u5316uv_pipe_t\u7ed3\u6784\u4f53\u7684\u4e00\u4e9b\u5b57\u6bb5\u3002uv_pipe_t\u7ee7\u627f\u4e8estream\uff0cuv__stream_init\u5c31\u662f\u521d\u59cb\u5316stream\uff08\u7236\u7c7b\uff09\u7684\u5b57\u6bb5\u3002uv_pipe_t\u4e2d\u6709\u4e00\u4e2a\u5b57\u6bb5ipc\uff0c\u8be5\u5b57\u6bb5\u6807\u8bb0\u4e86\u662f\u5426\u5141\u8bb8\u5728\u8be5Unix\u57df\u901a\u4fe1\u4e2d\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 9.1.2 \u7ed1\u5b9aUnix\u57df\u8def\u5f84 \u00b6 \u5f00\u5934\u8bf4\u8fc7\uff0cUnix\u57df\u7684\u5b9e\u73b0\u7c7b\u4f3cTCP\u7684\u5b9e\u73b0\u3002\u9075\u5faa\u7f51\u7edcsocket\u7f16\u7a0b\u90a3\u4e00\u5957\u6d41\u7a0b\u3002\u670d\u52a1\u7aef\u4f7f\u7528bind\uff0clisten\u7b49\u51fd\u6570\u542f\u52a8\u670d\u52a1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // name\u662funix\u8def\u5f84\u540d\u79f0 int uv_pipe_bind ( uv_pipe_t * handle , const char * name ) { struct sockaddr_un saddr ; const char * pipe_fname ; int sockfd ; int err ; pipe_fname = NULL ; pipe_fname = uv__strdup ( name ); name = NULL ; // \u6d41\u5f0fUnix\u57df\u5957\u63a5\u5b57 sockfd = uv__socket ( AF_UNIX , SOCK_STREAM , 0 ); memset ( & saddr , 0 , sizeof saddr ); strncpy ( saddr . sun_path , pipe_fname , sizeof ( saddr . sun_path ) - 1 ); saddr . sun_path [ sizeof ( saddr . sun_path ) - 1 ] = '\\0' ; saddr . sun_family = AF_UNIX ; // \u7ed1\u5b9a\u5230\u8def\u5f84\uff0cTCP\u662f\u7ed1\u5b9a\u5230IP\u548c\u7aef\u53e3 if ( bind ( sockfd , ( struct sockaddr * ) & saddr , sizeof saddr )) { // ... } // \u8bbe\u7f6e\u7ed1\u5b9a\u6210\u529f\u6807\u8bb0 handle -> flags |= UV_HANDLE_BOUND ; // Unix\u57df\u7684\u8def\u5f84 handle -> pipe_fname = pipe_fname ; // \u4fdd\u5b58socket\u5bf9\u5e94\u7684fd handle -> io_watcher . fd = sockfd ; return 0 ; } uv_pipe_bind\u51fd\u6570\u9996\u5148\u7533\u8bf7\u4e00\u4e2asocket\uff0c\u7136\u540e\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684bind\u51fd\u6570\u628aUnix\u57df\u8def\u5f84\u4fdd\u5b58\u5230socket\u4e2d\u3002\u6700\u540e\u6807\u8bb0\u5df2\u7ecf\u7ed1\u5b9a\u6807\u8bb0\uff0c\u5e76\u4e14\u4fdd\u5b58Unix\u57df\u7684\u8def\u5f84\u548csocket\u5bf9\u5e94\u7684fd\u5230handle\u4e2d\uff0c\u540e\u7eed\u9700\u8981\u4f7f\u7528\u3002\u6211\u4eec\u770b\u5230Node.js\u4e2dUnix\u57df\u7684\u7c7b\u578b\u662fSOCK_STREAM\u3002Unix\u57df\u652f\u6301\u4e24\u79cd\u6570\u636e\u6a21\u5f0f\u3002 1 \u6d41\u5f0f\uff08 SOCK_STREAM\uff09\uff0c\u7c7b\u4f3cTCP\uff0c\u6570\u636e\u4e3a\u5b57\u8282\u6d41\uff0c\u9700\u8981\u5e94\u7528\u5c42\u5904\u7406\u7c98\u5305\u95ee\u9898\u3002 2 \u6570\u636e\u62a5\u6a21\u5f0f\uff08 SOCK_DGRAM \uff09\uff0c\u7c7b\u4f3cUDP\uff0c\u4e0d\u9700\u8981\u5904\u7406\u7c98\u5305\u95ee\u9898\u3002 \u901a\u8fc7Unix\u57df\u867d\u7136\u53ef\u4ee5\u5b9e\u73b0\u8fdb\u7a0b\u95f4\u7684\u901a\u4fe1\uff0c\u4f46\u662f\u6211\u4eec\u62ff\u5230\u7684\u6570\u636e\u53ef\u80fd\u662f\"\u4e71\u7684\"\uff0c\u8fd9\u662f\u4e3a\u4ec0\u4e48\u5462\uff1f\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u5ba2\u6237\u7aef\u7ed9\u670d\u52a1\u5668\u53d1\u90011\u4e2a\u5b57\u8282\uff0c\u7136\u540e\u670d\u52a1\u5668\u5904\u7406\uff0c\u5982\u679c\u662f\u57fa\u4e8e\u8fd9\u79cd\u573a\u666f\uff0c\u90a3\u4e48\u6570\u636e\u5c31\u4e0d\u4f1a\u662f\u4e71\u7684\u3002\u56e0\u4e3a\u6bcf\u6b21\u5c31\u662f\u4e00\u4e2a\u9700\u8981\u5904\u7406\u7684\u6570\u636e\u5355\u4f4d\u3002\u4f46\u662f\u5982\u679c\u5ba2\u6237\u7aef\u7ed9\u670d\u52a1\u5668\u53d1\u90011\u4e2a\u5b57\u8282\uff0c\u670d\u52a1\u5668\u8fd8\u6ca1\u6765\u5f97\u53ca\u5904\u7406\uff0c\u5ba2\u6237\u7aef\u53c8\u53d1\u9001\u4e86\u4e00\u4e2a\u5b57\u8282\uff0c\u90a3\u4e48\u8fd9\u65f6\u5019\u670d\u52a1\u5668\u518d\u5904\u7406\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6709\u95ee\u9898\u3002\u56e0\u4e3a\u4e24\u4e2a\u5b57\u8282\u6df7\u4e00\u8d77\u4e86\u3002\u5c31\u597d\u6bd4\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u5148\u540e\u53d1\u9001\u4e24\u4e2aHTTP\u8bf7\u6c42\u4e00\u6837\uff0c\u5982\u679c\u670d\u52a1\u5668\u6ca1\u6709\u529e\u6cd5\u5224\u65ad\u4e24\u4e2a\u8bf7\u6c42\u7684\u6570\u636e\u8fb9\u754c\uff0c\u90a3\u4e48\u5904\u7406\u5c31\u4f1a\u6709\u95ee\u9898\u3002\u6240\u4ee5\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u5b9a\u4e49\u4e00\u4e2a\u5e94\u7528\u5c42\u534f\u8bae\uff0c\u5e76\u4e14\u5b9e\u73b0\u5c01\u5305\u89e3\u5305\u7684\u903b\u8f91\uff0c\u624d\u80fd\u771f\u6b63\u5b8c\u6210\u8fdb\u7a0b\u95f4\u901a\u4fe1\u3002 9.1.3 \u542f\u52a8\u670d\u52a1 \u00b6 \u7ed1\u5b9a\u4e86\u8def\u5f84\u540e\uff0c\u5c31\u53ef\u4ee5\u8c03\u7528listen\u51fd\u6570\u4f7f\u5f97socket\u5904\u4e8e\u76d1\u542c\u72b6\u6001\u3002 1 2 3 4 5 6 7 8 9 10 11 12 int uv_pipe_listen ( uv_pipe_t * handle , int backlog , uv_connection_cb cb ) { // uv__stream_fd(handle)\u5f97\u5230bind\u51fd\u6570\u4e2d\u83b7\u53d6\u7684socket if ( listen ( uv__stream_fd ( handle ), backlog )) return UV__ERR ( errno ); // \u4fdd\u5b58\u56de\u8c03\uff0c\u6709\u8fdb\u7a0b\u8c03\u7528connect\u7684\u65f6\u5019\u65f6\u89e6\u53d1\uff0c\u7531uv__server_io\u51fd\u6570\u89e6\u53d1 handle -> connection_cb = cb ; // IO\u89c2\u5bdf\u8005\u7684\u56de\u8c03 handle -> io_watcher . cb = uv__server_io ; // \u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230Libuv\uff0c\u7b49\u5f85\u8fde\u63a5\uff0c\u5373\u8bfb\u4e8b\u4ef6\u5230\u6765 uv__io_start ( handle -> loop , & handle -> io_watcher , POLLIN ); return 0 ; } uv_pipe_listen\u6267\u884c\u64cd\u4f5c\u7cfb\u7edf\u7684listen\u51fd\u6570\u4f7f\u5f97socket\u6210\u4e3a\u76d1\u542c\u578b\u7684\u5957\u63a5\u5b57\u3002\u7136\u540e\u628asocket\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u56de\u8c03\u5c01\u88c5\u6210IO\u89c2\u5bdf\u8005\u3002\u6ce8\u518c\u5230Libuv\u4e2d\u3002\u7b49\u5230\u6709\u8bfb\u4e8b\u4ef6\u5230\u6765\uff08\u6709\u8fde\u63a5\u5230\u6765\uff09\u3002\u5c31\u4f1a\u6267\u884cuv__server_io\u51fd\u6570\uff0c\u6458\u4e0b\u5bf9\u5e94\u7684\u5ba2\u6237\u7aef\u8282\u70b9\u3002\u6700\u540e\u6267\u884cconnection_cb\u56de\u8c03\u3002 9.1.4 \u53d1\u8d77\u8fde\u63a5 \u00b6 \u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u5df2\u7ecf\u6210\u529f\u542f\u52a8\u4e86\u4e00\u4e2aUnix\u57df\u670d\u52a1\u3002\u63a5\u4e0b\u6765\u5c31\u662f\u770b\u5ba2\u6237\u7aef\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 void uv_pipe_connect ( uv_connect_t * req , uv_pipe_t * handle , const char * name , uv_connect_cb cb ) { struct sockaddr_un saddr ; int new_sock ; int err ; int r ; // \u5224\u65ad\u662f\u5426\u5df2\u7ecf\u6709socket\u4e86\uff0c\u6ca1\u6709\u7684\u8bdd\u9700\u8981\u7533\u8bf7\u4e00\u4e2a\uff0c\u89c1\u4e0b\u9762 new_sock = ( uv__stream_fd ( handle ) == -1 ); // \u5ba2\u6237\u7aef\u8fd8\u6ca1\u6709\u5bf9\u5e94\u7684socket fd if ( new_sock ) { handle -> io_watcher . fd = uv__socket ( AF_UNIX , SOCK_STREAM , 0 ); } // \u9700\u8981\u8fde\u63a5\u7684\u670d\u52a1\u5668\u4fe1\u606f\u3002\u4e3b\u8981\u662fUnix\u57df\u8def\u5f84\u4fe1\u606f memset ( & saddr , 0 , sizeof saddr ); strncpy ( saddr . sun_path , name , sizeof ( saddr . sun_path ) - 1 ); saddr . sun_path [ sizeof ( saddr . sun_path ) - 1 ] = '\\0' ; saddr . sun_family = AF_UNIX ; // \u975e\u963b\u585e\u5f0f\u8fde\u63a5\u670d\u52a1\u5668\uff0cUnix\u57df\u8def\u5f84\u662fname do { r = connect ( uv__stream_fd ( handle ), ( struct sockaddr * ) & saddr , sizeof saddr ); } while ( r == -1 && errno == EINTR ); // \u5ffd\u7565\u9519\u8bef\u5904\u7406\u903b\u8f91 err = 0 ; // \u8bbe\u7f6esocket\u7684\u53ef\u8bfb\u5199\u5c5e\u6027 if ( new_sock ) { err = uv__stream_open (( uv_stream_t * ) handle , uv__stream_fd ( handle ), UV_HANDLE_READABLE | UV_HANDLE_WRITABLE ); } // \u628aIO\u89c2\u5bdf\u8005\u6ce8\u518c\u5230Libuv\uff0c\u7b49\u5230\u8fde\u63a5\u6210\u529f\u6216\u8005\u53ef\u4ee5\u53d1\u9001\u8bf7\u6c42 if ( err == 0 ) uv__io_start ( handle -> loop , & handle -> io_watcher , POLLIN | POLLOUT ); out : // \u8bb0\u5f55\u9519\u8bef\u7801\uff0c\u5982\u679c\u6709\u7684\u8bdd handle -> delayed_error = err ; // \u4fdd\u5b58\u8c03\u7528\u8005\u4fe1\u606f handle -> connect_req = req ; uv__req_init ( handle -> loop , req , UV_CONNECT ); req -> handle = ( uv_stream_t * ) handle ; req -> cb = cb ; QUEUE_INIT ( & req -> queue ); /* \u5982\u679c\u8fde\u63a5\u51fa\u9519\uff0c\u5728pending\u9636\u6bb5\u4f1a\u6267\u884cuv__stream_io\uff0c \u4ece\u800c\u6267\u884creq\u5bf9\u5e94\u7684\u56de\u8c03\u3002\u9519\u8bef\u7801\u662fdelayed_error */ if ( err ) uv__io_feed ( handle -> loop , & handle -> io_watcher ); } uv_pipe_connect\u51fd\u6570\u9996\u5148\u4ee5\u975e\u963b\u585e\u7684\u65b9\u5f0f\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684connect\u51fd\u6570\uff0c\u8c03\u7528connect\u540e\u64cd\u4f5c\u7cfb\u7edf\u628a\u5ba2\u6237\u7aef\u5bf9\u5e94\u7684socket\u76f4\u63a5\u63d2\u5165\u670d\u52a1\u5668socket\u7684\u5f85\u5904\u7406socket\u961f\u5217\u4e2d\uff0c\u7b49\u5f85\u670d\u52a1\u5668\u5904\u7406\u3002\u8fd9\u65f6\u5019socket\u662f\u5904\u4e8e\u8fde\u63a5\u4e2d\u7684\u72b6\u6001\uff0c\u5f53\u670d\u52a1\u5668\u8c03\u7528accept\u51fd\u6570\u5904\u7406\u8fde\u63a5\u65f6\uff0c\u4f1a\u4fee\u6539\u8fde\u63a5\u72b6\u6001\u4e3a\u5df2\u8fde\u63a5\uff08\u8fd9\u548cTCP\u4e0d\u4e00\u6837\uff0cTCP\u662f\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u540e\u5c31\u4f1a\u4fee\u6539\u4e3a\u8fde\u63a5\u72b6\u6001\uff0c\u800c\u4e0d\u662faccept\u7684\u65f6\u5019\uff09\uff0c\u5e76\u4e14\u4f1a\u89e6\u53d1\u5ba2\u6237\u7aefsocket\u7684\u53ef\u5199\u4e8b\u4ef6\u3002\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u5c31\u4f1a\u6267\u884c\u76f8\u5e94\u7684\u56de\u8c03\uff08uv__stream_io\uff09\uff0c\u4ece\u800c\u6267\u884cC++\u548cJS\u7684\u56de\u8c03\u3002 9.1.5 \u5173\u95edUnix\u57df \u00b6 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7uv_close\u5173\u95ed\u4e00\u4e2aUnix\u57dfhandle\u3002uv_close\u4e2d\u4f1a\u8c03\u7528uv__pipe_close\u3002 1 2 3 4 5 6 7 8 9 10 void uv__pipe_close ( uv_pipe_t * handle ) { // \u5982\u679c\u662fUnix\u57df\u670d\u52a1\u5668\u5219\u9700\u8981\u5220\u9664Unix\u57df\u8def\u5f84\u5e76\u5220\u9664\u6307\u5411\u7684\u5806\u5185\u5b58 if ( handle -> pipe_fname ) { unlink ( handle -> pipe_fname ); uv__free (( void * ) handle -> pipe_fname ); handle -> pipe_fname = NULL ; } // \u5173\u95ed\u6d41\u76f8\u5173\u7684\u5185\u5bb9 uv__stream_close (( uv_stream_t * ) handle ); } \u5173\u95edUnix\u57dfhandle\u65f6\uff0cLibuv\u4f1a\u81ea\u52a8\u5220\u9664Unix\u57df\u8def\u5f84\u5bf9\u5e94\u7684\u6587\u4ef6\u3002\u4f46\u662f\u5982\u679c\u8fdb\u7a0b\u5f02\u5e38\u9000\u51fa\u65f6\uff0c\u8be5\u6587\u4ef6\u53ef\u80fd\u4e0d\u4f1a\u88ab\u5220\u9664\uff0c\u8fd9\u6837\u4f1a\u5bfc\u81f4\u4e0b\u6b21\u76d1\u542c\u7684\u65f6\u5019\u62a5\u9519listen EADDRINUSE\uff0c\u6240\u4ee5\u5b89\u5168\u8d77\u89c1\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u8fdb\u7a0b\u9000\u51fa\u6216\u8005\u76d1\u542c\u4e4b\u524d\u5224\u65ad\u8be5\u6587\u4ef6\u662f\u5426\u5b58\u5728\uff0c\u5b58\u5728\u7684\u8bdd\u5219\u5220\u9664\u3002\u53e6\u5916\u8fd8\u6709\u4e00\u4e2a\u95ee\u9898\u662f\uff0c\u5982\u679c\u4e24\u4e2a\u4e0d\u76f8\u5173\u7684\u8fdb\u7a0b\u4f7f\u7528\u4e86\u540c\u4e00\u4e2a\u6587\u4ef6\u5219\u4f1a\u5bfc\u81f4\u8bef\u5220\uff0c\u6240\u4ee5Unix\u57df\u5bf9\u5e94\u7684\u6587\u4ef6\uff0c\u6211\u4eec\u9700\u8981\u5c0f\u5fc3\u5904\u7406\uff0c\u6700\u597d\u80fd\u4fdd\u8bc1\u552f\u4e00\u6027\u3002 Unix\u57df\u5927\u81f4\u7684\u6d41\u7a0b\u548c\u7f51\u7edc\u7f16\u7a0b\u4e00\u6837\u3002\u5206\u4e3a\u670d\u52a1\u7aef\u548c\u5ba2\u6237\u7aef\u4e24\u9762\u3002Libuv\u5728\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684API\u7684\u57fa\u7840\u4e0a\u3002\u548cLibuv\u7684\u5f02\u6b65\u975e\u963b\u585e\u7ed3\u5408\u3002\u5728Libuv\u4e2d\u4e3a\u8fdb\u7a0b\u95f4\u63d0\u4f9b\u4e86\u4e00\u79cd\u901a\u4fe1\u65b9\u5f0f\u3002\u4e0b\u9762\u770b\u4e00\u4e0b\u5728Node.js\u4e2d\u662f\u5982\u4f55\u4f7f\u7528Libuv\u63d0\u4f9b\u7684\u529f\u80fd\u7684\u3002 9.2 Unix\u57df\u5728Node.js\u4e2d\u7684\u4f7f\u7528 \u00b6 9.2.1 Unix\u57df\u670d\u52a1\u5668 \u00b6 \u5728Node.js\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u4ee3\u7801\u521b\u5efa\u4e00\u4e2aUnix\u57df\u670d\u52a1\u5668 1 2 3 4 5 6 const server = net . createServer (( client ) => { // \u5904\u7406client }); server . listen ( '/tmp/test.sock' , () => { console . log ( `bind uinx domain success` ); }); \u6211\u4eec\u4ecelisten\u51fd\u6570\u5f00\u59cb\u5206\u6790\u8fd9\u4e2a\u8fc7\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 Server . prototype . listen = function (... args ) { const normalized = normalizeArgs ( args ); let options = normalized [ 0 ]; const cb = normalized [ 1 ]; // \u8c03\u7528\u5e95\u5c42\u7684listen\u51fd\u6570\u6210\u529f\u540e\u6267\u884c\u7684\u56de\u8c03 if ( cb !== null ) { this . once ( 'listening' , cb ); } if ( options . path && isPipeName ( options . path )) { const pipeName = this . _pipeName = options . path ; backlog = options . backlog || backlogFromArgs ; listenIncluster ( this , pipeName , - 1 , - 1 , backlog , undefined , options . exclusive ); /* Unix\u57df\u4f7f\u7528\u6587\u4ef6\u5b9e\u73b0\u7684\uff0c\u5ba2\u6237\u7aef\u9700\u8981\u8bbf\u95ee\u8be5\u6587\u4ef6\u7684\u6743\u9650\u624d\u80fd\u901a\u4fe1\uff0c \u8fd9\u91cc\u505a\u6743\u9650\u63a7\u5236 */ let mode = 0 ; if ( options . readableAll === true ) mode |= PipeConstants . UV_READABLE ; if ( options . writableAll === true ) mode |= PipeConstants . UV_WRITABLE ; if ( mode !== 0 ) { // \u4fee\u6539\u6587\u4ef6\u7684\u8bbf\u95ee\u5c5e\u6027 const err = this . _handle . fchmod ( mode ); if ( err ) { this . _handle . close (); this . _handle = null ; throw errnoException ( err , 'uv_pipe_chmod' ); } } return this ; } } \u8fd9\u6bb5\u4ee3\u7801\u4e2d\u6700\u4e3b\u8981\u7684\u662flistenIncluster\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8be5\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 function listenIncluster ( server , address , port , addressType , backlog , fd , exclusive , flags ) { exclusive = !! exclusive ; if ( cluster === undefined ) cluster = require ( 'cluster' ); if ( cluster . isMaster || exclusive ) { server . _listen2 ( address , port , addressType , backlog , fd , flags ); return ; } } \u76f4\u63a5\u8c03\u7528_listen2\uff08isMaster\u53ea\u6709\u5728cluster.fork\u521b\u5efa\u7684\u8fdb\u7a0b\u4e2d\u624d\u662ffalse\uff0c\u5176\u4f59\u60c5\u51b5\u90fd\u662ftrue\uff0c\u5305\u62ecchild_process\u6a21\u5757\u521b\u5efa\u7684\u5b50\u8fdb\u7a0b\uff09\u3002\u6211\u4eec\u7ee7\u7eed\u770blisten\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Server . prototype . _listen2 = setupListenHandle ; function setupListenHandle ( address , port , addressType , backlog , fd , flags ) { this . _handle = createServerHandle ( address , port , addressType , fd , flags ); // \u6709\u5b8c\u6210\u8fde\u63a5\u5b8c\u6210\u65f6\u89e6\u53d1 this . _handle . onconnection = onconnection ; const err = this . _handle . listen ( backlog || 511 ); if ( err ) { // \u89e6\u53d1error\u4e8b\u4ef6 } // \u4e0b\u4e00\u4e2atick\u89e6\u53d1listen\u56de\u8c03 defaultTriggerAsyncIdScope ( this [ async_id_symbol ], process . nextTick , emitListeningNT , this ); } \u9996\u5148\u8c03\u7528createServerHandle\u521b\u5efa\u4e00\u4e2ahandle\uff0c\u7136\u540e\u6267\u884clisten\u51fd\u6570\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bcreateServerHandle\u3002 1 2 3 4 5 6 7 8 9 function createServerHandle ( address , port , addressType , fd , flags ) { let handle = new Pipe ( PipeConstants . SERVER ); handle . bind ( address , port ); return handle ; } \u521b\u5efa\u4e86\u4e00\u4e2aPipe\u5bf9\u8c61\uff0c\u7136\u540e\u8c03\u7528\u5b83\u7684bind\u548clisten\u51fd\u6570\uff0c\u6211\u4eec\u770bnew Pipe\u7684\u903b\u8f91\uff0c\u4ecepipe_wrap.cc\u7684\u5bfc\u51fa\u903b\u8f91\uff0c\u6211\u4eec\u77e5\u9053\uff0c\u8fd9\u65f6\u5019\u4f1a\u65b0\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u7136\u540e\u6267\u884cNew\u51fd\u6570\uff0c\u5e76\u4e14\u628a\u65b0\u5efa\u7684C++\u5bf9\u8c61\u7b49\u4fe1\u606f\u4f5c\u4e3a\u5165\u53c2\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void PipeWrap::New ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); // \u7c7b\u578b int type_value = args [ 0 ]. As < Int32 > () -> Value (); PipeWrap :: SocketType type = static_cast < PipeWrap :: SocketType > ( type_value ); // \u662f\u5426\u662f\u7528\u4e8eIPC bool ipc ; ProviderType provider ; switch ( type ) { case SOCKET : provider = PROVIDER_PIPEWRAP ; ipc = false ; break ; case SERVER : provider = PROVIDER_PIPESERVERWRAP ; ipc = false ; break ; case IPC : provider = PROVIDER_PIPEWRAP ; ipc = true ; break ; default : UNREACHABLE (); } new PipeWrap ( env , args . This (), provider , ipc ); } New\u51fd\u6570\u5904\u7406\u4e86\u53c2\u6570\uff0c\u7136\u540e\u6267\u884c\u4e86new PipeWrap\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 PipeWrap :: PipeWrap ( Environment * env , Local < Object > object , ProviderType provider , bool ipc ) : ConnectionWrap ( env , object , provider ) { int r = uv_pipe_init ( env -> event_loop (), & handle_ , ipc ); } new Pipe\u6267\u884c\u5b8c\u540e\uff0c\u5c31\u4f1a\u901a\u8fc7\u8be5C++\u5bf9\u8c61\u8c03\u7528Libuv\u7684bind\u548clisten\u5b8c\u6210\u670d\u52a1\u5668\u7684\u542f\u52a8\uff0c\u5c31\u4e0d\u518d\u5c55\u5f00\u5206\u6790\u3002 9.2.2 Unix\u57df\u5ba2\u6237\u7aef \u00b6 \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bUnix\u57df\u4f5c\u4e3a\u5ba2\u6237\u7aef\u4f7f\u7528\u65f6\u7684\u8fc7\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Socket . prototype . connect = function (... args ) { const path = options . path ; // Unix\u57df\u8def\u5f84 var pipe = !! path ; if ( ! this . _handle ) { // \u521b\u5efa\u4e00\u4e2aC++\u5c42handle\uff0c\u5373pipe_wrap.cc\u5bfc\u51fa\u7684Pipe\u7c7b this . _handle = pipe ? new Pipe ( PipeConstants . SOCKET ) : new TCP ( TCPConstants . SOCKET ); // \u6302\u8f7donread\u65b9\u6cd5\u5230this\u4e2d initSocketHandle ( this ); } if ( cb !== null ) { this . once ( 'connect' , cb ); } // \u6267\u884cinternalConnect defaultTriggerAsyncIdScope ( this [ async_id_symbol ], internalConnect , this , path ); return this ; }; \u9996\u5148\u65b0\u5efa\u4e00\u4e2ahandle\uff0c\u503c\u662fnew Pipe\u3002\u63a5\u7740\u6267\u884c\u4e86internalConnect\uff0cinternalConnect\u51fd\u6570\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 2 3 4 5 6 const req = new PipeConnectWrap (); // address\u4e3aUnix\u57df\u8def\u5f84 req . address = address ; req . oncomplete = afterConnect ; // \u8c03\u7528C++\u5c42connect err = self . _handle . connect ( req , address , afterConnect ); \u6211\u4eec\u770bC++\u5c42\u7684connect\u51fd\u6570\uff0c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void PipeWrap::Connect ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); PipeWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder ()); // PipeConnectWrap\u5bf9\u8c61 Local < Object > req_wrap_obj = args [ 0 ]. As < Object > (); // Unix\u57df\u8def\u5f84 node :: Utf8Value name ( env -> isolate (), args [ 1 ]); /* \u65b0\u5efa\u4e00\u4e2aConnectWrap\u5bf9\u8c61\uff0cConnectWrap\u662f\u5bf9handle\u8fdb\u884c\u4e00\u6b21\u8fde\u63a5\u8bf7\u6c42 \u7684\u5c01\u88c5\uff0c\u5185\u90e8\u7ef4\u62a4\u4e00\u4e2auv_connect_t\u7ed3\u6784\u4f53\uff0c req_wrap_obj\u7684\u4e00\u4e2a\u5b57\u6bb5 \u6307\u5411ConnectWrap\u5bf9\u8c61\uff0c\u7528\u4e8e\u4fdd\u5b58\u5bf9\u5e94\u7684\u8bf7\u6c42\u4e0a\u4e0b\u6587 */ ConnectWrap * req_wrap = new ConnectWrap ( env , req_wrap_obj , AsyncWrap :: PROVIDER_PIPECONNECTWRAP ); // \u8c03\u7528Libuv\u7684connect\u51fd\u6570 uv_pipe_connect ( req_wrap -> req (), & wrap -> handle_ , * name , AfterConnect ); // req_wrap->req_.data = req_wrap;\u5173\u8054\u8d77\u6765 req_wrap -> Dispatched (); // uv_pipe_connect() doesn't return errors. args . GetReturnValue (). Set ( 0 ); } uv_pipe_connect\u51fd\u6570\uff0c\u7b2c\u4e00\u4e2a\u53c2\u6570\u662fuv_connect_t\u7ed3\u6784\u4f53\uff08request\uff09\uff0c\u7b2c\u4e8c\u4e2a\u662f\u4e00\u4e2auv_pipe_t\u7ed3\u6784\u4f53\uff08handle\uff09\uff0chandle\u662f\u5bf9Unix\u57df\u5ba2\u6237\u7aef\u7684\u5c01\u88c5\uff0crequest\u662f\u8bf7\u6c42\u7684\u5c01\u88c5\uff0c\u5b83\u8868\u793a\u57fa\u4e8ehandle\u53d1\u8d77\u4e00\u6b21\u8fde\u63a5\u8bf7\u6c42\u3002\u8fde\u63a5\u6210\u529f\u540e\u4f1a\u6267\u884cAfterConnect\u3002\u7531\u524d\u9762\u5206\u6790\u6211\u4eec\u77e5\u9053\uff0c\u5f53\u8fde\u63a5\u6210\u529f\u65f6\uff0c\u9996\u5148\u4f1a\u6267\u884c\u56de\u8c03Libuv\u7684uv__stream_io\uff0c\u7136\u540e\u6267\u884cC++\u5c42\u7684AfterConnect\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // \u4e3b\u52a8\u53d1\u8d77\u8fde\u63a5\uff0c\u6210\u529f/\u5931\u8d25\u540e\u7684\u56de\u8c03 template < typename WrapType , typename UVType > = PipeWrap , uv_pipe_t void ConnectionWrap < WrapType , UVType >:: AfterConnect ( uv_connect_t * req , int status ) { // \u5728Connect\u51fd\u6570\u91cc\u5173\u8054\u8d77\u6765\u7684 ConnectWrap * req_wrap = static_cast < ConnectWrap *> ( req -> data ); // \u5728uv_pipe_connect\u4e2d\u5b8c\u6210\u5173\u8054\u7684 WrapType * wrap = static_cast < WrapType *> ( req -> handle -> data ); Environment * env = wrap -> env (); HandleScope handle_scope ( env -> isolate ()); Context :: Scope context_scope ( env -> context ()); bool readable , writable ; // \u662f\u5426\u8fde\u63a5\u6210\u529f if ( status ) { readable = writable = 0 ; } else { readable = uv_is_readable ( req -> handle ) != 0 ; writable = uv_is_writable ( req -> handle ) != 0 ; } Local < Value > argv [ 5 ] = { Integer :: New ( env -> isolate (), status ), wrap -> object (), req_wrap -> object (), Boolean :: New ( env -> isolate (), readable ), Boolean :: New ( env -> isolate (), writable ) }; // \u6267\u884cJS\u5c42\u7684oncomplete\u56de\u8c03 req_wrap -> MakeCallback ( env -> oncomplete_string (), arraysize ( argv ), argv ); delete req_wrap ; } \u6211\u4eec\u518d\u56de\u5230JS\u5c42\u7684afterConnect 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function afterConnect ( status , handle , req , readable , writable ) { var self = handle . owner ; handle = self . _handle ; if ( status === 0 ) { self . readable = readable ; self . writable = writable ; self . _unrefTimer (); // \u89e6\u53d1connect\u4e8b\u4ef6 self . emit ( 'connect' ); // \u53ef\u8bfb\u5e76\u4e14\u6ca1\u6709\u5904\u4e8e\u6682\u505c\u6a21\u5f0f\uff0c\u5219\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 if ( readable && ! self . isPaused ()) self . read ( 0 ); } } \u81f3\u6b64\uff0c\u4f5c\u4e3a\u5ba2\u6237\u7aef\u5bf9\u670d\u52a1\u5668\u7684\u8fde\u63a5\u5c31\u5b8c\u6210\u4e86\u3002\u540e\u7eed\u5c31\u53ef\u4ee5\u8fdb\u884c\u901a\u4fe1\u3002","title":"09-Unix\u57df"},{"location":"chapter09-Unix%E5%9F%9F/#91-unixlibuv","text":"\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0b\u5728Libuv\u4e2d\u5173\u4e8eUnix\u57df\u7684\u5b9e\u73b0\u548c\u4f7f\u7528\u3002","title":"9.1 Unix\u57df\u5728Libuv\u4e2d\u7684\u4f7f\u7528"},{"location":"chapter09-Unix%E5%9F%9F/#911","text":"Unix\u57df\u4f7f\u7528uv_pipe_t\u7ed3\u6784\u4f53\u8868\u793a\uff0c\u4f7f\u7528\u4e4b\u524d\u9996\u5148\u9700\u8981\u521d\u59cb\u5316uv_pipe_t\u3002\u4e0b\u9762\u770b\u4e00\u4e0b\u5b83\u7684\u5b9e\u73b0\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 int uv_pipe_init ( uv_loop_t * loop , uv_pipe_t * handle , int ipc ) { uv__stream_init ( loop , ( uv_stream_t * ) handle , UV_NAMED_PIPE ); handle -> shutdown_req = NULL ; handle -> connect_req = NULL ; handle -> pipe_fname = NULL ; handle -> ipc = ipc ; return 0 ; } uv_pipe_init\u903b\u8f91\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u521d\u59cb\u5316uv_pipe_t\u7ed3\u6784\u4f53\u7684\u4e00\u4e9b\u5b57\u6bb5\u3002uv_pipe_t\u7ee7\u627f\u4e8estream\uff0cuv__stream_init\u5c31\u662f\u521d\u59cb\u5316stream\uff08\u7236\u7c7b\uff09\u7684\u5b57\u6bb5\u3002uv_pipe_t\u4e2d\u6709\u4e00\u4e2a\u5b57\u6bb5ipc\uff0c\u8be5\u5b57\u6bb5\u6807\u8bb0\u4e86\u662f\u5426\u5141\u8bb8\u5728\u8be5Unix\u57df\u901a\u4fe1\u4e2d\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002","title":"9.1.1 \u521d\u59cb\u5316"},{"location":"chapter09-Unix%E5%9F%9F/#912-unix","text":"\u5f00\u5934\u8bf4\u8fc7\uff0cUnix\u57df\u7684\u5b9e\u73b0\u7c7b\u4f3cTCP\u7684\u5b9e\u73b0\u3002\u9075\u5faa\u7f51\u7edcsocket\u7f16\u7a0b\u90a3\u4e00\u5957\u6d41\u7a0b\u3002\u670d\u52a1\u7aef\u4f7f\u7528bind\uff0clisten\u7b49\u51fd\u6570\u542f\u52a8\u670d\u52a1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // name\u662funix\u8def\u5f84\u540d\u79f0 int uv_pipe_bind ( uv_pipe_t * handle , const char * name ) { struct sockaddr_un saddr ; const char * pipe_fname ; int sockfd ; int err ; pipe_fname = NULL ; pipe_fname = uv__strdup ( name ); name = NULL ; // \u6d41\u5f0fUnix\u57df\u5957\u63a5\u5b57 sockfd = uv__socket ( AF_UNIX , SOCK_STREAM , 0 ); memset ( & saddr , 0 , sizeof saddr ); strncpy ( saddr . sun_path , pipe_fname , sizeof ( saddr . sun_path ) - 1 ); saddr . sun_path [ sizeof ( saddr . sun_path ) - 1 ] = '\\0' ; saddr . sun_family = AF_UNIX ; // \u7ed1\u5b9a\u5230\u8def\u5f84\uff0cTCP\u662f\u7ed1\u5b9a\u5230IP\u548c\u7aef\u53e3 if ( bind ( sockfd , ( struct sockaddr * ) & saddr , sizeof saddr )) { // ... } // \u8bbe\u7f6e\u7ed1\u5b9a\u6210\u529f\u6807\u8bb0 handle -> flags |= UV_HANDLE_BOUND ; // Unix\u57df\u7684\u8def\u5f84 handle -> pipe_fname = pipe_fname ; // \u4fdd\u5b58socket\u5bf9\u5e94\u7684fd handle -> io_watcher . fd = sockfd ; return 0 ; } uv_pipe_bind\u51fd\u6570\u9996\u5148\u7533\u8bf7\u4e00\u4e2asocket\uff0c\u7136\u540e\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684bind\u51fd\u6570\u628aUnix\u57df\u8def\u5f84\u4fdd\u5b58\u5230socket\u4e2d\u3002\u6700\u540e\u6807\u8bb0\u5df2\u7ecf\u7ed1\u5b9a\u6807\u8bb0\uff0c\u5e76\u4e14\u4fdd\u5b58Unix\u57df\u7684\u8def\u5f84\u548csocket\u5bf9\u5e94\u7684fd\u5230handle\u4e2d\uff0c\u540e\u7eed\u9700\u8981\u4f7f\u7528\u3002\u6211\u4eec\u770b\u5230Node.js\u4e2dUnix\u57df\u7684\u7c7b\u578b\u662fSOCK_STREAM\u3002Unix\u57df\u652f\u6301\u4e24\u79cd\u6570\u636e\u6a21\u5f0f\u3002 1 \u6d41\u5f0f\uff08 SOCK_STREAM\uff09\uff0c\u7c7b\u4f3cTCP\uff0c\u6570\u636e\u4e3a\u5b57\u8282\u6d41\uff0c\u9700\u8981\u5e94\u7528\u5c42\u5904\u7406\u7c98\u5305\u95ee\u9898\u3002 2 \u6570\u636e\u62a5\u6a21\u5f0f\uff08 SOCK_DGRAM \uff09\uff0c\u7c7b\u4f3cUDP\uff0c\u4e0d\u9700\u8981\u5904\u7406\u7c98\u5305\u95ee\u9898\u3002 \u901a\u8fc7Unix\u57df\u867d\u7136\u53ef\u4ee5\u5b9e\u73b0\u8fdb\u7a0b\u95f4\u7684\u901a\u4fe1\uff0c\u4f46\u662f\u6211\u4eec\u62ff\u5230\u7684\u6570\u636e\u53ef\u80fd\u662f\"\u4e71\u7684\"\uff0c\u8fd9\u662f\u4e3a\u4ec0\u4e48\u5462\uff1f\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u5ba2\u6237\u7aef\u7ed9\u670d\u52a1\u5668\u53d1\u90011\u4e2a\u5b57\u8282\uff0c\u7136\u540e\u670d\u52a1\u5668\u5904\u7406\uff0c\u5982\u679c\u662f\u57fa\u4e8e\u8fd9\u79cd\u573a\u666f\uff0c\u90a3\u4e48\u6570\u636e\u5c31\u4e0d\u4f1a\u662f\u4e71\u7684\u3002\u56e0\u4e3a\u6bcf\u6b21\u5c31\u662f\u4e00\u4e2a\u9700\u8981\u5904\u7406\u7684\u6570\u636e\u5355\u4f4d\u3002\u4f46\u662f\u5982\u679c\u5ba2\u6237\u7aef\u7ed9\u670d\u52a1\u5668\u53d1\u90011\u4e2a\u5b57\u8282\uff0c\u670d\u52a1\u5668\u8fd8\u6ca1\u6765\u5f97\u53ca\u5904\u7406\uff0c\u5ba2\u6237\u7aef\u53c8\u53d1\u9001\u4e86\u4e00\u4e2a\u5b57\u8282\uff0c\u90a3\u4e48\u8fd9\u65f6\u5019\u670d\u52a1\u5668\u518d\u5904\u7406\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6709\u95ee\u9898\u3002\u56e0\u4e3a\u4e24\u4e2a\u5b57\u8282\u6df7\u4e00\u8d77\u4e86\u3002\u5c31\u597d\u6bd4\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u5148\u540e\u53d1\u9001\u4e24\u4e2aHTTP\u8bf7\u6c42\u4e00\u6837\uff0c\u5982\u679c\u670d\u52a1\u5668\u6ca1\u6709\u529e\u6cd5\u5224\u65ad\u4e24\u4e2a\u8bf7\u6c42\u7684\u6570\u636e\u8fb9\u754c\uff0c\u90a3\u4e48\u5904\u7406\u5c31\u4f1a\u6709\u95ee\u9898\u3002\u6240\u4ee5\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u5b9a\u4e49\u4e00\u4e2a\u5e94\u7528\u5c42\u534f\u8bae\uff0c\u5e76\u4e14\u5b9e\u73b0\u5c01\u5305\u89e3\u5305\u7684\u903b\u8f91\uff0c\u624d\u80fd\u771f\u6b63\u5b8c\u6210\u8fdb\u7a0b\u95f4\u901a\u4fe1\u3002","title":"9.1.2 \u7ed1\u5b9aUnix\u57df\u8def\u5f84"},{"location":"chapter09-Unix%E5%9F%9F/#913","text":"\u7ed1\u5b9a\u4e86\u8def\u5f84\u540e\uff0c\u5c31\u53ef\u4ee5\u8c03\u7528listen\u51fd\u6570\u4f7f\u5f97socket\u5904\u4e8e\u76d1\u542c\u72b6\u6001\u3002 1 2 3 4 5 6 7 8 9 10 11 12 int uv_pipe_listen ( uv_pipe_t * handle , int backlog , uv_connection_cb cb ) { // uv__stream_fd(handle)\u5f97\u5230bind\u51fd\u6570\u4e2d\u83b7\u53d6\u7684socket if ( listen ( uv__stream_fd ( handle ), backlog )) return UV__ERR ( errno ); // \u4fdd\u5b58\u56de\u8c03\uff0c\u6709\u8fdb\u7a0b\u8c03\u7528connect\u7684\u65f6\u5019\u65f6\u89e6\u53d1\uff0c\u7531uv__server_io\u51fd\u6570\u89e6\u53d1 handle -> connection_cb = cb ; // IO\u89c2\u5bdf\u8005\u7684\u56de\u8c03 handle -> io_watcher . cb = uv__server_io ; // \u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230Libuv\uff0c\u7b49\u5f85\u8fde\u63a5\uff0c\u5373\u8bfb\u4e8b\u4ef6\u5230\u6765 uv__io_start ( handle -> loop , & handle -> io_watcher , POLLIN ); return 0 ; } uv_pipe_listen\u6267\u884c\u64cd\u4f5c\u7cfb\u7edf\u7684listen\u51fd\u6570\u4f7f\u5f97socket\u6210\u4e3a\u76d1\u542c\u578b\u7684\u5957\u63a5\u5b57\u3002\u7136\u540e\u628asocket\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u56de\u8c03\u5c01\u88c5\u6210IO\u89c2\u5bdf\u8005\u3002\u6ce8\u518c\u5230Libuv\u4e2d\u3002\u7b49\u5230\u6709\u8bfb\u4e8b\u4ef6\u5230\u6765\uff08\u6709\u8fde\u63a5\u5230\u6765\uff09\u3002\u5c31\u4f1a\u6267\u884cuv__server_io\u51fd\u6570\uff0c\u6458\u4e0b\u5bf9\u5e94\u7684\u5ba2\u6237\u7aef\u8282\u70b9\u3002\u6700\u540e\u6267\u884cconnection_cb\u56de\u8c03\u3002","title":"9.1.3 \u542f\u52a8\u670d\u52a1"},{"location":"chapter09-Unix%E5%9F%9F/#914","text":"\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u5df2\u7ecf\u6210\u529f\u542f\u52a8\u4e86\u4e00\u4e2aUnix\u57df\u670d\u52a1\u3002\u63a5\u4e0b\u6765\u5c31\u662f\u770b\u5ba2\u6237\u7aef\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 void uv_pipe_connect ( uv_connect_t * req , uv_pipe_t * handle , const char * name , uv_connect_cb cb ) { struct sockaddr_un saddr ; int new_sock ; int err ; int r ; // \u5224\u65ad\u662f\u5426\u5df2\u7ecf\u6709socket\u4e86\uff0c\u6ca1\u6709\u7684\u8bdd\u9700\u8981\u7533\u8bf7\u4e00\u4e2a\uff0c\u89c1\u4e0b\u9762 new_sock = ( uv__stream_fd ( handle ) == -1 ); // \u5ba2\u6237\u7aef\u8fd8\u6ca1\u6709\u5bf9\u5e94\u7684socket fd if ( new_sock ) { handle -> io_watcher . fd = uv__socket ( AF_UNIX , SOCK_STREAM , 0 ); } // \u9700\u8981\u8fde\u63a5\u7684\u670d\u52a1\u5668\u4fe1\u606f\u3002\u4e3b\u8981\u662fUnix\u57df\u8def\u5f84\u4fe1\u606f memset ( & saddr , 0 , sizeof saddr ); strncpy ( saddr . sun_path , name , sizeof ( saddr . sun_path ) - 1 ); saddr . sun_path [ sizeof ( saddr . sun_path ) - 1 ] = '\\0' ; saddr . sun_family = AF_UNIX ; // \u975e\u963b\u585e\u5f0f\u8fde\u63a5\u670d\u52a1\u5668\uff0cUnix\u57df\u8def\u5f84\u662fname do { r = connect ( uv__stream_fd ( handle ), ( struct sockaddr * ) & saddr , sizeof saddr ); } while ( r == -1 && errno == EINTR ); // \u5ffd\u7565\u9519\u8bef\u5904\u7406\u903b\u8f91 err = 0 ; // \u8bbe\u7f6esocket\u7684\u53ef\u8bfb\u5199\u5c5e\u6027 if ( new_sock ) { err = uv__stream_open (( uv_stream_t * ) handle , uv__stream_fd ( handle ), UV_HANDLE_READABLE | UV_HANDLE_WRITABLE ); } // \u628aIO\u89c2\u5bdf\u8005\u6ce8\u518c\u5230Libuv\uff0c\u7b49\u5230\u8fde\u63a5\u6210\u529f\u6216\u8005\u53ef\u4ee5\u53d1\u9001\u8bf7\u6c42 if ( err == 0 ) uv__io_start ( handle -> loop , & handle -> io_watcher , POLLIN | POLLOUT ); out : // \u8bb0\u5f55\u9519\u8bef\u7801\uff0c\u5982\u679c\u6709\u7684\u8bdd handle -> delayed_error = err ; // \u4fdd\u5b58\u8c03\u7528\u8005\u4fe1\u606f handle -> connect_req = req ; uv__req_init ( handle -> loop , req , UV_CONNECT ); req -> handle = ( uv_stream_t * ) handle ; req -> cb = cb ; QUEUE_INIT ( & req -> queue ); /* \u5982\u679c\u8fde\u63a5\u51fa\u9519\uff0c\u5728pending\u9636\u6bb5\u4f1a\u6267\u884cuv__stream_io\uff0c \u4ece\u800c\u6267\u884creq\u5bf9\u5e94\u7684\u56de\u8c03\u3002\u9519\u8bef\u7801\u662fdelayed_error */ if ( err ) uv__io_feed ( handle -> loop , & handle -> io_watcher ); } uv_pipe_connect\u51fd\u6570\u9996\u5148\u4ee5\u975e\u963b\u585e\u7684\u65b9\u5f0f\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684connect\u51fd\u6570\uff0c\u8c03\u7528connect\u540e\u64cd\u4f5c\u7cfb\u7edf\u628a\u5ba2\u6237\u7aef\u5bf9\u5e94\u7684socket\u76f4\u63a5\u63d2\u5165\u670d\u52a1\u5668socket\u7684\u5f85\u5904\u7406socket\u961f\u5217\u4e2d\uff0c\u7b49\u5f85\u670d\u52a1\u5668\u5904\u7406\u3002\u8fd9\u65f6\u5019socket\u662f\u5904\u4e8e\u8fde\u63a5\u4e2d\u7684\u72b6\u6001\uff0c\u5f53\u670d\u52a1\u5668\u8c03\u7528accept\u51fd\u6570\u5904\u7406\u8fde\u63a5\u65f6\uff0c\u4f1a\u4fee\u6539\u8fde\u63a5\u72b6\u6001\u4e3a\u5df2\u8fde\u63a5\uff08\u8fd9\u548cTCP\u4e0d\u4e00\u6837\uff0cTCP\u662f\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u540e\u5c31\u4f1a\u4fee\u6539\u4e3a\u8fde\u63a5\u72b6\u6001\uff0c\u800c\u4e0d\u662faccept\u7684\u65f6\u5019\uff09\uff0c\u5e76\u4e14\u4f1a\u89e6\u53d1\u5ba2\u6237\u7aefsocket\u7684\u53ef\u5199\u4e8b\u4ef6\u3002\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u5c31\u4f1a\u6267\u884c\u76f8\u5e94\u7684\u56de\u8c03\uff08uv__stream_io\uff09\uff0c\u4ece\u800c\u6267\u884cC++\u548cJS\u7684\u56de\u8c03\u3002","title":"9.1.4 \u53d1\u8d77\u8fde\u63a5"},{"location":"chapter09-Unix%E5%9F%9F/#915-unix","text":"\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7uv_close\u5173\u95ed\u4e00\u4e2aUnix\u57dfhandle\u3002uv_close\u4e2d\u4f1a\u8c03\u7528uv__pipe_close\u3002 1 2 3 4 5 6 7 8 9 10 void uv__pipe_close ( uv_pipe_t * handle ) { // \u5982\u679c\u662fUnix\u57df\u670d\u52a1\u5668\u5219\u9700\u8981\u5220\u9664Unix\u57df\u8def\u5f84\u5e76\u5220\u9664\u6307\u5411\u7684\u5806\u5185\u5b58 if ( handle -> pipe_fname ) { unlink ( handle -> pipe_fname ); uv__free (( void * ) handle -> pipe_fname ); handle -> pipe_fname = NULL ; } // \u5173\u95ed\u6d41\u76f8\u5173\u7684\u5185\u5bb9 uv__stream_close (( uv_stream_t * ) handle ); } \u5173\u95edUnix\u57dfhandle\u65f6\uff0cLibuv\u4f1a\u81ea\u52a8\u5220\u9664Unix\u57df\u8def\u5f84\u5bf9\u5e94\u7684\u6587\u4ef6\u3002\u4f46\u662f\u5982\u679c\u8fdb\u7a0b\u5f02\u5e38\u9000\u51fa\u65f6\uff0c\u8be5\u6587\u4ef6\u53ef\u80fd\u4e0d\u4f1a\u88ab\u5220\u9664\uff0c\u8fd9\u6837\u4f1a\u5bfc\u81f4\u4e0b\u6b21\u76d1\u542c\u7684\u65f6\u5019\u62a5\u9519listen EADDRINUSE\uff0c\u6240\u4ee5\u5b89\u5168\u8d77\u89c1\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u8fdb\u7a0b\u9000\u51fa\u6216\u8005\u76d1\u542c\u4e4b\u524d\u5224\u65ad\u8be5\u6587\u4ef6\u662f\u5426\u5b58\u5728\uff0c\u5b58\u5728\u7684\u8bdd\u5219\u5220\u9664\u3002\u53e6\u5916\u8fd8\u6709\u4e00\u4e2a\u95ee\u9898\u662f\uff0c\u5982\u679c\u4e24\u4e2a\u4e0d\u76f8\u5173\u7684\u8fdb\u7a0b\u4f7f\u7528\u4e86\u540c\u4e00\u4e2a\u6587\u4ef6\u5219\u4f1a\u5bfc\u81f4\u8bef\u5220\uff0c\u6240\u4ee5Unix\u57df\u5bf9\u5e94\u7684\u6587\u4ef6\uff0c\u6211\u4eec\u9700\u8981\u5c0f\u5fc3\u5904\u7406\uff0c\u6700\u597d\u80fd\u4fdd\u8bc1\u552f\u4e00\u6027\u3002 Unix\u57df\u5927\u81f4\u7684\u6d41\u7a0b\u548c\u7f51\u7edc\u7f16\u7a0b\u4e00\u6837\u3002\u5206\u4e3a\u670d\u52a1\u7aef\u548c\u5ba2\u6237\u7aef\u4e24\u9762\u3002Libuv\u5728\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684API\u7684\u57fa\u7840\u4e0a\u3002\u548cLibuv\u7684\u5f02\u6b65\u975e\u963b\u585e\u7ed3\u5408\u3002\u5728Libuv\u4e2d\u4e3a\u8fdb\u7a0b\u95f4\u63d0\u4f9b\u4e86\u4e00\u79cd\u901a\u4fe1\u65b9\u5f0f\u3002\u4e0b\u9762\u770b\u4e00\u4e0b\u5728Node.js\u4e2d\u662f\u5982\u4f55\u4f7f\u7528Libuv\u63d0\u4f9b\u7684\u529f\u80fd\u7684\u3002","title":"9.1.5 \u5173\u95edUnix\u57df"},{"location":"chapter09-Unix%E5%9F%9F/#92-unixnodejs","text":"","title":"9.2 Unix\u57df\u5728Node.js\u4e2d\u7684\u4f7f\u7528"},{"location":"chapter09-Unix%E5%9F%9F/#921-unix","text":"\u5728Node.js\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u4ee3\u7801\u521b\u5efa\u4e00\u4e2aUnix\u57df\u670d\u52a1\u5668 1 2 3 4 5 6 const server = net . createServer (( client ) => { // \u5904\u7406client }); server . listen ( '/tmp/test.sock' , () => { console . log ( `bind uinx domain success` ); }); \u6211\u4eec\u4ecelisten\u51fd\u6570\u5f00\u59cb\u5206\u6790\u8fd9\u4e2a\u8fc7\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 Server . prototype . listen = function (... args ) { const normalized = normalizeArgs ( args ); let options = normalized [ 0 ]; const cb = normalized [ 1 ]; // \u8c03\u7528\u5e95\u5c42\u7684listen\u51fd\u6570\u6210\u529f\u540e\u6267\u884c\u7684\u56de\u8c03 if ( cb !== null ) { this . once ( 'listening' , cb ); } if ( options . path && isPipeName ( options . path )) { const pipeName = this . _pipeName = options . path ; backlog = options . backlog || backlogFromArgs ; listenIncluster ( this , pipeName , - 1 , - 1 , backlog , undefined , options . exclusive ); /* Unix\u57df\u4f7f\u7528\u6587\u4ef6\u5b9e\u73b0\u7684\uff0c\u5ba2\u6237\u7aef\u9700\u8981\u8bbf\u95ee\u8be5\u6587\u4ef6\u7684\u6743\u9650\u624d\u80fd\u901a\u4fe1\uff0c \u8fd9\u91cc\u505a\u6743\u9650\u63a7\u5236 */ let mode = 0 ; if ( options . readableAll === true ) mode |= PipeConstants . UV_READABLE ; if ( options . writableAll === true ) mode |= PipeConstants . UV_WRITABLE ; if ( mode !== 0 ) { // \u4fee\u6539\u6587\u4ef6\u7684\u8bbf\u95ee\u5c5e\u6027 const err = this . _handle . fchmod ( mode ); if ( err ) { this . _handle . close (); this . _handle = null ; throw errnoException ( err , 'uv_pipe_chmod' ); } } return this ; } } \u8fd9\u6bb5\u4ee3\u7801\u4e2d\u6700\u4e3b\u8981\u7684\u662flistenIncluster\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8be5\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 function listenIncluster ( server , address , port , addressType , backlog , fd , exclusive , flags ) { exclusive = !! exclusive ; if ( cluster === undefined ) cluster = require ( 'cluster' ); if ( cluster . isMaster || exclusive ) { server . _listen2 ( address , port , addressType , backlog , fd , flags ); return ; } } \u76f4\u63a5\u8c03\u7528_listen2\uff08isMaster\u53ea\u6709\u5728cluster.fork\u521b\u5efa\u7684\u8fdb\u7a0b\u4e2d\u624d\u662ffalse\uff0c\u5176\u4f59\u60c5\u51b5\u90fd\u662ftrue\uff0c\u5305\u62ecchild_process\u6a21\u5757\u521b\u5efa\u7684\u5b50\u8fdb\u7a0b\uff09\u3002\u6211\u4eec\u7ee7\u7eed\u770blisten\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Server . prototype . _listen2 = setupListenHandle ; function setupListenHandle ( address , port , addressType , backlog , fd , flags ) { this . _handle = createServerHandle ( address , port , addressType , fd , flags ); // \u6709\u5b8c\u6210\u8fde\u63a5\u5b8c\u6210\u65f6\u89e6\u53d1 this . _handle . onconnection = onconnection ; const err = this . _handle . listen ( backlog || 511 ); if ( err ) { // \u89e6\u53d1error\u4e8b\u4ef6 } // \u4e0b\u4e00\u4e2atick\u89e6\u53d1listen\u56de\u8c03 defaultTriggerAsyncIdScope ( this [ async_id_symbol ], process . nextTick , emitListeningNT , this ); } \u9996\u5148\u8c03\u7528createServerHandle\u521b\u5efa\u4e00\u4e2ahandle\uff0c\u7136\u540e\u6267\u884clisten\u51fd\u6570\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bcreateServerHandle\u3002 1 2 3 4 5 6 7 8 9 function createServerHandle ( address , port , addressType , fd , flags ) { let handle = new Pipe ( PipeConstants . SERVER ); handle . bind ( address , port ); return handle ; } \u521b\u5efa\u4e86\u4e00\u4e2aPipe\u5bf9\u8c61\uff0c\u7136\u540e\u8c03\u7528\u5b83\u7684bind\u548clisten\u51fd\u6570\uff0c\u6211\u4eec\u770bnew Pipe\u7684\u903b\u8f91\uff0c\u4ecepipe_wrap.cc\u7684\u5bfc\u51fa\u903b\u8f91\uff0c\u6211\u4eec\u77e5\u9053\uff0c\u8fd9\u65f6\u5019\u4f1a\u65b0\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u7136\u540e\u6267\u884cNew\u51fd\u6570\uff0c\u5e76\u4e14\u628a\u65b0\u5efa\u7684C++\u5bf9\u8c61\u7b49\u4fe1\u606f\u4f5c\u4e3a\u5165\u53c2\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 void PipeWrap::New ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); // \u7c7b\u578b int type_value = args [ 0 ]. As < Int32 > () -> Value (); PipeWrap :: SocketType type = static_cast < PipeWrap :: SocketType > ( type_value ); // \u662f\u5426\u662f\u7528\u4e8eIPC bool ipc ; ProviderType provider ; switch ( type ) { case SOCKET : provider = PROVIDER_PIPEWRAP ; ipc = false ; break ; case SERVER : provider = PROVIDER_PIPESERVERWRAP ; ipc = false ; break ; case IPC : provider = PROVIDER_PIPEWRAP ; ipc = true ; break ; default : UNREACHABLE (); } new PipeWrap ( env , args . This (), provider , ipc ); } New\u51fd\u6570\u5904\u7406\u4e86\u53c2\u6570\uff0c\u7136\u540e\u6267\u884c\u4e86new PipeWrap\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 PipeWrap :: PipeWrap ( Environment * env , Local < Object > object , ProviderType provider , bool ipc ) : ConnectionWrap ( env , object , provider ) { int r = uv_pipe_init ( env -> event_loop (), & handle_ , ipc ); } new Pipe\u6267\u884c\u5b8c\u540e\uff0c\u5c31\u4f1a\u901a\u8fc7\u8be5C++\u5bf9\u8c61\u8c03\u7528Libuv\u7684bind\u548clisten\u5b8c\u6210\u670d\u52a1\u5668\u7684\u542f\u52a8\uff0c\u5c31\u4e0d\u518d\u5c55\u5f00\u5206\u6790\u3002","title":"9.2.1 Unix\u57df\u670d\u52a1\u5668"},{"location":"chapter09-Unix%E5%9F%9F/#922-unix","text":"\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bUnix\u57df\u4f5c\u4e3a\u5ba2\u6237\u7aef\u4f7f\u7528\u65f6\u7684\u8fc7\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Socket . prototype . connect = function (... args ) { const path = options . path ; // Unix\u57df\u8def\u5f84 var pipe = !! path ; if ( ! this . _handle ) { // \u521b\u5efa\u4e00\u4e2aC++\u5c42handle\uff0c\u5373pipe_wrap.cc\u5bfc\u51fa\u7684Pipe\u7c7b this . _handle = pipe ? new Pipe ( PipeConstants . SOCKET ) : new TCP ( TCPConstants . SOCKET ); // \u6302\u8f7donread\u65b9\u6cd5\u5230this\u4e2d initSocketHandle ( this ); } if ( cb !== null ) { this . once ( 'connect' , cb ); } // \u6267\u884cinternalConnect defaultTriggerAsyncIdScope ( this [ async_id_symbol ], internalConnect , this , path ); return this ; }; \u9996\u5148\u65b0\u5efa\u4e00\u4e2ahandle\uff0c\u503c\u662fnew Pipe\u3002\u63a5\u7740\u6267\u884c\u4e86internalConnect\uff0cinternalConnect\u51fd\u6570\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 2 3 4 5 6 const req = new PipeConnectWrap (); // address\u4e3aUnix\u57df\u8def\u5f84 req . address = address ; req . oncomplete = afterConnect ; // \u8c03\u7528C++\u5c42connect err = self . _handle . connect ( req , address , afterConnect ); \u6211\u4eec\u770bC++\u5c42\u7684connect\u51fd\u6570\uff0c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void PipeWrap::Connect ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); PipeWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder ()); // PipeConnectWrap\u5bf9\u8c61 Local < Object > req_wrap_obj = args [ 0 ]. As < Object > (); // Unix\u57df\u8def\u5f84 node :: Utf8Value name ( env -> isolate (), args [ 1 ]); /* \u65b0\u5efa\u4e00\u4e2aConnectWrap\u5bf9\u8c61\uff0cConnectWrap\u662f\u5bf9handle\u8fdb\u884c\u4e00\u6b21\u8fde\u63a5\u8bf7\u6c42 \u7684\u5c01\u88c5\uff0c\u5185\u90e8\u7ef4\u62a4\u4e00\u4e2auv_connect_t\u7ed3\u6784\u4f53\uff0c req_wrap_obj\u7684\u4e00\u4e2a\u5b57\u6bb5 \u6307\u5411ConnectWrap\u5bf9\u8c61\uff0c\u7528\u4e8e\u4fdd\u5b58\u5bf9\u5e94\u7684\u8bf7\u6c42\u4e0a\u4e0b\u6587 */ ConnectWrap * req_wrap = new ConnectWrap ( env , req_wrap_obj , AsyncWrap :: PROVIDER_PIPECONNECTWRAP ); // \u8c03\u7528Libuv\u7684connect\u51fd\u6570 uv_pipe_connect ( req_wrap -> req (), & wrap -> handle_ , * name , AfterConnect ); // req_wrap->req_.data = req_wrap;\u5173\u8054\u8d77\u6765 req_wrap -> Dispatched (); // uv_pipe_connect() doesn't return errors. args . GetReturnValue (). Set ( 0 ); } uv_pipe_connect\u51fd\u6570\uff0c\u7b2c\u4e00\u4e2a\u53c2\u6570\u662fuv_connect_t\u7ed3\u6784\u4f53\uff08request\uff09\uff0c\u7b2c\u4e8c\u4e2a\u662f\u4e00\u4e2auv_pipe_t\u7ed3\u6784\u4f53\uff08handle\uff09\uff0chandle\u662f\u5bf9Unix\u57df\u5ba2\u6237\u7aef\u7684\u5c01\u88c5\uff0crequest\u662f\u8bf7\u6c42\u7684\u5c01\u88c5\uff0c\u5b83\u8868\u793a\u57fa\u4e8ehandle\u53d1\u8d77\u4e00\u6b21\u8fde\u63a5\u8bf7\u6c42\u3002\u8fde\u63a5\u6210\u529f\u540e\u4f1a\u6267\u884cAfterConnect\u3002\u7531\u524d\u9762\u5206\u6790\u6211\u4eec\u77e5\u9053\uff0c\u5f53\u8fde\u63a5\u6210\u529f\u65f6\uff0c\u9996\u5148\u4f1a\u6267\u884c\u56de\u8c03Libuv\u7684uv__stream_io\uff0c\u7136\u540e\u6267\u884cC++\u5c42\u7684AfterConnect\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // \u4e3b\u52a8\u53d1\u8d77\u8fde\u63a5\uff0c\u6210\u529f/\u5931\u8d25\u540e\u7684\u56de\u8c03 template < typename WrapType , typename UVType > = PipeWrap , uv_pipe_t void ConnectionWrap < WrapType , UVType >:: AfterConnect ( uv_connect_t * req , int status ) { // \u5728Connect\u51fd\u6570\u91cc\u5173\u8054\u8d77\u6765\u7684 ConnectWrap * req_wrap = static_cast < ConnectWrap *> ( req -> data ); // \u5728uv_pipe_connect\u4e2d\u5b8c\u6210\u5173\u8054\u7684 WrapType * wrap = static_cast < WrapType *> ( req -> handle -> data ); Environment * env = wrap -> env (); HandleScope handle_scope ( env -> isolate ()); Context :: Scope context_scope ( env -> context ()); bool readable , writable ; // \u662f\u5426\u8fde\u63a5\u6210\u529f if ( status ) { readable = writable = 0 ; } else { readable = uv_is_readable ( req -> handle ) != 0 ; writable = uv_is_writable ( req -> handle ) != 0 ; } Local < Value > argv [ 5 ] = { Integer :: New ( env -> isolate (), status ), wrap -> object (), req_wrap -> object (), Boolean :: New ( env -> isolate (), readable ), Boolean :: New ( env -> isolate (), writable ) }; // \u6267\u884cJS\u5c42\u7684oncomplete\u56de\u8c03 req_wrap -> MakeCallback ( env -> oncomplete_string (), arraysize ( argv ), argv ); delete req_wrap ; } \u6211\u4eec\u518d\u56de\u5230JS\u5c42\u7684afterConnect 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function afterConnect ( status , handle , req , readable , writable ) { var self = handle . owner ; handle = self . _handle ; if ( status === 0 ) { self . readable = readable ; self . writable = writable ; self . _unrefTimer (); // \u89e6\u53d1connect\u4e8b\u4ef6 self . emit ( 'connect' ); // \u53ef\u8bfb\u5e76\u4e14\u6ca1\u6709\u5904\u4e8e\u6682\u505c\u6a21\u5f0f\uff0c\u5219\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 if ( readable && ! self . isPaused ()) self . read ( 0 ); } } \u81f3\u6b64\uff0c\u4f5c\u4e3a\u5ba2\u6237\u7aef\u5bf9\u670d\u52a1\u5668\u7684\u8fde\u63a5\u5c31\u5b8c\u6210\u4e86\u3002\u540e\u7eed\u5c31\u53ef\u4ee5\u8fdb\u884c\u901a\u4fe1\u3002","title":"9.2.2 Unix\u57df\u5ba2\u6237\u7aef"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/","text":"Node.js V14\u5bf9\u5b9a\u65f6\u5668\u6a21\u5757\u8fdb\u884c\u4e86\u91cd\u6784\uff0c\u4e4b\u524d\u7248\u672c\u7684\u5b9e\u73b0\u662f\u7528\u4e00\u4e2amap\uff0c\u4ee5\u8d85\u65f6\u65f6\u95f4\u4e3a\u952e\uff0c\u6bcf\u4e2a\u952e\u5bf9\u5e94\u4e00\u4e2a\u961f\u5217\u3002\u5373\u6709\u540c\u6837\u8d85\u65f6\u65f6\u95f4\u7684\u8282\u70b9\u5728\u540c\u4e00\u4e2a\u961f\u5217\u3002\u6bcf\u4e2a\u961f\u5217\u5bf9\u5e94\u4e00\u4e2a\u5e95\u5c42\u7684\u4e00\u4e2a\u8282\u70b9\uff08\u4e8c\u53c9\u5806\u91cc\u7684\u8282\u70b9\uff09\uff0cNode.js\u5728\u4e8b\u4ef6\u5faa\u73af\u7684timer\u9636\u6bb5\u4f1a\u4ece\u4e8c\u53c9\u5806\u91cc\u627e\u51fa\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03\uff0c\u56de\u8c03\u91cc\u4f1a\u904d\u5386\u961f\u5217\uff0c\u5224\u65ad\u54ea\u4e2a\u8282\u70b9\u8d85\u65f6\u4e86\u300214\u91cd\u6784\u540e\uff0c\u53ea\u4f7f\u7528\u4e86\u4e00\u4e2a\u4e8c\u53c9\u5806\u7684\u8282\u70b9\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u7684\u5b9e\u73b0\uff0c\u9996\u5148\u770b\u4e0b\u5b9a\u65f6\u5668\u6a21\u5757\u7684\u6574\u4f53\u5173\u7cfb\u56fe\uff0c\u5982\u56fe10-1\u6240\u793a\u3002 \u56fe10-1 \u4e0b\u9762\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u5b9a\u65f6\u5668\u6a21\u5757\u7684\u51e0\u4e2a\u91cd\u8981\u7684\u6570\u636e\u7ed3\u6784\u3002 10.1 Libuv\u7684\u5b9e\u73b0 \u00b6 Libuv\u4e2d\u4f7f\u7528\u4e8c\u53c9\u5806\u5b9e\u73b0\u4e86\u5b9a\u65f6\u5668\u3002\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9\u662f\u6839\u8282\u70b9\u3002 10.1.1 Libuv\u4e2d\u7ef4\u62a4\u5b9a\u65f6\u5668\u7684\u6570\u636e\u7ed3\u6784 \u00b6 1 2 3 4 // \u53d6\u51faloop\u4e2d\u7684\u8ba1\u65f6\u5668\u5806\u6307\u9488 static struct heap * timer_heap ( const uv_loop_t * loop ) { return ( struct heap * ) & loop -> timer_heap ; } 10.1.2 \u6bd4\u8f83\u51fd\u6570 \u00b6 \u56e0\u4e3aLibuv\u4f7f\u7528\u4e8c\u53c9\u5806\u5b9e\u73b0\u5b9a\u65f6\u5668\uff0c\u8fd9\u5c31\u6d89\u53ca\u5230\u8282\u70b9\u63d2\u5165\u5806\u7684\u65f6\u5019\u7684\u89c4\u5219\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 static int timer_less_than ( const struct heap_node * ha , const struct heap_node * hb ) { const uv_timer_t * a ; const uv_timer_t * b ; // \u901a\u8fc7\u7ed3\u6784\u4f53\u6210\u5458\u627e\u5230\u7ed3\u6784\u4f53\u9996\u5730\u5740 a = container_of ( ha , uv_timer_t , heap_node ); b = container_of ( hb , uv_timer_t , heap_node ); // \u6bd4\u8f83\u4e24\u4e2a\u7ed3\u6784\u4f53\u4e2d\u7684\u8d85\u65f6\u65f6\u95f4 if ( a -> timeout < b -> timeout ) return 1 ; if ( b -> timeout < a -> timeout ) return 0 ; // \u8d85\u65f6\u65f6\u95f4\u4e00\u6837\u7684\u8bdd\uff0c\u770b\u8c01\u5148\u521b\u5efa if ( a -> start_id < b -> start_id ) return 1 ; if ( b -> start_id < a -> start_id ) return 0 ; return 0 ; } 10.1.3 \u521d\u59cb\u5316\u5b9a\u65f6\u5668\u7ed3\u6784\u4f53 \u00b6 \u5982\u679c\u9700\u8981\u4f7f\u7528\u5b9a\u65f6\u5668\uff0c\u9996\u5148\u8981\u5bf9\u5b9a\u65f6\u5668\u7684\u7ed3\u6784\u4f53\u8fdb\u884c\u521d\u59cb\u5316\u3002 1 2 3 4 5 6 7 // \u521d\u59cb\u5316uv_timer_t\u7ed3\u6784\u4f53 int uv_timer_init ( uv_loop_t * loop , uv_timer_t * handle ) { uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_TIMER ); handle -> timer_cb = NULL ; handle -> repeat = 0 ; return 0 ; } 10.1.4 \u63d2\u5165\u4e00\u4e2a\u5b9a\u65f6\u5668 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // \u542f\u52a8\u4e00\u4e2a\u8ba1\u65f6\u5668 int uv_timer_start ( uv_timer_t * handle , uv_timer_cb cb , uint64_t timeout , uint64_t repeat ) { uint64_t clamped_timeout ; if ( cb == NULL ) return UV_EINVAL ; // \u91cd\u65b0\u6267\u884cstart\u7684\u65f6\u5019\u5148\u628a\u4e4b\u524d\u7684\u505c\u6389 if ( uv__is_active ( handle )) uv_timer_stop ( handle ); // \u8d85\u65f6\u65f6\u95f4\uff0c\u4e3a\u7edd\u5bf9\u503c clamped_timeout = handle -> loop -> time + timeout ; if ( clamped_timeout < timeout ) clamped_timeout = ( uint64_t ) -1 ; // \u521d\u59cb\u5316\u56de\u8c03\uff0c\u8d85\u65f6\u65f6\u95f4\uff0c\u662f\u5426\u91cd\u590d\u8ba1\u65f6\uff0c\u8d4b\u4e88\u4e00\u4e2a\u72ec\u7acb\u65e0\u4e8c\u7684id handle -> timer_cb = cb ; handle -> timeout = clamped_timeout ; handle -> repeat = repeat ; // \u7528\u4e8e\u8d85\u65f6\u65f6\u95f4\u4e00\u6837\u7684\u65f6\u5019\uff0c\u6bd4\u8f83\u5b9a\u65f6\u5668\u5728\u4e8c\u53c9\u5806\u7684\u4f4d\u7f6e\uff0c\u89c1cmp\u51fd\u6570 handle -> start_id = handle -> loop -> timer_counter ++ ; // \u63d2\u5165\u6700\u5c0f\u5806 heap_insert ( timer_heap ( handle -> loop ), ( struct heap_node * ) & handle -> heap_node , timer_less_than ); // \u6fc0\u6d3b\u8be5handle uv__handle_start ( handle ); return 0 ; } 10.1.5 \u505c\u6b62\u4e00\u4e2a\u5b9a\u65f6\u5668 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 // \u505c\u6b62\u4e00\u4e2a\u8ba1\u65f6\u5668 int uv_timer_stop ( uv_timer_t * handle ) { if ( ! uv__is_active ( handle )) return 0 ; // \u4ece\u6700\u5c0f\u5806\u4e2d\u79fb\u9664\u8be5\u8ba1\u65f6\u5668\u8282\u70b9 heap_remove ( timer_heap ( handle -> loop ), ( struct heap_node * ) & handle -> heap_node , timer_less_than ); // \u6e05\u9664\u6fc0\u6d3b\u72b6\u6001\u548chandle\u7684active\u6570\u51cf\u4e00 uv__handle_stop ( handle ); return 0 ; } 10.1.6 \u91cd\u65b0\u8bbe\u7f6e\u5b9a\u65f6\u5668 \u00b6 \u91cd\u65b0\u8bbe\u7f6e\u5b9a\u65f6\u5668\u7c7b\u4f3c\u63d2\u5165\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u5b83\u9996\u5148\u9700\u8981\u628a\u4e4b\u524d\u7684\u5b9a\u65f6\u5668\u4ece\u4e8c\u53c9\u5806\u4e2d\u79fb\u9664\uff0c\u7136\u540e\u91cd\u65b0\u63d2\u5165\u4e8c\u53c9\u5806\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // \u91cd\u65b0\u542f\u52a8\u4e00\u4e2a\u8ba1\u65f6\u5668\uff0c\u9700\u8981\u8bbe\u7f6erepeat\u6807\u8bb0 int uv_timer_again ( uv_timer_t * handle ) { if ( handle -> timer_cb == NULL ) return UV_EINVAL ; // \u5982\u679c\u8bbe\u7f6e\u4e86repeat\u6807\u8bb0\u8bf4\u660e\u8ba1\u65f6\u5668\u662f\u9700\u8981\u91cd\u590d\u89e6\u53d1\u7684 if ( handle -> repeat ) { // \u5148\u628a\u65e7\u7684\u8282\u70b9\u4ece\u6700\u5c0f\u5806\u4e2d\u79fb\u9664\uff0c\u7136\u540e\u518d\u91cd\u65b0\u5f00\u542f\u4e00\u4e2a\u8ba1\u65f6\u5668 uv_timer_stop ( handle ); uv_timer_start ( handle , handle -> timer_cb , handle -> repeat , handle -> repeat ); } return 0 ; } 10.1.7 \u8ba1\u7b97\u4e8c\u53c9\u5806\u4e2d\u8d85\u65f6\u65f6\u95f4\u6700\u5c0f\u503c \u00b6 \u8d85\u65f6\u65f6\u95f4\u6700\u5c0f\u503c\uff0c\u4e3b\u8981\u7528\u4e8e\u5224\u65adPoll IO\u8282\u70b9\u662f\u963b\u585e\u7684\u6700\u957f\u65f6\u95f4\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // \u8ba1\u7b97\u6700\u5c0f\u5806\u4e2d\u6700\u5c0f\u8282\u70b9\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u5373\u6700\u5c0f\u7684\u8d85\u65f6\u65f6\u95f4 int uv__next_timeout ( const uv_loop_t * loop ) { const struct heap_node * heap_node ; const uv_timer_t * handle ; uint64_t diff ; // \u53d6\u51fa\u5806\u7684\u6839\u8282\u70b9\uff0c\u5373\u8d85\u65f6\u65f6\u95f4\u6700\u5c0f\u7684 heap_node = heap_min ( timer_heap ( loop )); if ( heap_node == NULL ) return -1 ; /* block indefinitely */ handle = container_of ( heap_node , uv_timer_t , heap_node ); // \u5982\u679c\u6700\u5c0f\u7684\u8d85\u65f6\u65f6\u95f4\u5c0f\u4e8e\u5f53\u524d\u65f6\u95f4\uff0c\u5219\u8fd4\u56de0\uff0c\u8bf4\u660e\u5df2\u7ecf\u8d85\u65f6 if ( handle -> timeout <= loop -> time ) return 0 ; // \u5426\u5219\u8ba1\u7b97\u8fd8\u6709\u591a\u4e45\u8d85\u65f6\uff0c\u8fd4\u56de\u7ed9epoll\uff0cepoll\u7684timeout\u4e0d\u80fd\u5927\u4e8ediff diff = handle -> timeout - loop -> time ; if ( diff > INT_MAX ) diff = INT_MAX ; return diff ; } 10.1.8 \u5904\u7406\u5b9a\u65f6\u5668 \u00b6 \u5904\u7406\u8d85\u65f6\u5b9a\u65f6\u5668\u5c31\u662f\u904d\u5386\u4e8c\u53c9\u5806\uff0c\u5224\u65ad\u54ea\u4e2a\u8282\u70b9\u8d85\u65f6\u4e86\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // \u627e\u51fa\u5df2\u7ecf\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u5e76\u4e14\u6267\u884c\u91cc\u9762\u7684\u56de\u8c03 void uv__run_timers ( uv_loop_t * loop ) { struct heap_node * heap_node ; uv_timer_t * handle ; for (;;) { heap_node = heap_min ( timer_heap ( loop )); if ( heap_node == NULL ) break ; handle = container_of ( heap_node , uv_timer_t , heap_node ); // \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u65f6\u95f4\u5927\u4e8e\u5f53\u524d\u65f6\u95f4\u5219\u8fd4\u56de\uff0c\u8bf4\u660e\u540e\u9762\u7684\u8282\u70b9\u4e5f\u6ca1\u6709\u8d85\u65f6 if ( handle -> timeout > loop -> time ) break ; // \u79fb\u9664\u8be5\u8ba1\u65f6\u5668\u8282\u70b9\uff0c\u91cd\u65b0\u63d2\u5165\u6700\u5c0f\u5806\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86repeat\u7684\u8bdd uv_timer_stop ( handle ); uv_timer_again ( handle ); // \u6267\u884c\u8d85\u65f6\u56de\u8c03 handle -> timer_cb ( handle ); } } 10.2 \u6838\u5fc3\u6570\u636e\u7ed3\u6784 \u00b6 10.2.1 TimersList \u00b6 \u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u4e00\u6837\u7684\u5b9a\u65f6\u5668\u4f1a\u88ab\u653e\u5230\u540c\u4e00\u4e2a\u961f\u5217\uff0c\u6bd4\u5982\u5f53\u524d\u6267\u884csetTimeout(()=>{}, 10000})\u548c5\u79d2\u540e\u6267\u884csetTimeout(()=>{}, 10000})\uff0c\u8fd9\u4e24\u4e2a\u4efb\u52a1\u5c31\u4f1a\u5728\u540c\u4e00\u4e2aList\u4e2d\uff0c\u8fd9\u4e2a\u961f\u5217\u7531TimersList\u6765\u7ba1\u7406\u3002\u5bf9\u5e94\u56fe1\u4e2d\u7684List\u90a3\u4e2a\u961f\u5217\u3002 1 2 3 4 5 6 7 8 9 10 function TimersList ( expiry , msecs ) { // \u7528\u4e8e\u94fe\u8868 this . _idleNext = this ; this . _idlePrev = this ; this . expiry = expiry ; this . id = timerListId ++ ; this . msecs = msecs ; // \u5728\u4f18\u5148\u961f\u5217\u91cc\u7684\u4f4d\u7f6e this . priorityQueuePosition = null ; } expiry\u8bb0\u5f55\u7684\u662f\u94fe\u8868\u4e2d\u6700\u5feb\u8d85\u65f6\u7684\u8282\u70b9\u7684\u7edd\u5bf9\u65f6\u95f4\u3002\u6bcf\u6b21\u6267\u884c\u5b9a\u65f6\u5668\u9636\u6bb5\u65f6\u4f1a\u52a8\u6001\u66f4\u65b0\uff0cmsecs\u662f\u8d85\u65f6\u65f6\u95f4\u7684\u76f8\u5bf9\u503c\uff08\u76f8\u5bf9\u63d2\u5165\u65f6\u7684\u5f53\u524d\u65f6\u95f4\uff09\u3002\u7528\u4e8e\u8ba1\u7b97\u8be5\u94fe\u8868\u4e2d\u7684\u8282\u70b9\u662f\u5426\u8d85\u65f6\u3002\u540e\u7eed\u6211\u4eec\u4f1a\u770b\u5230\u5177\u4f53\u7684\u7528\u5904\u3002 10.2.2 \u4f18\u5148\u961f\u5217 \u00b6 1 const timerListQueue = new PriorityQueue ( compareTimersLists , setPosition ) Node.js\u7528\u4f18\u5148\u961f\u5217\u5bf9\u6240\u6709TimersList\u94fe\u8868\u8fdb\u884c\u7ba1\u7406\uff0c\u4f18\u5148\u961f\u5217\u672c\u8d28\u662f\u4e00\u4e2a\u4e8c\u53c9\u5806\uff08\u5c0f\u6839\u5806\uff09\uff0c\u6bcf\u4e2aTimersList\u94fe\u8868\u5728\u4e8c\u53c9\u5806\u91cc\u5bf9\u5e94\u4e00\u4e2a\u8282\u70b9\u3002\u6839\u636eTimersList\u7684\u7ed3\u6784\uff0c\u6211\u4eec\u77e5\u9053\u6bcf\u4e2a\u94fe\u8868\u90fd\u4fdd\u5b58\u94fe\u8868\u4e2d\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9\u7684\u8fc7\u671f\u65f6\u95f4\u3002\u4e8c\u53c9\u5806\u4ee5\u8be5\u65f6\u95f4\u4e3a\u4f9d\u636e\uff0c\u5373\u6700\u5feb\u5230\u671f\u7684list\u5bf9\u5e94\u4e8c\u53c9\u5806\u4e2d\u7684\u6839\u8282\u70b9\u3002\u6839\u8282\u70b9\u7684\u5230\u671f\u65f6\u95f4\u5c31\u662f\u6574\u4e2aNode.js\u5b9a\u65f6\u5668\u6700\u5feb\u5230\u671f\u7684\u65f6\u95f4\uff0cNode.js\u628aLibuv\u4e2d\u5b9a\u65f6\u5668\u8282\u70b9\u7684\u8d85\u65f6\u65f6\u95f4\u8bbe\u7f6e\u4e3a\u8be5\u503c\uff0c\u5728\u4e8b\u4ef6\u5faa\u73af\u7684\u5b9a\u65f6\u5668\u9636\u6bb5\u5c31\u4f1a\u5904\u7406\u5b9a\u65f6\u7684\u8282\u70b9\uff0c\u5e76\u4e14\u4e0d\u65ad\u904d\u5386\u4f18\u5148\u961f\u5217\uff0c\u5224\u65ad\u5f53\u524d\u8282\u70b9\u662f\u5426\u8d85\u65f6\uff0c\u5982\u679c\u8d85\u65f6\u4e86\uff0c\u5c31\u9700\u8981\u5904\u7406\uff0c\u5982\u679c\u6ca1\u6709\u8d85\u65f6\uff0c\u8bf4\u660e\u6574\u4e2a\u4e8c\u53c9\u5806\u7684\u8282\u70b9\u90fd\u6ca1\u6709\u8d85\u65f6\u3002\u7136\u540e\u91cd\u65b0\u8bbe\u7f6eLibuv\u5b9a\u65f6\u5668\u8282\u70b9\u65b0\u7684\u5230\u671f\u65f6\u95f4\u3002 \u53e6\u5916\uff0cNode.js\u4e2d\u7528\u4e00\u4e2amap\u4fdd\u5b58\u4e86\u8d85\u65f6\u65f6\u95f4\u5230TimersList\u94fe\u8868\u7684\u6620\u5c04\u5173\u7cfb\u3002 \u8fd9\u6837\u5c31\u53ef\u4ee5\u6839\u636e\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u5feb\u901f\u627e\u5230\u5bf9\u5e94\u7684\u5217\u8868\uff0c\u5229\u7528\u7a7a\u95f4\u6362\u65f6\u95f4\u3002\u4e86\u89e3\u5b8c\u5b9a\u65f6\u5668\u6574\u4f53\u7684\u7ec4\u7ec7\u548c\u6838\u5fc3\u6570\u636e\u7ed3\u6784\uff0c\u6211\u4eec\u53ef\u4ee5\u5f00\u59cb\u8fdb\u5165\u771f\u6b63\u7684\u6e90\u7801\u5206\u6790\u4e86\u3002 10.3 \u8bbe\u7f6e\u5b9a\u65f6\u5668\u5904\u7406\u51fd\u6570 \u00b6 Node.js\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u4e86\u5904\u7406\u5b9a\u65f6\u5668\u7684\u51fd\u6570\u3002 setupTimers(processImmediate, processTimers); setupTimers\u5bf9\u5e94\u7684C++\u51fd\u6570\u662f 1 2 3 4 5 void SetupTimers ( const FunctionCallbackInfo < Value >& args ) { auto env = Environment :: GetCurrent ( args ); env -> set_immediate_callback_function ( args [ 0 ]. As < Function > ()); env -> set_timers_callback_function ( args [ 1 ]. As < Function > ()); } SetupTimers\u5728env\u4e2d\u4fdd\u5b58\u4e86\u4e24\u4e2a\u51fd\u6570\uff0cprocessImmediate\u662f\u5904\u7406setImmediate\u7684\uff0cprocessTimers\u662f\u5904\u7406\u5b9a\u65f6\u5668\u7684\u3002\u5f53\u6709\u8282\u70b9\u8d85\u65f6\u65f6\uff0cNode.js\u4f1a\u6267\u884c\u8be5\u51fd\u6570\u5904\u7406\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u540e\u7eed\u4f1a\u770b\u5230\u8be5\u51fd\u6570\u7684\u5177\u4f53\u5904\u7406\u903b\u8f91\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u8bbe\u7f6e\u4e00\u4e2a\u5b9a\u65f6\u5668\u3002 10.4 \u8bbe\u7f6e\u5b9a\u65f6\u5668 \u00b6 1 2 3 4 5 6 7 8 9 10 11 function setTimeout ( callback , after , arg1 , arg2 , arg3 ) { // \u5ffd\u7565\u5904\u7406\u53c2\u6570args\u903b\u8f91 // \u65b0\u5efa\u4e00\u4e2aTimeout\u5bf9\u8c61 const timeout = new Timeout ( callback , after , args , false , true ); insert ( timeout , timeout . _idleTimeout ); return timeout ; } setTimeout\u4e3b\u8981\u5305\u542b\u4e24\u4e2a\u64cd\u4f5c\uff0cnew Timeout\u548cinsert\u3002\u6211\u4eec\u9010\u4e2a\u5206\u6790\u4e00\u4e0b\u3002 1 setTimeout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function Timeout ( callback , after , args , isRepeat , isRefed ) { after *= 1 ; // Coalesce to number or NaN // \u5173\u4e8esetTimeout\u7684\u8d85\u65f6\u65f6\u95f4\u4e3a0\u7684\u95ee\u9898\u5728\u8fd9\u91cc\u53ef\u4ee5\u63ed\u5f00\u8ff7\u96fe if ( ! ( after >= 1 && after <= TIMEOUT_MAX )) { after = 1 ; } // \u8d85\u65f6\u65f6\u95f4\u76f8\u5bf9\u503c this . _idleTimeout = after ; // \u524d\u540e\u6307\u9488\uff0c\u7528\u4e8e\u94fe\u8868 this . _idlePrev = this ; this . _idleNext = this ; // \u5b9a\u65f6\u5668\u7684\u5f00\u59cb\u65f6\u95f4 this . _idleStart = null ; // \u8d85\u65f6\u56de\u8c03 this . _onTimeout = callback ; // \u6267\u884c\u56de\u8c03\u65f6\u4f20\u5165\u7684\u53c2\u6570 this . _timerArgs = args ; // \u662f\u5426\u5b9a\u671f\u89e6\u53d1\u8d85\u65f6\uff0c\u7528\u4e8esetInterval this . _repeat = isRepeat ? after : null ; this . _destroyed = false ; // this._idleStart = now(); // \u6fc0\u6d3b\u5e95\u5c42\u7684\u5b9a\u65f6\u5668\u8282\u70b9\uff08\u4e8c\u53c9\u5806\u7684\u8282\u70b9\uff09\uff0c\u8bf4\u660e\u6709\u5b9a\u65f6\u8282\u70b9\u9700\u8981\u5904\u7406 if ( isRefed ) incRefCount (); // \u8bb0\u5f55\u72b6\u6001 this [ kRefed ] = isRefed ; } Timeout\u4e3b\u8981\u662f\u65b0\u5efa\u4e00\u4e2a\u5bf9\u8c61\u8bb0\u5f55\u4e00\u4e9b\u5b9a\u65f6\u5668\u7684\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\uff08\u7528\u4e8e\u652f\u6301setInterval\uff0c\u91cd\u65b0\u63d2\u5165\u961f\u5217\u65f6\u627e\u5230\u6240\u5c5e\u961f\u5217\uff09\u3001\u5f00\u59cb\u65f6\u95f4\uff08\u7528\u4e8e\u8ba1\u7b97\u5b9a\u65f6\u5668\u662f\u5426\u8d85\u65f6\uff09\u7b49\u4e0a\u4e0b\u6587\u4fe1\u606f\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\u5173\u952e\u7684\u903b\u8f91\u662fisRefed\u7684\u503c\u3002Node.js\u652f\u6301ref\u548cunref\u72b6\u6001\u7684\u5b9a\u65f6\u5668\uff08setTimeout \u548csetUnrefTimeout\uff09\uff0cunref\u72b6\u6001\u7684\u5b9a\u65f6\u5668\uff0c\u4e0d\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002\u5373\u5f53\u53ea\u6709unref\u72b6\u6001\u7684\u5b9a\u65f6\u5668\u65f6\uff0c\u4e8b\u4ef6\u5faa\u73af\u4f1a\u7ed3\u675f\u3002\u5f53isRefed\u4e3atrue\u65f6\u4f1a\u6267\u884cincRefCount(); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function incRefCount () { if ( refCount ++ === 0 ) toggleTimerRef ( true ); } void ToggleTimerRef ( const FunctionCallbackInfo < Value >& args ) { Environment :: GetCurrent ( args ) -> ToggleTimerRef ( args [ 0 ] -> IsTrue ()); } void Environment::ToggleTimerRef ( bool ref ) { if ( started_cleanup_ ) return ; // \u6253\u4e0aref\u6807\u8bb0\uff0c if ( ref ) { uv_ref ( reinterpret_cast < uv_handle_t *> ( timer_handle ())); } else { uv_unref ( reinterpret_cast < uv_handle_t *> ( timer_handle ())); } } \u6211\u4eec\u770b\u5230\u6700\u7ec8\u4f1a\u8c03\u7528Libuv\u7684uv_ref\u6216uv_unref\u4fee\u6539\u5b9a\u65f6\u5668\u76f8\u5173handle\u7684\u72b6\u6001\uff0c\u56e0\u4e3aNode.js\u53ea\u4f1a\u5728Libuv\u4e2d\u6ce8\u518c\u4e00\u4e2a\u5b9a\u65f6\u5668handle\u5e76\u4e14\u662f\u5e38\u9a7b\u7684\uff0c\u5982\u679cJS\u5c42\u5f53\u524d\u6ca1\u6709\u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u5219\u9700\u8981\u4fee\u6539\u5b9a\u65f6\u5668handle\u7684\u72b6\u6001\u4e3aunref\uff0c\u5426\u5219\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002refCount\u503c\u4fbf\u662f\u8bb0\u5f55JS\u5c42ref\u72b6\u6001\u7684\u5b9a\u65f6\u5668\u4e2a\u6570\u7684\u3002\u6240\u4ee5\u5f53\u6211\u4eec\u7b2c\u4e00\u6b21\u6267\u884csetTimeout\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u6fc0\u6d3bLibuv\u7684\u5b9a\u65f6\u5668\u8282\u70b9\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0binsert\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 let nextExpiry = Infinity ; function insert ( item , msecs , start = getLibuvNow ()) { msecs = MathTrunc ( msecs ); // \u8bb0\u5f55\u5b9a\u65f6\u5668\u7684\u5f00\u59cb\u65f6\u95f4\uff0c\u89c1Timeout\u51fd\u6570\u7684\u5b9a\u4e49 item . _idleStart = start ; // \u8be5\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u662f\u5426\u5df2\u7ecf\u5b58\u5728\u5bf9\u5e94\u7684\u94fe\u8868 let list = timerListMap [ msecs ]; // \u8fd8\u6ca1\u6709 if ( list === undefined ) { // \u7b97\u51fa\u7edd\u5bf9\u8d85\u65f6\u65f6\u95f4\uff0c\u7b2c\u4e00\u4e2a\u8282\u70b9\u662f\u8be5\u94fe\u8868\u4e2d\u6700\u65e9\u5230\u671f\u7684\u8282\u70b9 const expiry = start + msecs ; // \u65b0\u5efa\u4e00\u4e2a\u94fe\u8868 timerListMap [ msecs ] = list = new TimersList ( expiry , msecs ); // \u63d2\u5165\u4f18\u5148\u961f\u5217 timerListQueue . insert ( list ); /* nextExpiry\u8bb0\u5f55\u6240\u6709\u8d85\u65f6\u8282\u70b9\u4e2d\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9\uff0c \u5982\u679c\u6709\u66f4\u5feb\u5230\u671f\u7684\uff0c\u5219\u4fee\u6539\u5e95\u5c42\u5b9a\u65f6\u5668\u8282\u70b9\u7684\u8fc7\u671f\u65f6\u95f4 */ if ( nextExpiry > expiry ) { // \u4fee\u6539\u5e95\u5c42\u8d85\u65f6\u8282\u70b9\u7684\u8d85\u65f6\u65f6\u95f4 scheduleTimer ( msecs ); nextExpiry = expiry ; } } // \u628a\u5f53\u524d\u8282\u70b9\u52a0\u5230\u94fe\u8868\u91cc L . append ( list , item ); } Insert\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 \u5982\u679c\u8be5\u8d85\u65f6\u65f6\u95f4\u8fd8\u6ca1\u6709\u5bf9\u5e94\u7684\u94fe\u8868\uff0c\u5219\u65b0\u5efa\u4e00\u4e2a\u94fe\u8868\uff0c\u6bcf\u4e2a\u94fe\u8868\u90fd\u4f1a\u8bb0\u5f55\u8be5\u94fe\u8868\u4e2d\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9\u7684\u503c\uff0c\u5373\u7b2c\u4e00\u4e2a\u63d2\u5165\u7684\u503c\u3002\u7136\u540e\u628a\u94fe\u8868\u63d2\u5165\u4f18\u5148\u961f\u5217\uff0c\u4f18\u5148\u961f\u5217\u4f1a\u6839\u636e\u8be5\u94fe\u8868\u7684\u6700\u5feb\u8fc7\u671f\u65f6\u95f4\u7684\u503c\uff0c\u628a\u94fe\u8868\u5bf9\u5e94\u7684\u8282\u70b9\u8c03\u6574\u5230\u76f8\u5e94\u7684\u4f4d\u7f6e\u3002 2 \u5982\u679c\u5f53\u524d\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\uff0c\u6bd4\u4e4b\u524d\u6240\u6709\u7684\u5b9a\u65f6\u5668\u90fd\u5feb\u5230\u671f\uff0c\u5219\u9700\u8981\u4fee\u6539\u5e95\u5c42\u7684\u5b9a\u65f6\u5668\u8282\u70b9\uff0c\u4f7f\u5f97\u66f4\u5feb\u89e6\u53d1\u8d85\u65f6\u3002 3 \u628a\u5f53\u524d\u7684\u5b9a\u65f6\u5668\u8282\u70b9\u63d2\u5165\u5bf9\u5e94\u7684\u94fe\u8868\u5c3e\u90e8\u3002\u5373\u8be5\u94fe\u8868\u4e2d\u6700\u4e45\u8d85\u65f6\u7684\u8282\u70b9\u3002 \u5047\u8bbe\u6211\u4eec\u57280s\u7684\u65f6\u5019\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u4e0b\u9762\u662f\u63d2\u5165\u7b2c\u4e00\u4e2a\u8282\u70b9\u65f6\u7684\u7ed3\u6784\u56fe\u5982\u56fe10-2\u6240\u793a\u3002 \u56fe10-2 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u591a\u4e2a\u8282\u70b9\u7684\u60c5\u51b5\u3002\u5047\u8bbe0s\u7684\u65f6\u5019\u63d2\u5165\u4e24\u4e2a\u8282\u70b910s\u8fc7\u671f\u548c11s\u8fc7\u671f\u3002\u5982\u56fe10-3\u6240\u793a\u3002 \u56fe10-3 \u7136\u540e\u57281s\u7684\u65f6\u5019\uff0c\u63d2\u5165\u4e00\u4e2a\u65b0\u768411s\u8fc7\u671f\u7684\u8282\u70b9\uff0c9s\u7684\u65f6\u5019\u63d2\u5165\u4e00\u4e2a\u65b0\u768410s\u8fc7\u671f\u8282\u70b9\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u65f6\u5019\u7684\u5173\u7cfb\u56fe\u5982\u56fe10-4\u6240\u793a\u3002 \u56fe10-4 \u6211\u4eec\u770b\u5230\u4f18\u5148\u961f\u5217\u4e2d\uff0c\u6bcf\u4e00\u4e2a\u8282\u70b9\u662f\u4e00\u4e2a\u94fe\u8868\uff0c\u7236\u8282\u70b9\u5bf9\u5e94\u7684\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u662f\u6bd4\u5b50\u8282\u70b9\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u5148\u8d85\u65f6\u7684\uff0c\u4f46\u662f\u94fe\u8868\u4e2d\u540e\u7eed\u8282\u70b9\u7684\u8d85\u65f6\u5c31\u4e0d\u4e00\u5b9a\u3002\u6bd4\u5982\u5b50\u8282\u70b91s\u5f00\u59cb\u7684\u8282\u70b9\u5c31\u6bd4\u7236\u8282\u70b99s\u5f00\u59cb\u7684\u8282\u70b9\u5148\u8d85\u65f6\u3002\u56e0\u4e3a\u540c\u4e00\u961f\u5217\uff0c\u53ea\u662f\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u4e00\u6837\uff0c\u800c\u8fd8\u6709\u4e00\u4e2a\u91cd\u8981\u7684\u56e0\u7d20\u662f\u5f00\u59cb\u7684\u65f6\u95f4\u3002\u867d\u7136\u67d0\u8282\u70b9\u7684\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u957f\uff0c\u4f46\u662f\u5982\u679c\u5b83\u6bd4\u53e6\u4e00\u4e2a\u8282\u70b9\u5f00\u59cb\u7684\u65e9\uff0c\u90a3\u4e48\u5c31\u6709\u53ef\u80fd\u6bd4\u5b83\u5148\u8d85\u65f6\u3002\u540e\u7eed\u6211\u4eec\u4f1a\u770b\u5230\u5177\u4f53\u662f\u600e\u4e48\u5b9e\u73b0\u7684\u3002 10.5 \u5904\u7406\u5b9a\u65f6\u5668 \u00b6 \u524d\u9762\u6211\u4eec\u8bb2\u5230\u4e86\u8bbe\u7f6e\u5b9a\u65f6\u5668\u5904\u7406\u51fd\u6570\u548c\u8bbe\u7f6e\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u4f46\u662f\u5728\u54ea\u91cc\u89e6\u53d1\u8fd9\u4e2a\u5904\u7406\u5b9a\u65f6\u5668\u7684\u51fd\u6570\u5462\uff1f\u7b54\u6848\u5728scheduleTimer\u51fd\u6570\u3002Node.js\u7684\u5b9e\u73b0\u4e2d\uff0c\u6240\u6709JS\u5c42\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\u5bf9\u5e94Libuv\u7684\u4e00\u4e2a\u5b9a\u65f6\u5668\u8282\u70b9\uff0cNode.js\u7ef4\u62a4\u4e86JS\u5c42\u6240\u6709\u5b9a\u65f6\u5668\u7684\u8d85\u65f6\u6700\u5c0f\u503c\u3002\u5728\u7b2c\u4e00\u4e2a\u8bbe\u7f6e\u5b9a\u65f6\u5668\u6216\u8005\u8bbe\u7f6e\u4e00\u4e2a\u65b0\u7684\u5b9a\u65f6\u5668\u65f6\uff0c\u5982\u679c\u65b0\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\u6bd4\u5f53\u524d\u7684\u6700\u5c0f\u503c\u5c0f\uff0c\u5219\u4f1a\u901a\u8fc7scheduleTimer\u4fee\u6539\u8d85\u65f6\u65f6\u95f4\u3002\u8d85\u65f6\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884c\u56de\u8c03\u3002scheduleTimer\u51fd\u6570\u662f\u5bf9C++\u51fd\u6570\u7684\u5c01\u88c5\u3002 1 2 3 4 5 6 7 8 9 void ScheduleTimer ( const FunctionCallbackInfo < Value >& args ) { auto env = Environment :: GetCurrent ( args ); env -> ScheduleTimer ( args [ 0 ] -> IntegerValue ( env -> context ()). FromJust ()); } void Environment::ScheduleTimer ( int64_t duration_ms ) { if ( started_cleanup_ ) return ; uv_timer_start ( timer_handle (), RunTimers , duration_ms , 0 ); } uv_timer_start\u5c31\u662f\u5f00\u542f\u5e95\u5c42\u8ba1\u65f6\uff0c\u5373\u5f80Libuv\u7684\u4e8c\u53c9\u5806\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff08\u5982\u679c\u8be5handle\u5df2\u7ecf\u5b58\u5728\u4e8c\u53c9\u5806\uff0c\u5219\u5148\u5220\u9664\uff09\u3002\u8d85\u65f6\u65f6\u95f4\u662fduration_ms\uff0c\u5c31\u662f\u6700\u5feb\u5230\u671f\u7684\u65f6\u95f4\uff0c\u8d85\u65f6\u56de\u8c03\u662fRunTimers\uff0c\u5728timer\u9636\u6bb5\u4f1a\u5224\u65ad\u662f\u5426\u8fc7\u671f\u3002\u662f\u7684\u8bdd\u6267\u884cRunTimers\u51fd\u6570\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bRunTimers\u51fd\u6570\u7684\u4e3b\u8981\u4ee3\u7801\u3002 1 2 Local < Function > cb = env -> timers_callback_function (); ret = cb -> Call ( env -> context (), process , 1 , & arg ); RunTimers\u4f1a\u6267\u884ctimers_callback_function\u3002timers_callback_function\u662f\u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u7684processTimers\u51fd\u6570\u3002\u73b0\u5728\u6211\u4eec\u77e5\u9053\u4e86Node.js\u662f\u5982\u4f55\u8bbe\u7f6e\u8d85\u65f6\u7684\u5904\u7406\u51fd\u6570\uff0c\u4e5f\u77e5\u9053\u4e86\u4ec0\u4e48\u65f6\u5019\u4f1a\u6267\u884c\u8be5\u56de\u8c03\u3002\u90a3\u6211\u4eec\u5c31\u6765\u770b\u4e00\u4e0b\u56de\u8c03\u65f6\u5177\u4f53\u5904\u7406\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 void Environment::RunTimers ( uv_timer_t * handle ) { Local < Function > cb = env -> timers_callback_function (); MaybeLocal < Value > ret ; Local < Value > arg = env -> GetNow (); do { // \u6267\u884cjs\u56de\u8c03processTimers\u51fd\u6570 ret = cb -> Call ( env -> context (), process , 1 , & arg ); } while ( ret . IsEmpty () && env -> can_call_into_js ()); // \u5982\u679c\u8fd8\u6709\u672a\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u5219ret\u4e3a\u7b2c\u4e00\u4e2a\u672a\u8d85\u65f6\u7684\u8282\u70b9\u7684\u8d85\u65f6\u65f6\u95f4 int64_t expiry_ms = ret . ToLocalChecked () -> IntegerValue ( env -> context ()). FromJust (); uv_handle_t * h = reinterpret_cast < uv_handle_t *> ( handle ); /* 1 \u7b49\u4e8e0\u8bf4\u660e\u6240\u6709\u8282\u70b9\u90fd\u6267\u884c\u5b8c\u4e86\uff0c\u4f46\u662f\u5b9a\u65f6\u5668\u8282\u70b9\u8fd8\u662f\u5728Libuv\u4e2d\uff0c \u4e0d\u8fc7\u6539\u6210\u975e\u6fc0\u6d3b\u72b6\u6001\uff0c\u5373\u4e0d\u4f1a\u5f71\u54cdLibuv\u9000\u51fa\uff0c\u56e0\u4e3a\u5f53\u524d\u6ca1\u6709\u9700\u8981\u5904\u7406\u7684\u8282\u70b9\u4e86\uff08handle\uff09\uff0c 2 \u4e0d\u7b49\u4e8e0\u8bf4\u660e\u6ca1\u6709\u8fd8\u8981\u8282\u70b9\u9700\u8981\u5904\u7406\uff0c\u8fd9\u79cd\u60c5\u51b5\u53c8\u5206\u4e3a\u4e24\u79cd 1 \u8fd8\u6709\u6fc0\u6d3b\u72b6\u6001\u7684\u5b9a\u65f6\u5668\uff0c\u5373\u4e0d\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 2 \u5b9a\u65f6\u5668\u90fd\u662f\u975e\u6fc0\u6d3b\u72b6\u6001\u7684\uff0c\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa \u5177\u4f53\u89c1Timeout\u7684unref\u548cref\u65b9\u6cd5 */ if ( expiry_ms != 0 ) { // \u7b97\u51fa\u4e0b\u6b21\u8d85\u65f6\u7684\u76f8\u5bf9\u503c int64_t duration_ms = llabs ( expiry_ms ) - ( uv_now ( env -> event_loop ()) - env -> timer_base ()); // \u91cd\u65b0\u628ahandle\u63d2\u5165Libuv\u7684\u4e8c\u53c9\u5806 env -> ScheduleTimer ( duration_ms > 0 ? duration_ms : 1 ); /* \u89c1internal/timer.js\u7684processTimers 1 \u5927\u4e8e0\u8bf4\u660e\u8fd8\u6709\u8282\u70b9\u6ca1\u8d85\u65f6\uff0c\u5e76\u4e14\u4e0d\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\uff0c \u9700\u8981\u4fdd\u6301\u5b9a\u65f6\u5668\u7684\u6fc0\u6d3b\u72b6\u6001\uff08\u5982\u679c\u4e4b\u524d\u662f\u6fc0\u6d3b\u72b6\u6001\u5219\u4e0d\u5f71\u54cd\uff09\uff0c 2 \u5c0f\u4e8e0\u8bf4\u660e\u5b9a\u65f6\u5668\u4e0d\u5f71\u54cdLibuv\u7684\u4e8b\u4ef6\u5faa\u73af\u7684\u7ed3\u675f\uff0c\u6539\u6210\u975e\u6fc0\u6d3b\u72b6\u6001 */ if ( expiry_ms > 0 ) uv_ref ( h ); else uv_unref ( h ); } else { uv_unref ( h ); } } \u8be5\u51fd\u6570\u4e3b\u8981\u662f\u6267\u884c\u56de\u8c03\uff0c\u7136\u540e\u5982\u679c\u8fd8\u6709\u6ca1\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u91cd\u65b0\u8bbe\u7f6eLibuv\u5b9a\u65f6\u5668\u7684\u65f6\u95f4\u3002\u770b\u770bJS\u5c42\u9762\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 function processTimers ( now ) { nextExpiry = Infinity ; let list ; let ranAtLeastOneList = false ; // \u53d6\u51fa\u4f18\u5148\u961f\u5217\u7684\u6839\u8282\u70b9\uff0c\u5373\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9 while ( list = timerListQueue . peek ()) { // \u8fd8\u6ca1\u8fc7\u671f\uff0c\u5219\u53d6\u5f97\u4e0b\u6b21\u5230\u671f\u7684\u65f6\u95f4\uff0c\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4 if ( list . expiry > now ) { nextExpiry = list . expiry ; // \u8fd4\u56de\u4e0b\u4e00\u6b21\u8fc7\u671f\u7684\u65f6\u95f4\uff0c\u8d1f\u7684\u8bf4\u660e\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa return refCount > 0 ? nextExpiry : - nextExpiry ; } // \u5904\u7406\u8d85\u65f6\u8282\u70b9 listOnTimeout ( list , now ); } // \u6240\u6709\u8282\u70b9\u90fd\u5904\u7406\u5b8c\u4e86 return 0 ; } function listOnTimeout ( list , now ) { const msecs = list . msecs ; let ranAtLeastOneTimer = false ; let timer ; // \u904d\u5386\u5177\u6709\u7edf\u4e00\u76f8\u5bf9\u8fc7\u671f\u65f6\u95f4\u7684\u961f\u5217 while ( timer = L . peek ( list )) { // \u7b97\u51fa\u5df2\u7ecf\u8fc7\u53bb\u7684\u65f6\u95f4 const diff = now - timer . _idleStart ; // \u8fc7\u671f\u7684\u65f6\u95f4\u6bd4\u8d85\u65f6\u65f6\u95f4\u5c0f\uff0c\u8fd8\u6ca1\u8fc7\u671f if ( diff < msecs ) { /* \u6574\u4e2a\u94fe\u8868\u8282\u70b9\u7684\u6700\u5feb\u8fc7\u671f\u65f6\u95f4\u7b49\u4e8e\u5f53\u524d \u8fd8\u6ca1\u8fc7\u671f\u8282\u70b9\u7684\u503c\uff0c\u94fe\u8868\u662f\u6709\u5e8f\u7684 */ list . expiry = MathMax ( timer . _idleStart + msecs , now + 1 ); // \u66f4\u65b0id\uff0c\u7528\u4e8e\u51b3\u5b9a\u5728\u4f18\u5148\u961f\u5217\u91cc\u7684\u4f4d\u7f6e list . id = timerListId ++ ; /* \u8c03\u6574\u8fc7\u671f\u65f6\u95f4\u540e\uff0c\u5f53\u524d\u94fe\u8868\u5bf9\u5e94\u7684\u8282\u70b9\u4e0d\u4e00\u5b9a\u662f\u4f18\u5148\u961f\u5217 \u91cc\u7684\u6839\u8282\u70b9\u4e86\uff0c\u53ef\u80fd\u6709\u5b83\u66f4\u5feb\u5230\u671f\uff0c\u5373\u5f53\u524d\u94fe\u8868\u5bf9\u5e94\u7684\u8282 \u70b9\u53ef\u80fd\u9700\u8981\u5f80\u4e0b\u6c89 */ timerListQueue . percolateDown ( 1 ); return ; } // \u51c6\u5907\u6267\u884c\u7528\u6237\u8bbe\u7f6e\u7684\u56de\u8c03\uff0c\u5220\u9664\u8fd9\u4e2a\u8282\u70b9 L . remove ( timer ); let start ; if ( timer . _repeat ) start = getLibuvNow (); try { const args = timer . _timerArgs ; // \u6267\u884c\u7528\u6237\u8bbe\u7f6e\u7684\u56de\u8c03 if ( args === undefined ) timer . _onTimeout (); else timer . _onTimeout (... args ); } finally { /* \u8bbe\u7f6e\u4e86\u91cd\u590d\u6267\u884c\u56de\u8c03\uff0c\u5373\u6765\u81easetInterval\u3002 \u5219\u9700\u8981\u91cd\u65b0\u52a0\u5165\u94fe\u8868\u3002 */ if ( timer . _repeat && timer . _idleTimeout !== - 1 ) { // \u66f4\u65b0\u8d85\u65f6\u65f6\u95f4\uff0c\u4e00\u6837\u7684\u65f6\u95f4\u95f4\u9694 timer . _idleTimeout = timer . _repeat ; // \u91cd\u65b0\u63d2\u5165\u94fe\u8868 insert ( timer , timer . _idleTimeout , start ); } else if ( ! timer . _idleNext && ! timer . _idlePrev && ! timer . _destroyed ) { timer . _destroyed = true ; // \u662fref\u7c7b\u578b\uff0c\u5219\u51cf\u53bb\u4e00\u4e2a\uff0c\u9632\u6b62\u963b\u6b62\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa if ( timer [ kRefed ]) refCount -- ; } // \u4e3a\u7a7a\u5219\u5220\u9664 if ( list === timerListMap [ msecs ]) { delete timerListMap [ msecs ]; // \u4ece\u4f18\u5148\u961f\u5217\u4e2d\u5220\u9664\u8be5\u8282\u70b9\uff0c\u5e76\u8c03\u6574\u961f\u5217\u7ed3\u6784 timerListQueue . shift (); } } \u4e0a\u9762\u7684\u4ee3\u7801\u4e3b\u8981\u662f\u904d\u5386\u4f18\u5148\u961f\u5217 1 \u5982\u679c\u5f53\u524d\u8282\u70b9\u8d85\u65f6\uff0c\u5219\u904d\u5386\u5b83\u5bf9\u5e94\u7684\u94fe\u8868\u3002\u904d\u5386\u94fe\u8868\u7684\u65f6\u5019\u5982\u679c\u9047\u5230\u8d85\u65f6\u7684\u8282\u70b9\u5219\u6267\u884c\u3002\u5982\u679c\u9047\u5230\u6ca1\u6709\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u5219\u8bf4\u660e\u540e\u9762\u7684\u8282\u70b9\u4e5f\u4e0d\u4f1a\u8d85\u65f6\u4e86\uff0c\u56e0\u4e3a\u94fe\u8868\u662f\u6709\u5e8f\u7684\uff0c\u63a5\u7740\u91cd\u65b0\u8ba1\u7b97\u51fa\u6700\u5feb\u8d85\u65f6\u65f6\u95f4\uff0c\u4fee\u6539\u94fe\u8868\u7684expiry\u5b57\u6bb5\u3002\u8c03\u6574\u5728\u4f18\u5148\u961f\u5217\u7684\u4f4d\u7f6e\u3002\u56e0\u4e3a\u4fee\u6539\u540e\u7684expiry\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4f4d\u7f6e\u53d1\u751f\u53d8\u5316\u3002\u5982\u679c\u94fe\u8868\u7684\u8282\u70b9\u5168\u90e8\u90fd\u8d85\u65f6\u4e86\uff0c\u5219\u4ece\u4f18\u5148\u961f\u5217\u4e2d\u5220\u9664\u94fe\u8868\u5bf9\u5e94\u7684\u8282\u70b9\u3002\u91cd\u65b0\u8c03\u6574\u4f18\u5148\u961f\u5217\u7684\u8282\u70b9\u3002 2 \u5982\u679c\u5f53\u524d\u8282\u70b9\u6ca1\u6709\u8d85\u65f6\u5219\u8bf4\u660e\u540e\u9762\u7684\u8282\u70b9\u4e5f\u4e0d\u4f1a\u8d85\u65f6\u4e86\u3002\u56e0\u4e3a\u5f53\u524d\u8282\u70b9\u662f\u4f18\u5148\u961f\u5217\u4e2d\u6700\u5feb\u5230\u671f\uff08\u6700\u5c0f\u7684\uff09\u7684\u8282\u70b9\u3002\u63a5\u7740\u8bbe\u7f6eLibuv\u7684\u5b9a\u65f6\u5668\u65f6\u95f4\u4e3a\u5f53\u524d\u8282\u70b9\u7684\u65f6\u95f4\u3002\u7b49\u5f85\u4e0b\u4e00\u6b21\u8d85\u65f6\u5904\u7406\u3002 10.6 ref\u548cunref \u00b6 setTimeout\u8fd4\u56de\u7684\u662f\u4e00\u4e2aTimeout\u5bf9\u8c61\uff0c\u8be5\u63d0\u4f9b\u4e86ref\u548cunref\u63a5\u53e3\uff0c\u521a\u624d\u63d0\u5230\u4e86\u5173\u4e8e\u5b9a\u65f6\u5668\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\u7684\u5185\u5bb9\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u539f\u7406\u3002\u521a\u624d\u8bf4\u5230Node.js\u5b9a\u65f6\u5668\u6a21\u5757\u5728Libuv\u4e2d\u53ea\u5bf9\u5e94\u4e00\u4e2a\u5b9a\u65f6\u5668\u8282\u70b9\u3002\u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u521d\u59cb\u5316\u4e86\u8be5\u8282\u70b9\u3002 1 2 3 4 5 6 void Environment::InitializeLibuv ( bool start_profiler_idle_notifier ) { // \u521d\u59cb\u5316\u5b9a\u65f6\u5668 CHECK_EQ ( 0 , uv_timer_init ( event_loop (), timer_handle ())); // \u7f6eunref\u72b6\u6001 uv_unref ( reinterpret_cast < uv_handle_t *> ( timer_handle ())); } \u6211\u4eec\u770b\u5230\u5e95\u5c42\u5b9a\u65f6\u5668\u8282\u70b9\u9ed8\u8ba4\u662funref\u72b6\u6001\u7684\uff0c\u6240\u4ee5\u4e0d\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002\u56e0\u4e3a\u521d\u59cb\u5316\u65f6JS\u5c42\u6ca1\u6709\u5b9a\u65f6\u8282\u70b9\u3002\u53ef\u4ee5\u901a\u8fc7Node.js\u63d0\u4f9b\u7684\u63a5\u53e3\u4fee\u6539\u8be5\u72b6\u6001\u3002Node.js\u652f\u6301ref\u72b6\u6001\u7684Timeout\uff08setTimeout\uff09\u548cunref\u72b6\u6001\u7684Timeout\uff08setUnrefTimeout\uff09\u3002 1 2 3 4 5 function Timeout ( callback , after , args , isRepeat , isRefed ) { if ( isRefed ) incRefCount (); this [ kRefed ] = isRefed ; } \u6700\u540e\u4e00\u4e2a\u53c2\u6570\u5c31\u662f\u63a7\u5236ref\u8fd8\u662funref\u7684\u3002\u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0b\u5982\u679cisRefed\u4e3atrue\u7684\u65f6\u5019\u7684\u903b\u8f91 1 2 3 4 function incRefCount () { if ( refCount ++ === 0 ) toggleTimerRef ( true ); } refCount\u521d\u59cb\u5316\u7684\u65f6\u5019\u662f1\uff0c\u6240\u4ee5\u5728\u65b0\u52a0\u7b2c\u4e00\u4e2aTimeout\u7684\u65f6\u5019\uff0cif\u6210\u7acb\u3002\u6211\u4eec\u63a5\u7740\u770btoggleTimerRef\uff0c\u8be5\u51fd\u6570\u5bf9\u5e94\u7684\u4ee3\u7801\u5982\u4e0b 1 2 3 4 5 6 7 8 void Environment::ToggleTimerRef ( bool ref ) { // \u6253\u4e0aref\u6807\u8bb0\uff0c if ( ref ) { uv_ref ( reinterpret_cast < uv_handle_t *> ( timer_handle ())); } else { uv_unref ( reinterpret_cast < uv_handle_t *> ( timer_handle ())); } } \u8be5\u51fd\u6570\u6b63\u662f\u7ed9\u5b9a\u65f6\u5668\u5bf9\u5e94\u7684handle\u8bbe\u7f6e\u72b6\u6001\u7684\u3002setTimeout\u7684\u65f6\u5019\uff0cisRefed\u7684\u503c\u662ftrue\u7684\uff0cNode.js\u8fd8\u63d0\u4f9b\u4e86\u53e6\u5916\u4e00\u4e2a\u51fd\u6570setUnrefTimeout\u3002 1 2 3 4 5 function setUnrefTimeout ( callback , after ) { const timer = new Timeout ( callback , after , undefined , false , false ); insert ( timer , timer . _idleTimeout ); return timer ; } \u8be5\u51fd\u6570\u548csetTimeout\u6700\u4e3b\u8981\u7684\u533a\u522b\u662fnew Timeout\u7684\u65f6\u5019\uff0c\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u662ffalse\uff08isRefed\u53d8\u91cf\u7684\u503c\uff09\uff0c\u6240\u4ee5setUnrefTimeout\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\u662f\u4e0d\u4f1a\u5f71\u54cdLibuv\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\u7684\u3002\u53e6\u5916\u9664\u4e86Node.js\u76f4\u63a5\u63d0\u4f9b\u7684api\u540e\u3002\u6211\u4eec\u8fd8\u53ef\u4ee5\u901a\u8fc7Timeout\u5bf9\u8c61\u63d0\u4f9b\u7684ref\u548cunref\u624b\u52a8\u63a7\u5236\u8fd9\u4e2a\u72b6\u6001\u3002 \u73b0\u5728\u901a\u8fc7\u4e00\u4e2a\u4f8b\u5b50\u5177\u4f53\u6765\u770b\u4e00\u4e0b\u3002 1 2 3 4 5 const timeout = setTimeout (() => { console . log ( 1 ) }, 10000 ); timeout . unref (); // timeout.ref(); \u52a0\u8fd9\u4e00\u53e5\u4f1a\u8f93\u51fa1 \u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c1\u662f\u4e0d\u4f1a\u8f93\u51fa\uff0c\u9664\u975e\u628a\u6ce8\u91ca\u53bb\u6389\u3002Unref\u548cref\u662f\u76f8\u53cd\u7684\u53c2\u6570\uff0c\u5373\u628a\u5b9a\u65f6\u5668\u6a21\u5757\u5bf9\u5e94\u7684Libuv handle\u6539\u6210unref\u72b6\u6001\u3002","title":"10-\u5b9a\u65f6\u5668"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#101-libuv","text":"Libuv\u4e2d\u4f7f\u7528\u4e8c\u53c9\u5806\u5b9e\u73b0\u4e86\u5b9a\u65f6\u5668\u3002\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9\u662f\u6839\u8282\u70b9\u3002","title":"10.1 Libuv\u7684\u5b9e\u73b0"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1011-libuv","text":"1 2 3 4 // \u53d6\u51faloop\u4e2d\u7684\u8ba1\u65f6\u5668\u5806\u6307\u9488 static struct heap * timer_heap ( const uv_loop_t * loop ) { return ( struct heap * ) & loop -> timer_heap ; }","title":"10.1.1 Libuv\u4e2d\u7ef4\u62a4\u5b9a\u65f6\u5668\u7684\u6570\u636e\u7ed3\u6784"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1012","text":"\u56e0\u4e3aLibuv\u4f7f\u7528\u4e8c\u53c9\u5806\u5b9e\u73b0\u5b9a\u65f6\u5668\uff0c\u8fd9\u5c31\u6d89\u53ca\u5230\u8282\u70b9\u63d2\u5165\u5806\u7684\u65f6\u5019\u7684\u89c4\u5219\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 static int timer_less_than ( const struct heap_node * ha , const struct heap_node * hb ) { const uv_timer_t * a ; const uv_timer_t * b ; // \u901a\u8fc7\u7ed3\u6784\u4f53\u6210\u5458\u627e\u5230\u7ed3\u6784\u4f53\u9996\u5730\u5740 a = container_of ( ha , uv_timer_t , heap_node ); b = container_of ( hb , uv_timer_t , heap_node ); // \u6bd4\u8f83\u4e24\u4e2a\u7ed3\u6784\u4f53\u4e2d\u7684\u8d85\u65f6\u65f6\u95f4 if ( a -> timeout < b -> timeout ) return 1 ; if ( b -> timeout < a -> timeout ) return 0 ; // \u8d85\u65f6\u65f6\u95f4\u4e00\u6837\u7684\u8bdd\uff0c\u770b\u8c01\u5148\u521b\u5efa if ( a -> start_id < b -> start_id ) return 1 ; if ( b -> start_id < a -> start_id ) return 0 ; return 0 ; }","title":"10.1.2 \u6bd4\u8f83\u51fd\u6570"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1013","text":"\u5982\u679c\u9700\u8981\u4f7f\u7528\u5b9a\u65f6\u5668\uff0c\u9996\u5148\u8981\u5bf9\u5b9a\u65f6\u5668\u7684\u7ed3\u6784\u4f53\u8fdb\u884c\u521d\u59cb\u5316\u3002 1 2 3 4 5 6 7 // \u521d\u59cb\u5316uv_timer_t\u7ed3\u6784\u4f53 int uv_timer_init ( uv_loop_t * loop , uv_timer_t * handle ) { uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_TIMER ); handle -> timer_cb = NULL ; handle -> repeat = 0 ; return 0 ; }","title":"10.1.3 \u521d\u59cb\u5316\u5b9a\u65f6\u5668\u7ed3\u6784\u4f53"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1014","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // \u542f\u52a8\u4e00\u4e2a\u8ba1\u65f6\u5668 int uv_timer_start ( uv_timer_t * handle , uv_timer_cb cb , uint64_t timeout , uint64_t repeat ) { uint64_t clamped_timeout ; if ( cb == NULL ) return UV_EINVAL ; // \u91cd\u65b0\u6267\u884cstart\u7684\u65f6\u5019\u5148\u628a\u4e4b\u524d\u7684\u505c\u6389 if ( uv__is_active ( handle )) uv_timer_stop ( handle ); // \u8d85\u65f6\u65f6\u95f4\uff0c\u4e3a\u7edd\u5bf9\u503c clamped_timeout = handle -> loop -> time + timeout ; if ( clamped_timeout < timeout ) clamped_timeout = ( uint64_t ) -1 ; // \u521d\u59cb\u5316\u56de\u8c03\uff0c\u8d85\u65f6\u65f6\u95f4\uff0c\u662f\u5426\u91cd\u590d\u8ba1\u65f6\uff0c\u8d4b\u4e88\u4e00\u4e2a\u72ec\u7acb\u65e0\u4e8c\u7684id handle -> timer_cb = cb ; handle -> timeout = clamped_timeout ; handle -> repeat = repeat ; // \u7528\u4e8e\u8d85\u65f6\u65f6\u95f4\u4e00\u6837\u7684\u65f6\u5019\uff0c\u6bd4\u8f83\u5b9a\u65f6\u5668\u5728\u4e8c\u53c9\u5806\u7684\u4f4d\u7f6e\uff0c\u89c1cmp\u51fd\u6570 handle -> start_id = handle -> loop -> timer_counter ++ ; // \u63d2\u5165\u6700\u5c0f\u5806 heap_insert ( timer_heap ( handle -> loop ), ( struct heap_node * ) & handle -> heap_node , timer_less_than ); // \u6fc0\u6d3b\u8be5handle uv__handle_start ( handle ); return 0 ; }","title":"10.1.4 \u63d2\u5165\u4e00\u4e2a\u5b9a\u65f6\u5668"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1015","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 // \u505c\u6b62\u4e00\u4e2a\u8ba1\u65f6\u5668 int uv_timer_stop ( uv_timer_t * handle ) { if ( ! uv__is_active ( handle )) return 0 ; // \u4ece\u6700\u5c0f\u5806\u4e2d\u79fb\u9664\u8be5\u8ba1\u65f6\u5668\u8282\u70b9 heap_remove ( timer_heap ( handle -> loop ), ( struct heap_node * ) & handle -> heap_node , timer_less_than ); // \u6e05\u9664\u6fc0\u6d3b\u72b6\u6001\u548chandle\u7684active\u6570\u51cf\u4e00 uv__handle_stop ( handle ); return 0 ; }","title":"10.1.5 \u505c\u6b62\u4e00\u4e2a\u5b9a\u65f6\u5668"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1016","text":"\u91cd\u65b0\u8bbe\u7f6e\u5b9a\u65f6\u5668\u7c7b\u4f3c\u63d2\u5165\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u5b83\u9996\u5148\u9700\u8981\u628a\u4e4b\u524d\u7684\u5b9a\u65f6\u5668\u4ece\u4e8c\u53c9\u5806\u4e2d\u79fb\u9664\uff0c\u7136\u540e\u91cd\u65b0\u63d2\u5165\u4e8c\u53c9\u5806\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // \u91cd\u65b0\u542f\u52a8\u4e00\u4e2a\u8ba1\u65f6\u5668\uff0c\u9700\u8981\u8bbe\u7f6erepeat\u6807\u8bb0 int uv_timer_again ( uv_timer_t * handle ) { if ( handle -> timer_cb == NULL ) return UV_EINVAL ; // \u5982\u679c\u8bbe\u7f6e\u4e86repeat\u6807\u8bb0\u8bf4\u660e\u8ba1\u65f6\u5668\u662f\u9700\u8981\u91cd\u590d\u89e6\u53d1\u7684 if ( handle -> repeat ) { // \u5148\u628a\u65e7\u7684\u8282\u70b9\u4ece\u6700\u5c0f\u5806\u4e2d\u79fb\u9664\uff0c\u7136\u540e\u518d\u91cd\u65b0\u5f00\u542f\u4e00\u4e2a\u8ba1\u65f6\u5668 uv_timer_stop ( handle ); uv_timer_start ( handle , handle -> timer_cb , handle -> repeat , handle -> repeat ); } return 0 ; }","title":"10.1.6 \u91cd\u65b0\u8bbe\u7f6e\u5b9a\u65f6\u5668"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1017","text":"\u8d85\u65f6\u65f6\u95f4\u6700\u5c0f\u503c\uff0c\u4e3b\u8981\u7528\u4e8e\u5224\u65adPoll IO\u8282\u70b9\u662f\u963b\u585e\u7684\u6700\u957f\u65f6\u95f4\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // \u8ba1\u7b97\u6700\u5c0f\u5806\u4e2d\u6700\u5c0f\u8282\u70b9\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u5373\u6700\u5c0f\u7684\u8d85\u65f6\u65f6\u95f4 int uv__next_timeout ( const uv_loop_t * loop ) { const struct heap_node * heap_node ; const uv_timer_t * handle ; uint64_t diff ; // \u53d6\u51fa\u5806\u7684\u6839\u8282\u70b9\uff0c\u5373\u8d85\u65f6\u65f6\u95f4\u6700\u5c0f\u7684 heap_node = heap_min ( timer_heap ( loop )); if ( heap_node == NULL ) return -1 ; /* block indefinitely */ handle = container_of ( heap_node , uv_timer_t , heap_node ); // \u5982\u679c\u6700\u5c0f\u7684\u8d85\u65f6\u65f6\u95f4\u5c0f\u4e8e\u5f53\u524d\u65f6\u95f4\uff0c\u5219\u8fd4\u56de0\uff0c\u8bf4\u660e\u5df2\u7ecf\u8d85\u65f6 if ( handle -> timeout <= loop -> time ) return 0 ; // \u5426\u5219\u8ba1\u7b97\u8fd8\u6709\u591a\u4e45\u8d85\u65f6\uff0c\u8fd4\u56de\u7ed9epoll\uff0cepoll\u7684timeout\u4e0d\u80fd\u5927\u4e8ediff diff = handle -> timeout - loop -> time ; if ( diff > INT_MAX ) diff = INT_MAX ; return diff ; }","title":"10.1.7 \u8ba1\u7b97\u4e8c\u53c9\u5806\u4e2d\u8d85\u65f6\u65f6\u95f4\u6700\u5c0f\u503c"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1018","text":"\u5904\u7406\u8d85\u65f6\u5b9a\u65f6\u5668\u5c31\u662f\u904d\u5386\u4e8c\u53c9\u5806\uff0c\u5224\u65ad\u54ea\u4e2a\u8282\u70b9\u8d85\u65f6\u4e86\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // \u627e\u51fa\u5df2\u7ecf\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u5e76\u4e14\u6267\u884c\u91cc\u9762\u7684\u56de\u8c03 void uv__run_timers ( uv_loop_t * loop ) { struct heap_node * heap_node ; uv_timer_t * handle ; for (;;) { heap_node = heap_min ( timer_heap ( loop )); if ( heap_node == NULL ) break ; handle = container_of ( heap_node , uv_timer_t , heap_node ); // \u5982\u679c\u5f53\u524d\u8282\u70b9\u7684\u65f6\u95f4\u5927\u4e8e\u5f53\u524d\u65f6\u95f4\u5219\u8fd4\u56de\uff0c\u8bf4\u660e\u540e\u9762\u7684\u8282\u70b9\u4e5f\u6ca1\u6709\u8d85\u65f6 if ( handle -> timeout > loop -> time ) break ; // \u79fb\u9664\u8be5\u8ba1\u65f6\u5668\u8282\u70b9\uff0c\u91cd\u65b0\u63d2\u5165\u6700\u5c0f\u5806\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86repeat\u7684\u8bdd uv_timer_stop ( handle ); uv_timer_again ( handle ); // \u6267\u884c\u8d85\u65f6\u56de\u8c03 handle -> timer_cb ( handle ); } }","title":"10.1.8 \u5904\u7406\u5b9a\u65f6\u5668"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#102","text":"","title":"10.2 \u6838\u5fc3\u6570\u636e\u7ed3\u6784"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1021-timerslist","text":"\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u4e00\u6837\u7684\u5b9a\u65f6\u5668\u4f1a\u88ab\u653e\u5230\u540c\u4e00\u4e2a\u961f\u5217\uff0c\u6bd4\u5982\u5f53\u524d\u6267\u884csetTimeout(()=>{}, 10000})\u548c5\u79d2\u540e\u6267\u884csetTimeout(()=>{}, 10000})\uff0c\u8fd9\u4e24\u4e2a\u4efb\u52a1\u5c31\u4f1a\u5728\u540c\u4e00\u4e2aList\u4e2d\uff0c\u8fd9\u4e2a\u961f\u5217\u7531TimersList\u6765\u7ba1\u7406\u3002\u5bf9\u5e94\u56fe1\u4e2d\u7684List\u90a3\u4e2a\u961f\u5217\u3002 1 2 3 4 5 6 7 8 9 10 function TimersList ( expiry , msecs ) { // \u7528\u4e8e\u94fe\u8868 this . _idleNext = this ; this . _idlePrev = this ; this . expiry = expiry ; this . id = timerListId ++ ; this . msecs = msecs ; // \u5728\u4f18\u5148\u961f\u5217\u91cc\u7684\u4f4d\u7f6e this . priorityQueuePosition = null ; } expiry\u8bb0\u5f55\u7684\u662f\u94fe\u8868\u4e2d\u6700\u5feb\u8d85\u65f6\u7684\u8282\u70b9\u7684\u7edd\u5bf9\u65f6\u95f4\u3002\u6bcf\u6b21\u6267\u884c\u5b9a\u65f6\u5668\u9636\u6bb5\u65f6\u4f1a\u52a8\u6001\u66f4\u65b0\uff0cmsecs\u662f\u8d85\u65f6\u65f6\u95f4\u7684\u76f8\u5bf9\u503c\uff08\u76f8\u5bf9\u63d2\u5165\u65f6\u7684\u5f53\u524d\u65f6\u95f4\uff09\u3002\u7528\u4e8e\u8ba1\u7b97\u8be5\u94fe\u8868\u4e2d\u7684\u8282\u70b9\u662f\u5426\u8d85\u65f6\u3002\u540e\u7eed\u6211\u4eec\u4f1a\u770b\u5230\u5177\u4f53\u7684\u7528\u5904\u3002","title":"10.2.1 TimersList"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#1022","text":"1 const timerListQueue = new PriorityQueue ( compareTimersLists , setPosition ) Node.js\u7528\u4f18\u5148\u961f\u5217\u5bf9\u6240\u6709TimersList\u94fe\u8868\u8fdb\u884c\u7ba1\u7406\uff0c\u4f18\u5148\u961f\u5217\u672c\u8d28\u662f\u4e00\u4e2a\u4e8c\u53c9\u5806\uff08\u5c0f\u6839\u5806\uff09\uff0c\u6bcf\u4e2aTimersList\u94fe\u8868\u5728\u4e8c\u53c9\u5806\u91cc\u5bf9\u5e94\u4e00\u4e2a\u8282\u70b9\u3002\u6839\u636eTimersList\u7684\u7ed3\u6784\uff0c\u6211\u4eec\u77e5\u9053\u6bcf\u4e2a\u94fe\u8868\u90fd\u4fdd\u5b58\u94fe\u8868\u4e2d\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9\u7684\u8fc7\u671f\u65f6\u95f4\u3002\u4e8c\u53c9\u5806\u4ee5\u8be5\u65f6\u95f4\u4e3a\u4f9d\u636e\uff0c\u5373\u6700\u5feb\u5230\u671f\u7684list\u5bf9\u5e94\u4e8c\u53c9\u5806\u4e2d\u7684\u6839\u8282\u70b9\u3002\u6839\u8282\u70b9\u7684\u5230\u671f\u65f6\u95f4\u5c31\u662f\u6574\u4e2aNode.js\u5b9a\u65f6\u5668\u6700\u5feb\u5230\u671f\u7684\u65f6\u95f4\uff0cNode.js\u628aLibuv\u4e2d\u5b9a\u65f6\u5668\u8282\u70b9\u7684\u8d85\u65f6\u65f6\u95f4\u8bbe\u7f6e\u4e3a\u8be5\u503c\uff0c\u5728\u4e8b\u4ef6\u5faa\u73af\u7684\u5b9a\u65f6\u5668\u9636\u6bb5\u5c31\u4f1a\u5904\u7406\u5b9a\u65f6\u7684\u8282\u70b9\uff0c\u5e76\u4e14\u4e0d\u65ad\u904d\u5386\u4f18\u5148\u961f\u5217\uff0c\u5224\u65ad\u5f53\u524d\u8282\u70b9\u662f\u5426\u8d85\u65f6\uff0c\u5982\u679c\u8d85\u65f6\u4e86\uff0c\u5c31\u9700\u8981\u5904\u7406\uff0c\u5982\u679c\u6ca1\u6709\u8d85\u65f6\uff0c\u8bf4\u660e\u6574\u4e2a\u4e8c\u53c9\u5806\u7684\u8282\u70b9\u90fd\u6ca1\u6709\u8d85\u65f6\u3002\u7136\u540e\u91cd\u65b0\u8bbe\u7f6eLibuv\u5b9a\u65f6\u5668\u8282\u70b9\u65b0\u7684\u5230\u671f\u65f6\u95f4\u3002 \u53e6\u5916\uff0cNode.js\u4e2d\u7528\u4e00\u4e2amap\u4fdd\u5b58\u4e86\u8d85\u65f6\u65f6\u95f4\u5230TimersList\u94fe\u8868\u7684\u6620\u5c04\u5173\u7cfb\u3002 \u8fd9\u6837\u5c31\u53ef\u4ee5\u6839\u636e\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u5feb\u901f\u627e\u5230\u5bf9\u5e94\u7684\u5217\u8868\uff0c\u5229\u7528\u7a7a\u95f4\u6362\u65f6\u95f4\u3002\u4e86\u89e3\u5b8c\u5b9a\u65f6\u5668\u6574\u4f53\u7684\u7ec4\u7ec7\u548c\u6838\u5fc3\u6570\u636e\u7ed3\u6784\uff0c\u6211\u4eec\u53ef\u4ee5\u5f00\u59cb\u8fdb\u5165\u771f\u6b63\u7684\u6e90\u7801\u5206\u6790\u4e86\u3002","title":"10.2.2 \u4f18\u5148\u961f\u5217"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#103","text":"Node.js\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u4e86\u5904\u7406\u5b9a\u65f6\u5668\u7684\u51fd\u6570\u3002 setupTimers(processImmediate, processTimers); setupTimers\u5bf9\u5e94\u7684C++\u51fd\u6570\u662f 1 2 3 4 5 void SetupTimers ( const FunctionCallbackInfo < Value >& args ) { auto env = Environment :: GetCurrent ( args ); env -> set_immediate_callback_function ( args [ 0 ]. As < Function > ()); env -> set_timers_callback_function ( args [ 1 ]. As < Function > ()); } SetupTimers\u5728env\u4e2d\u4fdd\u5b58\u4e86\u4e24\u4e2a\u51fd\u6570\uff0cprocessImmediate\u662f\u5904\u7406setImmediate\u7684\uff0cprocessTimers\u662f\u5904\u7406\u5b9a\u65f6\u5668\u7684\u3002\u5f53\u6709\u8282\u70b9\u8d85\u65f6\u65f6\uff0cNode.js\u4f1a\u6267\u884c\u8be5\u51fd\u6570\u5904\u7406\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u540e\u7eed\u4f1a\u770b\u5230\u8be5\u51fd\u6570\u7684\u5177\u4f53\u5904\u7406\u903b\u8f91\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u8bbe\u7f6e\u4e00\u4e2a\u5b9a\u65f6\u5668\u3002","title":"10.3 \u8bbe\u7f6e\u5b9a\u65f6\u5668\u5904\u7406\u51fd\u6570"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#104","text":"1 2 3 4 5 6 7 8 9 10 11 function setTimeout ( callback , after , arg1 , arg2 , arg3 ) { // \u5ffd\u7565\u5904\u7406\u53c2\u6570args\u903b\u8f91 // \u65b0\u5efa\u4e00\u4e2aTimeout\u5bf9\u8c61 const timeout = new Timeout ( callback , after , args , false , true ); insert ( timeout , timeout . _idleTimeout ); return timeout ; } setTimeout\u4e3b\u8981\u5305\u542b\u4e24\u4e2a\u64cd\u4f5c\uff0cnew Timeout\u548cinsert\u3002\u6211\u4eec\u9010\u4e2a\u5206\u6790\u4e00\u4e0b\u3002 1 setTimeout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function Timeout ( callback , after , args , isRepeat , isRefed ) { after *= 1 ; // Coalesce to number or NaN // \u5173\u4e8esetTimeout\u7684\u8d85\u65f6\u65f6\u95f4\u4e3a0\u7684\u95ee\u9898\u5728\u8fd9\u91cc\u53ef\u4ee5\u63ed\u5f00\u8ff7\u96fe if ( ! ( after >= 1 && after <= TIMEOUT_MAX )) { after = 1 ; } // \u8d85\u65f6\u65f6\u95f4\u76f8\u5bf9\u503c this . _idleTimeout = after ; // \u524d\u540e\u6307\u9488\uff0c\u7528\u4e8e\u94fe\u8868 this . _idlePrev = this ; this . _idleNext = this ; // \u5b9a\u65f6\u5668\u7684\u5f00\u59cb\u65f6\u95f4 this . _idleStart = null ; // \u8d85\u65f6\u56de\u8c03 this . _onTimeout = callback ; // \u6267\u884c\u56de\u8c03\u65f6\u4f20\u5165\u7684\u53c2\u6570 this . _timerArgs = args ; // \u662f\u5426\u5b9a\u671f\u89e6\u53d1\u8d85\u65f6\uff0c\u7528\u4e8esetInterval this . _repeat = isRepeat ? after : null ; this . _destroyed = false ; // this._idleStart = now(); // \u6fc0\u6d3b\u5e95\u5c42\u7684\u5b9a\u65f6\u5668\u8282\u70b9\uff08\u4e8c\u53c9\u5806\u7684\u8282\u70b9\uff09\uff0c\u8bf4\u660e\u6709\u5b9a\u65f6\u8282\u70b9\u9700\u8981\u5904\u7406 if ( isRefed ) incRefCount (); // \u8bb0\u5f55\u72b6\u6001 this [ kRefed ] = isRefed ; } Timeout\u4e3b\u8981\u662f\u65b0\u5efa\u4e00\u4e2a\u5bf9\u8c61\u8bb0\u5f55\u4e00\u4e9b\u5b9a\u65f6\u5668\u7684\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\uff08\u7528\u4e8e\u652f\u6301setInterval\uff0c\u91cd\u65b0\u63d2\u5165\u961f\u5217\u65f6\u627e\u5230\u6240\u5c5e\u961f\u5217\uff09\u3001\u5f00\u59cb\u65f6\u95f4\uff08\u7528\u4e8e\u8ba1\u7b97\u5b9a\u65f6\u5668\u662f\u5426\u8d85\u65f6\uff09\u7b49\u4e0a\u4e0b\u6587\u4fe1\u606f\u3002\u8fd9\u91cc\u6709\u4e00\u4e2a\u5173\u952e\u7684\u903b\u8f91\u662fisRefed\u7684\u503c\u3002Node.js\u652f\u6301ref\u548cunref\u72b6\u6001\u7684\u5b9a\u65f6\u5668\uff08setTimeout \u548csetUnrefTimeout\uff09\uff0cunref\u72b6\u6001\u7684\u5b9a\u65f6\u5668\uff0c\u4e0d\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002\u5373\u5f53\u53ea\u6709unref\u72b6\u6001\u7684\u5b9a\u65f6\u5668\u65f6\uff0c\u4e8b\u4ef6\u5faa\u73af\u4f1a\u7ed3\u675f\u3002\u5f53isRefed\u4e3atrue\u65f6\u4f1a\u6267\u884cincRefCount(); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function incRefCount () { if ( refCount ++ === 0 ) toggleTimerRef ( true ); } void ToggleTimerRef ( const FunctionCallbackInfo < Value >& args ) { Environment :: GetCurrent ( args ) -> ToggleTimerRef ( args [ 0 ] -> IsTrue ()); } void Environment::ToggleTimerRef ( bool ref ) { if ( started_cleanup_ ) return ; // \u6253\u4e0aref\u6807\u8bb0\uff0c if ( ref ) { uv_ref ( reinterpret_cast < uv_handle_t *> ( timer_handle ())); } else { uv_unref ( reinterpret_cast < uv_handle_t *> ( timer_handle ())); } } \u6211\u4eec\u770b\u5230\u6700\u7ec8\u4f1a\u8c03\u7528Libuv\u7684uv_ref\u6216uv_unref\u4fee\u6539\u5b9a\u65f6\u5668\u76f8\u5173handle\u7684\u72b6\u6001\uff0c\u56e0\u4e3aNode.js\u53ea\u4f1a\u5728Libuv\u4e2d\u6ce8\u518c\u4e00\u4e2a\u5b9a\u65f6\u5668handle\u5e76\u4e14\u662f\u5e38\u9a7b\u7684\uff0c\u5982\u679cJS\u5c42\u5f53\u524d\u6ca1\u6709\u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u5219\u9700\u8981\u4fee\u6539\u5b9a\u65f6\u5668handle\u7684\u72b6\u6001\u4e3aunref\uff0c\u5426\u5219\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002refCount\u503c\u4fbf\u662f\u8bb0\u5f55JS\u5c42ref\u72b6\u6001\u7684\u5b9a\u65f6\u5668\u4e2a\u6570\u7684\u3002\u6240\u4ee5\u5f53\u6211\u4eec\u7b2c\u4e00\u6b21\u6267\u884csetTimeout\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u6fc0\u6d3bLibuv\u7684\u5b9a\u65f6\u5668\u8282\u70b9\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0binsert\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 let nextExpiry = Infinity ; function insert ( item , msecs , start = getLibuvNow ()) { msecs = MathTrunc ( msecs ); // \u8bb0\u5f55\u5b9a\u65f6\u5668\u7684\u5f00\u59cb\u65f6\u95f4\uff0c\u89c1Timeout\u51fd\u6570\u7684\u5b9a\u4e49 item . _idleStart = start ; // \u8be5\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u662f\u5426\u5df2\u7ecf\u5b58\u5728\u5bf9\u5e94\u7684\u94fe\u8868 let list = timerListMap [ msecs ]; // \u8fd8\u6ca1\u6709 if ( list === undefined ) { // \u7b97\u51fa\u7edd\u5bf9\u8d85\u65f6\u65f6\u95f4\uff0c\u7b2c\u4e00\u4e2a\u8282\u70b9\u662f\u8be5\u94fe\u8868\u4e2d\u6700\u65e9\u5230\u671f\u7684\u8282\u70b9 const expiry = start + msecs ; // \u65b0\u5efa\u4e00\u4e2a\u94fe\u8868 timerListMap [ msecs ] = list = new TimersList ( expiry , msecs ); // \u63d2\u5165\u4f18\u5148\u961f\u5217 timerListQueue . insert ( list ); /* nextExpiry\u8bb0\u5f55\u6240\u6709\u8d85\u65f6\u8282\u70b9\u4e2d\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9\uff0c \u5982\u679c\u6709\u66f4\u5feb\u5230\u671f\u7684\uff0c\u5219\u4fee\u6539\u5e95\u5c42\u5b9a\u65f6\u5668\u8282\u70b9\u7684\u8fc7\u671f\u65f6\u95f4 */ if ( nextExpiry > expiry ) { // \u4fee\u6539\u5e95\u5c42\u8d85\u65f6\u8282\u70b9\u7684\u8d85\u65f6\u65f6\u95f4 scheduleTimer ( msecs ); nextExpiry = expiry ; } } // \u628a\u5f53\u524d\u8282\u70b9\u52a0\u5230\u94fe\u8868\u91cc L . append ( list , item ); } Insert\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 \u5982\u679c\u8be5\u8d85\u65f6\u65f6\u95f4\u8fd8\u6ca1\u6709\u5bf9\u5e94\u7684\u94fe\u8868\uff0c\u5219\u65b0\u5efa\u4e00\u4e2a\u94fe\u8868\uff0c\u6bcf\u4e2a\u94fe\u8868\u90fd\u4f1a\u8bb0\u5f55\u8be5\u94fe\u8868\u4e2d\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9\u7684\u503c\uff0c\u5373\u7b2c\u4e00\u4e2a\u63d2\u5165\u7684\u503c\u3002\u7136\u540e\u628a\u94fe\u8868\u63d2\u5165\u4f18\u5148\u961f\u5217\uff0c\u4f18\u5148\u961f\u5217\u4f1a\u6839\u636e\u8be5\u94fe\u8868\u7684\u6700\u5feb\u8fc7\u671f\u65f6\u95f4\u7684\u503c\uff0c\u628a\u94fe\u8868\u5bf9\u5e94\u7684\u8282\u70b9\u8c03\u6574\u5230\u76f8\u5e94\u7684\u4f4d\u7f6e\u3002 2 \u5982\u679c\u5f53\u524d\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\uff0c\u6bd4\u4e4b\u524d\u6240\u6709\u7684\u5b9a\u65f6\u5668\u90fd\u5feb\u5230\u671f\uff0c\u5219\u9700\u8981\u4fee\u6539\u5e95\u5c42\u7684\u5b9a\u65f6\u5668\u8282\u70b9\uff0c\u4f7f\u5f97\u66f4\u5feb\u89e6\u53d1\u8d85\u65f6\u3002 3 \u628a\u5f53\u524d\u7684\u5b9a\u65f6\u5668\u8282\u70b9\u63d2\u5165\u5bf9\u5e94\u7684\u94fe\u8868\u5c3e\u90e8\u3002\u5373\u8be5\u94fe\u8868\u4e2d\u6700\u4e45\u8d85\u65f6\u7684\u8282\u70b9\u3002 \u5047\u8bbe\u6211\u4eec\u57280s\u7684\u65f6\u5019\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u4e0b\u9762\u662f\u63d2\u5165\u7b2c\u4e00\u4e2a\u8282\u70b9\u65f6\u7684\u7ed3\u6784\u56fe\u5982\u56fe10-2\u6240\u793a\u3002 \u56fe10-2 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u591a\u4e2a\u8282\u70b9\u7684\u60c5\u51b5\u3002\u5047\u8bbe0s\u7684\u65f6\u5019\u63d2\u5165\u4e24\u4e2a\u8282\u70b910s\u8fc7\u671f\u548c11s\u8fc7\u671f\u3002\u5982\u56fe10-3\u6240\u793a\u3002 \u56fe10-3 \u7136\u540e\u57281s\u7684\u65f6\u5019\uff0c\u63d2\u5165\u4e00\u4e2a\u65b0\u768411s\u8fc7\u671f\u7684\u8282\u70b9\uff0c9s\u7684\u65f6\u5019\u63d2\u5165\u4e00\u4e2a\u65b0\u768410s\u8fc7\u671f\u8282\u70b9\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u65f6\u5019\u7684\u5173\u7cfb\u56fe\u5982\u56fe10-4\u6240\u793a\u3002 \u56fe10-4 \u6211\u4eec\u770b\u5230\u4f18\u5148\u961f\u5217\u4e2d\uff0c\u6bcf\u4e00\u4e2a\u8282\u70b9\u662f\u4e00\u4e2a\u94fe\u8868\uff0c\u7236\u8282\u70b9\u5bf9\u5e94\u7684\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u662f\u6bd4\u5b50\u8282\u70b9\u94fe\u8868\u7684\u7b2c\u4e00\u4e2a\u5143\u7d20\u5148\u8d85\u65f6\u7684\uff0c\u4f46\u662f\u94fe\u8868\u4e2d\u540e\u7eed\u8282\u70b9\u7684\u8d85\u65f6\u5c31\u4e0d\u4e00\u5b9a\u3002\u6bd4\u5982\u5b50\u8282\u70b91s\u5f00\u59cb\u7684\u8282\u70b9\u5c31\u6bd4\u7236\u8282\u70b99s\u5f00\u59cb\u7684\u8282\u70b9\u5148\u8d85\u65f6\u3002\u56e0\u4e3a\u540c\u4e00\u961f\u5217\uff0c\u53ea\u662f\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u4e00\u6837\uff0c\u800c\u8fd8\u6709\u4e00\u4e2a\u91cd\u8981\u7684\u56e0\u7d20\u662f\u5f00\u59cb\u7684\u65f6\u95f4\u3002\u867d\u7136\u67d0\u8282\u70b9\u7684\u76f8\u5bf9\u8d85\u65f6\u65f6\u95f4\u957f\uff0c\u4f46\u662f\u5982\u679c\u5b83\u6bd4\u53e6\u4e00\u4e2a\u8282\u70b9\u5f00\u59cb\u7684\u65e9\uff0c\u90a3\u4e48\u5c31\u6709\u53ef\u80fd\u6bd4\u5b83\u5148\u8d85\u65f6\u3002\u540e\u7eed\u6211\u4eec\u4f1a\u770b\u5230\u5177\u4f53\u662f\u600e\u4e48\u5b9e\u73b0\u7684\u3002","title":"10.4 \u8bbe\u7f6e\u5b9a\u65f6\u5668"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#105","text":"\u524d\u9762\u6211\u4eec\u8bb2\u5230\u4e86\u8bbe\u7f6e\u5b9a\u65f6\u5668\u5904\u7406\u51fd\u6570\u548c\u8bbe\u7f6e\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u4f46\u662f\u5728\u54ea\u91cc\u89e6\u53d1\u8fd9\u4e2a\u5904\u7406\u5b9a\u65f6\u5668\u7684\u51fd\u6570\u5462\uff1f\u7b54\u6848\u5728scheduleTimer\u51fd\u6570\u3002Node.js\u7684\u5b9e\u73b0\u4e2d\uff0c\u6240\u6709JS\u5c42\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\u5bf9\u5e94Libuv\u7684\u4e00\u4e2a\u5b9a\u65f6\u5668\u8282\u70b9\uff0cNode.js\u7ef4\u62a4\u4e86JS\u5c42\u6240\u6709\u5b9a\u65f6\u5668\u7684\u8d85\u65f6\u6700\u5c0f\u503c\u3002\u5728\u7b2c\u4e00\u4e2a\u8bbe\u7f6e\u5b9a\u65f6\u5668\u6216\u8005\u8bbe\u7f6e\u4e00\u4e2a\u65b0\u7684\u5b9a\u65f6\u5668\u65f6\uff0c\u5982\u679c\u65b0\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\u6bd4\u5f53\u524d\u7684\u6700\u5c0f\u503c\u5c0f\uff0c\u5219\u4f1a\u901a\u8fc7scheduleTimer\u4fee\u6539\u8d85\u65f6\u65f6\u95f4\u3002\u8d85\u65f6\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884c\u56de\u8c03\u3002scheduleTimer\u51fd\u6570\u662f\u5bf9C++\u51fd\u6570\u7684\u5c01\u88c5\u3002 1 2 3 4 5 6 7 8 9 void ScheduleTimer ( const FunctionCallbackInfo < Value >& args ) { auto env = Environment :: GetCurrent ( args ); env -> ScheduleTimer ( args [ 0 ] -> IntegerValue ( env -> context ()). FromJust ()); } void Environment::ScheduleTimer ( int64_t duration_ms ) { if ( started_cleanup_ ) return ; uv_timer_start ( timer_handle (), RunTimers , duration_ms , 0 ); } uv_timer_start\u5c31\u662f\u5f00\u542f\u5e95\u5c42\u8ba1\u65f6\uff0c\u5373\u5f80Libuv\u7684\u4e8c\u53c9\u5806\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff08\u5982\u679c\u8be5handle\u5df2\u7ecf\u5b58\u5728\u4e8c\u53c9\u5806\uff0c\u5219\u5148\u5220\u9664\uff09\u3002\u8d85\u65f6\u65f6\u95f4\u662fduration_ms\uff0c\u5c31\u662f\u6700\u5feb\u5230\u671f\u7684\u65f6\u95f4\uff0c\u8d85\u65f6\u56de\u8c03\u662fRunTimers\uff0c\u5728timer\u9636\u6bb5\u4f1a\u5224\u65ad\u662f\u5426\u8fc7\u671f\u3002\u662f\u7684\u8bdd\u6267\u884cRunTimers\u51fd\u6570\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bRunTimers\u51fd\u6570\u7684\u4e3b\u8981\u4ee3\u7801\u3002 1 2 Local < Function > cb = env -> timers_callback_function (); ret = cb -> Call ( env -> context (), process , 1 , & arg ); RunTimers\u4f1a\u6267\u884ctimers_callback_function\u3002timers_callback_function\u662f\u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u7684processTimers\u51fd\u6570\u3002\u73b0\u5728\u6211\u4eec\u77e5\u9053\u4e86Node.js\u662f\u5982\u4f55\u8bbe\u7f6e\u8d85\u65f6\u7684\u5904\u7406\u51fd\u6570\uff0c\u4e5f\u77e5\u9053\u4e86\u4ec0\u4e48\u65f6\u5019\u4f1a\u6267\u884c\u8be5\u56de\u8c03\u3002\u90a3\u6211\u4eec\u5c31\u6765\u770b\u4e00\u4e0b\u56de\u8c03\u65f6\u5177\u4f53\u5904\u7406\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 void Environment::RunTimers ( uv_timer_t * handle ) { Local < Function > cb = env -> timers_callback_function (); MaybeLocal < Value > ret ; Local < Value > arg = env -> GetNow (); do { // \u6267\u884cjs\u56de\u8c03processTimers\u51fd\u6570 ret = cb -> Call ( env -> context (), process , 1 , & arg ); } while ( ret . IsEmpty () && env -> can_call_into_js ()); // \u5982\u679c\u8fd8\u6709\u672a\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u5219ret\u4e3a\u7b2c\u4e00\u4e2a\u672a\u8d85\u65f6\u7684\u8282\u70b9\u7684\u8d85\u65f6\u65f6\u95f4 int64_t expiry_ms = ret . ToLocalChecked () -> IntegerValue ( env -> context ()). FromJust (); uv_handle_t * h = reinterpret_cast < uv_handle_t *> ( handle ); /* 1 \u7b49\u4e8e0\u8bf4\u660e\u6240\u6709\u8282\u70b9\u90fd\u6267\u884c\u5b8c\u4e86\uff0c\u4f46\u662f\u5b9a\u65f6\u5668\u8282\u70b9\u8fd8\u662f\u5728Libuv\u4e2d\uff0c \u4e0d\u8fc7\u6539\u6210\u975e\u6fc0\u6d3b\u72b6\u6001\uff0c\u5373\u4e0d\u4f1a\u5f71\u54cdLibuv\u9000\u51fa\uff0c\u56e0\u4e3a\u5f53\u524d\u6ca1\u6709\u9700\u8981\u5904\u7406\u7684\u8282\u70b9\u4e86\uff08handle\uff09\uff0c 2 \u4e0d\u7b49\u4e8e0\u8bf4\u660e\u6ca1\u6709\u8fd8\u8981\u8282\u70b9\u9700\u8981\u5904\u7406\uff0c\u8fd9\u79cd\u60c5\u51b5\u53c8\u5206\u4e3a\u4e24\u79cd 1 \u8fd8\u6709\u6fc0\u6d3b\u72b6\u6001\u7684\u5b9a\u65f6\u5668\uff0c\u5373\u4e0d\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa 2 \u5b9a\u65f6\u5668\u90fd\u662f\u975e\u6fc0\u6d3b\u72b6\u6001\u7684\uff0c\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa \u5177\u4f53\u89c1Timeout\u7684unref\u548cref\u65b9\u6cd5 */ if ( expiry_ms != 0 ) { // \u7b97\u51fa\u4e0b\u6b21\u8d85\u65f6\u7684\u76f8\u5bf9\u503c int64_t duration_ms = llabs ( expiry_ms ) - ( uv_now ( env -> event_loop ()) - env -> timer_base ()); // \u91cd\u65b0\u628ahandle\u63d2\u5165Libuv\u7684\u4e8c\u53c9\u5806 env -> ScheduleTimer ( duration_ms > 0 ? duration_ms : 1 ); /* \u89c1internal/timer.js\u7684processTimers 1 \u5927\u4e8e0\u8bf4\u660e\u8fd8\u6709\u8282\u70b9\u6ca1\u8d85\u65f6\uff0c\u5e76\u4e14\u4e0d\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\uff0c \u9700\u8981\u4fdd\u6301\u5b9a\u65f6\u5668\u7684\u6fc0\u6d3b\u72b6\u6001\uff08\u5982\u679c\u4e4b\u524d\u662f\u6fc0\u6d3b\u72b6\u6001\u5219\u4e0d\u5f71\u54cd\uff09\uff0c 2 \u5c0f\u4e8e0\u8bf4\u660e\u5b9a\u65f6\u5668\u4e0d\u5f71\u54cdLibuv\u7684\u4e8b\u4ef6\u5faa\u73af\u7684\u7ed3\u675f\uff0c\u6539\u6210\u975e\u6fc0\u6d3b\u72b6\u6001 */ if ( expiry_ms > 0 ) uv_ref ( h ); else uv_unref ( h ); } else { uv_unref ( h ); } } \u8be5\u51fd\u6570\u4e3b\u8981\u662f\u6267\u884c\u56de\u8c03\uff0c\u7136\u540e\u5982\u679c\u8fd8\u6709\u6ca1\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u91cd\u65b0\u8bbe\u7f6eLibuv\u5b9a\u65f6\u5668\u7684\u65f6\u95f4\u3002\u770b\u770bJS\u5c42\u9762\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 function processTimers ( now ) { nextExpiry = Infinity ; let list ; let ranAtLeastOneList = false ; // \u53d6\u51fa\u4f18\u5148\u961f\u5217\u7684\u6839\u8282\u70b9\uff0c\u5373\u6700\u5feb\u5230\u671f\u7684\u8282\u70b9 while ( list = timerListQueue . peek ()) { // \u8fd8\u6ca1\u8fc7\u671f\uff0c\u5219\u53d6\u5f97\u4e0b\u6b21\u5230\u671f\u7684\u65f6\u95f4\uff0c\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4 if ( list . expiry > now ) { nextExpiry = list . expiry ; // \u8fd4\u56de\u4e0b\u4e00\u6b21\u8fc7\u671f\u7684\u65f6\u95f4\uff0c\u8d1f\u7684\u8bf4\u660e\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa return refCount > 0 ? nextExpiry : - nextExpiry ; } // \u5904\u7406\u8d85\u65f6\u8282\u70b9 listOnTimeout ( list , now ); } // \u6240\u6709\u8282\u70b9\u90fd\u5904\u7406\u5b8c\u4e86 return 0 ; } function listOnTimeout ( list , now ) { const msecs = list . msecs ; let ranAtLeastOneTimer = false ; let timer ; // \u904d\u5386\u5177\u6709\u7edf\u4e00\u76f8\u5bf9\u8fc7\u671f\u65f6\u95f4\u7684\u961f\u5217 while ( timer = L . peek ( list )) { // \u7b97\u51fa\u5df2\u7ecf\u8fc7\u53bb\u7684\u65f6\u95f4 const diff = now - timer . _idleStart ; // \u8fc7\u671f\u7684\u65f6\u95f4\u6bd4\u8d85\u65f6\u65f6\u95f4\u5c0f\uff0c\u8fd8\u6ca1\u8fc7\u671f if ( diff < msecs ) { /* \u6574\u4e2a\u94fe\u8868\u8282\u70b9\u7684\u6700\u5feb\u8fc7\u671f\u65f6\u95f4\u7b49\u4e8e\u5f53\u524d \u8fd8\u6ca1\u8fc7\u671f\u8282\u70b9\u7684\u503c\uff0c\u94fe\u8868\u662f\u6709\u5e8f\u7684 */ list . expiry = MathMax ( timer . _idleStart + msecs , now + 1 ); // \u66f4\u65b0id\uff0c\u7528\u4e8e\u51b3\u5b9a\u5728\u4f18\u5148\u961f\u5217\u91cc\u7684\u4f4d\u7f6e list . id = timerListId ++ ; /* \u8c03\u6574\u8fc7\u671f\u65f6\u95f4\u540e\uff0c\u5f53\u524d\u94fe\u8868\u5bf9\u5e94\u7684\u8282\u70b9\u4e0d\u4e00\u5b9a\u662f\u4f18\u5148\u961f\u5217 \u91cc\u7684\u6839\u8282\u70b9\u4e86\uff0c\u53ef\u80fd\u6709\u5b83\u66f4\u5feb\u5230\u671f\uff0c\u5373\u5f53\u524d\u94fe\u8868\u5bf9\u5e94\u7684\u8282 \u70b9\u53ef\u80fd\u9700\u8981\u5f80\u4e0b\u6c89 */ timerListQueue . percolateDown ( 1 ); return ; } // \u51c6\u5907\u6267\u884c\u7528\u6237\u8bbe\u7f6e\u7684\u56de\u8c03\uff0c\u5220\u9664\u8fd9\u4e2a\u8282\u70b9 L . remove ( timer ); let start ; if ( timer . _repeat ) start = getLibuvNow (); try { const args = timer . _timerArgs ; // \u6267\u884c\u7528\u6237\u8bbe\u7f6e\u7684\u56de\u8c03 if ( args === undefined ) timer . _onTimeout (); else timer . _onTimeout (... args ); } finally { /* \u8bbe\u7f6e\u4e86\u91cd\u590d\u6267\u884c\u56de\u8c03\uff0c\u5373\u6765\u81easetInterval\u3002 \u5219\u9700\u8981\u91cd\u65b0\u52a0\u5165\u94fe\u8868\u3002 */ if ( timer . _repeat && timer . _idleTimeout !== - 1 ) { // \u66f4\u65b0\u8d85\u65f6\u65f6\u95f4\uff0c\u4e00\u6837\u7684\u65f6\u95f4\u95f4\u9694 timer . _idleTimeout = timer . _repeat ; // \u91cd\u65b0\u63d2\u5165\u94fe\u8868 insert ( timer , timer . _idleTimeout , start ); } else if ( ! timer . _idleNext && ! timer . _idlePrev && ! timer . _destroyed ) { timer . _destroyed = true ; // \u662fref\u7c7b\u578b\uff0c\u5219\u51cf\u53bb\u4e00\u4e2a\uff0c\u9632\u6b62\u963b\u6b62\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa if ( timer [ kRefed ]) refCount -- ; } // \u4e3a\u7a7a\u5219\u5220\u9664 if ( list === timerListMap [ msecs ]) { delete timerListMap [ msecs ]; // \u4ece\u4f18\u5148\u961f\u5217\u4e2d\u5220\u9664\u8be5\u8282\u70b9\uff0c\u5e76\u8c03\u6574\u961f\u5217\u7ed3\u6784 timerListQueue . shift (); } } \u4e0a\u9762\u7684\u4ee3\u7801\u4e3b\u8981\u662f\u904d\u5386\u4f18\u5148\u961f\u5217 1 \u5982\u679c\u5f53\u524d\u8282\u70b9\u8d85\u65f6\uff0c\u5219\u904d\u5386\u5b83\u5bf9\u5e94\u7684\u94fe\u8868\u3002\u904d\u5386\u94fe\u8868\u7684\u65f6\u5019\u5982\u679c\u9047\u5230\u8d85\u65f6\u7684\u8282\u70b9\u5219\u6267\u884c\u3002\u5982\u679c\u9047\u5230\u6ca1\u6709\u8d85\u65f6\u7684\u8282\u70b9\uff0c\u5219\u8bf4\u660e\u540e\u9762\u7684\u8282\u70b9\u4e5f\u4e0d\u4f1a\u8d85\u65f6\u4e86\uff0c\u56e0\u4e3a\u94fe\u8868\u662f\u6709\u5e8f\u7684\uff0c\u63a5\u7740\u91cd\u65b0\u8ba1\u7b97\u51fa\u6700\u5feb\u8d85\u65f6\u65f6\u95f4\uff0c\u4fee\u6539\u94fe\u8868\u7684expiry\u5b57\u6bb5\u3002\u8c03\u6574\u5728\u4f18\u5148\u961f\u5217\u7684\u4f4d\u7f6e\u3002\u56e0\u4e3a\u4fee\u6539\u540e\u7684expiry\u53ef\u80fd\u4f1a\u5bfc\u81f4\u4f4d\u7f6e\u53d1\u751f\u53d8\u5316\u3002\u5982\u679c\u94fe\u8868\u7684\u8282\u70b9\u5168\u90e8\u90fd\u8d85\u65f6\u4e86\uff0c\u5219\u4ece\u4f18\u5148\u961f\u5217\u4e2d\u5220\u9664\u94fe\u8868\u5bf9\u5e94\u7684\u8282\u70b9\u3002\u91cd\u65b0\u8c03\u6574\u4f18\u5148\u961f\u5217\u7684\u8282\u70b9\u3002 2 \u5982\u679c\u5f53\u524d\u8282\u70b9\u6ca1\u6709\u8d85\u65f6\u5219\u8bf4\u660e\u540e\u9762\u7684\u8282\u70b9\u4e5f\u4e0d\u4f1a\u8d85\u65f6\u4e86\u3002\u56e0\u4e3a\u5f53\u524d\u8282\u70b9\u662f\u4f18\u5148\u961f\u5217\u4e2d\u6700\u5feb\u5230\u671f\uff08\u6700\u5c0f\u7684\uff09\u7684\u8282\u70b9\u3002\u63a5\u7740\u8bbe\u7f6eLibuv\u7684\u5b9a\u65f6\u5668\u65f6\u95f4\u4e3a\u5f53\u524d\u8282\u70b9\u7684\u65f6\u95f4\u3002\u7b49\u5f85\u4e0b\u4e00\u6b21\u8d85\u65f6\u5904\u7406\u3002","title":"10.5 \u5904\u7406\u5b9a\u65f6\u5668"},{"location":"chapter10-%E5%AE%9A%E6%97%B6%E5%99%A8/#106-refunref","text":"setTimeout\u8fd4\u56de\u7684\u662f\u4e00\u4e2aTimeout\u5bf9\u8c61\uff0c\u8be5\u63d0\u4f9b\u4e86ref\u548cunref\u63a5\u53e3\uff0c\u521a\u624d\u63d0\u5230\u4e86\u5173\u4e8e\u5b9a\u65f6\u5668\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\u7684\u5185\u5bb9\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u539f\u7406\u3002\u521a\u624d\u8bf4\u5230Node.js\u5b9a\u65f6\u5668\u6a21\u5757\u5728Libuv\u4e2d\u53ea\u5bf9\u5e94\u4e00\u4e2a\u5b9a\u65f6\u5668\u8282\u70b9\u3002\u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u521d\u59cb\u5316\u4e86\u8be5\u8282\u70b9\u3002 1 2 3 4 5 6 void Environment::InitializeLibuv ( bool start_profiler_idle_notifier ) { // \u521d\u59cb\u5316\u5b9a\u65f6\u5668 CHECK_EQ ( 0 , uv_timer_init ( event_loop (), timer_handle ())); // \u7f6eunref\u72b6\u6001 uv_unref ( reinterpret_cast < uv_handle_t *> ( timer_handle ())); } \u6211\u4eec\u770b\u5230\u5e95\u5c42\u5b9a\u65f6\u5668\u8282\u70b9\u9ed8\u8ba4\u662funref\u72b6\u6001\u7684\uff0c\u6240\u4ee5\u4e0d\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002\u56e0\u4e3a\u521d\u59cb\u5316\u65f6JS\u5c42\u6ca1\u6709\u5b9a\u65f6\u8282\u70b9\u3002\u53ef\u4ee5\u901a\u8fc7Node.js\u63d0\u4f9b\u7684\u63a5\u53e3\u4fee\u6539\u8be5\u72b6\u6001\u3002Node.js\u652f\u6301ref\u72b6\u6001\u7684Timeout\uff08setTimeout\uff09\u548cunref\u72b6\u6001\u7684Timeout\uff08setUnrefTimeout\uff09\u3002 1 2 3 4 5 function Timeout ( callback , after , args , isRepeat , isRefed ) { if ( isRefed ) incRefCount (); this [ kRefed ] = isRefed ; } \u6700\u540e\u4e00\u4e2a\u53c2\u6570\u5c31\u662f\u63a7\u5236ref\u8fd8\u662funref\u7684\u3002\u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0b\u5982\u679cisRefed\u4e3atrue\u7684\u65f6\u5019\u7684\u903b\u8f91 1 2 3 4 function incRefCount () { if ( refCount ++ === 0 ) toggleTimerRef ( true ); } refCount\u521d\u59cb\u5316\u7684\u65f6\u5019\u662f1\uff0c\u6240\u4ee5\u5728\u65b0\u52a0\u7b2c\u4e00\u4e2aTimeout\u7684\u65f6\u5019\uff0cif\u6210\u7acb\u3002\u6211\u4eec\u63a5\u7740\u770btoggleTimerRef\uff0c\u8be5\u51fd\u6570\u5bf9\u5e94\u7684\u4ee3\u7801\u5982\u4e0b 1 2 3 4 5 6 7 8 void Environment::ToggleTimerRef ( bool ref ) { // \u6253\u4e0aref\u6807\u8bb0\uff0c if ( ref ) { uv_ref ( reinterpret_cast < uv_handle_t *> ( timer_handle ())); } else { uv_unref ( reinterpret_cast < uv_handle_t *> ( timer_handle ())); } } \u8be5\u51fd\u6570\u6b63\u662f\u7ed9\u5b9a\u65f6\u5668\u5bf9\u5e94\u7684handle\u8bbe\u7f6e\u72b6\u6001\u7684\u3002setTimeout\u7684\u65f6\u5019\uff0cisRefed\u7684\u503c\u662ftrue\u7684\uff0cNode.js\u8fd8\u63d0\u4f9b\u4e86\u53e6\u5916\u4e00\u4e2a\u51fd\u6570setUnrefTimeout\u3002 1 2 3 4 5 function setUnrefTimeout ( callback , after ) { const timer = new Timeout ( callback , after , undefined , false , false ); insert ( timer , timer . _idleTimeout ); return timer ; } \u8be5\u51fd\u6570\u548csetTimeout\u6700\u4e3b\u8981\u7684\u533a\u522b\u662fnew Timeout\u7684\u65f6\u5019\uff0c\u6700\u540e\u4e00\u4e2a\u53c2\u6570\u662ffalse\uff08isRefed\u53d8\u91cf\u7684\u503c\uff09\uff0c\u6240\u4ee5setUnrefTimeout\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\u662f\u4e0d\u4f1a\u5f71\u54cdLibuv\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\u7684\u3002\u53e6\u5916\u9664\u4e86Node.js\u76f4\u63a5\u63d0\u4f9b\u7684api\u540e\u3002\u6211\u4eec\u8fd8\u53ef\u4ee5\u901a\u8fc7Timeout\u5bf9\u8c61\u63d0\u4f9b\u7684ref\u548cunref\u624b\u52a8\u63a7\u5236\u8fd9\u4e2a\u72b6\u6001\u3002 \u73b0\u5728\u901a\u8fc7\u4e00\u4e2a\u4f8b\u5b50\u5177\u4f53\u6765\u770b\u4e00\u4e0b\u3002 1 2 3 4 5 const timeout = setTimeout (() => { console . log ( 1 ) }, 10000 ); timeout . unref (); // timeout.ref(); \u52a0\u8fd9\u4e00\u53e5\u4f1a\u8f93\u51fa1 \u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c1\u662f\u4e0d\u4f1a\u8f93\u51fa\uff0c\u9664\u975e\u628a\u6ce8\u91ca\u53bb\u6389\u3002Unref\u548cref\u662f\u76f8\u53cd\u7684\u53c2\u6570\uff0c\u5373\u628a\u5b9a\u65f6\u5668\u6a21\u5757\u5bf9\u5e94\u7684Libuv handle\u6539\u6210unref\u72b6\u6001\u3002","title":"10.6 ref\u548cunref"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/","text":"setImmediate\u5bf9\u5e94Libuv\u7684check\u9636\u6bb5\u3002\u6240\u63d0\u4ea4\u7684\u4efb\u52a1\u4f1a\u5728Libuv\u4e8b\u4ef6\u5faa\u73af\u7684check\u9636\u6bb5\u88ab\u6267\u884c\uff0ccheck\u9636\u6bb5\u7684\u4efb\u52a1\u4f1a\u5728\u6bcf\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u4e2d\u88ab\u6267\u884c\uff0c\u4f46\u662fsetImmediate\u63d0\u4ea4\u7684\u4efb\u52a1\u53ea\u4f1a\u6267\u884c\u4e00\u6b21\uff0c\u4e0b\u9762\u6211\u4eec\u4f1a\u770b\u5230Node.js\u662f\u600e\u4e48\u5904\u7406\u7684\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002 11.1 setImmediate \u00b6 11.1.1\u8bbe\u7f6e\u5904\u7406immediate\u4efb\u52a1\u7684\u51fd\u6570 \u00b6 \u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u8bbe\u7f6e\u4e86\u5904\u7406immediate\u4efb\u52a1\u7684\u51fd\u6570 1 2 3 // runNextTicks\u7528\u4e8e\u5904\u7406nextTick\u4ea7\u751f\u7684\u4efb\u52a1\uff0c\u8fd9\u91cc\u4e0d\u5173\u6ce8 const { processImmediate , processTimers } = getTimerCallbacks ( runNextTicks ); setupTimers ( processImmediate , processTimers ); \u6211\u4eec\u5148\u770b\u770b\u4e00\u4e0bsetupTimers\uff08timer.cc\uff09\u7684\u903b\u8f91\u3002 1 2 3 4 5 void SetupTimers ( const FunctionCallbackInfo < Value >& args ) { auto env = Environment :: GetCurrent ( args ); env -> set_immediate_callback_function ( args [ 0 ]. As < Function > ()); env -> set_timers_callback_function ( args [ 1 ]. As < Function > ()); } SetupTimers\u5728env\u4e2d\u4fdd\u5b58\u4e86\u4e24\u4e2a\u51fd\u6570processImmediate, processTimers\uff0cprocessImmediate\u662f\u5904\u7406immediate\u4efb\u52a1\u7684\uff0cprocessTimers\u662f\u5904\u7406\u5b9a\u65f6\u5668\u4efb\u52a1\u7684\uff0c\u5728\u5b9a\u65f6\u5668\u7ae0\u8282\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\u3002 11.1.2 \u6ce8\u518ccheck\u9636\u6bb5\u7684\u56de\u8c03 \u00b6 \u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u540c\u65f6\u521d\u59cb\u5316\u4e86immediate\u4efb\u52a1\u76f8\u5173\u7684\u6570\u636e\u7ed3\u6784\u548c\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 void Environment::InitializeLibuv ( bool start_profiler_idle_notifier ) { // \u521d\u59cb\u5316immediate\u76f8\u5173\u7684handle uv_check_init ( event_loop (), immediate_check_handle ()); // \u4fee\u6539\u72b6\u6001\u4e3aunref\uff0c\u907f\u514d\u6ca1\u6709\u4efb\u52a1\u7684\u65f6\u5019\uff0c\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa uv_unref ( reinterpret_cast < uv_handle_t *> ( immediate_check_handle ())); // \u6fc0\u6d3bhandle\uff0c\u8bbe\u7f6e\u56de\u8c03 uv_check_start ( immediate_check_handle (), CheckImmediate ); // \u5728idle\u9636\u6bb5\u4e5f\u63d2\u5165\u4e00\u4e2a\u76f8\u5173\u7684\u8282\u70b9 uv_idle_init ( event_loop (), immediate_idle_handle ()); } Node.js\u9ed8\u8ba4\u4f1a\u5f80check\u9636\u6bb5\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u5e76\u8bbe\u7f6e\u56de\u8c03\u4e3aCheckImmediate\uff0c\u4f46\u662f\u521d\u59cb\u5316\u72b6\u6001\u662funref\u7684\uff0c\u6240\u4ee5\u5982\u679c\u6ca1\u6709immediate\u4efb\u52a1\u7684\u8bdd\uff0c\u4e0d\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002\u6211\u4eec\u770b\u4e00\u4e0bCheckImmediate\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void Environment::CheckImmediate ( uv_check_t * handle ) { // \u7701\u7565\u90e8\u5206\u4ee3\u7801 // \u6ca1\u6709Immediate\u8282\u70b9\u9700\u8981\u5904\u7406 if ( env -> immediate_info () -> count () == 0 || ! env -> can_call_into_js ()) return ; do { // \u6267\u884cJS\u5c42\u56de\u8c03immediate_callback_function MakeCallback ( env -> isolate (), env -> process_object (), env -> immediate_callback_function (), 0 , nullptr , { 0 , 0 }). ToLocalChecked (); } while ( env -> immediate_info () -> has_outstanding () && env -> can_call_into_js ()); /* \u6240\u6709immediate\u8282\u70b9\u90fd\u5904\u7406\u5b8c\u4e86\uff0c\u7f6eidle\u9636\u6bb5\u5bf9\u5e94\u8282\u70b9\u4e3a\u975e\u6fc0\u6d3b\u72b6\u6001\uff0c \u5141\u8bb8Poll IO\u9636\u6bb5\u963b\u585e\u548c\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa */ if ( env -> immediate_info () -> ref_count () == 0 ) env -> ToggleImmediateRef ( false ); } \u6211\u4eec\u770b\u5230\u6bcf\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u65f6\uff0cCheckImmediate\u90fd\u4f1a\u88ab\u6267\u884c\uff0c\u4f46\u662f\u5982\u679c\u6ca1\u6709\u9700\u8981\u5904\u7406\u7684\u4efb\u52a1\u5219\u76f4\u63a5\u8fd4\u56de\u3002\u5982\u679c\u6709\u4efb\u52a1\uff0cCheckImmediate\u51fd\u6570\u6267\u884cimmediate_callback_function\u51fd\u6570\uff0c\u8fd9\u6b63\u662fNode.js\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u7684\u51fd\u6570processImmediate\u3002\u770b\u5b8c\u521d\u59cb\u5316\u548c\u5904\u7406immediate\u4efb\u52a1\u7684\u903b\u8f91\u540e\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u4ea7\u751f\u4e00\u4e2aimmediate\u4efb\u52a1\u3002 11.1.3 setImmediate\u751f\u6210\u4efb\u52a1 \u00b6 \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7setImmediate\u751f\u6210\u4e00\u4e2a\u4efb\u52a1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function setImmediate ( callback , arg1 , arg2 , arg3 ) { let i , args ; switch ( arguments . length ) { case 1 : break ; case 2 : args = [ arg1 ]; break ; case 3 : args = [ arg1 , arg2 ]; break ; default : args = [ arg1 , arg2 , arg3 ]; for ( i = 4 ; i < arguments . length ; i ++ ) { args [ i - 1 ] = arguments [ i ]; } break ; } return new Immediate ( callback , args ); } setImmediate\u7684\u4ee3\u7801\u6bd4\u8f83\u7b80\u5355\uff0c\u65b0\u5efa\u4e00\u4e2aImmediate\u3002\u6211\u4eec\u770b\u4e00\u4e0bImmediate\u7684\u7c7b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 const Immediate = class Immediate { constructor ( callback , args ) { this . _idleNext = null ; this . _idlePrev = null ; this . _onImmediate = callback ; this . _argv = args ; this . _destroyed = false ; this [ kRefed ] = false ; this . ref (); // Immediate\u94fe\u8868\u7684\u8282\u70b9\u4e2a\u6570\uff0c\u5305\u62ecref\u548cunref\u72b6\u6001 immediateInfo [ kCount ] ++ ; // \u52a0\u5165\u94fe\u8868\u4e2d immediateQueue . append ( this ); } // \u6253\u4e0aref\u6807\u8bb0\uff0c\u5f80Libuv\u7684idle\u94fe\u8868\u63d2\u5165\u4e00\u4e2a\u6fc0\u6d3b\u72b6\u6001\u7684\u8282\u70b9\uff0c\u5982\u679c\u8fd8\u6ca1\u6709\u7684\u8bdd ref () { if ( this [ kRefed ] === false ) { this [ kRefed ] = true ; if ( immediateInfo [ kRefCount ] ++ === 0 ) toggleImmediateRef ( true ); } return this ; } // \u548c\u4e0a\u9762\u76f8\u53cd unref () { if ( this [ kRefed ] === true ) { this [ kRefed ] = false ; if ( -- immediateInfo [ kRefCount ] === 0 ) toggleImmediateRef ( false ); } return this ; } hasRef () { return !! this [ kRefed ]; } }; Immediate\u7c7b\u4e3b\u8981\u505a\u4e86\u4e24\u4e2a\u4e8b\u60c5\u3002 1 \u751f\u6210\u4e00\u4e2a\u8282\u70b9\u63d2\u5165\u5230\u94fe\u8868\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 const immediateQueue = new ImmediateList (); // \u53cc\u5411\u975e\u5faa\u73af\u7684\u94fe\u8868 function ImmediateList () { this . head = null ; this . tail = null ; } ImmediateList . prototype . append = function ( item ) { // \u5c3e\u6307\u9488\u975e\u7a7a\uff0c\u8bf4\u660e\u94fe\u8868\u975e\u7a7a\uff0c\u76f4\u63a5\u8ffd\u52a0\u5728\u5c3e\u8282\u70b9\u540e\u9762 if ( this . tail !== null ) { this . tail . _idleNext = item ; item . _idlePrev = this . tail ; } else { // \u5c3e\u6307\u9488\u662f\u7a7a\u8bf4\u660e\u94fe\u8868\u662f\u7a7a\u7684\uff0c\u5934\u5c3e\u6307\u9488\u90fd\u6307\u5411item this . head = item ; } this . tail = item ; }; ImmediateList . prototype . remove = function ( item ) { // \u5982\u679citem\u5728\u4e2d\u95f4\u5219\u81ea\u5df1\u5168\u8eab\u800c\u9000\uff0c\u524d\u540e\u4e24\u4e2a\u8282\u70b9\u8fde\u4e0a if ( item . _idleNext !== null ) { item . _idleNext . _idlePrev = item . _idlePrev ; } if ( item . _idlePrev !== null ) { item . _idlePrev . _idleNext = item . _idleNext ; } // \u662f\u5934\u6307\u9488\uff0c\u5219\u9700\u8981\u66f4\u65b0\u5934\u6307\u9488\u6307\u5411item\u7684\u4e0b\u4e00\u4e2a\uff0c\u56e0\u4e3aitem\u88ab\u5220\u9664\u4e86\uff0c\u5c3e\u6307\u9488\u540c\u7406 if ( item === this . head ) this . head = item . _idleNext ; if ( item === this . tail ) this . tail = item . _idlePrev ; // \u91cd\u7f6e\u524d\u540e\u6307\u9488 item . _idleNext = null ; item . _idlePrev = null ; }; 2 \u5982\u679c\u8fd8\u6ca1\u6709\u5f80Libuv\u7684idle\u94fe\u8868\u91cc\u63d2\u5165\u4e00\u4e2a\u6fc0\u6d3b\u8282\u70b9\u7684\u8bdd\uff0c\u5219\u63d2\u5165\u4e00\u4e2a\u3002\u4ece\u4e4b\u524d\u7684\u5206\u6790\uff0c\u6211\u4eec\u77e5\u9053\uff0cNode.js\u5728check\u9636\u6bb5\u63d2\u5165\u4e86\u4e00\u4e2aunref\u8282\u70b9\uff0c\u5728\u6bcf\u6b21check\u9636\u6bb5\u90fd\u4f1a\u6267\u884c\u8be5\u8282\u70b9\u7684\u56de\u8c03\uff0c\u90a3\u4e48\u8fd9\u4e2aidle\u8282\u70b9\u6709\u4ec0\u4e48\u7528\u5462\uff1f\u7b54\u6848\u5728uv_backend_timeout\u51fd\u6570\u4e2d\uff0cuv_backend_timeout\u5b9a\u4e49\u4e86Poll IO\u963b\u585e\u7684\u65f6\u957f\uff0c\u5982\u679c\u6709ref\u72b6\u6001\u7684idle\u8282\u70b9\u5219Poll IO\u9636\u6bb5\u4e0d\u4f1a\u963b\u585e\uff08\u4f46\u662f\u4e0d\u4f1a\u5224\u65ad\u662f\u5426\u6709check\u8282\u70b9\uff09\u3002\u6240\u4ee5\u5f53\u6709immediate\u4efb\u52a1\u65f6\uff0cNode.js\u4f1a\u628a\u8fd9\u4e2aidle\u63d2\u5165idle\u9636\u6bb5\u4e2d\uff0c\u8868\u793a\u6709\u4efb\u52a1\u5904\u7406\uff0c\u4e0d\u80fd\u963b\u585ePoll IO\u9636\u6bb5\u3002\u6ca1\u6709immediate\u4efb\u52a1\u65f6\uff0c\u5219\u79fb\u9664idle\u8282\u70b9\u3002\u603b\u7684\u6765\u8bf4\uff0cidle\u8282\u70b9\u7684\u610f\u4e49\u662f\u6807\u8bb0\u662f\u5426\u6709immediate\u4efb\u52a1\u9700\u8981\u5904\u7406\uff0c\u6709\u7684\u8bdd\u5c31\u4e0d\u80fd\u963b\u585ePoll IO\u9636\u6bb5\uff0c\u5e76\u4e14\u4e0d\u80fd\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void ToggleImmediateRef ( const FunctionCallbackInfo < Value >& args ) { Environment :: GetCurrent ( args ) -> ToggleImmediateRef ( args [ 0 ] -> IsTrue ()) } void Environment::ToggleImmediateRef ( bool ref ) { if ( started_cleanup_ ) return ; // \u6539\u53d8handle\u7684\u72b6\u6001\uff08\u6fc0\u6d3b\u6216\u4e0d\u6fc0\u6d3b\uff09\uff0c\u9632\u6b62\u5728Poll IO\u9636\u6bb5\u963b\u585e if ( ref ) { uv_idle_start ( immediate_idle_handle (), []( uv_idle_t * ){ }); } else { // \u4e0d\u963b\u585ePoll IO\uff0c\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa uv_idle_stop ( immediate_idle_handle ()); } } \u8fd9\u662fsetImmediate\u51fd\u6570\u7684\u6574\u4e2a\u8fc7\u7a0b\u3002\u548c\u5b9a\u65f6\u5668\u4e00\u6837\uff0c\u6211\u4eec\u53ef\u4ee5\u8c03\u7528immediate\u4efb\u52a1\u7684ref\u548cunref\u51fd\u6570\uff0c\u63a7\u5236\u5b83\u5bf9\u4e8b\u4ef6\u5faa\u73af\u7684\u5f71\u54cd\u3002 11.1.4 \u5904\u7406setImmediate\u4ea7\u751f\u7684\u4efb\u52a1 \u00b6 \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u5728check\u9636\u6bb5\u65f6\uff0c\u662f\u5982\u4f55\u5904\u7406immediate\u4efb\u52a1\u7684\u3002\u7531\u524d\u9762\u5206\u6790\u6211\u4eec\u77e5\u9053processImmediate\u51fd\u6570\u662f\u5904\u7406immediate\u4efb\u52a1\u7684\u51fd\u6570\uff0c\u6765\u81eagetTimerCallbacks\uff08internal/timer.js\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 function processImmediate () { /* \u4e0a\u6b21\u6267\u884cprocessImmediate\u7684\u65f6\u5019\u5982\u679c\u7531\u672a\u6355\u83b7\u7684\u5f02\u5e38\uff0c \u5219outstandingQueue\u4fdd\u5b58\u4e86\u672a\u6267\u884c\u7684\u8282\u70b9\uff0c\u4e0b\u6b21\u6267\u884cprocessImmediate\u7684\u65f6\u5019\uff0c \u4f18\u5148\u6267\u884coutstandingQueue\u961f\u5217\u7684\u8282\u70b9 */ const queue = outstandingQueue . head !== null ? outstandingQueue : immediateQueue ; let immediate = queue . head ; /* \u5728\u6267\u884cimmediateQueue\u961f\u5217\u7684\u8bdd\uff0c\u5148\u7f6e\u7a7a\u961f\u5217\uff0c\u907f\u514d\u6267\u884c\u56de\u8c03 \u7684\u65f6\u5019\u4e00\u76f4\u5f80\u961f\u5217\u52a0\u8282\u70b9\uff0c\u6b7b\u5faa\u73af\u3002 \u6240\u4ee5\u65b0\u52a0\u7684\u63a5\u53e3\u4f1a\u63d2\u5165\u65b0\u7684\u961f\u5217\uff0c \u4e0d\u4f1a\u5728\u672c\u6b21\u88ab\u6267\u884c\u3002\u5e76\u6253\u4e00\u4e2a\u6807\u8bb0,\u5168\u90e8immediateQueue\u8282\u70b9\u90fd\u88ab\u6267 \u884c\u5219\u6e05\u7a7a\uff0c\u5426\u5219\u4f1a\u518d\u6267\u884cprocessImmediate\u4e00\u6b21\uff0c\u89c1Environment::CheckImmediate */ if ( queue !== outstandingQueue ) { queue . head = queue . tail = null ; immediateInfo [ kHasOutstanding ] = 1 ; } let prevImmediate ; let ranAtLeastOneImmediate = false ; while ( immediate !== null ) { // \u6267\u884c\u5fae\u4efb\u52a1 if ( ranAtLeastOneImmediate ) runNextTicks (); else ranAtLeastOneImmediate = true ; // \u5fae\u4efb\u52a1\u628a\u8be5\u8282\u70b9\u5220\u9664\u4e86\uff0c\u5219\u4e0d\u9700\u8981\u6307\u5411\u5b83\u7684\u56de\u8c03\u4e86\uff0c\u7ee7\u7eed\u4e0b\u4e00\u4e2a if ( immediate . _destroyed ) { outstandingQueue . head = immediate = prevImmediate . _idleNext ; continue ; } immediate . _destroyed = true ; // \u6267\u884c\u5b8c\u8981\u4fee\u6539\u4e2a\u6570 immediateInfo [ kCount ] -- ; if ( immediate [ kRefed ]) immediateInfo [ kRefCount ] -- ; immediate [ kRefed ] = null ; // \u89c1\u4e0a\u9762if (immediate._destroyed)\u7684\u6ce8\u91ca prevImmediate = immediate ; // \u6267\u884c\u56de\u8c03\uff0c\u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9 try { const argv = immediate . _argv ; if ( ! argv ) immediate . _onImmediate (); else immediate . _onImmediate (... argv ); } finally { immediate . _onImmediate = null ; outstandingQueue . head = immediate = immediate . _idleNext ; } } // \u5f53\u524d\u6267\u884c\u7684\u662foutstandingQueue\u7684\u8bdd\u5219\u628a\u5b83\u6e05\u7a7a if ( queue === outstandingQueue ) outstandingQueue . head = null ; // \u5168\u90e8\u8282\u70b9\u6267\u884c\u5b8c immediateInfo [ kHasOutstanding ] = 0 ; } processImmediate\u7684\u903b\u8f91\u5c31\u662f\u9010\u4e2a\u6267\u884cimmediate\u4efb\u52a1\u961f\u5217\u7684\u8282\u70b9\u3002Immediate\u5206\u4e24\u4e2a\u961f\u5217\uff0c\u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u63d2\u5165\u7684immediate\u8282\u70b9\u63d2\u5165\u5230immediateQueue\u961f\u5217\u3002\u5982\u679c\u6267\u884c\u7684\u65f6\u5019\u6709\u5f02\u5e38\uff0c\u5219\u672a\u5904\u7406\u5b8c\u7684\u8282\u70b9\u5c31\u4f1a\u88ab\u63d2\u5165\u5230outstandingQueue\u961f\u5217\uff0c\u7b49\u4e0b\u4e00\u6b21\u6267\u884c\u3002\u53e6\u5916\u6211\u4eec\u770b\u5230runNextTicks\u3002runNextTicks\u5728\u6bcf\u6267\u884c\u5b8cimmediate\u8282\u70b9\u540e\uff0c\u90fd\u5148\u5904\u7406tick\u4efb\u52a1\u7136\u540e\u518d\u5904\u7406\u4e0b\u4e00\u4e2aimmediate\u8282\u70b9\u3002 11.1.5 Node.js\u7684setTimeout(fn,0)\u548csetImmediate\u8c01\u5148\u6267\u884c\u7684\u95ee\u9898 \u00b6 \u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u4e0b\u9762\u8fd9\u6bb5\u4ee3\u7801 1 2 setTimeout (()=>{ console . log ( 'setTimeout' ); }, 0 ) setImmediate (()=>{ console . log ( 'setImmedate' );}) \u6211\u4eec\u6267\u884c\u4e0a\u9762\u8fd9\u6bb5\u4ee3\u7801\uff0c\u4f1a\u53d1\u73b0\u8f93\u51fa\u662f\u4e0d\u786e\u5b9a\u7684\u3002\u4e0b\u9762\u6765\u770b\u4e00\u4e0b\u4e3a\u4ec0\u4e48\u3002Node.js\u7684\u4e8b\u4ef6\u5faa\u73af\u5206\u4e3a\u51e0\u4e2a\u9636\u6bb5(phase)\u3002setTimeout\u662f\u5c5e\u4e8e\u5b9a\u65f6\u5668\u9636\u6bb5\uff0csetImmediate\u662f\u5c5e\u4e8echeck\u9636\u6bb5\u3002\u987a\u5e8f\u4e0a\u5b9a\u65f6\u5668\u9636\u6bb5\u662f\u6bd4check\u66f4\u65e9\u88ab\u6267\u884c\u7684\u3002\u5176\u4e2dsetTimeout\u7684\u5b9e\u73b0\u4ee3\u7801\u91cc\u6709\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u7ec6\u8282\u3002 1 2 3 4 5 6 7 after *= 1 ; // coalesce to number or NaN if ( ! ( after >= 1 && after <= TIMEOUT_MAX )) { if ( after > TIMEOUT_MAX ) { process . emitWarning ( `\u9519\u8bef\u63d0\u793a` ); } after = 1 ; // schedule on next tick, follows browser behavior } \u6211\u4eec\u53d1\u73b0\u867d\u7136\u6211\u4eec\u4f20\u7684\u8d85\u65f6\u65f6\u95f4\u662f0\uff0c\u4f46\u662f0\u4e0d\u662f\u5408\u6cd5\u503c\uff0cNode.js\u4f1a\u628a\u8d85\u65f6\u65f6\u95f4\u53d8\u62101\u3002\u8fd9\u5c31\u662f\u5bfc\u81f4\u4e0a\u9762\u7684\u4ee3\u7801\u8f93\u51fa\u4e0d\u786e\u5b9a\u7684\u539f\u56e0\u3002\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u8fd9\u6bb5\u4ee3\u7801\u7684\u6267\u884c\u8fc7\u7a0b\u3002Node.js\u542f\u52a8\u7684\u65f6\u5019\uff0c\u4f1a\u7f16\u8bd1\u6267\u884c\u4e0a\u9762\u7684\u4ee3\u7801\uff0c\u5f00\u59cb\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u6302\u8f7d\u4e00\u4e2asetImmediate\u8282\u70b9\u5728\u961f\u5217\u3002\u7136\u540e\u8fdb\u5165Libuv\u7684\u4e8b\u4ef6\u5faa\u73af\uff0c\u7136\u540e\u6267\u884c\u5b9a\u65f6\u5668\u9636\u6bb5\uff0cLibuv\u5224\u65ad\u4ece\u5f00\u542f\u5b9a\u65f6\u5668\u5230\u73b0\u5728\u662f\u5426\u5df2\u7ecf\u8fc7\u53bb\u4e861\u6beb\u79d2\uff0c\u662f\u7684\u8bdd\uff0c\u6267\u884c\u5b9a\u65f6\u5668\u56de\u8c03\uff0c\u5426\u5219\u6267\u884c\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u6267\u884c\u5b8c\u5176\u5b83\u9636\u6bb5\u540e\uff0c\u4f1a\u6267\u884ccheck\u9636\u6bb5\u3002\u8fd9\u65f6\u5019\u5c31\u4f1a\u6267\u884csetImmediate\u7684\u56de\u8c03\u3002\u6240\u4ee5\uff0c\u4e00\u5f00\u59cb\u7684\u90a3\u6bb5\u4ee3\u7801\u7684\u8f93\u51fa\u7ed3\u679c\u662f\u53d6\u51b3\u4e8e\u542f\u52a8\u5b9a\u65f6\u5668\u7684\u65f6\u95f4\u5230Libuv\u6267\u884c\u5b9a\u65f6\u5668\u9636\u6bb5\u662f\u5426\u8fc7\u53bb\u4e861\u6beb\u79d2\u3002 11.2 nextTick \u00b6 nextTick\u7528\u4e8e\u5f02\u6b65\u6267\u884c\u4e00\u4e2a\u56de\u8c03\u51fd\u6570\uff0c\u548csetTimeout\u3001setImmediate\u7c7b\u4f3c\uff0c\u4e0d\u540c\u7684\u5730\u65b9\u5728\u4e8e\u4ed6\u4eec\u7684\u6267\u884c\u65f6\u673a\uff0csetTimeout\u548csetImmediate\u7684\u4efb\u52a1\u5c5e\u4e8e\u4e8b\u4ef6\u5faa\u73af\u7684\u4e00\u90e8\u5206\uff0c\u4f46\u662fnextTick\u7684\u4efb\u52a1\u4e0d\u5c5e\u4e8e\u4e8b\u4ef6\u5faa\u73af\u7684\u4e00\u90e8\u5206\uff0c\u5177\u4f53\u7684\u6267\u884c\u65f6\u673a\u6211\u4eec\u4f1a\u5728\u672c\u8282\u5206\u6790\u3002 11.2.1 \u521d\u59cb\u5316nextTick \u00b6 nextTick\u51fd\u6570\u662f\u5728Node.js\u542f\u52a8\u8fc7\u7a0b\u4e2d\uff0c\u5728\u6267\u884cbootstrap/node.js\u65f6\u6302\u8f7d\u5230process\u5bf9\u8c61\u4e2d\u3002 1 2 3 4 5 6 7 8 9 const { nextTick , runNextTicks } = setupTaskQueue (); process . nextTick = nextTick ; // \u771f\u6b63\u7684\u5b9a\u4e49\u5728task_queues.js\u3002 setupTaskQueue () { setTickCallback ( processTicksAndRejections ); return { nextTick , }; }, nextTick\u63a5\u4e0b\u6765\u4f1a\u8bb2\uff0csetTickCallback\u662f\u6ce8\u518c\u5904\u7406tick\u4efb\u52a1\u7684\u51fd\u6570\uff0c 1 2 3 4 5 static void SetTickCallback ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); CHECK ( args [ 0 ] -> IsFunction ()); env -> set_tick_callback_function ( args [ 0 ]. As < Function > ()); } \u53ea\u662f\u7b80\u5355\u5730\u4fdd\u5b58\u5904\u7406tick\u4efb\u52a1\u7684\u51fd\u6570\u3002\u540e\u7eed\u4f1a\u7528\u5230 11.2.2 nextTick\u751f\u4ea7\u4efb\u52a1 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function nextTick ( callback ) { let args ; switch ( arguments . length ) { case 1 : break ; case 2 : args = [ arguments [ 1 ]]; break ; case 3 : args = [ arguments [ 1 ], arguments [ 2 ]]; break ; case 4 : args = [ arguments [ 1 ], arguments [ 2 ], arguments [ 3 ]]; break ; default : args = new Array ( arguments . length - 1 ); for ( let i = 1 ; i < arguments . length ; i ++ ) args [ i - 1 ] = arguments [ i ]; } // \u7b2c\u4e00\u4e2a\u4efb\u52a1\uff0c\u5f00\u542ftick\u5904\u7406\u903b\u8f91 if ( queue . isEmpty ()) setHasTickScheduled ( true ); const asyncId = newAsyncId (); const triggerAsyncId = getDefaultTriggerAsyncId (); const tickObject = { [ async_id_symbol ] : asyncId , [ trigger_async_id_symbol ] : triggerAsyncId , callback , args }; // \u63d2\u5165\u961f\u5217 queue . push ( tickObject ); } \u8fd9\u5c31\u662f\u6211\u4eec\u6267\u884cnextTick\u65f6\u7684\u903b\u8f91\u3002\u6bcf\u6b21\u8c03\u7528nextTick\u90fd\u4f1a\u5f80\u961f\u5217\u4e2d\u8ffd\u52a0\u4e00\u4e2a\u8282\u70b9\u3002 11.2.3 \u5904\u7406tick\u4efb\u52a1 \u00b6 \u6211\u4eec\u518d\u770b\u4e00\u4e0b\u5904\u7406\u7684tick\u4efb\u52a1\u7684\u903b\u8f91\u3002Nodejs\u5728\u521d\u59cb\u5316\u65f6\uff0c\u901a\u8fc7\u6267\u884csetTickCallback(processTicksAndRejections)\u6ce8\u518c\u4e86\u5904\u7406tick\u4efb\u52a1\u7684\u51fd\u6570\u3002Node.js\u5728\u521d\u59cb\u5316\u65f6\u628a\u5904\u7406tick\u4efb\u52a1\u7684\u51fd\u6570\u4fdd\u5b58\u5230env\u4e2d\u3002\u53e6\u5916\uff0cNodejs\u4f7f\u7528TickInfo\u7c7b\u7ba1\u7406tick\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 class TickInfo : public MemoryRetainer { public : inline AliasedUint8Array & fields (); inline bool has_tick_scheduled () const ; inline bool has_rejection_to_warn () const ; private : inline explicit TickInfo ( v8 :: Isolate * isolate ); enum Fields { kHasTickScheduled = 0 , kHasRejectionToWarn , kFieldsCount }; AliasedUint8Array fields_ ; }; TickInfo\u4e3b\u8981\u662f\u6709\u4e24\u4e2a\u6807\u8bb0\u4f4d\uff0ckHasTickScheduled\u6807\u8bb0\u662f\u5426\u6709tick\u4efb\u52a1\u9700\u8981\u5904\u7406\u3002\u7136\u540e\u901a\u8fc7InternalCallbackScope\u7c7b\u7684\u5bf9\u8c61\u65b9\u6cd5Close\u51fd\u6570\u6267\u884ctick_callback_function\u3002\u5f53Nodejs\u5e95\u5c42\u9700\u8981\u6267\u884c\u4e00\u4e2ajs\u56de\u8c03\u65f6\uff0c\u4f1a\u8c03\u7528AsyncWrap\u7684MakeCallback\u3002MakeCallback\u91cc\u9762\u8c03\u7528\u4e86InternalMakeCallback\u3002 1 2 3 4 5 6 7 8 9 MaybeLocal < Value > InternalMakeCallback ( Environment * env , Local < Object > recv , const Local < Function > callback , int argc , Local < Value > argv [], async_context asyncContext ) { InternalCallbackScope scope ( env , recv , asyncContext ); // \u6267\u884c\u7528\u6237\u5c42js\u56de\u8c03 scope . Close (); return ret ; } \u6211\u4eec\u770bInternalCallbackScope \u7684Close 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void InternalCallbackScope::Close () { // \u7701\u7565\u90e8\u5206\u4ee3\u7801 TickInfo * tick_info = env_ -> tick_info (); // \u6ca1\u6709tick\u4efb\u52a1\u5219\u4e0d\u9700\u8981\u5f80\u4e0b\u8d70\uff0c\u5728\u63d2\u5165tick\u4efb\u52a1\u7684\u65f6\u5019\u4f1a\u8bbe\u7f6e\u8fd9\u4e2a\u4e3atrue\uff0c\u6ca1\u6709\u4efb\u52a1\u65f6\u53d8\u6210false if ( ! tick_info -> has_tick_scheduled () && ! tick_info -> has_rejection_to_warn ()) { return ; } HandleScope handle_scope ( env_ -> isolate ()); Local < Object > process = env_ -> process_object (); if ( ! env_ -> can_call_into_js ()) return ; // \u5904\u7406tick\u7684\u51fd\u6570 Local < Function > tick_callback = env_ -> tick_callback_function (); // \u5904\u7406tick\u4efb\u52a1 if ( tick_callback -> Call ( env_ -> context (), process , 0 , nullptr ). IsEmpty ()) { failed_ = true ; } } \u6211\u4eec\u770b\u5230\u6bcf\u6b21\u6267\u884cjs\u5c42\u7684\u56de\u8c03\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u5904\u7406tick\u4efb\u52a1\u3002Close\u51fd\u6570\u53ef\u4ee5\u4e3b\u52a8\u8c03\u7528\uff0c\u6216\u8005\u5728InternalCallbackScope\u5bf9\u8c61\u6790\u6784\u7684\u65f6\u5019\u88ab\u8c03\u7528\u3002\u9664\u4e86\u6267\u884cjs\u56de\u8c03\u65f6\u662f\u4e3b\u52a8\u8c03\u7528Close\u5916\uff0c\u4e00\u822c\u5904\u7406tick\u4efb\u52a1\u7684\u65f6\u95f4\u70b9\u5c31\u662f\u5728InternalCallbackScope\u5bf9\u8c61\u88ab\u6790\u6784\u7684\u65f6\u5019\u3002\u6240\u4ee5\u5728\u5b9a\u4e49\u4e86InternalCallbackScope\u5bf9\u8c61\u7684\u65f6\u5019\uff0c\u4e00\u822c\u5c31\u4f1a\u5728\u5bf9\u8c61\u6790\u6784\u7684\u65f6\u5019\uff0c\u8fdb\u884ctick\u4efb\u52a1\u7684\u5904\u7406\u3002\u53e6\u5916\u4e00\u79cd\u5c31\u662f\u5728\u6267\u884c\u7684js\u56de\u8c03\u91cc\uff0c\u8c03\u7528runNextTicks\u5904\u7406tick\u4efb\u52a1\u3002\u6bd4\u5982\u6267\u884cimmediate\u4efb\u52a1\u7684\u8fc7\u7a0b\u4e2d\u3002 1 2 3 4 5 6 7 function runNextTicks () { if ( ! hasTickScheduled () && ! hasRejectionToWarn ()) runMicrotasks (); if ( ! hasTickScheduled () && ! hasRejectionToWarn ()) return ; processTicksAndRejections (); } \u6211\u4eec\u770bprocessTicksAndRejections\u662f\u5982\u4f55\u5904\u7406tick\u4efb\u52a1\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 function processTicksAndRejections () { let tock ; do { while ( tock = queue . shift ()) { const asyncId = tock [ async_id_symbol ]; emitBefore ( asyncId , tock [ trigger_async_id_symbol ]); try { const callback = tock . callback ; if ( tock . args === undefined ) { callback (); } else { const args = tock . args ; switch ( args . length ) { case 1 : callback ( args [ 0 ]); break ; case 2 : callback ( args [ 0 ], args [ 1 ]); break ; case 3 : callback ( args [ 0 ], args [ 1 ], args [ 2 ]); break ; case 4 : callback ( args [ 0 ], args [ 1 ], args [ 2 ], args [ 3 ]); break ; default : callback (... args ); } } } finally { if ( destroyHooksExist ()) emitDestroy ( asyncId ); } emitAfter ( asyncId ); } runMicrotasks (); } while ( ! queue . isEmpty () || processPromiseRejections ()); setHasTickScheduled ( false ); setHasRejectionToWarn ( false ); } \u4eceprocessTicksAndRejections\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0cNode.js\u662f\u5b9e\u65f6\u4ece\u4efb\u52a1\u961f\u5217\u91cc\u53d6\u8282\u70b9\u6267\u884c\u7684\uff0c\u6240\u4ee5\u5982\u679c\u6211\u4eec\u5728nextTick\u7684\u56de\u8c03\u91cc\u4e00\u76f4\u8c03\u7528nextTick\u7684\u8bdd\uff0c\u5c31\u4f1a\u5bfc\u81f4\u6b7b\u5faa\u73af\u3002 1 2 3 4 5 6 7 8 9 10 11 function test () { process . nextTick (() => { console . log ( 1 ); test () }); } test (); setTimeout (() => { console . log ( 2 ) }, 10 ) \u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c\u4f1a\u4e00\u76f4\u8f93\u51fa1\uff0c\u4e0d\u4f1a\u8f93\u51fa2\u3002\u800c\u5728Nodejs\u6e90\u7801\u7684\u5f88\u591a\u5730\u65b9\u90fd\u5904\u7406\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0c\u9996\u5148\u628a\u8981\u6267\u884c\u7684\u4efb\u52a1\u961f\u5217\u79fb\u5230\u4e00\u4e2a\u53d8\u91cfq2\u4e2d\uff0c\u6e05\u7a7a\u4e4b\u524d\u7684\u961f\u5217q1\u3002\u63a5\u7740\u904d\u5386q2\u6307\u5411\u7684\u961f\u5217\uff0c\u5982\u679c\u6267\u884c\u56de\u8c03\u7684\u65f6\u5019\u53c8\u65b0\u589e\u4e86\u8282\u70b9\uff0c\u53ea\u4f1a\u52a0\u5165\u5230q1\u4e2d\u3002q2\u4e0d\u4f1a\u5bfc\u81f4\u6b7b\u5faa\u73af\u3002 11.2.4 nextTick\u7684\u4f7f\u7528 \u00b6 \u6211\u4eec\u77e5\u9053nextTick\u53ef\u7528\u4e8e\u5ef6\u8fdf\u6267\u884c\u4e00\u4e9b\u903b\u8f91\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u54ea\u4e9b\u573a\u666f\u4e0b\u53ef\u4ee5\u4f7f\u7528nextTick\u3002 1 2 3 4 5 6 7 8 9 10 11 12 const { EventEmitter } = require ( 'events' ); class DemoEvents extends EventEmitter { constructor () { super (); this . emit ( 'start' ); } } const demoEvents = new DemoEvents (); demoEvents . on ( 'start' , () => { console . log ( 'start' ); }); \u4ee5\u4e0a\u4ee3\u7801\u5728\u6784\u9020\u51fd\u6570\u4e2d\u4f1a\u89e6\u53d1start\u4e8b\u4ef6\uff0c\u4f46\u662f\u4e8b\u4ef6\u7684\u6ce8\u518c\u5374\u5728\u6784\u9020\u51fd\u6570\u4e4b\u540e\u6267\u884c\uff0c\u800c\u5728\u6784\u9020\u51fd\u6570\u4e4b\u524d\u6211\u4eec\u8fd8\u6ca1\u6709\u62ff\u5230DemoEvents\u5bf9\u8c61\uff0c\u65e0\u6cd5\u5b8c\u6210\u4e8b\u4ef6\u7684\u6ce8\u518c\u3002\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u4f7f\u7528nextTick\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const { EventEmitter } = require ( 'events' ); class DemoEvents extends EventEmitter { constructor () { super (); process . nextTick (() => { this . emit ( 'start' ); }) } } const demoEvents = new DemoEvents (); demoEvents . on ( 'start' , () => { console . log ( 'start' ); });","title":"11-setImmediate\u548cnextTick"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#111-setimmediate","text":"","title":"11.1 setImmediate"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1111immediate","text":"\u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u8bbe\u7f6e\u4e86\u5904\u7406immediate\u4efb\u52a1\u7684\u51fd\u6570 1 2 3 // runNextTicks\u7528\u4e8e\u5904\u7406nextTick\u4ea7\u751f\u7684\u4efb\u52a1\uff0c\u8fd9\u91cc\u4e0d\u5173\u6ce8 const { processImmediate , processTimers } = getTimerCallbacks ( runNextTicks ); setupTimers ( processImmediate , processTimers ); \u6211\u4eec\u5148\u770b\u770b\u4e00\u4e0bsetupTimers\uff08timer.cc\uff09\u7684\u903b\u8f91\u3002 1 2 3 4 5 void SetupTimers ( const FunctionCallbackInfo < Value >& args ) { auto env = Environment :: GetCurrent ( args ); env -> set_immediate_callback_function ( args [ 0 ]. As < Function > ()); env -> set_timers_callback_function ( args [ 1 ]. As < Function > ()); } SetupTimers\u5728env\u4e2d\u4fdd\u5b58\u4e86\u4e24\u4e2a\u51fd\u6570processImmediate, processTimers\uff0cprocessImmediate\u662f\u5904\u7406immediate\u4efb\u52a1\u7684\uff0cprocessTimers\u662f\u5904\u7406\u5b9a\u65f6\u5668\u4efb\u52a1\u7684\uff0c\u5728\u5b9a\u65f6\u5668\u7ae0\u8282\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\u3002","title":"11.1.1\u8bbe\u7f6e\u5904\u7406immediate\u4efb\u52a1\u7684\u51fd\u6570"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1112-check","text":"\u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\uff0c\u540c\u65f6\u521d\u59cb\u5316\u4e86immediate\u4efb\u52a1\u76f8\u5173\u7684\u6570\u636e\u7ed3\u6784\u548c\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 void Environment::InitializeLibuv ( bool start_profiler_idle_notifier ) { // \u521d\u59cb\u5316immediate\u76f8\u5173\u7684handle uv_check_init ( event_loop (), immediate_check_handle ()); // \u4fee\u6539\u72b6\u6001\u4e3aunref\uff0c\u907f\u514d\u6ca1\u6709\u4efb\u52a1\u7684\u65f6\u5019\uff0c\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa uv_unref ( reinterpret_cast < uv_handle_t *> ( immediate_check_handle ())); // \u6fc0\u6d3bhandle\uff0c\u8bbe\u7f6e\u56de\u8c03 uv_check_start ( immediate_check_handle (), CheckImmediate ); // \u5728idle\u9636\u6bb5\u4e5f\u63d2\u5165\u4e00\u4e2a\u76f8\u5173\u7684\u8282\u70b9 uv_idle_init ( event_loop (), immediate_idle_handle ()); } Node.js\u9ed8\u8ba4\u4f1a\u5f80check\u9636\u6bb5\u63d2\u5165\u4e00\u4e2a\u8282\u70b9\uff0c\u5e76\u8bbe\u7f6e\u56de\u8c03\u4e3aCheckImmediate\uff0c\u4f46\u662f\u521d\u59cb\u5316\u72b6\u6001\u662funref\u7684\uff0c\u6240\u4ee5\u5982\u679c\u6ca1\u6709immediate\u4efb\u52a1\u7684\u8bdd\uff0c\u4e0d\u4f1a\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002\u6211\u4eec\u770b\u4e00\u4e0bCheckImmediate\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void Environment::CheckImmediate ( uv_check_t * handle ) { // \u7701\u7565\u90e8\u5206\u4ee3\u7801 // \u6ca1\u6709Immediate\u8282\u70b9\u9700\u8981\u5904\u7406 if ( env -> immediate_info () -> count () == 0 || ! env -> can_call_into_js ()) return ; do { // \u6267\u884cJS\u5c42\u56de\u8c03immediate_callback_function MakeCallback ( env -> isolate (), env -> process_object (), env -> immediate_callback_function (), 0 , nullptr , { 0 , 0 }). ToLocalChecked (); } while ( env -> immediate_info () -> has_outstanding () && env -> can_call_into_js ()); /* \u6240\u6709immediate\u8282\u70b9\u90fd\u5904\u7406\u5b8c\u4e86\uff0c\u7f6eidle\u9636\u6bb5\u5bf9\u5e94\u8282\u70b9\u4e3a\u975e\u6fc0\u6d3b\u72b6\u6001\uff0c \u5141\u8bb8Poll IO\u9636\u6bb5\u963b\u585e\u548c\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa */ if ( env -> immediate_info () -> ref_count () == 0 ) env -> ToggleImmediateRef ( false ); } \u6211\u4eec\u770b\u5230\u6bcf\u4e00\u8f6e\u4e8b\u4ef6\u5faa\u73af\u65f6\uff0cCheckImmediate\u90fd\u4f1a\u88ab\u6267\u884c\uff0c\u4f46\u662f\u5982\u679c\u6ca1\u6709\u9700\u8981\u5904\u7406\u7684\u4efb\u52a1\u5219\u76f4\u63a5\u8fd4\u56de\u3002\u5982\u679c\u6709\u4efb\u52a1\uff0cCheckImmediate\u51fd\u6570\u6267\u884cimmediate_callback_function\u51fd\u6570\uff0c\u8fd9\u6b63\u662fNode.js\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u7684\u51fd\u6570processImmediate\u3002\u770b\u5b8c\u521d\u59cb\u5316\u548c\u5904\u7406immediate\u4efb\u52a1\u7684\u903b\u8f91\u540e\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u4ea7\u751f\u4e00\u4e2aimmediate\u4efb\u52a1\u3002","title":"11.1.2 \u6ce8\u518ccheck\u9636\u6bb5\u7684\u56de\u8c03"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1113-setimmediate","text":"\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7setImmediate\u751f\u6210\u4e00\u4e2a\u4efb\u52a1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function setImmediate ( callback , arg1 , arg2 , arg3 ) { let i , args ; switch ( arguments . length ) { case 1 : break ; case 2 : args = [ arg1 ]; break ; case 3 : args = [ arg1 , arg2 ]; break ; default : args = [ arg1 , arg2 , arg3 ]; for ( i = 4 ; i < arguments . length ; i ++ ) { args [ i - 1 ] = arguments [ i ]; } break ; } return new Immediate ( callback , args ); } setImmediate\u7684\u4ee3\u7801\u6bd4\u8f83\u7b80\u5355\uff0c\u65b0\u5efa\u4e00\u4e2aImmediate\u3002\u6211\u4eec\u770b\u4e00\u4e0bImmediate\u7684\u7c7b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 const Immediate = class Immediate { constructor ( callback , args ) { this . _idleNext = null ; this . _idlePrev = null ; this . _onImmediate = callback ; this . _argv = args ; this . _destroyed = false ; this [ kRefed ] = false ; this . ref (); // Immediate\u94fe\u8868\u7684\u8282\u70b9\u4e2a\u6570\uff0c\u5305\u62ecref\u548cunref\u72b6\u6001 immediateInfo [ kCount ] ++ ; // \u52a0\u5165\u94fe\u8868\u4e2d immediateQueue . append ( this ); } // \u6253\u4e0aref\u6807\u8bb0\uff0c\u5f80Libuv\u7684idle\u94fe\u8868\u63d2\u5165\u4e00\u4e2a\u6fc0\u6d3b\u72b6\u6001\u7684\u8282\u70b9\uff0c\u5982\u679c\u8fd8\u6ca1\u6709\u7684\u8bdd ref () { if ( this [ kRefed ] === false ) { this [ kRefed ] = true ; if ( immediateInfo [ kRefCount ] ++ === 0 ) toggleImmediateRef ( true ); } return this ; } // \u548c\u4e0a\u9762\u76f8\u53cd unref () { if ( this [ kRefed ] === true ) { this [ kRefed ] = false ; if ( -- immediateInfo [ kRefCount ] === 0 ) toggleImmediateRef ( false ); } return this ; } hasRef () { return !! this [ kRefed ]; } }; Immediate\u7c7b\u4e3b\u8981\u505a\u4e86\u4e24\u4e2a\u4e8b\u60c5\u3002 1 \u751f\u6210\u4e00\u4e2a\u8282\u70b9\u63d2\u5165\u5230\u94fe\u8868\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 const immediateQueue = new ImmediateList (); // \u53cc\u5411\u975e\u5faa\u73af\u7684\u94fe\u8868 function ImmediateList () { this . head = null ; this . tail = null ; } ImmediateList . prototype . append = function ( item ) { // \u5c3e\u6307\u9488\u975e\u7a7a\uff0c\u8bf4\u660e\u94fe\u8868\u975e\u7a7a\uff0c\u76f4\u63a5\u8ffd\u52a0\u5728\u5c3e\u8282\u70b9\u540e\u9762 if ( this . tail !== null ) { this . tail . _idleNext = item ; item . _idlePrev = this . tail ; } else { // \u5c3e\u6307\u9488\u662f\u7a7a\u8bf4\u660e\u94fe\u8868\u662f\u7a7a\u7684\uff0c\u5934\u5c3e\u6307\u9488\u90fd\u6307\u5411item this . head = item ; } this . tail = item ; }; ImmediateList . prototype . remove = function ( item ) { // \u5982\u679citem\u5728\u4e2d\u95f4\u5219\u81ea\u5df1\u5168\u8eab\u800c\u9000\uff0c\u524d\u540e\u4e24\u4e2a\u8282\u70b9\u8fde\u4e0a if ( item . _idleNext !== null ) { item . _idleNext . _idlePrev = item . _idlePrev ; } if ( item . _idlePrev !== null ) { item . _idlePrev . _idleNext = item . _idleNext ; } // \u662f\u5934\u6307\u9488\uff0c\u5219\u9700\u8981\u66f4\u65b0\u5934\u6307\u9488\u6307\u5411item\u7684\u4e0b\u4e00\u4e2a\uff0c\u56e0\u4e3aitem\u88ab\u5220\u9664\u4e86\uff0c\u5c3e\u6307\u9488\u540c\u7406 if ( item === this . head ) this . head = item . _idleNext ; if ( item === this . tail ) this . tail = item . _idlePrev ; // \u91cd\u7f6e\u524d\u540e\u6307\u9488 item . _idleNext = null ; item . _idlePrev = null ; }; 2 \u5982\u679c\u8fd8\u6ca1\u6709\u5f80Libuv\u7684idle\u94fe\u8868\u91cc\u63d2\u5165\u4e00\u4e2a\u6fc0\u6d3b\u8282\u70b9\u7684\u8bdd\uff0c\u5219\u63d2\u5165\u4e00\u4e2a\u3002\u4ece\u4e4b\u524d\u7684\u5206\u6790\uff0c\u6211\u4eec\u77e5\u9053\uff0cNode.js\u5728check\u9636\u6bb5\u63d2\u5165\u4e86\u4e00\u4e2aunref\u8282\u70b9\uff0c\u5728\u6bcf\u6b21check\u9636\u6bb5\u90fd\u4f1a\u6267\u884c\u8be5\u8282\u70b9\u7684\u56de\u8c03\uff0c\u90a3\u4e48\u8fd9\u4e2aidle\u8282\u70b9\u6709\u4ec0\u4e48\u7528\u5462\uff1f\u7b54\u6848\u5728uv_backend_timeout\u51fd\u6570\u4e2d\uff0cuv_backend_timeout\u5b9a\u4e49\u4e86Poll IO\u963b\u585e\u7684\u65f6\u957f\uff0c\u5982\u679c\u6709ref\u72b6\u6001\u7684idle\u8282\u70b9\u5219Poll IO\u9636\u6bb5\u4e0d\u4f1a\u963b\u585e\uff08\u4f46\u662f\u4e0d\u4f1a\u5224\u65ad\u662f\u5426\u6709check\u8282\u70b9\uff09\u3002\u6240\u4ee5\u5f53\u6709immediate\u4efb\u52a1\u65f6\uff0cNode.js\u4f1a\u628a\u8fd9\u4e2aidle\u63d2\u5165idle\u9636\u6bb5\u4e2d\uff0c\u8868\u793a\u6709\u4efb\u52a1\u5904\u7406\uff0c\u4e0d\u80fd\u963b\u585ePoll IO\u9636\u6bb5\u3002\u6ca1\u6709immediate\u4efb\u52a1\u65f6\uff0c\u5219\u79fb\u9664idle\u8282\u70b9\u3002\u603b\u7684\u6765\u8bf4\uff0cidle\u8282\u70b9\u7684\u610f\u4e49\u662f\u6807\u8bb0\u662f\u5426\u6709immediate\u4efb\u52a1\u9700\u8981\u5904\u7406\uff0c\u6709\u7684\u8bdd\u5c31\u4e0d\u80fd\u963b\u585ePoll IO\u9636\u6bb5\uff0c\u5e76\u4e14\u4e0d\u80fd\u9000\u51fa\u4e8b\u4ef6\u5faa\u73af\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void ToggleImmediateRef ( const FunctionCallbackInfo < Value >& args ) { Environment :: GetCurrent ( args ) -> ToggleImmediateRef ( args [ 0 ] -> IsTrue ()) } void Environment::ToggleImmediateRef ( bool ref ) { if ( started_cleanup_ ) return ; // \u6539\u53d8handle\u7684\u72b6\u6001\uff08\u6fc0\u6d3b\u6216\u4e0d\u6fc0\u6d3b\uff09\uff0c\u9632\u6b62\u5728Poll IO\u9636\u6bb5\u963b\u585e if ( ref ) { uv_idle_start ( immediate_idle_handle (), []( uv_idle_t * ){ }); } else { // \u4e0d\u963b\u585ePoll IO\uff0c\u5141\u8bb8\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa uv_idle_stop ( immediate_idle_handle ()); } } \u8fd9\u662fsetImmediate\u51fd\u6570\u7684\u6574\u4e2a\u8fc7\u7a0b\u3002\u548c\u5b9a\u65f6\u5668\u4e00\u6837\uff0c\u6211\u4eec\u53ef\u4ee5\u8c03\u7528immediate\u4efb\u52a1\u7684ref\u548cunref\u51fd\u6570\uff0c\u63a7\u5236\u5b83\u5bf9\u4e8b\u4ef6\u5faa\u73af\u7684\u5f71\u54cd\u3002","title":"11.1.3 setImmediate\u751f\u6210\u4efb\u52a1"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1114-setimmediate","text":"\u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u5728check\u9636\u6bb5\u65f6\uff0c\u662f\u5982\u4f55\u5904\u7406immediate\u4efb\u52a1\u7684\u3002\u7531\u524d\u9762\u5206\u6790\u6211\u4eec\u77e5\u9053processImmediate\u51fd\u6570\u662f\u5904\u7406immediate\u4efb\u52a1\u7684\u51fd\u6570\uff0c\u6765\u81eagetTimerCallbacks\uff08internal/timer.js\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 function processImmediate () { /* \u4e0a\u6b21\u6267\u884cprocessImmediate\u7684\u65f6\u5019\u5982\u679c\u7531\u672a\u6355\u83b7\u7684\u5f02\u5e38\uff0c \u5219outstandingQueue\u4fdd\u5b58\u4e86\u672a\u6267\u884c\u7684\u8282\u70b9\uff0c\u4e0b\u6b21\u6267\u884cprocessImmediate\u7684\u65f6\u5019\uff0c \u4f18\u5148\u6267\u884coutstandingQueue\u961f\u5217\u7684\u8282\u70b9 */ const queue = outstandingQueue . head !== null ? outstandingQueue : immediateQueue ; let immediate = queue . head ; /* \u5728\u6267\u884cimmediateQueue\u961f\u5217\u7684\u8bdd\uff0c\u5148\u7f6e\u7a7a\u961f\u5217\uff0c\u907f\u514d\u6267\u884c\u56de\u8c03 \u7684\u65f6\u5019\u4e00\u76f4\u5f80\u961f\u5217\u52a0\u8282\u70b9\uff0c\u6b7b\u5faa\u73af\u3002 \u6240\u4ee5\u65b0\u52a0\u7684\u63a5\u53e3\u4f1a\u63d2\u5165\u65b0\u7684\u961f\u5217\uff0c \u4e0d\u4f1a\u5728\u672c\u6b21\u88ab\u6267\u884c\u3002\u5e76\u6253\u4e00\u4e2a\u6807\u8bb0,\u5168\u90e8immediateQueue\u8282\u70b9\u90fd\u88ab\u6267 \u884c\u5219\u6e05\u7a7a\uff0c\u5426\u5219\u4f1a\u518d\u6267\u884cprocessImmediate\u4e00\u6b21\uff0c\u89c1Environment::CheckImmediate */ if ( queue !== outstandingQueue ) { queue . head = queue . tail = null ; immediateInfo [ kHasOutstanding ] = 1 ; } let prevImmediate ; let ranAtLeastOneImmediate = false ; while ( immediate !== null ) { // \u6267\u884c\u5fae\u4efb\u52a1 if ( ranAtLeastOneImmediate ) runNextTicks (); else ranAtLeastOneImmediate = true ; // \u5fae\u4efb\u52a1\u628a\u8be5\u8282\u70b9\u5220\u9664\u4e86\uff0c\u5219\u4e0d\u9700\u8981\u6307\u5411\u5b83\u7684\u56de\u8c03\u4e86\uff0c\u7ee7\u7eed\u4e0b\u4e00\u4e2a if ( immediate . _destroyed ) { outstandingQueue . head = immediate = prevImmediate . _idleNext ; continue ; } immediate . _destroyed = true ; // \u6267\u884c\u5b8c\u8981\u4fee\u6539\u4e2a\u6570 immediateInfo [ kCount ] -- ; if ( immediate [ kRefed ]) immediateInfo [ kRefCount ] -- ; immediate [ kRefed ] = null ; // \u89c1\u4e0a\u9762if (immediate._destroyed)\u7684\u6ce8\u91ca prevImmediate = immediate ; // \u6267\u884c\u56de\u8c03\uff0c\u6307\u5411\u4e0b\u4e00\u4e2a\u8282\u70b9 try { const argv = immediate . _argv ; if ( ! argv ) immediate . _onImmediate (); else immediate . _onImmediate (... argv ); } finally { immediate . _onImmediate = null ; outstandingQueue . head = immediate = immediate . _idleNext ; } } // \u5f53\u524d\u6267\u884c\u7684\u662foutstandingQueue\u7684\u8bdd\u5219\u628a\u5b83\u6e05\u7a7a if ( queue === outstandingQueue ) outstandingQueue . head = null ; // \u5168\u90e8\u8282\u70b9\u6267\u884c\u5b8c immediateInfo [ kHasOutstanding ] = 0 ; } processImmediate\u7684\u903b\u8f91\u5c31\u662f\u9010\u4e2a\u6267\u884cimmediate\u4efb\u52a1\u961f\u5217\u7684\u8282\u70b9\u3002Immediate\u5206\u4e24\u4e2a\u961f\u5217\uff0c\u6b63\u5e38\u60c5\u51b5\u4e0b\uff0c\u63d2\u5165\u7684immediate\u8282\u70b9\u63d2\u5165\u5230immediateQueue\u961f\u5217\u3002\u5982\u679c\u6267\u884c\u7684\u65f6\u5019\u6709\u5f02\u5e38\uff0c\u5219\u672a\u5904\u7406\u5b8c\u7684\u8282\u70b9\u5c31\u4f1a\u88ab\u63d2\u5165\u5230outstandingQueue\u961f\u5217\uff0c\u7b49\u4e0b\u4e00\u6b21\u6267\u884c\u3002\u53e6\u5916\u6211\u4eec\u770b\u5230runNextTicks\u3002runNextTicks\u5728\u6bcf\u6267\u884c\u5b8cimmediate\u8282\u70b9\u540e\uff0c\u90fd\u5148\u5904\u7406tick\u4efb\u52a1\u7136\u540e\u518d\u5904\u7406\u4e0b\u4e00\u4e2aimmediate\u8282\u70b9\u3002","title":"11.1.4 \u5904\u7406setImmediate\u4ea7\u751f\u7684\u4efb\u52a1"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1115-nodejssettimeoutfn0setimmediate","text":"\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u4e0b\u9762\u8fd9\u6bb5\u4ee3\u7801 1 2 setTimeout (()=>{ console . log ( 'setTimeout' ); }, 0 ) setImmediate (()=>{ console . log ( 'setImmedate' );}) \u6211\u4eec\u6267\u884c\u4e0a\u9762\u8fd9\u6bb5\u4ee3\u7801\uff0c\u4f1a\u53d1\u73b0\u8f93\u51fa\u662f\u4e0d\u786e\u5b9a\u7684\u3002\u4e0b\u9762\u6765\u770b\u4e00\u4e0b\u4e3a\u4ec0\u4e48\u3002Node.js\u7684\u4e8b\u4ef6\u5faa\u73af\u5206\u4e3a\u51e0\u4e2a\u9636\u6bb5(phase)\u3002setTimeout\u662f\u5c5e\u4e8e\u5b9a\u65f6\u5668\u9636\u6bb5\uff0csetImmediate\u662f\u5c5e\u4e8echeck\u9636\u6bb5\u3002\u987a\u5e8f\u4e0a\u5b9a\u65f6\u5668\u9636\u6bb5\u662f\u6bd4check\u66f4\u65e9\u88ab\u6267\u884c\u7684\u3002\u5176\u4e2dsetTimeout\u7684\u5b9e\u73b0\u4ee3\u7801\u91cc\u6709\u4e00\u4e2a\u5f88\u91cd\u8981\u7684\u7ec6\u8282\u3002 1 2 3 4 5 6 7 after *= 1 ; // coalesce to number or NaN if ( ! ( after >= 1 && after <= TIMEOUT_MAX )) { if ( after > TIMEOUT_MAX ) { process . emitWarning ( `\u9519\u8bef\u63d0\u793a` ); } after = 1 ; // schedule on next tick, follows browser behavior } \u6211\u4eec\u53d1\u73b0\u867d\u7136\u6211\u4eec\u4f20\u7684\u8d85\u65f6\u65f6\u95f4\u662f0\uff0c\u4f46\u662f0\u4e0d\u662f\u5408\u6cd5\u503c\uff0cNode.js\u4f1a\u628a\u8d85\u65f6\u65f6\u95f4\u53d8\u62101\u3002\u8fd9\u5c31\u662f\u5bfc\u81f4\u4e0a\u9762\u7684\u4ee3\u7801\u8f93\u51fa\u4e0d\u786e\u5b9a\u7684\u539f\u56e0\u3002\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u8fd9\u6bb5\u4ee3\u7801\u7684\u6267\u884c\u8fc7\u7a0b\u3002Node.js\u542f\u52a8\u7684\u65f6\u5019\uff0c\u4f1a\u7f16\u8bd1\u6267\u884c\u4e0a\u9762\u7684\u4ee3\u7801\uff0c\u5f00\u59cb\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u6302\u8f7d\u4e00\u4e2asetImmediate\u8282\u70b9\u5728\u961f\u5217\u3002\u7136\u540e\u8fdb\u5165Libuv\u7684\u4e8b\u4ef6\u5faa\u73af\uff0c\u7136\u540e\u6267\u884c\u5b9a\u65f6\u5668\u9636\u6bb5\uff0cLibuv\u5224\u65ad\u4ece\u5f00\u542f\u5b9a\u65f6\u5668\u5230\u73b0\u5728\u662f\u5426\u5df2\u7ecf\u8fc7\u53bb\u4e861\u6beb\u79d2\uff0c\u662f\u7684\u8bdd\uff0c\u6267\u884c\u5b9a\u65f6\u5668\u56de\u8c03\uff0c\u5426\u5219\u6267\u884c\u4e0b\u4e00\u4e2a\u8282\u70b9\uff0c\u6267\u884c\u5b8c\u5176\u5b83\u9636\u6bb5\u540e\uff0c\u4f1a\u6267\u884ccheck\u9636\u6bb5\u3002\u8fd9\u65f6\u5019\u5c31\u4f1a\u6267\u884csetImmediate\u7684\u56de\u8c03\u3002\u6240\u4ee5\uff0c\u4e00\u5f00\u59cb\u7684\u90a3\u6bb5\u4ee3\u7801\u7684\u8f93\u51fa\u7ed3\u679c\u662f\u53d6\u51b3\u4e8e\u542f\u52a8\u5b9a\u65f6\u5668\u7684\u65f6\u95f4\u5230Libuv\u6267\u884c\u5b9a\u65f6\u5668\u9636\u6bb5\u662f\u5426\u8fc7\u53bb\u4e861\u6beb\u79d2\u3002","title":"11.1.5 Node.js\u7684setTimeout(fn,0)\u548csetImmediate\u8c01\u5148\u6267\u884c\u7684\u95ee\u9898"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#112-nexttick","text":"nextTick\u7528\u4e8e\u5f02\u6b65\u6267\u884c\u4e00\u4e2a\u56de\u8c03\u51fd\u6570\uff0c\u548csetTimeout\u3001setImmediate\u7c7b\u4f3c\uff0c\u4e0d\u540c\u7684\u5730\u65b9\u5728\u4e8e\u4ed6\u4eec\u7684\u6267\u884c\u65f6\u673a\uff0csetTimeout\u548csetImmediate\u7684\u4efb\u52a1\u5c5e\u4e8e\u4e8b\u4ef6\u5faa\u73af\u7684\u4e00\u90e8\u5206\uff0c\u4f46\u662fnextTick\u7684\u4efb\u52a1\u4e0d\u5c5e\u4e8e\u4e8b\u4ef6\u5faa\u73af\u7684\u4e00\u90e8\u5206\uff0c\u5177\u4f53\u7684\u6267\u884c\u65f6\u673a\u6211\u4eec\u4f1a\u5728\u672c\u8282\u5206\u6790\u3002","title":"11.2 nextTick"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1121-nexttick","text":"nextTick\u51fd\u6570\u662f\u5728Node.js\u542f\u52a8\u8fc7\u7a0b\u4e2d\uff0c\u5728\u6267\u884cbootstrap/node.js\u65f6\u6302\u8f7d\u5230process\u5bf9\u8c61\u4e2d\u3002 1 2 3 4 5 6 7 8 9 const { nextTick , runNextTicks } = setupTaskQueue (); process . nextTick = nextTick ; // \u771f\u6b63\u7684\u5b9a\u4e49\u5728task_queues.js\u3002 setupTaskQueue () { setTickCallback ( processTicksAndRejections ); return { nextTick , }; }, nextTick\u63a5\u4e0b\u6765\u4f1a\u8bb2\uff0csetTickCallback\u662f\u6ce8\u518c\u5904\u7406tick\u4efb\u52a1\u7684\u51fd\u6570\uff0c 1 2 3 4 5 static void SetTickCallback ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); CHECK ( args [ 0 ] -> IsFunction ()); env -> set_tick_callback_function ( args [ 0 ]. As < Function > ()); } \u53ea\u662f\u7b80\u5355\u5730\u4fdd\u5b58\u5904\u7406tick\u4efb\u52a1\u7684\u51fd\u6570\u3002\u540e\u7eed\u4f1a\u7528\u5230","title":"11.2.1 \u521d\u59cb\u5316nextTick"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1122-nexttick","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function nextTick ( callback ) { let args ; switch ( arguments . length ) { case 1 : break ; case 2 : args = [ arguments [ 1 ]]; break ; case 3 : args = [ arguments [ 1 ], arguments [ 2 ]]; break ; case 4 : args = [ arguments [ 1 ], arguments [ 2 ], arguments [ 3 ]]; break ; default : args = new Array ( arguments . length - 1 ); for ( let i = 1 ; i < arguments . length ; i ++ ) args [ i - 1 ] = arguments [ i ]; } // \u7b2c\u4e00\u4e2a\u4efb\u52a1\uff0c\u5f00\u542ftick\u5904\u7406\u903b\u8f91 if ( queue . isEmpty ()) setHasTickScheduled ( true ); const asyncId = newAsyncId (); const triggerAsyncId = getDefaultTriggerAsyncId (); const tickObject = { [ async_id_symbol ] : asyncId , [ trigger_async_id_symbol ] : triggerAsyncId , callback , args }; // \u63d2\u5165\u961f\u5217 queue . push ( tickObject ); } \u8fd9\u5c31\u662f\u6211\u4eec\u6267\u884cnextTick\u65f6\u7684\u903b\u8f91\u3002\u6bcf\u6b21\u8c03\u7528nextTick\u90fd\u4f1a\u5f80\u961f\u5217\u4e2d\u8ffd\u52a0\u4e00\u4e2a\u8282\u70b9\u3002","title":"11.2.2 nextTick\u751f\u4ea7\u4efb\u52a1"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1123-tick","text":"\u6211\u4eec\u518d\u770b\u4e00\u4e0b\u5904\u7406\u7684tick\u4efb\u52a1\u7684\u903b\u8f91\u3002Nodejs\u5728\u521d\u59cb\u5316\u65f6\uff0c\u901a\u8fc7\u6267\u884csetTickCallback(processTicksAndRejections)\u6ce8\u518c\u4e86\u5904\u7406tick\u4efb\u52a1\u7684\u51fd\u6570\u3002Node.js\u5728\u521d\u59cb\u5316\u65f6\u628a\u5904\u7406tick\u4efb\u52a1\u7684\u51fd\u6570\u4fdd\u5b58\u5230env\u4e2d\u3002\u53e6\u5916\uff0cNodejs\u4f7f\u7528TickInfo\u7c7b\u7ba1\u7406tick\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 class TickInfo : public MemoryRetainer { public : inline AliasedUint8Array & fields (); inline bool has_tick_scheduled () const ; inline bool has_rejection_to_warn () const ; private : inline explicit TickInfo ( v8 :: Isolate * isolate ); enum Fields { kHasTickScheduled = 0 , kHasRejectionToWarn , kFieldsCount }; AliasedUint8Array fields_ ; }; TickInfo\u4e3b\u8981\u662f\u6709\u4e24\u4e2a\u6807\u8bb0\u4f4d\uff0ckHasTickScheduled\u6807\u8bb0\u662f\u5426\u6709tick\u4efb\u52a1\u9700\u8981\u5904\u7406\u3002\u7136\u540e\u901a\u8fc7InternalCallbackScope\u7c7b\u7684\u5bf9\u8c61\u65b9\u6cd5Close\u51fd\u6570\u6267\u884ctick_callback_function\u3002\u5f53Nodejs\u5e95\u5c42\u9700\u8981\u6267\u884c\u4e00\u4e2ajs\u56de\u8c03\u65f6\uff0c\u4f1a\u8c03\u7528AsyncWrap\u7684MakeCallback\u3002MakeCallback\u91cc\u9762\u8c03\u7528\u4e86InternalMakeCallback\u3002 1 2 3 4 5 6 7 8 9 MaybeLocal < Value > InternalMakeCallback ( Environment * env , Local < Object > recv , const Local < Function > callback , int argc , Local < Value > argv [], async_context asyncContext ) { InternalCallbackScope scope ( env , recv , asyncContext ); // \u6267\u884c\u7528\u6237\u5c42js\u56de\u8c03 scope . Close (); return ret ; } \u6211\u4eec\u770bInternalCallbackScope \u7684Close 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void InternalCallbackScope::Close () { // \u7701\u7565\u90e8\u5206\u4ee3\u7801 TickInfo * tick_info = env_ -> tick_info (); // \u6ca1\u6709tick\u4efb\u52a1\u5219\u4e0d\u9700\u8981\u5f80\u4e0b\u8d70\uff0c\u5728\u63d2\u5165tick\u4efb\u52a1\u7684\u65f6\u5019\u4f1a\u8bbe\u7f6e\u8fd9\u4e2a\u4e3atrue\uff0c\u6ca1\u6709\u4efb\u52a1\u65f6\u53d8\u6210false if ( ! tick_info -> has_tick_scheduled () && ! tick_info -> has_rejection_to_warn ()) { return ; } HandleScope handle_scope ( env_ -> isolate ()); Local < Object > process = env_ -> process_object (); if ( ! env_ -> can_call_into_js ()) return ; // \u5904\u7406tick\u7684\u51fd\u6570 Local < Function > tick_callback = env_ -> tick_callback_function (); // \u5904\u7406tick\u4efb\u52a1 if ( tick_callback -> Call ( env_ -> context (), process , 0 , nullptr ). IsEmpty ()) { failed_ = true ; } } \u6211\u4eec\u770b\u5230\u6bcf\u6b21\u6267\u884cjs\u5c42\u7684\u56de\u8c03\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u5904\u7406tick\u4efb\u52a1\u3002Close\u51fd\u6570\u53ef\u4ee5\u4e3b\u52a8\u8c03\u7528\uff0c\u6216\u8005\u5728InternalCallbackScope\u5bf9\u8c61\u6790\u6784\u7684\u65f6\u5019\u88ab\u8c03\u7528\u3002\u9664\u4e86\u6267\u884cjs\u56de\u8c03\u65f6\u662f\u4e3b\u52a8\u8c03\u7528Close\u5916\uff0c\u4e00\u822c\u5904\u7406tick\u4efb\u52a1\u7684\u65f6\u95f4\u70b9\u5c31\u662f\u5728InternalCallbackScope\u5bf9\u8c61\u88ab\u6790\u6784\u7684\u65f6\u5019\u3002\u6240\u4ee5\u5728\u5b9a\u4e49\u4e86InternalCallbackScope\u5bf9\u8c61\u7684\u65f6\u5019\uff0c\u4e00\u822c\u5c31\u4f1a\u5728\u5bf9\u8c61\u6790\u6784\u7684\u65f6\u5019\uff0c\u8fdb\u884ctick\u4efb\u52a1\u7684\u5904\u7406\u3002\u53e6\u5916\u4e00\u79cd\u5c31\u662f\u5728\u6267\u884c\u7684js\u56de\u8c03\u91cc\uff0c\u8c03\u7528runNextTicks\u5904\u7406tick\u4efb\u52a1\u3002\u6bd4\u5982\u6267\u884cimmediate\u4efb\u52a1\u7684\u8fc7\u7a0b\u4e2d\u3002 1 2 3 4 5 6 7 function runNextTicks () { if ( ! hasTickScheduled () && ! hasRejectionToWarn ()) runMicrotasks (); if ( ! hasTickScheduled () && ! hasRejectionToWarn ()) return ; processTicksAndRejections (); } \u6211\u4eec\u770bprocessTicksAndRejections\u662f\u5982\u4f55\u5904\u7406tick\u4efb\u52a1\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 function processTicksAndRejections () { let tock ; do { while ( tock = queue . shift ()) { const asyncId = tock [ async_id_symbol ]; emitBefore ( asyncId , tock [ trigger_async_id_symbol ]); try { const callback = tock . callback ; if ( tock . args === undefined ) { callback (); } else { const args = tock . args ; switch ( args . length ) { case 1 : callback ( args [ 0 ]); break ; case 2 : callback ( args [ 0 ], args [ 1 ]); break ; case 3 : callback ( args [ 0 ], args [ 1 ], args [ 2 ]); break ; case 4 : callback ( args [ 0 ], args [ 1 ], args [ 2 ], args [ 3 ]); break ; default : callback (... args ); } } } finally { if ( destroyHooksExist ()) emitDestroy ( asyncId ); } emitAfter ( asyncId ); } runMicrotasks (); } while ( ! queue . isEmpty () || processPromiseRejections ()); setHasTickScheduled ( false ); setHasRejectionToWarn ( false ); } \u4eceprocessTicksAndRejections\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\uff0cNode.js\u662f\u5b9e\u65f6\u4ece\u4efb\u52a1\u961f\u5217\u91cc\u53d6\u8282\u70b9\u6267\u884c\u7684\uff0c\u6240\u4ee5\u5982\u679c\u6211\u4eec\u5728nextTick\u7684\u56de\u8c03\u91cc\u4e00\u76f4\u8c03\u7528nextTick\u7684\u8bdd\uff0c\u5c31\u4f1a\u5bfc\u81f4\u6b7b\u5faa\u73af\u3002 1 2 3 4 5 6 7 8 9 10 11 function test () { process . nextTick (() => { console . log ( 1 ); test () }); } test (); setTimeout (() => { console . log ( 2 ) }, 10 ) \u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c\u4f1a\u4e00\u76f4\u8f93\u51fa1\uff0c\u4e0d\u4f1a\u8f93\u51fa2\u3002\u800c\u5728Nodejs\u6e90\u7801\u7684\u5f88\u591a\u5730\u65b9\u90fd\u5904\u7406\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0c\u9996\u5148\u628a\u8981\u6267\u884c\u7684\u4efb\u52a1\u961f\u5217\u79fb\u5230\u4e00\u4e2a\u53d8\u91cfq2\u4e2d\uff0c\u6e05\u7a7a\u4e4b\u524d\u7684\u961f\u5217q1\u3002\u63a5\u7740\u904d\u5386q2\u6307\u5411\u7684\u961f\u5217\uff0c\u5982\u679c\u6267\u884c\u56de\u8c03\u7684\u65f6\u5019\u53c8\u65b0\u589e\u4e86\u8282\u70b9\uff0c\u53ea\u4f1a\u52a0\u5165\u5230q1\u4e2d\u3002q2\u4e0d\u4f1a\u5bfc\u81f4\u6b7b\u5faa\u73af\u3002","title":"11.2.3 \u5904\u7406tick\u4efb\u52a1"},{"location":"chapter11-setImmediate%E5%92%8CnextTick/#1124-nexttick","text":"\u6211\u4eec\u77e5\u9053nextTick\u53ef\u7528\u4e8e\u5ef6\u8fdf\u6267\u884c\u4e00\u4e9b\u903b\u8f91\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u54ea\u4e9b\u573a\u666f\u4e0b\u53ef\u4ee5\u4f7f\u7528nextTick\u3002 1 2 3 4 5 6 7 8 9 10 11 12 const { EventEmitter } = require ( 'events' ); class DemoEvents extends EventEmitter { constructor () { super (); this . emit ( 'start' ); } } const demoEvents = new DemoEvents (); demoEvents . on ( 'start' , () => { console . log ( 'start' ); }); \u4ee5\u4e0a\u4ee3\u7801\u5728\u6784\u9020\u51fd\u6570\u4e2d\u4f1a\u89e6\u53d1start\u4e8b\u4ef6\uff0c\u4f46\u662f\u4e8b\u4ef6\u7684\u6ce8\u518c\u5374\u5728\u6784\u9020\u51fd\u6570\u4e4b\u540e\u6267\u884c\uff0c\u800c\u5728\u6784\u9020\u51fd\u6570\u4e4b\u524d\u6211\u4eec\u8fd8\u6ca1\u6709\u62ff\u5230DemoEvents\u5bf9\u8c61\uff0c\u65e0\u6cd5\u5b8c\u6210\u4e8b\u4ef6\u7684\u6ce8\u518c\u3002\u8fd9\u65f6\u5019\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u4f7f\u7528nextTick\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const { EventEmitter } = require ( 'events' ); class DemoEvents extends EventEmitter { constructor () { super (); process . nextTick (() => { this . emit ( 'start' ); }) } } const demoEvents = new DemoEvents (); demoEvents . on ( 'start' , () => { console . log ( 'start' ); });","title":"11.2.4 nextTick\u7684\u4f7f\u7528"},{"location":"chapter12-%E6%96%87%E4%BB%B6/","text":"\u6587\u4ef6\u64cd\u4f5c\u662f\u6211\u4eec\u4f7f\u7528Node.js\u65f6\u7ecf\u5e38\u4f1a\u7528\u5230\u7684\u529f\u80fd\u3002Node.js\u4e2d\uff0c\u6587\u4ef6\u6a21\u5757\u7684API\u51e0\u4e4e\u90fd\u63d0\u4f9b\u4e86\u540c\u6b65\u548c\u5f02\u6b65\u7684\u7248\u672c\u3002\u540c\u6b65\u7684API\u76f4\u63a5\u5728\u4e3b\u7ebf\u7a0b\u4e2d\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\u63a5\u53e3\uff0c\u5b83\u4f1a\u5bfc\u81f4\u4e3b\u7ebf\u7a0b\u963b\u585e\u3002\u5f02\u6b65API\u5219\u662f\u5728Libuv\u63d0\u4f9b\u7684\u7ebf\u7a0b\u6c60\u4e2d\u6267\u884c\u963b\u585e\u5f0fAPI\u5b9e\u73b0\u7684\u3002\u8fd9\u6837\u5c31\u4e0d\u4f1a\u5bfc\u81f4\u4e3b\u7ebf\u7a0b\u963b\u585e\u3002\u6587\u4ef6IO\u4e0d\u540c\u4e8e\u7f51\u7edcIO\uff0c\u6587\u4ef6IO\u7531\u4e8e\u517c\u5bb9\u6027\u95ee\u9898\uff0c\u65e0\u6cd5\u50cf\u7f51\u7edcIO\u4e00\u6837\u5229\u7528\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\u80fd\u529b\u76f4\u63a5\u5b9e\u73b0\u5f02\u6b65\u3002\u5728Libuv\u4e2d\uff0c\u6587\u4ef6\u64cd\u4f5c\u662f\u4ee5\u7ebf\u7a0b\u6c60\u5b9e\u73b0\u7684\uff0c\u64cd\u4f5c\u6587\u4ef6\u7684\u65f6\u5019\uff0c\u4f1a\u963b\u585e\u5728\u67d0\u4e2a\u7ebf\u7a0b\u3002\u6240\u4ee5\u8fd9\u79cd\u5f02\u6b65\u53ea\u662f\u5bf9\u7528\u6237\u800c\u8a00\u3002\u6587\u4ef6\u6a21\u5757\u867d\u7136\u63d0\u4f9b\u7684\u63a5\u53e3\u975e\u5e38\u591a\uff0c\u6e90\u7801\u4e5f\u51e0\u5343\u884c\uff0c\u4f46\u662f\u5f88\u591a\u903b\u8f91\u90fd\u662f\u7c7b\u4f3c\u7684\uff0c\u6240\u4ee5\u6211\u4eec\u53ea\u8bb2\u89e3\u4e0d\u540c\u7684\u5730\u65b9\u3002\u4ecb\u7ecd\u6587\u4ef6\u6a21\u5757\u4e4b\u524d\u5148\u4ecb\u7ecd\u4e00\u4e0bLinux\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u6587\u4ef6\u3002 Linux\u7cfb\u7edf\u4e2d\u4e07\u7269\u7686\u6587\u4ef6\uff0c\u4ece\u5e94\u7528\u5c42\u6765\u770b\uff0c\u6211\u4eec\u62ff\u5230\u90fd\u662f\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u6211\u4eec\u64cd\u4f5c\u7684\u4e5f\u662f\u8fd9\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u4f7f\u7528\u8d77\u6765\u975e\u5e38\u7b80\u5355\uff0c\u90a3\u662f\u56e0\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u5e2e\u6211\u4eec\u505a\u4e86\u5f88\u591a\u4e8b\u60c5\u3002\u7b80\u5355\u6765\u8bf4\uff0c\u6587\u4ef6\u63cf\u8ff0\u7b26\u53ea\u662f\u4e00\u4e2a\u7d22\u5f15\u3002\u5b83\u7684\u5e95\u5c42\u53ef\u4ee5\u5bf9\u5e94\u5404\u79cd\u5404\u6837\u7684\u8d44\u6e90\uff0c\u5305\u62ec\u666e\u901a\u6587\u4ef6\uff0c\u7f51\u7edc\uff0c\u5185\u5b58\u7b49\u3002\u5f53\u6211\u4eec\u64cd\u4f5c\u4e00\u4e2a\u8d44\u6e90\u4e4b\u524d\uff0c\u6211\u4eec\u9996\u5148\u4f1a\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u63a5\u53e3\u62ff\u5230\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4e5f\u8bb0\u5f55\u4e86\u8fd9\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u5e95\u5c42\u5bf9\u5e94\u7684\u8d44\u6e90\u3001\u5c5e\u6027\u3001\u64cd\u4f5c\u51fd\u6570\u7b49\u3002\u5f53\u6211\u4eec\u540e\u7eed\u64cd\u4f5c\u8fd9\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u64cd\u4f5c\u3002\u6bd4\u5982\u6211\u4eec\u5728write\u7684\u65f6\u5019\uff0c\u4f20\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u662f\u666e\u901a\u6587\u4ef6\u548c\u7f51\u7edcsocket\uff0c\u5e95\u5c42\u6240\u505a\u7684\u64cd\u4f5c\u662f\u4e0d\u4e00\u6837\u7684\u3002\u4f46\u662f\u6211\u4eec\u4e00\u822c\u4e0d\u9700\u8981\u5173\u6ce8\u8fd9\u4e9b\u3002\u6211\u4eec\u53ea\u9700\u8981\u4ece\u62bd\u8c61\u7684\u89d2\u5ea6\u53bb\u4f7f\u7528\u5b83\u3002\u672c\u7ae0\u4ecb\u7ecdNode.js\u4e2d\u5173\u4e8e\u6587\u4ef6\u6a21\u5757\u7684\u539f\u7406\u548c\u5b9e\u73b0\u3002 12.1 \u540c\u6b65API \u00b6 \u5728Node.js\u4e2d\uff0c\u540c\u6b65API\u7684\u672c\u8d28\u662f\u76f4\u63a5\u5728\u4e3b\u7ebf\u7a0b\u91cc\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\u7cfb\u7edf\u8c03\u7528\u3002\u4e0b\u9762\u4ee5readFileSync\u4e3a\u4f8b\uff0c\u770b\u4e00\u4e0b\u6574\u4f53\u7684\u6d41\u7a0b\uff0c\u5982\u56fe12-1\u6240\u793a\u3002 \u56fe12-1 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 function readFileSync ( path , options ) { options = getOptions ( options , { flag : 'r' }); // \u4f20\u7684\u662ffd\u8fd8\u662f\u6587\u4ef6\u8def\u5f84 const isUserFd = isFd ( path ); // \u4f20\u7684\u662f\u8def\u5f84\uff0c\u5219\u5148\u540c\u6b65\u6253\u5f00\u6587\u4ef6 const fd = isUserFd ? path : fs . openSync ( path , options . flag , 0o666 ); // \u67e5\u770b\u6587\u4ef6\u7684stat\u4fe1\u606f\uff0c\u62ff\u5230\u6587\u4ef6\u7684\u5927\u5c0f const stats = tryStatSync ( fd , isUserFd ); // \u662f\u5426\u662f\u4e00\u822c\u6587\u4ef6 const size = isFileType ( stats , S_IFREG ) ? stats [ 8 ] : 0 ; let pos = 0 ; let buffer ; let buffers ; // \u6587\u4ef6\u5927\u5c0f\u662f0\u6216\u8005\u4e0d\u662f\u4e00\u822c\u6587\u4ef6\uff0csize\u5219\u4e3a0 if ( size === 0 ) { buffers = []; } else { // \u4e00\u822c\u6587\u4ef6\u4e14\u6709\u5927\u5c0f\uff0c\u5219\u5206\u914d\u4e00\u4e2a\u5927\u5c0f\u4e3asize\u7684buffer\uff0csize\u9700\u8981\u5c0f\u4e8e2G buffer = tryCreateBuffer ( size , fd , isUserFd ); } let bytesRead ; // \u4e0d\u65ad\u5730\u540c\u6b65\u8bfb\u6587\u4ef6\u5185\u5bb9 if ( size !== 0 ) { do { bytesRead = tryReadSync ( fd , isUserFd , buffer , pos , size - pos ); pos += bytesRead ; } while ( bytesRead !== 0 && pos < size ); } else { do { /* \u6587\u4ef6\u5927\u5c0f\u4e3a0\uff0c\u6216\u8005\u4e0d\u662f\u4e00\u822c\u6587\u4ef6\uff0c\u4e5f\u5c1d\u8bd5\u53bb\u8bfb\uff0c \u4f46\u662f\u56e0\u4e3a\u4e0d\u77e5\u9053\u5927\u5c0f\uff0c\u6240\u4ee5\u53ea\u80fd\u5206\u914d\u4e00\u4e2a\u4e00\u5b9a\u5927\u5c0f\u7684buffer, \u6bcf\u6b21\u8bfb\u53d6\u4e00\u5b9a\u5927\u5c0f\u7684\u5185\u5bb9 */ buffer = Buffer . allocUnsafe ( 8192 ); bytesRead = tryReadSync ( fd , isUserFd , buffer , 0 , 8192 ); // \u628a\u8bfb\u53d6\u5230\u7684\u5185\u5bb9\u653e\u5230buffers\u91cc if ( bytesRead !== 0 ) { buffers . push ( buffer . slice ( 0 , bytesRead )); } // \u8bb0\u5f55\u8bfb\u53d6\u5230\u7684\u6570\u636e\u957f\u5ea6 pos += bytesRead ; } while ( bytesRead !== 0 ); } // \u7528\u6237\u4f20\u7684\u662f\u6587\u4ef6\u8def\u5f84\uff0cNode.js\u81ea\u5df1\u6253\u5f00\u4e86\u6587\u4ef6\uff0c\u6240\u4ee5\u9700\u8981\u81ea\u5df1\u5173\u95ed if ( ! isUserFd ) fs . closeSync ( fd ); // \u6587\u4ef6\u5927\u5c0f\u662f0\u6216\u8005\u975e\u4e00\u822c\u6587\u4ef6\u7684\u8bdd\uff0c\u5982\u679c\u8bfb\u5230\u4e86\u5185\u5bb9 if ( size === 0 ) { // \u628a\u8bfb\u53d6\u5230\u7684\u6240\u6709\u5185\u5bb9\u653e\u5230buffer\u4e2d buffer = Buffer . concat ( buffers , pos ); } else if ( pos < size ) { buffer = buffer . slice ( 0 , pos ); } // \u7f16\u7801 if ( options . encoding ) buffer = buffer . toString ( options . encoding ); return buffer ; } tryReadSync\u8c03\u7528\u7684\u662ffs.readSync\uff0c\u7136\u540e\u5230binding.read(node_file.cc\u4e2d\u5b9a\u4e49\u7684Read\u51fd\u6570)\u3002Read\u51fd\u6570\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 FSReqWrapSync req_wrap_sync ; const int bytesRead = SyncCall ( env , args [ 6 ], & req_wrap_sync , \"read\" , uv_fs_read , fd , & uvbuf , 1 , pos ); \u6211\u4eec\u770b\u4e00\u4e0bSyncCall\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int SyncCall ( Environment * env , v8 :: Local < v8 :: Value > ctx , FSReqWrapSync * req_wrap , const char * syscall , Func fn , Args ... args ) { /* req_wrap->req\u662f\u4e00\u4e2auv_fs_t\u7ed3\u6784\u4f53\uff0c\u5c5e\u4e8erequest\u7c7b\uff0c \u7ba1\u7406\u4e00\u6b21\u6587\u4ef6\u64cd\u4f5c\u7684\u8bf7\u6c42 */ int err = fn ( env -> event_loop (), & ( req_wrap -> req ), args ..., nullptr ); // \u5ffd\u7565\u51fa\u9519\u5904\u7406 return err ; } \u6211\u4eec\u770b\u5230\u6700\u7ec8\u8c03\u7528\u7684\u662fLibuv\u7684uv_fs_read\uff0c\u5e76\u4f7f\u7528uv_fs_t\u7ba1\u7406\u672c\u6b21\u8bf7\u6c42\u3002\u56e0\u4e3a\u662f\u963b\u585e\u5f0f\u8c03\u7528\uff0c\u6240\u4ee5Libuv\u4f1a\u76f4\u63a5\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u7cfb\u7edf\u8c03\u7528read\u51fd\u6570\u3002\u8fd9\u662fNode.js\u4e2d\u540c\u6b65API\u7684\u8fc7\u7a0b\u3002 12.2 \u5f02\u6b65API \u00b6 \u6587\u4ef6\u7cfb\u7edf\u7684API\u4e2d\uff0c\u5f02\u6b65\u7684\u5b9e\u73b0\u662f\u4f9d\u8d56\u4e8eLibuv\u7684\u7ebf\u7a0b\u6c60\u7684\u3002Node.js\u628a\u4efb\u52a1\u653e\u5230\u7ebf\u7a0b\u6c60\uff0c\u7136\u540e\u8fd4\u56de\u4e3b\u7ebf\u7a0b\u7ee7\u7eed\u5904\u7406\u5176\u5b83\u4e8b\u60c5\uff0c\u7b49\u5230\u6761\u4ef6\u6ee1\u8db3\u65f6\uff0c\u5c31\u4f1a\u6267\u884c\u56de\u8c03\u3002\u6211\u4eec\u4ee5readFile\u4e3a\u4f8b\u8bb2\u89e3\u8fd9\u4e2a\u8fc7\u7a0b\u3002\u5f02\u6b65\u8bfb\u53d6\u6587\u4ef6\u7684\u6d41\u7a0b\u56fe\uff0c\u5982\u56fe12-2\u6240\u793a\u3002 \u56fe12-2 \u4e0b\u9762\u6211\u4eec\u770b\u5177\u4f53\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function readFile ( path , options , callback ) { callback = maybeCallback ( callback || options ); options = getOptions ( options , { flag : 'r' }); // \u7ba1\u7406\u6587\u4ef6\u8bfb\u7684\u5bf9\u8c61 if ( ! ReadFileContext ) ReadFileContext = require ( 'internal/fs/read_file_context' ); const context = new ReadFileContext ( callback , options . encoding ) // \u4f20\u7684\u662f\u6587\u4ef6\u8def\u5f84\u8fd8\u662ffd context . isUserFd = isFd ( path ); // File descriptor ownership // C++\u5c42\u7684\u5bf9\u8c61\uff0c\u5c01\u88c5\u4e86uv_fs_t\u7ed3\u6784\u4f53\uff0c\u7ba1\u7406\u4e00\u6b21\u6587\u4ef6\u8bfb\u8bf7\u6c42 const req = new FSReqCallback (); req . context = context ; // \u8bbe\u7f6e\u56de\u8c03\uff0c\u6253\u5f00\u6587\u4ef6\u540e\uff0c\u6267\u884c req . oncomplete = readFileAfterOpen ; // \u4f20\u7684\u662ffd\uff0c\u5219\u4e0d\u9700\u8981\u6253\u5f00\u6587\u4ef6\uff0c\u4e0b\u4e00\u4e2atick\u76f4\u63a5\u6267\u884c\u56de\u8c03\u8bfb\u53d6\u6587\u4ef6 if ( context . isUserFd ) { process . nextTick ( function tick () { req . oncomplete ( null , path ); }); return ; } path = getValidatedPath ( path ); const flagsNumber = stringToFlags ( options . flags ); // \u8c03\u7528C++\u5c42open\u6253\u5f00\u6587\u4ef6 binding . open ( pathModule . toNamespacedPath ( path ), flagsNumber , 0o666 , req ); } ReadFileContext\u5bf9\u8c61\u7528\u4e8e\u7ba1\u7406\u6587\u4ef6\u8bfb\u64cd\u4f5c\u6574\u4e2a\u8fc7\u7a0b\uff0cFSReqCallback\u662f\u5bf9uv_fs_t\u7684\u5c01\u88c5\uff0c\u6bcf\u6b21\u8bfb\u64cd\u4f5c\u5bf9\u4e8eLibuv\u6765\u8bf4\u5c31\u662f\u4e00\u6b21\u8bf7\u6c42\uff0c\u8be5\u8bf7\u6c42\u7684\u4e0a\u4e0b\u6587\u5c31\u662f\u4f7f\u7528uv_fs_t\u8868\u793a\u3002\u8bf7\u6c42\u5b8c\u6210\u540e\uff0c\u4f1a\u6267\u884cFSReqCallback\u5bf9\u8c61\u7684oncomplete\u51fd\u6570\u3002\u6240\u4ee5\u6211\u4eec\u7ee7\u7eed\u770breadFileAfterOpen\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function readFileAfterOpen ( err , fd ) { const context = this . context ; // \u6253\u5f00\u51fa\u9519\u5219\u76f4\u63a5\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u4f20\u5165err if ( err ) { context . callback ( err ); return ; } // \u4fdd\u5b58\u6253\u5f00\u6587\u4ef6\u7684fd context . fd = fd ; // \u65b0\u5efa\u4e00\u4e2aFSReqCallback\u5bf9\u8c61\u7ba1\u7406\u4e0b\u4e00\u4e2a\u5f02\u6b65\u8bf7\u6c42\u548c\u56de\u8c03 const req = new FSReqCallback (); req . oncomplete = readFileAfterStat ; req . context = context ; // \u83b7\u53d6\u6587\u4ef6\u7684\u5143\u6570\u636e\uff0c\u62ff\u5230\u6587\u4ef6\u5927\u5c0f binding . fstat ( fd , false , req ); } \u62ff\u5230\u6587\u4ef6\u7684\u5143\u6570\u636e\u540e\uff0c\u6267\u884creadFileAfterStat\uff0c\u8fd9\u6bb5\u903b\u8f91\u548c\u540c\u6b65\u7684\u7c7b\u4f3c\uff0c\u6839\u636e\u5143\u6570\u636e\u4e2d\u8bb0\u5f55\u7684\u6587\u4ef6\u5927\u5c0f\uff0c\u5206\u914d\u4e00\u4e2abuffer\u7528\u4e8e\u540e\u7eed\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9\u3002\u7136\u540e\u6267\u884c\u8bfb\u64cd\u4f5c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 read () { let buffer ; let offset ; let length ; // \u7701\u7565\u90e8\u5206buffer\u5904\u7406\u7684\u903b\u8f91 const req = new FSReqCallback (); req . oncomplete = readFileAfterRead ; req . context = this ; read ( this . fd , buffer , offset , length , - 1 , req ); } \u518d\u6b21\u65b0\u5efa\u4e00\u4e2aFSReqCallback\u5bf9\u8c61\u7ba1\u7406\u5f02\u6b65\u8bfb\u53d6\u64cd\u4f5c\u548c\u56de\u8c03\u3002\u6211\u4eec\u770b\u4e00\u4e0bC++\u5c42read\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1 2 3 4 // \u62ff\u5230C++\u5c42\u7684FSReqCallback\u5bf9\u8c61 FSReqBase* req_wrap_async = GetReqWrap(env, args[5]); // \u5f02\u6b65\u8c03\u7528uv_fs_read AsyncCall(env, req_wrap_async, args, \"read\", UTF8, AfterInteger,uv_fs_read, fd, &uvbuf, 1, pos); AsyncCall\u6700\u540e\u8c03\u7528Libuv\u7684uv_fs_read\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u51fd\u6570\u7684\u5173\u952e\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 do { \\ if ( cb != NULL ) { \\ uv__req_register ( loop , req ); \\ uv__work_submit ( loop , \\ & req -> work_req , \\ UV__WORK_FAST_IO , \\ uv__fs_work , \\ uv__fs_done ); \\ return 0 ; \\ } \\ else { \\ uv__fs_work ( & req -> work_req ); \\ return req -> result ; \\ } \\ } \\ while ( 0 ) uv__work_submit\u662f\u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4e00\u4e2a\u4efb\u52a1\uff0c\u5f53\u5b50\u7ebf\u7a0b\u6267\u884c\u8fd9\u4e2a\u4efb\u52a1\u65f6\uff0c\u5c31\u4f1a\u6267\u884cuv__fs_work\uff0cuv__fs_work\u4f1a\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u7cfb\u7edf\u8c03\u7528read\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u963b\u585e\u3002\u7b49\u5230\u8bfb\u53d6\u6210\u529f\u540e\u6267\u884cuv__fs_done\u3002uv__fs_done\u4f1a\u6267\u884cC++\u5c42\u7684\u56de\u8c03\uff0c\u4ece\u800c\u6267\u884cJS\u5c42\u7684\u56de\u8c03\u3002JS\u5c42\u7684\u56de\u8c03\u662freadFileAfterRead\uff0c\u8fd9\u91cc\u5c31\u4e0d\u5177\u4f53\u5c55\u5f00\uff0creadFileAfterRead\u7684\u903b\u8f91\u662f\u5224\u65ad\u662f\u5426\u8bfb\u53d6\u5b8c\u6bd5\uff0c\u662f\u7684\u8bdd\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u5426\u5219\u7ee7\u7eed\u53d1\u8d77\u8bfb\u53d6\u64cd\u4f5c\u3002 12.3 \u6587\u4ef6\u76d1\u542c \u00b6 \u6587\u4ef6\u76d1\u542c\u662f\u975e\u5e38\u5e38\u7528\u7684\u529f\u80fd\uff0c\u6bd4\u5982\u6211\u4eec\u4fee\u6539\u4e86\u6587\u4ef6\u540ewebpack\u91cd\u65b0\u6253\u5305\u4ee3\u7801\u6216\u8005Node.js\u670d\u52a1\u91cd\u542f\uff0c\u90fd\u7528\u5230\u4e86\u6587\u4ef6\u76d1\u542c\u7684\u529f\u80fd\uff0cNode.js\u63d0\u4f9b\u4e86\u4e24\u5957\u6587\u4ef6\u76d1\u542c\u7684\u673a\u5236\u3002 12.3.1 \u57fa\u4e8e\u8f6e\u8be2\u7684\u6587\u4ef6\u76d1\u542c\u673a\u5236 \u00b6 \u57fa\u4e8e\u8f6e\u8be2\u673a\u5236\u7684\u6587\u4ef6\u76d1\u542cAPI\u662fwatchFile\u3002\u6d41\u7a0b\u5982\u56fe12-3\u6240\u793a\u3002 \u56fe12-3 \u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function watchFile ( filename , options , listener ) { filename = getValidatedPath ( filename ); filename = pathModule . resolve ( filename ); let stat ; // \u7701\u7565\u90e8\u5206\u53c2\u6570\u5904\u7406\u903b\u8f91 options = { interval : 5007 , // \u4e00\u76f4\u8f6e\u8be2 persistent : true , ... options }; // \u7f13\u5b58\u5904\u7406\uff0cfilename\u662f\u5426\u5df2\u7ecf\u5f00\u542f\u8fc7\u76d1\u542c stat = statWatchers . get ( filename ); if ( stat === undefined ) { if ( ! watchers ) watchers = require ( 'internal/fs/watchers' ); stat = new watchers . StatWatcher ( options . bigint ); // \u5f00\u542f\u76d1\u542c stat [ watchers . kFSStatWatcherStart ]( filename , options . persistent , options . interval ); // \u66f4\u65b0\u7f13\u5b58 statWatchers . set ( filename , stat ); } stat . addListener ( 'change' , listener ); return stat ; } StatWatcher\u662f\u7ba1\u7406\u6587\u4ef6\u76d1\u542c\u7684\u7c7b\uff0c\u6211\u4eec\u770b\u4e00\u4e0bwatchers.kFSStatWatcherStart\u65b9\u6cd5\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 StatWatcher . prototype [ kFSStatWatcherStart ] = function ( filename , persistent , interval ) { this . _handle = new _StatWatcher ( this [ kUseBigint ]); this . _handle . onchange = onchange ; filename = getValidatedPath ( filename , ' filename ' ); const err = this . _handle . start ( toNamespacedPath ( filename ), interval ); } \u65b0\u5efa\u4e00\u4e2a_StatWatcher\u5bf9\u8c61\uff0c_StatWatcher\u662fC++\u6a21\u5757\u63d0\u4f9b\u7684\u529f\u80fd\uff08node_stat_watcher.cc\uff09\uff0c\u7136\u540e\u6267\u884c\u5b83\u7684start\u65b9\u6cd5\u3002Start\u65b9\u6cd5\u6267\u884cLibuv\u7684uv_fs_poll_start\u5f00\u59cb\u76d1\u542c\u6587\u4ef6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int uv_fs_poll_start ( uv_fs_poll_t * handle , uv_fs_poll_cb cb , const char * path , unsigned int interval ) { // \u7ba1\u7406\u6587\u4ef6\u76d1\u542c\u7684\u6570\u636e\u7ed3\u6784 struct poll_ctx * ctx ; uv_loop_t * loop ; size_t len ; int err ; loop = handle -> loop ; len = strlen ( path ); // calloc\u4f1a\u628a\u5185\u5b58\u521d\u59cb\u5316\u4e3a0 ctx = uv__calloc ( 1 , sizeof ( * ctx ) + len ); ctx -> loop = loop ; // C++\u5c42\u56de\u8c03 ctx -> poll_cb = cb ; // \u591a\u4e45\u8f6e\u8be2\u4e00\u6b21 ctx -> interval = interval ? interval : 1 ; ctx -> start_time = uv_now ( loop ); // \u5173\u8054\u7684handle ctx -> parent_handle = handle ; // \u76d1\u542c\u7684\u6587\u4ef6\u8def\u5f84 memcpy ( ctx -> path , path , len + 1 ); // \u521d\u59cb\u5316\u5b9a\u65f6\u5668\u7ed3\u6784\u4f53 err = uv_timer_init ( loop , & ctx -> timer_handle ); // \u5f02\u6b65\u67e5\u8be2\u6587\u4ef6\u5143\u6570\u636e err = uv_fs_stat ( loop , & ctx -> fs_req , ctx -> path , poll_cb ); if ( handle -> poll_ctx != NULL ) ctx -> previous = handle -> poll_ctx ; // \u5173\u8054\u8d1f\u8d23\u7ba1\u7406\u8f6e\u8be2\u7684\u5bf9\u8c61 handle -> poll_ctx = ctx ; uv__handle_start ( handle ); return 0 ; } Start\u51fd\u6570\u521d\u59cb\u5316\u4e00\u4e2apoll_ctx\u7ed3\u6784\u4f53\uff0c\u7528\u4e8e\u7ba1\u7406\u6587\u4ef6\u76d1\u542c\uff0c\u7136\u540e\u53d1\u8d77\u5f02\u6b65\u8bf7\u6c42\u6587\u4ef6\u5143\u6570\u636e\u7684\u8bf7\u6c42\uff0c\u83b7\u53d6\u5143\u6570\u636e\u540e\uff0c\u6267\u884cpoll_cb\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 static void poll_cb ( uv_fs_t * req ) { uv_stat_t * statbuf ; struct poll_ctx * ctx ; uint64_t interval ; // \u901a\u8fc7\u7ed3\u6784\u4f53\u5b57\u6bb5\u83b7\u53d6\u7ed3\u6784\u4f53\u9996\u5730\u5740 ctx = container_of ( req , struct poll_ctx , fs_req ); statbuf = & req -> statbuf ; /* \u7b2c\u4e00\u6b21\u4e0d\u6267\u884c\u56de\u8c03\uff0c\u56e0\u4e3a\u6ca1\u6709\u53ef\u5bf9\u6bd4\u7684\u5143\u6570\u636e\uff0c\u7b2c\u4e8c\u6b21\u53ca\u540e\u7eed\u7684\u64cd\u4f5c\u624d\u53ef\u80fd \u6267\u884c\u56de\u8c03\uff0cbusy_polling\u521d\u59cb\u5316\u7684\u65f6\u5019\u4e3a0\uff0c\u7b2c\u4e00\u6b21\u6267\u884c\u7684\u65f6\u5019\u7f6e busy_polling=1 */ if ( ctx -> busy_polling != 0 ) // \u51fa\u9519\u6216\u8005stat\u53d1\u751f\u4e86\u53d8\u5316\u5219\u6267\u884c\u56de\u8c03 if ( ctx -> busy_polling < 0 || ! statbuf_eq ( & ctx -> statbuf , statbuf )) ctx -> poll_cb ( ctx -> parent_handle , 0 , & ctx -> statbuf , statbuf ); // \u4fdd\u5b58\u5f53\u524d\u83b7\u53d6\u5230\u7684stat\u4fe1\u606f\uff0c\u7f6e1 ctx -> statbuf = * statbuf ; ctx -> busy_polling = 1 ; out : uv_fs_req_cleanup ( req ); if ( ctx -> parent_handle == NULL ) { uv_close (( uv_handle_t * ) & ctx -> timer_handle , timer_close_cb ); return ; } /* \u5047\u8bbe\u5728\u5f00\u59cb\u65f6\u95f4\u70b9\u4e3a1\uff0cinterval\u4e3a10\u7684\u60c5\u51b5\u4e0b\u6267\u884c\u4e86stat\uff0cstat \u5b8c\u6210\u6267\u884c\u5e76\u6267\u884cpoll_cb\u56de\u8c03\u7684\u65f6\u95f4\u70b9\u662f3\uff0c\u90a3\u4e48\u5b9a\u65f6\u5668\u7684\u8d85\u65f6\u65f6\u95f4 \u5219\u4e3a10-3=7\uff0c\u53737\u4e2a\u5355\u4f4d\u540e\u5c31\u8981\u89e6\u53d1\u8d85\u65f6\uff0c\u800c\u4e0d\u662f10\uff0c\u662f\u56e0\u4e3astat \u963b\u585e\u6d88\u8017\u4e863\u4e2a\u5355\u4f4d\u7684\u65f6\u95f4\uff0c\u6240\u4ee5\u4e0b\u6b21\u6267\u884c\u8d85\u65f6\u56de\u8c03\u51fd\u6570\u65f6\u8bf4\u660e\u4ece start\u65f6\u95f4\u70b9\u5f00\u59cb\u7b97\uff0c\u5df2\u7ecf\u7ecf\u5386\u4e86x\u5355\u4f4d\u5404interval\uff0c\u7136\u540e\u8d85\u65f6\u56de\u8c03\u91cc \u53c8\u6267\u884c\u4e86stat\u51fd\u6570\uff0c\u518d\u5230\u6267\u884cstat\u56de\u8c03\uff0c\u8fd9\u4e2a\u65f6\u95f4\u70b9\u5373now=start+x \u5355\u4f4d\u4e2ainterval+stat\u6d88\u8017\u7684\u65f6\u95f4\u3002\u5f97\u51fanow-start\u4e3ainterval\u7684 x\u500d+stat\u6d88\u8017\uff0c\u5373\u5bf9interval\u53d6\u4f59\u53ef\u5f97\u5230stat\u6d88\u8017\uff0c\u6240\u4ee5\u5f53\u524d\u8f6e\uff0c \u5b9a\u65f6\u5668\u7684\u8d85\u65f6\u65f6\u95f4\u4e3ainterval - ((now-start) % interval) */ interval = ctx -> interval ; interval = ( uv_now ( ctx -> loop ) - ctx -> start_time ) % interval ; if ( uv_timer_start ( & ctx -> timer_handle , timer_cb , interval , 0 )) abort (); } \u57fa\u4e8e\u8f6e\u8be2\u7684\u76d1\u542c\u6587\u4ef6\u673a\u5236\u672c\u8d28\u4e0a\u662f\u4e0d\u65ad\u8f6e\u8be2\u6587\u4ef6\u7684\u5143\u6570\u636e\uff0c\u7136\u540e\u548c\u4e0a\u4e00\u6b21\u7684\u5143\u6570\u636e\u8fdb\u884c\u5bf9\u6bd4\uff0c\u5982\u679c\u6709\u4e0d\u4e00\u81f4\u7684\u5c31\u8ba4\u4e3a\u6587\u4ef6\u53d8\u5316\u4e86\uff0c\u56e0\u4e3a\u7b2c\u4e00\u6b21\u83b7\u53d6\u5143\u6570\u636e\u65f6\uff0c\u8fd8\u6ca1\u6709\u53ef\u4ee5\u5bf9\u6bd4\u7684\u6570\u636e\uff0c\u6240\u4ee5\u4e0d\u8ba4\u4e3a\u662f\u6587\u4ef6\u53d8\u5316\uff0c\u8fd9\u65f6\u5019\u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\u3002\u9694\u4e00\u6bb5\u65f6\u95f4\u518d\u53bb\u83b7\u53d6\u6587\u4ef6\u7684\u5143\u6570\u636e\uff0c\u5982\u6b64\u53cd\u590d\uff0c\u76f4\u5230\u7528\u6237\u8c03stop\u51fd\u6570\u505c\u6b62\u8fd9\u4e2a\u884c\u4e3a\u3002\u4e0b\u9762\u662fLibuv\u5173\u4e8e\u6587\u4ef6\u53d8\u5316\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 static int statbuf_eq ( const uv_stat_t * a , const uv_stat_t * b ) { return a -> st_ctim . tv_nsec == b -> st_ctim . tv_nsec && a -> st_mtim . tv_nsec == b -> st_mtim . tv_nsec && a -> st_birthtim . tv_nsec == b -> st_birthtim . tv_nsec && a -> st_ctim . tv_sec == b -> st_ctim . tv_sec && a -> st_mtim . tv_sec == b -> st_mtim . tv_sec && a -> st_birthtim . tv_sec == b -> st_birthtim . tv_sec && a -> st_size == b -> st_size && a -> st_mode == b -> st_mode && a -> st_uid == b -> st_uid && a -> st_gid == b -> st_gid && a -> st_ino == b -> st_ino && a -> st_dev == b -> st_dev && a -> st_flags == b -> st_flags && a -> st_gen == b -> st_gen ; } 12.3.2\u57fa\u4e8einotify\u7684\u6587\u4ef6\u76d1\u542c\u673a\u5236 \u00b6 \u6211\u4eec\u770b\u5230\u57fa\u4e8e\u8f6e\u8be2\u7684\u76d1\u542c\u5176\u5b9e\u6548\u7387\u662f\u5f88\u4f4e\u7684\uff0c\u56e0\u4e3a\u9700\u8981\u6211\u4eec\u4e0d\u65ad\u53bb\u8f6e\u8be2\u6587\u4ef6\u7684\u5143\u6570\u636e\uff0c\u5982\u679c\u6587\u4ef6\u5927\u90e8\u5206\u65f6\u95f4\u91cc\u90fd\u6ca1\u6709\u53d8\u5316\uff0c\u90a3\u5c31\u4f1a\u767d\u767d\u6d6a\u8d39CPU\u3002\u5982\u679c\u6587\u4ef6\u6539\u53d8\u4e86\u4f1a\u4e3b\u52a8\u901a\u77e5\u6211\u4eec\u90a3\u5c31\u597d\u4e86\uff0c\u8fd9\u5c31\u662f\u57fa\u4e8einotify\u673a\u5236\u7684\u6587\u4ef6\u76d1\u542c\u3002Node.js\u63d0\u4f9b\u7684\u63a5\u53e3\u662fwatch\u3002watch\u7684\u5b9e\u73b0\u548cwatchFile\u7684\u6bd4\u8f83\u7c7b\u4f3c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function watch ( filename , options , listener ) { // Don't make changes directly on options object options = copyObject ( options ); // \u662f\u5426\u6301\u7eed\u76d1\u542c if ( options . persistent === undefined ) options . persistent = true ; // \u5982\u679c\u662f\u76ee\u5f55\uff0c\u662f\u5426\u76d1\u542c\u6240\u6709\u5b50\u76ee\u5f55\u548c\u6587\u4ef6\u7684\u53d8\u5316 if ( options . recursive === undefined ) options . recursive = false ; // \u6709\u4e9b\u5e73\u53f0\u4e0d\u652f\u6301 if ( options . recursive && ! ( isOSX || isWindows )) throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM ( 'watch recursively' ); if ( ! watchers ) watchers = require ( 'internal/fs/watchers' ); // \u65b0\u5efa\u4e00\u4e2aFSWatcher\u5bf9\u8c61\u7ba1\u7406\u6587\u4ef6\u76d1\u542c\uff0c\u7136\u540e\u5f00\u542f\u76d1\u542c const watcher = new watchers . FSWatcher (); watcher [ watchers . kFSWatchStart ]( filename , options . persistent , options . recursive , options . encoding ); if ( listener ) { watcher . addListener ( 'change' , listener ); } return watcher ; } FSWatcher\u51fd\u6570\u662f\u5bf9C++\u5c42FSEvent\u6a21\u5757\u7684\u5c01\u88c5\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e0bstart\u51fd\u6570\u7684\u903b\u8f91\uff0cstart\u51fd\u6570\u900f\u8fc7C++\u5c42\u8c03\u7528\u4e86Libuv\u7684uv_fs_event_start\u51fd\u6570\u3002\u5728\u8bb2\u89e3uv_fs_event_start\u51fd\u6570\u524d\uff0c\u6211\u4eec\u5148\u4e86\u89e3\u4e00\u4e0binotify\u7684\u539f\u7406\u548c\u5b83\u5728Libuv\u4e2d\u7684\u5b9e\u73b0\u3002inotify\u662fLinux\u7cfb\u7edf\u63d0\u4f9b\u7528\u4e8e\u76d1\u542c\u6587\u4ef6\u7cfb\u7edf\u7684\u673a\u5236\u3002inotify\u673a\u5236\u7684\u903b\u8f91\u5927\u81f4\u662f 1 init_inotify\u521b\u5efa\u4e00\u4e2ainotify\u7684\u5b9e\u4f8b\uff0c\u8fd4\u56de\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u7c7b\u4f3cepoll\u3002 2 inotify_add_watch\u5f80inotify\u5b9e\u4f8b\u6ce8\u518c\u4e00\u4e2a\u9700\u76d1\u542c\u7684\u6587\u4ef6\uff08inotify_rm_watch\u662f\u79fb\u9664\uff09\u3002 3 read(inotify\u5b9e\u4f8b\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26, &buf, sizeof(buf))\uff0c\u5982\u679c\u6ca1\u6709\u4e8b\u4ef6\u89e6\u53d1\uff0c\u5219\u963b\u585e\uff08\u9664\u975e\u8bbe\u7f6e\u4e86\u975e\u963b\u585e\uff09\u3002\u5426\u5219\u8fd4\u56de\u5f85\u8bfb\u53d6\u7684\u6570\u636e\u957f\u5ea6\u3002buf\u5c31\u662f\u4fdd\u5b58\u4e86\u89e6\u53d1\u4e8b\u4ef6\u7684\u4fe1\u606f\u3002 Libuv\u5728inotify\u673a\u5236\u7684\u57fa\u7840\u4e0a\u505a\u4e86\u4e00\u5c42\u5c01\u88c5\u3002\u6211\u4eec\u770b\u4e00\u4e0binotify\u5728Libuv\u7684\u67b6\u6784\u56fe\u5982\u56fe12-4\u6240\u793a\u3002 \u56fe12-4 \u6211\u4eec\u518d\u6765\u770b\u4e00\u4e0bLibuv\u4e2d\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u4ece\u4e00\u4e2a\u4f7f\u7528\u4f8b\u5b50\u5f00\u59cb\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main ( int argc , char ** argv ) { // \u5b9e\u73b0\u5faa\u73af\u6838\u5fc3\u7ed3\u6784\u4f53loop loop = uv_default_loop (); uv_fs_event_t * fs_event_req = malloc ( sizeof ( uv_fs_event_t )); // \u521d\u59cb\u5316fs_event_req\u7ed3\u6784\u4f53\u7684\u7c7b\u578b\u4e3aUV_FS_EVENT uv_fs_event_init ( loop , fs_event_req ); /* argv[argc]\u662f\u6587\u4ef6\u8def\u5f84\uff0c uv_fs_event_start \u5411\u5e95\u5c42\u6ce8\u518c\u76d1\u542c\u6587\u4ef6argv[argc], cb\u662f\u4e8b\u4ef6\u89e6\u53d1\u65f6\u7684\u56de\u8c03 */ uv_fs_event_start ( fs_event_req , cb , argv [ argc ], UV_FS_EVENT_RECURSIVE ); // \u5f00\u542f\u4e8b\u4ef6\u5faa\u73af return uv_run ( loop , UV_RUN_DEFAULT ); } Libuv\u5728\u7b2c\u4e00\u6b21\u76d1\u542c\u6587\u4ef6\u7684\u65f6\u5019(\u8c03\u7528uv_fs_event_start\u7684\u65f6\u5019)\uff0c\u4f1a\u521b\u5efa\u4e00\u4e2ainotify\u5b9e\u4f8b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 static int init_inotify ( uv_loop_t * loop ) { int err ; // \u521d\u59cb\u5316\u8fc7\u4e86\u5219\u76f4\u63a5\u8fd4\u56de if ( loop -> inotify_fd != -1 ) return 0 ; /* \u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684inotify_init\u51fd\u6570\u7533\u8bf7\u4e00\u4e2ainotify\u5b9e\u4f8b\uff0c \u5e76\u8bbe\u7f6eUV__IN_NONBLOCK\uff0cUV__IN_CLOEXEC\u6807\u8bb0 */ err = new_inotify_fd (); if ( err < 0 ) return err ; // \u8bb0\u5f55inotify\u5b9e\u4f8b\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26,\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af\u4e00\u4e2ainotify\u5b9e\u4f8b loop -> inotify_fd = err ; /* inotify_read_watcher\u662f\u4e00\u4e2aIO\u89c2\u5bdf\u8005\uff0c uv__io_init\u8bbe\u7f6eIO\u89c2\u5bdf\u8005\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff08\u5f85\u89c2\u5bdf\u7684\u6587\u4ef6\uff09\u548c\u56de\u8c03 */ uv__io_init ( & loop -> inotify_read_watcher , uv__inotify_read , loop -> inotify_fd ); // \u5f80Libuv\u4e2d\u6ce8\u518c\u8be5IO\u89c2\u5bdf\u8005\uff0c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u4e3a\u53ef\u8bfb uv__io_start ( loop , & loop -> inotify_read_watcher , POLLIN ); return 0 ; } Libuv\u628ainotify\u5b9e\u4f8b\u5bf9\u5e94\u7684fd\u901a\u8fc7uv__io_start\u6ce8\u518c\u5230epoll\u4e2d\uff0c\u5f53\u6709\u6587\u4ef6\u53d8\u5316\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884c\u56de\u8c03uv__inotify_read\u3002\u5206\u6790\u5b8cLibuv\u7533\u8bf7inotify\u5b9e\u4f8b\u7684\u903b\u8f91\uff0c\u6211\u4eec\u56de\u5230main\u51fd\u6570\u770b\u770buv_fs_event_start\u51fd\u6570\u3002\u7528\u6237\u4f7f\u7528uv_fs_event_start\u51fd\u6570\u6765\u5f80Libuv\u6ce8\u518c\u4e00\u4e2a\u5f85\u76d1\u542c\u7684\u6587\u4ef6\u3002\u6211\u4eec\u770b\u770b\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 int uv_fs_event_start ( uv_fs_event_t * handle , uv_fs_event_cb cb , const char * path , unsigned int flags ) { struct watcher_list * w ; int events ; int err ; int wd ; if ( uv__is_active ( handle )) return UV_EINVAL ; // \u7533\u8bf7\u4e00\u4e2ainotify\u5b9e\u4f8b err = init_inotify ( handle -> loop ); if ( err ) return err ; // \u76d1\u542c\u7684\u4e8b\u4ef6 events = UV__IN_ATTRIB | UV__IN_CREATE | UV__IN_MODIFY | UV__IN_DELETE | UV__IN_DELETE_SELF | UV__IN_MOVE_SELF | UV__IN_MOVED_FROM | UV__IN_MOVED_TO ; // \u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u51fd\u6570\u6ce8\u518c\u4e00\u4e2a\u5f85\u76d1\u542c\u7684\u6587\u4ef6\uff0c\u8fd4\u56de\u4e00\u4e2a\u5bf9\u5e94\u4e8e\u8be5\u6587\u4ef6\u7684id wd = uv__inotify_add_watch ( handle -> loop -> inotify_fd , path , events ); if ( wd == -1 ) return UV__ERR ( errno ); // \u5224\u65ad\u8be5\u6587\u4ef6\u662f\u4e0d\u662f\u5df2\u7ecf\u6ce8\u518c\u8fc7\u4e86 w = find_watcher ( handle -> loop , wd ); // \u5df2\u7ecf\u6ce8\u518c\u8fc7\u5219\u8df3\u8fc7\u63d2\u5165\u7684\u903b\u8f91 if ( w ) goto no_insert ; // \u8fd8\u6ca1\u6709\u6ce8\u518c\u8fc7\u5219\u63d2\u5165Libuv\u7ef4\u62a4\u7684\u7ea2\u9ed1\u6811 w = uv__malloc ( sizeof ( * w ) + strlen ( path ) + 1 ); if ( w == NULL ) return UV_ENOMEM ; w -> wd = wd ; w -> path = strcpy (( char * )( w + 1 ), path ); QUEUE_INIT ( & w -> watchers ); w -> iterating = 0 ; // \u63d2\u5165Libuv\u7ef4\u62a4\u7684\u7ea2\u9ed1\u6811,inotify_watchers\u662f\u6839\u8282\u70b9 RB_INSERT ( watcher_root , CAST ( & handle -> loop -> inotify_watchers ), w ); no_insert : // \u6fc0\u6d3b\u8be5handle uv__handle_start ( handle ); // \u540c\u4e00\u4e2a\u6587\u4ef6\u53ef\u80fd\u6ce8\u518c\u4e86\u5f88\u591a\u4e2a\u56de\u8c03\uff0cw\u5bf9\u5e94\u4e00\u4e2a\u6587\u4ef6\uff0c\u6ce8\u518c\u5728\u7528\u4e00\u4e2a\u6587\u4ef6\u7684\u56de\u8c03\u6392\u6210\u961f QUEUE_INSERT_TAIL ( & w -> watchers , & handle -> watchers ); // \u4fdd\u5b58\u4fe1\u606f\u548c\u56de\u8c03 handle -> path = w -> path ; handle -> cb = cb ; handle -> wd = wd ; return 0 ; } \u4e0b\u9762\u6211\u4eec\u9010\u6b65\u5206\u6790\u4e0a\u9762\u7684\u51fd\u6570\u903b\u8f91\u3002 1 \u5982\u679c\u662f\u9996\u6b21\u8c03\u7528\u8be5\u51fd\u6570\u5219\u65b0\u5efa\u4e00\u4e2ainotify\u5b9e\u4f8b\u3002\u5e76\u4e14\u5f80Libuv\u63d2\u5165\u4e00\u4e2a\u89c2\u5bdf\u8005io\uff0cLibuv\u4f1a\u5728Poll IO\u9636\u6bb5\u6ce8\u518c\u5230epoll\u4e2d\u3002 2 \u5f80\u64cd\u4f5c\u7cfb\u7edf\u6ce8\u518c\u4e00\u4e2a\u5f85\u76d1\u542c\u7684\u6587\u4ef6\u3002\u8fd4\u56de\u4e00\u4e2aid\u3002 3 Libuv\u5224\u65ad\u8be5id\u662f\u4e0d\u662f\u5728\u81ea\u5df1\u7ef4\u62a4\u7684\u7ea2\u9ed1\u6811\u4e2d\u3002\u4e0d\u5728\u7ea2\u9ed1\u6811\u4e2d\uff0c\u5219\u63d2\u5165\u7ea2\u9ed1\u6811\u3002\u8fd4\u56de\u4e00\u4e2a\u7ea2\u9ed1\u6811\u4e2d\u5bf9\u5e94\u7684\u8282\u70b9\u3002\u628a\u672c\u6b21\u8bf7\u6c42\u7684\u4fe1\u606f\u5c01\u88c5\u5230handle\u4e2d\uff08\u56de\u8c03\u65f6\u9700\u8981\uff09\u3002\u7136\u540e\u628ahandle\u63d2\u5165\u521a\u624d\u8fd4\u56de\u7684\u8282\u70b9\u7684\u961f\u5217\u4e2d\u3002 \u8fd9\u65f6\u5019\u6ce8\u518c\u8fc7\u7a0b\u5c31\u5b8c\u6210\u4e86\u3002Libuv\u5728Poll IO\u9636\u6bb5\u5982\u679c\u68c0\u6d4b\u5230\u6709\u6587\u4ef6\u53d1\u751f\u53d8\u5316\uff0c\u5219\u4f1a\u6267\u884c\u56de\u8c03uv__inotify_read\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 static void uv__inotify_read ( uv_loop_t * loop , uv__io_t * dummy , unsigned int events ) { const struct uv__inotify_event * e ; struct watcher_list * w ; uv_fs_event_t * h ; QUEUE queue ; QUEUE * q ; const char * path ; ssize_t size ; const char * p ; /* needs to be large enough for sizeof(inotify_event) + strlen(path) */ char buf [ 4096 ]; // \u4e00\u6b21\u53ef\u80fd\u6ca1\u6709\u8bfb\u5b8c while ( 1 ) { do // \u8bfb\u53d6\u89e6\u53d1\u7684\u4e8b\u4ef6\u4fe1\u606f\uff0csize\u662f\u6570\u636e\u5927\u5c0f\uff0cbuffer\u4fdd\u5b58\u6570\u636e size = read ( loop -> inotify_fd , buf , sizeof ( buf )); while ( size == -1 && errno == EINTR ); // \u6ca1\u6709\u6570\u636e\u53ef\u53d6\u4e86 if ( size == -1 ) { assert ( errno == EAGAIN || errno == EWOULDBLOCK ); break ; } // \u5904\u7406buffer\u7684\u4fe1\u606f for ( p = buf ; p < buf + size ; p += sizeof ( * e ) + e -> len ) { // buffer\u91cc\u662f\u591a\u4e2auv__inotify_event\u7ed3\u6784\u4f53\uff0c\u91cc\u9762\u4fdd\u5b58\u4e86\u4e8b\u4ef6\u4fe1\u606f\u548c\u6587\u4ef6\u5bf9\u5e94\u7684id\uff08wd\u5b57\u6bb5\uff09 e = ( const struct uv__inotify_event * ) p ; events = 0 ; if ( e -> mask & ( UV__IN_ATTRIB | UV__IN_MODIFY )) events |= UV_CHANGE ; if ( e -> mask & ~ ( UV__IN_ATTRIB | UV__IN_MODIFY )) events |= UV_RENAME ; // \u901a\u8fc7\u6587\u4ef6\u5bf9\u5e94\u7684id\uff08wd\u5b57\u6bb5\uff09\u4ece\u7ea2\u9ed1\u6811\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u8282\u70b9 w = find_watcher ( loop , e -> wd ); path = e -> len ? ( const char * ) ( e + 1 ) : uv__basename_r ( w -> path ); w -> iterating = 1 ; // \u628a\u7ea2\u9ed1\u6811\u4e2d\uff0cwd\u5bf9\u5e94\u8282\u70b9\u7684handle\u961f\u5217\u79fb\u5230queue\u53d8\u91cf\uff0c\u51c6\u5907\u5904\u7406 QUEUE_MOVE ( & w -> watchers , & queue ); while ( ! QUEUE_EMPTY ( & queue )) { // \u5934\u7ed3\u70b9 q = QUEUE_HEAD ( & queue ); // \u901a\u8fc7\u7ed3\u6784\u4f53\u504f\u79fb\u62ff\u5230\u9996\u5730\u5740 h = QUEUE_DATA ( q , uv_fs_event_t , watchers ); // \u4ece\u5904\u7406\u961f\u5217\u4e2d\u79fb\u9664 QUEUE_REMOVE ( q ); // \u653e\u56de\u539f\u961f\u5217 QUEUE_INSERT_TAIL ( & w -> watchers , q ); // \u6267\u884c\u56de\u8c03 h -> cb ( h , path , events , 0 ); } } } } uv__inotify_read\u51fd\u6570\u7684\u903b\u8f91\u5c31\u662f\u4ece\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u628a\u6570\u636e\u8bfb\u53d6\u51fa\u6765\uff0c\u8fd9\u4e9b\u6570\u636e\u4e2d\u4fdd\u5b58\u4e86\u54ea\u4e9b\u6587\u4ef6\u89e6\u53d1\u4e86\u7528\u6237\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u3002\u7136\u540e\u904d\u5386\u6bcf\u4e2a\u89e6\u53d1\u4e86\u4e8b\u4ef6\u7684\u6587\u4ef6\u3002\u4ece\u7ea2\u9ed1\u6811\u4e2d\u627e\u5230\u8be5\u6587\u4ef6\u5bf9\u5e94\u7684\u7ea2\u9ed1\u6811\u8282\u70b9\u3002\u518d\u53d6\u51fa\u7ea2\u9ed1\u6811\u8282\u70b9\u4e2d\u7ef4\u62a4\u7684\u4e00\u4e2ahandle\u961f\u5217\uff0c\u6700\u540e\u6267\u884chandle\u961f\u5217\u4e2d\u6bcf\u4e2a\u8282\u70b9\u7684\u56de\u8c03\u3002 12.4 Promise\u5316API \u00b6 Node.js\u7684API\u90fd\u662f\u9075\u5faacallback\u6a21\u5f0f\u7684\uff0c\u6bd4\u5982\u6211\u4eec\u8981\u8bfb\u53d6\u4e00\u4e2a\u6587\u4ef6\u7684\u5185\u5bb9\u3002\u6211\u4eec\u901a\u5e38\u4f1a\u8fd9\u6837\u5199 1 2 3 4 5 6 7 8 9 10 11 12 13 const fs = require ( 'fs' ); fs . readFile ( 'filename' , 'utf-8' ,( err , data ) => { console . log ( data ) }) //\u4e3a\u4e86\u652f\u6301Promise\u6a21\u5f0f\uff0c\u6211\u4eec\u901a\u5e38\u8fd9\u6837\u5199 const fs = require ( 'fs' ); function readFile ( filename ) { return new Promise (( resolve , reject ) => { fs . readFile ( filename , 'utf-8' ,( err , data ) => { err ? reject ( err ) : resolve ( data ); }); }); } \u4f46\u662f\u5728Node.js V14\u4e2d\uff0c\u6587\u4ef6\u6a21\u5757\u652f\u6301\u4e86Promise\u5316\u7684api\u3002\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528await\u8fdb\u884c\u6587\u4ef6\u64cd\u4f5c\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4f7f\u7528\u4f8b\u5b50\u3002 1 2 3 4 5 6 7 8 9 const { open , readFile } = require ( 'fs' ). promises ; async function runDemo () { try { console . log ( await readFile ( '11111.md' , { encoding : 'utf-8' })); } catch ( e ){ } } runDemo (); \u4ece\u4f8b\u5b50\u4e2d\u6211\u4eec\u770b\u5230\uff0c\u548c\u4e4b\u524d\u7684API\u8c03\u7528\u65b9\u5f0f\u7c7b\u4f3c\uff0c\u4e0d\u540c\u7684\u5730\u65b9\u5728\u4e8e\u6211\u4eec\u4e0d\u7528\u518d\u5199\u56de\u8c03\u4e86\uff0c\u800c\u662f\u901a\u8fc7await\u7684\u65b9\u5f0f\u63a5\u6536\u7ed3\u679c\u3002\u8fd9\u53ea\u662f\u65b0\u7248API\u7684\u7279\u6027\u4e4b\u4e00\u3002\u5728\u65b0\u7248API\u4e4b\u524d\uff0c\u6587\u4ef6\u6a21\u5757\u5927\u90e8\u5206API\u90fd\u662f\u7c7b\u4f3c\u5de5\u5177\u51fd\u6570\uff0c\u6bd4\u5982readFile\uff0cwriteFile\uff0c\u65b0\u7248API\u4e2d\u652f\u6301\u9762\u5411\u5bf9\u8c61\u7684\u8c03\u7528\u65b9\u5f0f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const { open , readFile } = require ( 'fs' ). promises ; async function runDemo () { let filehandle ; try { filehandle = await open ( 'filename' , 'r' ); // console.log(await readFile(filehandle, { encoding: 'utf-8' })); console . log ( await filehandle . readFile ({ encoding : 'utf-8' })); } finally { if ( filehandle ) { await filehandle . close (); } } } runDemo (); \u9762\u5411\u5bf9\u8c61\u7684\u6a21\u5f0f\u4e2d\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u901a\u8fc7open\u51fd\u6570\u62ff\u5230\u4e00\u4e2aFileHandle\u5bf9\u8c61\uff08\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5c01\u88c5\uff09\uff0c\u7136\u540e\u5c31\u53ef\u4ee5\u5728\u8be5\u5bf9\u8c61\u4e0a\u8c03\u5404\u79cd\u6587\u4ef6\u64cd\u4f5c\u7684\u51fd\u6570\u3002\u5728\u4f7f\u7528\u9762\u5411\u5bf9\u8c61\u6a21\u5f0f\u7684API\u65f6\u6709\u4e00\u4e2a\u9700\u8981\u6ce8\u610f\u7684\u5730\u65b9\u662fNode.js\u4e0d\u4f1a\u4e3a\u6211\u4eec\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5373\u4f7f\u6587\u4ef6\u64cd\u4f5c\u51fa\u9519\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u81ea\u5df1\u624b\u52a8\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5426\u5219\u4f1a\u9020\u6210\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\uff0c\u800c\u5728\u975e\u9762\u5411\u5bf9\u8c61\u6a21\u5f0f\u4e2d\uff0c\u5728\u6587\u4ef6\u64cd\u4f5c\u5b8c\u6bd5\u540e\uff0c\u4e0d\u7ba1\u6210\u529f\u8fd8\u662f\u5931\u8d25\uff0cNode.js\u90fd\u4f1a\u4e3a\u6211\u4eec\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002\u9996\u5148\u4ecb\u7ecd\u4e00\u4e2aFileHandle\u7c7b\u3002\u8be5\u7c7b\u662f\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5c01\u88c5\uff0c\u63d0\u4f9b\u4e86\u9762\u5411\u5bf9\u8c61\u7684API\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class FileHandle { constructor ( filehandle ) { // filehandle\u4e3aC++\u5bf9\u8c61 this [ kHandle ] = filehandle ; this [ kFd ] = filehandle . fd ; } get fd () { return this [ kFd ]; } readFile ( options ) { return readFile ( this , options ); } close = () => { this [ kFd ] = - 1 ; return this [ kHandle ]. close (); } // \u7701\u7565\u90e8\u5206\u64cd\u4f5c\u6587\u4ef6\u7684api } FileHandle\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u9996\u5148\u5c01\u88c5\u4e86\u4e00\u7cfb\u5217\u6587\u4ef6\u64cd\u4f5c\u7684API\uff0c\u7136\u540e\u5b9e\u73b0\u4e86close\u51fd\u6570\u7528\u4e8e\u5173\u95ed\u5e95\u5c42\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 1 \u64cd\u4f5c\u6587\u4ef6\u7cfb\u7edfAPI \u8fd9\u91cc\u6211\u4eec\u4ee5readFile\u4e3a\u4f8b\u8fdb\u884c\u5206\u6790 1 2 3 4 5 6 7 8 9 10 async function readFile ( path , options ) { options = getOptions ( options , { flag : 'r' }); const flag = options . flag || 'r' ; // \u4ee5\u9762\u5411\u5bf9\u8c61\u7684\u65b9\u5f0f\u4f7f\u7528\uff0c\u8fd9\u65f6\u5019\u9700\u8981\u81ea\u5df1\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26 if ( path instanceof FileHandle ) return readFileHandle ( path , options ); // \u76f4\u63a5\u8c03\u7528\uff0c\u9996\u5148\u9700\u8981\u5148\u6253\u5f00\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u8bfb\u53d6\u5b8c\u6bd5\u540eNode.js\u4f1a\u4e3b\u52a8\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26 const fd = await open ( path , flag , 0o666 ); return readFileHandle ( fd , options ). finally ( fd . close ); } \u4ecereadFile\u4ee3\u7801\u4e2d\u6211\u4eec\u770b\u5230\u4e0d\u540c\u8c03\u7528\u65b9\u5f0f\u4e0b\uff0cNode.js\u7684\u5904\u7406\u662f\u4e0d\u4e00\u6837\u7684\uff0c\u5f53FileHandle\u662f\u6211\u4eec\u7ef4\u62a4\u65f6\uff0c\u5173\u95ed\u64cd\u4f5c\u4e5f\u662f\u6211\u4eec\u8d1f\u8d23\u6267\u884c\uff0c\u5f53FileHandle\u662fNode.js\u7ef4\u62a4\u65f6\uff0cNode.js\u5728\u6587\u4ef6\u64cd\u4f5c\u5b8c\u6bd5\u540e\uff0c\u4e0d\u7ba1\u6210\u529f\u8fd8\u662f\u5931\u8d25\u90fd\u4f1a\u4e3b\u52a8\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u63a5\u7740\u6211\u4eec\u770b\u5230readFileHandle\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 async function readFileHandle ( filehandle , options ) { // \u83b7\u53d6\u6587\u4ef6\u5143\u4fe1\u606f const statFields = await binding . fstat ( filehandle . fd , false , kUsePromises ); let size ; // \u662f\u4e0d\u662f\u666e\u901a\u6587\u4ef6\uff0c\u6839\u636e\u6587\u4ef6\u7c7b\u578b\u83b7\u53d6\u5bf9\u5e94\u5927\u5c0f if (( statFields [ 1 /* mode */ ] & S_IFMT ) === S_IFREG ) { size = statFields [ 8 /* size */ ]; } else { size = 0 ; } // \u592a\u5927\u4e86 if ( size > kIoMaxLength ) throw new ERR_FS_FILE_TOO_LARGE ( size ); const chunks = []; // \u8ba1\u7b97\u6bcf\u6b21\u8bfb\u53d6\u7684\u5927\u5c0f const chunkSize = size === 0 ? kReadFileMaxChunkSize : MathMin ( size , kReadFileMaxChunkSize ); let endOfFile = false ; do { // \u5206\u914d\u5185\u5b58\u627f\u8f7d\u6570\u636e const buf = Buffer . alloc ( chunkSize ); // \u8bfb\u53d6\u7684\u6570\u636e\u548c\u5927\u5c0f const { bytesRead , buffer } = await read ( filehandle , buf , 0 , chunkSize , - 1 ); // \u662f\u5426\u8bfb\u5b8c\u4e86 endOfFile = bytesRead === 0 ; // \u8bfb\u53d6\u4e86\u6709\u6548\u6570\u636e\u5219\u628a\u6709\u6548\u6570\u636e\u90e8\u5206\u5b58\u8d77\u6765 if ( bytesRead > 0 ) chunks . push ( buffer . slice ( 0 , bytesRead )); } while ( ! endOfFile ); const result = Buffer . concat ( chunks ); if ( options . encoding ) { return result . toString ( options . encoding ); } else { return result ; } } \u63a5\u7740\u6211\u4eec\u770bread\u51fd\u6570\u7684\u5b9e\u73b0 1 2 3 4 5 async function read ( handle , buffer , offset , length , position ) { // ... const bytesRead = ( await binding . read ( handle . fd , buffer , offset , length , position , kUsePromises )) || 0 ; return { bytesRead , buffer }; } Read\u6700\u7ec8\u6267\u884c\u4e86node_file.cc \u7684Read\u3002\u6211\u4eec\u770b\u4e00\u4e0bRead\u51fd\u6570\u7684\u5173\u952e\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 static void Read ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); // ... FSReqBase * req_wrap_async = GetReqWrap ( env , args [ 5 ]); // \u5f02\u6b65\u6267\u884c\uff0c\u6709\u4e24\u79cd\u60c5\u51b5 if ( req_wrap_async != nullptr ) { AsyncCall ( env , req_wrap_async , args , \"read\" , UTF8 , AfterInteger , uv_fs_read , fd , & uvbuf , 1 , pos ); } else { // \u540c\u6b65\u6267\u884c\uff0c\u6bd4\u5982fs.readFileSync CHECK_EQ ( argc , 7 ); FSReqWrapSync req_wrap_sync ; FS_SYNC_TRACE_BEGIN ( read ); const int bytesRead = SyncCall ( env , args [ 6 ], & req_wrap_sync , \"read\" , uv_fs_read , fd , & uvbuf , 1 , pos ); FS_SYNC_TRACE_END ( read , \"bytesRead\" , bytesRead ); args . GetReturnValue (). Set ( bytesRead ); } } Read\u51fd\u6570\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5\uff0c\u540c\u6b65\u548c\u5f02\u6b65\uff0c\u5176\u4e2d\u5f02\u6b65\u53c8\u5206\u4e3a\u4e24\u79cd\uff0ccallback\u6a21\u5f0f\u548cPromise\u6a21\u5f0f\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5f02\u6b65\u6a21\u5f0f\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u8fd9\u53e5\u4ee3\u7801\u3002 1 FSReqBase* req_wrap_async = GetReqWrap(env, args[5]); GetReqWrap\u6839\u636e\u7b2c\u516d\u4e2a\u53c2\u6570\u83b7\u53d6\u5bf9\u5e94\u7684\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 FSReqBase * GetReqWrap ( Environment * env , v8 :: Local < v8 :: Value > value , bool use_bigint ) { // \u662f\u5bf9\u8c61\u8bf4\u660e\u662f\u7ee7\u627fFSReqBase\u7684\u5bf9\u8c61,\u6bd4\u5982FSReqCallback\uff08\u5f02\u6b65\u6a21\u5f0f\uff09 if ( value -> IsObject ()) { return Unwrap < FSReqBase > ( value . As < v8 :: Object > ()); } else if ( value -> StrictEquals ( env -> fs_use_promises_symbol ())) { // Promise\u6a21\u5f0f\uff08\u5f02\u6b65\u6a21\u5f0f\uff09 if ( use_bigint ) { return FSReqPromise < AliasedBigUint64Array >:: New ( env , use_bigint ); } else { return FSReqPromise < AliasedFloat64Array >:: New ( env , use_bigint ); } } // \u540c\u6b65\u6a21\u5f0f return nullptr ; } \u8fd9\u91cc\u6211\u4eec\u53ea\u5173\u6ce8Promise\u6a21\u5f0f\u3002\u6240\u4ee5GetReqWrap\u8fd4\u56de\u7684\u662f\u4e00\u4e2aFSReqPromise\u5bf9\u8c61\uff0c\u6211\u4eec\u56de\u5230Read\u51fd\u6570\u3002\u770b\u5230\u4ee5\u4e0b\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 FSReqBase * req_wrap_async = GetReqWrap ( env , args [ 5 ]); AsyncCall ( env , req_wrap_async , args , \"read\" , UTF8 , AfterInteger , uv_fs_read , fd , & uvbuf , 1 , pos ); \u7ee7\u7eed\u770b AsyncCall\u51fd\u6570 \uff08 node_file - inl . h \uff09 template < typename Func , typename ... Args > FSReqBase * AsyncCall ( Environment * env , FSReqBase * req_wrap , const v8 :: FunctionCallbackInfo < v8 :: Value >& args , const char * syscall , enum encoding enc , uv_fs_cb after , Func fn , Args ... fn_args ) { return AsyncDestCall ( env , req_wrap , args , syscall , nullptr , 0 , enc , after , fn , fn_args ...); } AsyncCall\u662f\u5bf9AsyncDestCall\u7684\u5c01\u88c5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template < typename Func , typename ... Args > FSReqBase * AsyncDestCall ( Environment * env , FSReqBase * req_wrap , const v8 :: FunctionCallbackInfo < v8 :: Value >& args , const char * syscall , const char * dest , size_t len , enum encoding enc , uv_fs_cb after , Func fn , Args ... fn_args ) { CHECK_NOT_NULL ( req_wrap ); req_wrap -> Init ( syscall , dest , len , enc ); // \u8c03\u7528libuv\u51fd\u6570 int err = req_wrap -> Dispatch ( fn , fn_args ..., after ); // \u5931\u8d25\u5219\u76f4\u63a5\u6267\u884c\u56de\u8c03\uff0c\u5426\u5219\u8fd4\u56de\u4e00\u4e2aPromise\uff0c\u89c1SetReturnValue\u51fd\u6570 if ( err < 0 ) { uv_fs_t * uv_req = req_wrap -> req (); uv_req -> result = err ; uv_req -> path = nullptr ; after ( uv_req ); // after may delete req_wrap if there is an error req_wrap = nullptr ; } else { req_wrap -> SetReturnValue ( args ); } return req_wrap ; } AsyncDestCall\u51fd\u6570\u4e3b\u8981\u505a\u4e86\u4e24\u4e2a\u64cd\u4f5c\uff0c\u9996\u5148\u901a\u8fc7Dispatch\u8c03\u7528\u5e95\u5c42Libuv\u7684\u51fd\u6570\uff0c\u6bd4\u5982\u8fd9\u91cc\u662fuv_fs_read\u3002\u5982\u679c\u51fa\u9519\u6267\u884c\u56de\u8c03\u8fd4\u56de\u9519\u8bef\uff0c\u5426\u5219\u6267\u884creq_wrap->SetReturnValue(args)\u3002\u6211\u4eec\u77e5\u9053req_wrap\u662f\u5728GetReqWrap\u51fd\u6570\u4e2d\u7531FSReqPromise ::New(env, use_bigint)\u521b\u5efa\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template < typename AliasedBufferT > FSReqPromise < AliasedBufferT >* FSReqPromise < AliasedBufferT >:: New ( Environment * env , bool use_bigint ) { v8 :: Local < v8 :: Object > obj ; // \u521b\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\u5b58\u5230obj\u4e2d if ( ! env -> fsreqpromise_constructor_template () -> NewInstance ( env -> context ()) . ToLocal ( & obj )) { return nullptr ; } // \u8bbe\u7f6e\u4e00\u4e2apromise\u5c5e\u6027\uff0c\u503c\u662f\u4e00\u4e2aPromise::Resolver v8 :: Local < v8 :: Promise :: Resolver > resolver ; if ( ! v8 :: Promise :: Resolver :: New ( env -> context ()). ToLocal ( & resolver ) || obj -> Set ( env -> context (), env -> promise_string (), resolver ). IsNothing ()) { return nullptr ; } // \u8fd4\u56de\u53e6\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u91cc\u9762\u4fdd\u5b58\u4e86obj\uff0cobj\u4e5f\u4fdd\u5b58\u4e86\u6307\u5411FSReqPromise\u5bf9\u8c61\u7684\u6307\u9488 return new FSReqPromise ( env , obj , use_bigint ); } \u6240\u4ee5req_wrap\u662f\u4e00\u4e2aFSReqPromise\u5bf9\u8c61\u3002\u6211\u4eec\u770b\u4e00\u4e0bFSReqPromise\u5bf9\u8c61\u7684SetReturnValue\u65b9\u6cd5\u3002 1 2 3 4 5 6 7 8 9 10 11 template < typename AliasedBufferT > void FSReqPromise < AliasedBufferT >:: SetReturnValue ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ) { // \u62ff\u5230Promise::Resolver\u5bf9\u8c61 v8 :: Local < v8 :: Value > val = object () -> Get ( env () -> context (), env () -> promise_string ()). ToLocalChecked (); v8 :: Local < v8 :: Promise :: Resolver > resolver = val . As < v8 :: Promise :: Resolver > (); // \u62ff\u5230\u4e00\u4e2aPromise\u4f5c\u4e3a\u8fd4\u56de\u503c\uff0c\u5373JS\u5c42\u62ff\u5230\u7684\u503c args . GetReturnValue (). Set ( resolver -> GetPromise ()); } \u81f3\u6b64\u6211\u4eec\u770b\u5230\u4e86\u65b0\u7248API\u5b9e\u73b0\u7684\u6838\u5fc3\u903b\u8f91\uff0c\u6b63\u662f\u8fd9\u4e2aPromise\u8fd4\u56de\u503c\u3002\u901a\u8fc7\u5c42\u5c42\u8fd4\u56de\u540e\uff0c\u5728JS\u5c42\u5c31\u62ff\u5230\u8fd9\u4e2aPromise\uff0c\u7136\u540e\u5904\u4e8epending\u72b6\u6001\u7b49\u5f85\u51b3\u8bae\u3002\u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0bPromise\u51b3\u8bae\u7684\u903b\u8f91\u3002\u5728\u5206\u6790Read\u51fd\u6570\u4e2d\u6211\u4eec\u770b\u5230\u6267\u884cLibuv\u7684uv_fs_read\u51fd\u6570\u65f6\uff0c\u8bbe\u7f6e\u7684\u56de\u8c03\u662fAfterInteger\u3002\u90a3\u4e48\u5f53\u8bfb\u53d6\u6587\u4ef6\u6210\u529f\u540e\u5c31\u4f1a\u6267\u884c\u8be5\u51fd\u6570\u3002\u6240\u4ee5\u6211\u4eec\u770b\u770b\u8be5\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 void AfterInteger ( uv_fs_t * req ) { // \u901a\u8fc7\u5c5e\u6027\u62ff\u5230\u5bf9\u8c61\u7684\u5730\u5740 FSReqBase * req_wrap = FSReqBase :: from_req ( req ); FSReqAfterScope after ( req_wrap , req ); if ( after . Proceed ()) req_wrap -> Resolve ( Integer :: New ( req_wrap -> env () -> isolate (), req -> result )); } \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bResolve 1 2 3 4 5 6 7 8 9 10 11 12 template < typename AliasedBufferT > void FSReqPromise < AliasedBufferT >:: Resolve ( v8 :: Local < v8 :: Value > value ) { finished_ = true ; v8 :: HandleScope scope ( env () -> isolate ()); InternalCallbackScope callback_scope ( this ); // \u62ff\u5230\u4fdd\u5b58\u7684Promise\u5bf9\u8c61\uff0c\u4fee\u6539\u72b6\u6001\u4e3aresolve\uff0c\u5e76\u8bbe\u7f6e\u7ed3\u679c v8 :: Local < v8 :: Value > val = object () -> Get ( env () -> context (), env () -> promise_string ()). ToLocalChecked (); v8 :: Local < v8 :: Promise :: Resolver > resolver = val . As < v8 :: Promise :: Resolver > (); USE ( resolver -> Resolve ( env () -> context (), value ). FromJust ()); } Resolve\u51fd\u6570\u4fee\u6539Promise\u7684\u72b6\u6001\u548c\u8bbe\u7f6e\u8fd4\u56de\u503c\uff0c\u4ece\u800cJS\u5c42\u62ff\u5230\u8fd9\u4e2a\u51b3\u8bae\u7684\u503c\u3002\u56de\u5230fs\u5c42 1 2 3 4 5 const bytesRead = ( await binding . read ( handle . fd , buffer , offset , length , position , kUsePromises )) | 0 ; \u6211\u4eec\u5c31\u62ff\u5230\u4e86\u8fd4\u56de\u503c\u3002 12.5 \u6d41\u5f0fAPI \u00b6 \u524d\u9762\u5206\u6790\u4e86Node.js\u4e2d\u6587\u4ef6\u6a21\u5757\u7684\u591a\u79cd\u6587\u4ef6\u64cd\u4f5c\u7684\u65b9\u5f0f\uff0c\u4e0d\u7ba1\u662f\u540c\u6b65\u3001\u5f02\u6b65\u8fd8\u662fPromise\u5316\u7684API\uff0c\u5b83\u4eec\u90fd\u6709\u4e00\u4e2a\u95ee\u9898\u5c31\u662f\u5bf9\u4e8e\u7528\u6237\u6765\u8bf4\uff0c\u6587\u4ef6\u64cd\u4f5c\u90fd\u662f\u4e00\u6b21\u6027\u5b8c\u6210\u7684\uff0c\u6bd4\u5982\u6211\u4eec\u8c03\u7528readFile\u8bfb\u53d6\u4e00\u4e2a\u6587\u4ef6\u65f6\uff0cNode.js\u4f1a\u901a\u8fc7\u4e00\u6b21\u6216\u591a\u6b21\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u63a5\u53e3\u628a\u6240\u6709\u7684\u6587\u4ef6\u5185\u5bb9\u8bfb\u5230\u5185\u5b58\u4e2d\uff0c\u540c\u6837\u6211\u4eec\u8c03\u7528writeFile\u5199\u4e00\u4e2a\u6587\u4ef6\u65f6\uff0cNode.js\u4f1a\u901a\u8fc7\u4e00\u6b21\u6216\u591a\u6b21\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63a5\u53e3\u628a\u7528\u6237\u7684\u6570\u636e\u5199\u5165\u786c\u76d8\uff0c\u8fd9\u5bf9\u5185\u5b58\u6765\u8bf4\u662f\u975e\u5e38\u6709\u538b\u529b\u7684\u3002\u5047\u8bbe\u6211\u4eec\u6709\u8fd9\u6837\u7684\u4e00\u4e2a\u573a\u666f\uff0c\u6211\u4eec\u9700\u8981\u8bfb\u53d6\u4e00\u4e2a\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u7136\u540e\u8fd4\u56de\u7ed9\u524d\u7aef\uff0c\u5982\u679c\u6211\u4eec\u76f4\u63a5\u8bfb\u53d6\u6574\u4e2a\u6587\u4ef6\u5185\u5bb9\uff0c\u7136\u540e\u518d\u6267\u884c\u5199\u64cd\u4f5c\u8fd9\u65e0\u7591\u662f\u975e\u5e38\u6d88\u8017\u5185\u5b58\uff0c\u4e5f\u662f\u975e\u5e38\u4f4e\u6548\u7684\u3002 1 2 3 4 5 6 7 const http = require ( 'http' ); const fs = require ( 'fs' ); const server = http . createServer (( req , res ) => { fs . readFile ( '11111.md' , ( err , data ) => { res . end ( data ); }) }). listen ( 11111 ); \u8fd9\u65f6\u5019\u6211\u4eec\u9700\u8981\u4f7f\u7528\u6d41\u5f0f\u7684API\u3002 1 2 3 4 5 const http = require ( 'http' ); const fs = require ( 'fs' ); const server = http . createServer (( req , res ) => { fs . createReadStream ( '11111.md' ). pipe ( res ); }). listen ( 11111 ); \u6d41\u5f0fAPI\u7684\u597d\u5904\u5728\u4e8e\u6587\u4ef6\u7684\u5185\u5bb9\u5e76\u4e0d\u662f\u4e00\u6b21\u6027\u8bfb\u53d6\u5230\u5185\u5b58\u7684\uff0c\u800c\u662f\u90e8\u5206\u8bfb\u53d6\uff0c\u6d88\u8d39\u5b8c\u540e\u518d\u7ee7\u7eed\u8bfb\u53d6\u3002Node.js\u5185\u90e8\u5e2e\u6211\u4eec\u505a\u4e86\u6d41\u91cf\u7684\u63a7\u5236\uff0c\u5982\u56fe12-5\u6240\u793a\u3002 \u56fe12-5 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u6d41\u5f0fAPI\u7684\u5177\u4f53\u5b9e\u73b0\u3002 12.5.1 \u53ef\u8bfb\u6587\u4ef6\u6d41 \u00b6 \u53ef\u8bfb\u6587\u4ef6\u6d41\u662f\u5bf9\u6587\u4ef6\u8fdb\u884c\u6d41\u5f0f\u8bfb\u53d6\u7684\u62bd\u8c61\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7fs.createReadStream\u521b\u5efa\u4e00\u4e2a\u6587\u4ef6\u53ef\u8bfb\u6d41\u3002\u6587\u4ef6\u53ef\u8bfb\u6d41\u7ee7\u627f\u4e8e\u53ef\u8bfb\u6d41\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4ee5\u53ef\u8bfb\u6d41\u7684\u65b9\u5f0f\u4f7f\u7528\u5b83\u3002 1 2 3 4 5 6 7 8 9 const fs = require ( 'fs' ); const { Writable } = require ( 'stream' ); class DemoWritable extends Writable { _write ( data , encoding , cb ) { console . log ( data ); cb ( null ); } } fs . createReadStream ( '11111.md' ). pipe ( new DemoWritable ); \u6216\u8005 1 2 3 4 5 const fs = require ( 'fs' ); const readStream = fs . createReadStream ( '11111.md' ); readStream . on ( 'data' , ( data ) => { console . log ( data ) }); \u6211\u4eec\u770b\u4e00\u4e0bcreateReadStream\u7684\u5b9e\u73b0\u3002 1 2 3 fs . createReadStream = function ( path , options ) { return new ReadStream ( path , options ); }; CreateReadStream\u662f\u5bf9ReadStream\u7684\u5c01\u88c5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 function ReadStream ( path , options ) { if ( ! ( this instanceof ReadStream )) return new ReadStream ( path , options ); options = copyObject ( getOptions ( options , {})); // \u53ef\u8bfb\u6d41\u7684\u9608\u503c if ( options . highWaterMark === undefined ) options . highWaterMark = 64 * 1024 ; Readable . call ( this , options ); handleError (( this . path = getPathFromURL ( path ))); // \u652f\u6301\u4f20\u6587\u4ef6\u8def\u5f84\u6216\u6587\u4ef6\u63cf\u8ff0\u7b26 this . fd = options . fd === undefined ? null : options . fd ; this . flags = options . flags === undefined ? 'r' : options . flags ; this . mode = options . mode === undefined ? 0o666 : options . mode ; // \u8bfb\u53d6\u7684\u5f00\u59cb\u548c\u7ed3\u675f\u4f4d\u7f6e this . start = typeof this . fd !== 'number' && options . start === undefined ? 0 : options . start ; this . end = options . end ; // \u6d41\u51fa\u9519\u6216\u7ed3\u675f\u65f6\u662f\u5426\u81ea\u52a8\u9500\u6bc1\u6d41 this . autoClose = options . autoClose === undefined ? true : options . autoClose ; this . pos = undefined ; // \u5df2\u8bfb\u7684\u5b57\u8282\u6570 this . bytesRead = 0 ; // \u6d41\u662f\u5426\u5df2\u7ecf\u5173\u95ed this . closed = false ; // \u53c2\u6570\u6821\u9a8c if ( this . start !== undefined ) { if ( typeof this . start !== 'number' ) { throw new errors . TypeError ( 'ERR_INVALID_ARG_TYPE' , 'start' , 'number' , this . start ); } // \u9ed8\u8ba4\u8bfb\u53d6\u5168\u90e8\u5185\u5bb9 if ( this . end === undefined ) { this . end = Infinity ; } else if ( typeof this . end !== 'number' ) { throw new errors . TypeError ( 'ERR_INVALID_ARG_TYPE' , 'end' , 'number' , this . end ); } // \u4ece\u6587\u4ef6\u7684\u54ea\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u8bfb\uff0cstart\u662f\u5f00\u59cb\u4f4d\u7f6e\uff0cpos\u662f\u5f53\u524d\u4f4d\u7f6e\uff0c\u521d\u59cb\u5316\u7b49\u4e8e\u5f00\u59cb\u4f4d\u7f6e this . pos = this . start ; } // \u5982\u679c\u662f\u6839\u636e\u4e00\u4e2a\u6587\u4ef6\u540d\u521b\u5efa\u4e00\u4e2a\u6d41\uff0c\u5219\u9996\u5148\u6253\u5f00\u8fd9\u4e2a\u6587\u4ef6 if ( typeof this . fd !== 'number' ) this . open (); this . on ( 'end' , function () { // \u6d41\u7ed3\u675f\u65f6\u81ea\u52a8\u9500\u6bc1\u6d41 if ( this . autoClose ) { this . destroy (); } }); } ReadStream\u521d\u59cb\u5316\u5b8c\u540e\u505a\u4e86\u4e24\u4e2a\u64cd\u4f5c\uff0c\u9996\u5148\u8c03\u7528open\u6253\u5f00\u6587\u4ef6\uff08\u5982\u679c\u9700\u8981\u7684\u8bdd\uff09\uff0c\u63a5\u7740\u76d1\u542c\u6d41\u7ed3\u675f\u4e8b\u4ef6\uff0c\u7528\u6237\u53ef\u4ee5\u8bbe\u7f6eautoClose\u9009\u9879\u63a7\u5236\u5f53\u6d41\u7ed3\u675f\u6216\u8005\u51fa\u9519\u65f6\u662f\u5426\u9500\u6bc1\u6d41\uff0c\u5bf9\u4e8e\u6587\u4ef6\u6d41\u6765\u8bf4\uff0c\u9500\u6bc1\u6d41\u610f\u5473\u7740\u5173\u95ed\u5730\u65b9\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u6211\u4eec\u63a5\u7740\u770b\u4e00\u4e0bopen\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // \u6253\u5f00\u6587\u4ef6 ReadStream . prototype . open = function () { var self = this ; fs . open ( this . path , this . flags , this . mode , function ( er , fd ) { if ( er ) { // \u53d1\u751f\u9519\u8bef\uff0c\u662f\u5426\u9700\u8981\u81ea\u52a8\u9500\u6bc1\u6d41 if ( self . autoClose ) { self . destroy (); } // \u901a\u77e5\u7528\u6237 self . emit ( 'error' , er ); return ; } self . fd = fd ; // \u89e6\u53d1open\uff0c\u4e00\u822c\u7528\u4e8eNode.js\u5185\u90e8\u903b\u8f91 self . emit ( 'open' , fd ); // start the flow of data. // \u6253\u5f00\u6210\u529f\u540e\u5f00\u59cb\u6d41\u5f0f\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9 self . read (); }); }; open\u51fd\u6570\u9996\u5148\u6253\u5f00\u6587\u4ef6\uff0c\u6253\u5f00\u6210\u529f\u540e\u5f00\u542f\u6d41\u5f0f\u8bfb\u53d6\u3002\u4ece\u800c\u6587\u4ef6\u5185\u5bb9\u5c31\u4f1a\u6e90\u6e90\u4e0d\u65ad\u5730\u6d41\u5411\u76ee\u7684\u6d41\u3002\u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0b\u8bfb\u53d6\u64cd\u4f5c\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // \u5b9e\u73b0\u53ef\u8bfb\u6d41\u7684\u94a9\u5b50\u51fd\u6570 ReadStream . prototype . _read = function ( n ) { // \u5982\u679c\u6ca1\u6709\u8c03\u7528open\u800c\u662f\u76f4\u63a5\u8c03\u7528\u8be5\u65b9\u6cd5\u5219\u5148\u6267\u884copen if ( typeof this . fd !== 'number' ) { return this . once ( 'open' , function () { this . _read ( n ); }); } // \u6d41\u5df2\u7ecf\u9500\u6bc1\u5219\u4e0d\u5904\u7406 if ( this . destroyed ) return ; // \u5224\u65ad\u6c60\u5b50\u7a7a\u95f4\u662f\u5426\u8db3\u591f\uff0c\u4e0d\u591f\u5219\u7533\u8bf7\u65b0\u7684 if ( ! pool || pool . length - pool . used < kMinPoolSpace ) { // discard the old pool. allocNewPool ( this . readableHighWaterMark ); } // \u8ba1\u7b97\u53ef\u8bfb\u7684\u6700\u5927\u6570\u91cf var thisPool = pool ; /* \u53ef\u8bfb\u53d6\u7684\u6700\u5927\u503c,\u53d6\u53ef\u7528\u5185\u5b58\u5927\u5c0f\u548cNode.js\u6253\u7b97\u8bfb\u53d6\u7684\u5927\u5c0f \u4e2d\u7684\u5c0f\u503c,n\u4e0d\u662f\u7528\u6237\u60f3\u8bfb\u53d6\u7684\u5927\u5c0f\uff0c\u800c\u662f\u53ef\u8bfb\u6d41\u5185\u90e8\u7684\u903b\u8f91 \u89c1_stream_readable.js\u7684this._read(state.highWaterMark) */ var toRead = Math . min ( pool . length - pool . used , n ); var start = pool . used ; // \u5df2\u7ecf\u8bfb\u53d6\u4e86\u90e8\u5206\u4e86\uff0c\u5219\u8ba1\u7b97\u5269\u4e0b\u8bfb\u53d6\u7684\u5927\u5c0f\uff0c\u548c\u8ba1\u7b97\u8bfb\u53d6\u7684toRead\u6bd4\u8f83\u53d6\u5c0f\u503c if ( this . pos !== undefined ) toRead = Math . min ( this . end - this . pos + 1 , toRead ); // \u8bfb\u7ed3\u675f if ( toRead <= 0 ) return this . push ( null ); // pool.used\u662f\u5373\u5c06\u8bfb\u53d6\u7684\u6570\u636e\u5b58\u50a8\u5728pool\u4e2d\u7684\u5f00\u59cb\u4f4d\u7f6e\uff0cthis.pos\u662f\u4ece\u6587\u4ef6\u7684\u54ea\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u8bfb\u53d6 fs . read ( this . fd , pool , pool . used , toRead , this . pos , ( er , bytesRead ) => { if ( er ) { if ( this . autoClose ) { this . destroy (); } this . emit ( 'error' , er ); } else { var b = null ; if ( bytesRead > 0 ) { // \u5df2\u8bfb\u7684\u5b57\u8282\u6570\u7d2f\u52a0 this . bytesRead += bytesRead ; // \u83b7\u53d6\u6709\u6548\u6570\u636e b = thisPool . slice ( start , start + bytesRead ); } // push\u5230\u5e95\u5c42\u6d41\u7684bufferList\u4e2d\uff0c\u5e95\u5c42\u7684push\u4f1a\u89e6\u53d1data\u4e8b\u4ef6 this . push ( b ); } }); // \u91cd\u65b0\u8bbe\u7f6e\u5df2\u8bfb\u6307\u9488\u7684\u4f4d\u7f6e if ( this . pos !== undefined ) this . pos += toRead ; pool . used += toRead ; }; \u4ee3\u7801\u770b\u8d77\u6765\u5f88\u591a\uff0c\u4e3b\u8981\u7684\u903b\u8f91\u662f\u8c03\u7528\u5f02\u6b65read\u51fd\u6570\u8bfb\u53d6\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u7136\u540e\u653e\u5230\u53ef\u8bfb\u6d41\u4e2d\uff0c\u53ef\u8bfb\u6d41\u4f1a\u89e6\u53d1data\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u6709\u6570\u636e\u5230\u6765\uff0c\u7136\u540e\u7ee7\u7eed\u6267\u884cread\u51fd\u6570\uff0c\u4ece\u800c\u4e0d\u65ad\u9a71\u52a8\u7740\u6570\u636e\u7684\u8bfb\u53d6\uff08\u53ef\u8bfb\u6d41\u4f1a\u6839\u636e\u5f53\u524d\u60c5\u51b5\u5224\u65ad\u662f\u5426\u7ee7\u7eed\u6267\u884cread\u51fd\u6570\uff0c\u4ee5\u8fbe\u5230\u6d41\u91cf\u63a7\u5236\u7684\u76ee\u7684\uff09\u3002\u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u5173\u95ed\u548c\u9500\u6bc1\u4e00\u4e2a\u6587\u4ef6\u6d41\u7684\u5b9e\u73b0\u3002 1 2 3 ReadStream.prototype.close = function(cb) { this.destroy(null, cb); }; \u5f53\u6211\u4eec\u8bbe\u7f6eautoClose\u4e3afalse\u7684\u65f6\u5019\uff0c\u6211\u4eec\u5c31\u9700\u8981\u81ea\u5df1\u624b\u52a8\u8c03\u7528close\u51fd\u6570\u5173\u95ed\u53ef\u8bfb\u6587\u4ef6\u6d41\u3002\u5173\u95ed\u6587\u4ef6\u6d41\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u6b63\u5e38\u5730\u9500\u6bc1\u6d41\u3002\u6211\u4eec\u770b\u770b\u9500\u6bc1\u6d41\u7684\u65f6\u5019\uff0cNode.js\u505a\u4e86\u4ec0\u4e48\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // \u5173\u95ed\u5e95\u5c42\u6587\u4ef6 ReadStream . prototype . _destroy = function ( err , cb ) { const isOpen = typeof this . fd !== 'number' ; if ( isOpen ) { this . once ( 'open' , closeFsStream . bind ( null , this , cb , err )); return ; } closeFsStream ( this , cb ); this . fd = null ; }; function closeFsStream ( stream , cb , err ) { fs . close ( stream . fd , ( er ) => { er = er || err ; cb ( er ); stream . closed = true ; if ( ! er ) stream . emit ( 'close' ); }); } \u9500\u6bc1\u6587\u4ef6\u6d41\u5c31\u662f\u5173\u95ed\u5e95\u5c42\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u53e6\u5916\u5982\u679c\u662f\u56e0\u4e3a\u53d1\u751f\u9519\u8bef\u5bfc\u81f4\u9500\u6bc1\u6216\u8005\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u9519\u8bef\u5219\u4e0d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u3002 12.5.2 \u53ef\u5199\u6587\u4ef6\u6d41 \u00b6 \u53ef\u5199\u6587\u4ef6\u6d41\u662f\u5bf9\u6587\u4ef6\u8fdb\u884c\u6d41\u5f0f\u5199\u5165\u7684\u62bd\u8c61\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7fs.createWriteStream\u521b\u5efa\u4e00\u4e2a\u6587\u4ef6\u53ef\u5199\u6d41\u3002\u6587\u4ef6\u53ef\u4e9b\u6d41\u7ee7\u627f\u4e8e\u53ef\u5199\u6d41\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4ee5\u53ef\u5199\u6d41\u7684\u65b9\u5f0f\u4f7f\u7528\u5b83\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const fs = require ( 'fs' ); const writeStream = fs . createWriteStream ( '123.md' ); writeStream . end ( 'world' ); // \u6216\u8005 const fs = require ( 'fs' ); const { Readable } = require ( 'stream' ); class DemoReadStream extends Readable { constructor () { super (); this . i = 0 ; } _read ( n ) { this . i ++ ; if ( this . i > 10 ) { this . push ( null ); } else { this . push ( '1' . repeat ( n )); } } } new DemoReadStream (). pipe ( fs . createWriteStream ( '123.md' )); \u6211\u4eec\u770b\u4e00\u4e0bcreateWriteStream\u7684\u5b9e\u73b0\u3002 1 2 3 fs . createWriteStream = function ( path , options ) { return new WriteStream ( path , options ); }; createWriteStream\u662f\u5bf9WriteStream\u7684\u5c01\u88c5\uff0c\u6211\u4eec\u770b\u4e00\u4e0bWriteStream\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 function WriteStream ( path , options ) { if ( ! ( this instanceof WriteStream )) return new WriteStream ( path , options ); options = copyObject ( getOptions ( options , {})); Writable . call ( this , options ); handleError (( this . path = getPathFromURL ( path ))); this . fd = options . fd === undefined ? null : options . fd ; this . flags = options . flags === undefined ? 'w' : options . flags ; this . mode = options . mode === undefined ? 0o666 : options . mode ; // \u5199\u5165\u7684\u5f00\u59cb\u4f4d\u7f6e this . start = options . start ; // \u6d41\u7ed3\u675f\u548c\u89e6\u53d1\u9519\u8bef\u7684\u65f6\u5019\u662f\u5426\u9500\u6bc1\u6d41 this . autoClose = options . autoClose === undefined ? true : !! options . autoClose ; // \u5f53\u524d\u5199\u5165\u4f4d\u7f6e this . pos = undefined ; // \u5199\u6210\u529f\u7684\u5b57\u8282\u6570 this . bytesWritten = 0 ; this . closed = false ; if ( this . start !== undefined ) { if ( typeof this . start !== 'number' ) { throw new errors . TypeError ( 'ERR_INVALID_ARG_TYPE' , 'start' , 'number' , this . start ); } if ( this . start < 0 ) { const errVal = `{start: ${ this . start } }` ; throw new errors . RangeError ( 'ERR_OUT_OF_RANGE' , 'start' , '>= 0' , errVal ); } // \u8bb0\u5f55\u5199\u5165\u7684\u5f00\u59cb\u4f4d\u7f6e this . pos = this . start ; } if ( options . encoding ) this . setDefaultEncoding ( options . encoding ); // \u6ca1\u6709\u4f20\u6587\u4ef6\u63cf\u8ff0\u7b26\u5219\u6253\u5f00\u4e00\u4e2a\u65b0\u7684\u6587\u4ef6 if ( typeof this . fd !== 'number' ) this . open (); // \u76d1\u542c\u53ef\u5199\u6d41\u7684finish\u4e8b\u4ef6\uff0c\u5224\u65ad\u662f\u5426\u9700\u8981\u6267\u884c\u9500\u6bc1\u64cd\u4f5c this . once ( 'finish' , function () { if ( this . autoClose ) { this . destroy (); } }); } WriteStream\u521d\u59cb\u5316\u4e86\u4e00\u7cfb\u5217\u5b57\u6bb5\u540e\uff0c\u5982\u679c\u4f20\u7684\u662f\u6587\u4ef6\u8def\u5f84\u5219\u6253\u5f00\u6587\u4ef6\uff0c\u5982\u679c\u4f20\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5219\u4e0d\u9700\u8981\u518d\u6b21\u6253\u5f00\u6587\u4ef6\u3002\u540e\u7eed\u5bf9\u6587\u4ef6\u53ef\u5199\u6d41\u7684\u64cd\u4f5c\u5c31\u662f\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u64cd\u4f5c\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5199\u5165\u6587\u4ef6\u7684\u903b\u8f91\u3002\u6211\u4eec\u77e5\u9053\u53ef\u5199\u6d41\u53ea\u662f\u5b9e\u73b0\u4e86\u4e00\u4e9b\u62bd\u8c61\u7684\u903b\u8f91\uff0c\u5177\u4f53\u7684\u5199\u903b\u8f91\u662f\u5177\u4f53\u7684\u6d41\u901a\u8fc7_write\u6216\u8005_writev\u5b9e\u73b0\u7684\uff0c\u6211\u4eec\u770b\u4e00\u4e0b_write\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 WriteStream . prototype . _write = function ( data , encoding , cb ) { if ( ! ( data instanceof Buffer )) { const err = new errors . TypeError ( 'ERR_INVALID_ARG_TYPE' , 'data' , 'Buffer' , data ); return this . emit ( 'error' , err ); } // \u8fd8\u6ca1\u6253\u5f00\u6587\u4ef6\uff0c\u5219\u7b49\u5f85\u6253\u5f00\u6210\u529f\u540e\u518d\u6267\u884c\u5199\u64cd\u4f5c if ( typeof this . fd !== 'number' ) { return this . once ( 'open' , function () { this . _write ( data , encoding , cb ); }); } // \u6267\u884c\u5199\u64cd\u4f5c,0\u4ee3\u8868\u4ecedata\u7684\u54ea\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u5199\uff0c\u8fd9\u91cc\u662f\u5168\u90e8\u5199\u5165\uff0c\u6240\u4ee5\u662f0\uff0cpos\u4ee3\u8868\u6587\u4ef6\u7684\u4f4d\u7f6e fs . write ( this . fd , data , 0 , data . length , this . pos , ( er , bytes ) => { if ( er ) { if ( this . autoClose ) { this . destroy (); } return cb ( er ); } // \u5199\u5165\u6210\u529f\u7684\u5b57\u8282\u957f\u5ea6 this . bytesWritten += bytes ; cb (); }); // \u4e0b\u4e00\u4e2a\u5199\u5165\u7684\u4f4d\u7f6e if ( this . pos !== undefined ) this . pos += data . length ; }; _write\u5c31\u662f\u6839\u636e\u7528\u6237\u4f20\u5165\u6570\u636e\u7684\u5927\u5c0f\uff0c\u4e0d\u65ad\u8c03\u7528fs.write\u5f80\u5e95\u5c42\u5199\u5165\u6570\u636e\uff0c\u76f4\u5230\u5199\u5b8c\u6210\u6216\u8005\u51fa\u9519\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u6279\u91cf\u5199\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // \u5b9e\u73b0\u53ef\u5199\u6d41\u6279\u91cf\u5199\u94a9\u5b50 WriteStream . prototype . _writev = function ( data , cb ) { if ( typeof this . fd !== 'number' ) { return this . once ( 'open' , function () { this . _writev ( data , cb ); }); } const self = this ; const len = data . length ; const chunks = new Array ( len ); var size = 0 ; // \u8ba1\u7b97\u5f85\u5199\u5165\u7684\u51fa\u603b\u5927\u5c0f\uff0c\u5e76\u4e14\u628a\u6570\u636e\u4fdd\u5b58\u5230chunk\u6570\u7ec4\u4e2d\uff0c\u51c6\u5907\u5199\u5165 for ( var i = 0 ; i < len ; i ++ ) { var chunk = data [ i ]. chunk ; chunks [ i ] = chunk ; size += chunk . length ; } // \u6267\u884c\u6279\u91cf\u5199 writev ( this . fd , chunks , this . pos , function ( er , bytes ) { if ( er ) { self . destroy (); return cb ( er ); } // \u5199\u6210\u529f\u7684\u5b57\u8282\u6570\uff0c\u53ef\u80fd\u5c0f\u4e8e\u5e0c\u671b\u5199\u5165\u7684\u5b57\u8282\u6570 self . bytesWritten += bytes ; cb (); }); /* \u66f4\u65b0\u4e0b\u4e00\u4e2a\u5199\u5165\u4f4d\u7f6e\uff0c\u5982\u679c\u5199\u90e8\u5206\u6210\u529f\uff0c\u8ba1\u7b97\u4e0b\u4e00\u4e2a\u5199\u5165\u4f4d\u7f6e\u65f6 \u4e5f\u4f1a\u5305\u62ec\u6ca1\u5199\u6210\u529f\u7684\u5b57\u8282\u6570\uff0c\u6240\u4ee5\u662f\u5047\u8bbesize\u800c\u4e0d\u662fbytes */ if ( this . pos !== undefined ) this . pos += size ; }; \u6279\u91cf\u5199\u5165\u7684\u903b\u8f91\u548c_write\u7c7b\u4f3c\uff0c\u53ea\u4e0d\u8fc7\u5b83\u8c03\u7528\u7684\u662f\u4e0d\u540c\u7684\u63a5\u53e3\u5f80\u5e95\u5c42\u5199\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u5173\u95ed\u6587\u4ef6\u53ef\u5199\u6d41\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 WriteStream . prototype . close = function ( cb ) { // \u5173\u95ed\u6587\u4ef6\u6210\u529f\u540e\u6267\u884c\u7684\u56de\u8c03 if ( cb ) { if ( this . closed ) { process . nextTick ( cb ); return ; } else { this . on ( 'close' , cb ); } } /* \u5982\u679cautoClose\u662ffalse\uff0c\u8bf4\u660e\u6d41\u7ed3\u675f\u89e6\u53d1finish\u4e8b\u4ef6\u65f6\uff0c\u4e0d\u4f1a\u9500\u6bc1\u6d41\uff0c \u89c1WriteStream\u521d\u59cb\u5316\u4ee3\u7801 \u4ee5\u8fd9\u91cc\u9700\u8981\u76d1\u542cfinish\u4e8b\u4ef6\uff0c\u4fdd\u8bc1\u53ef\u5199\u6d41\u7ed3\u675f\u65f6\u53ef\u4ee5\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26 */ if ( ! this . autoClose ) { this . on ( 'finish' , this . destroy . bind ( this )); } // \u7ed3\u675f\u6d41\uff0c\u4f1a\u89e6\u53d1finish\u4e8b\u4ef6 this . end (); }; \u53ef\u5199\u6587\u4ef6\u6d41\u548c\u53ef\u8bfb\u6587\u4ef6\u6d41\u4e0d\u4e00\u6837\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u53ef\u8bfb\u6d41\u5728\u8bfb\u5b8c\u6587\u4ef6\u5185\u5bb9\u540eNode.js\u4f1a\u81ea\u52a8\u9500\u6bc1\u6d41\uff08\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\uff09\uff0c\u800c\u5199\u5165\u6587\u4ef6\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0bNode.js\u662f\u65e0\u6cd5\u77e5\u9053\u4ec0\u4e48\u65f6\u5019\u6d41\u7ed3\u675f\u7684\uff0c\u8fd9\u9700\u8981\u6211\u4eec\u663e\u5f0f\u5730\u901a\u77e5Node.js\u3002\u5728\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u662f\u4e0d\u9700\u8981\u663e\u5f0f\u901a\u77e5Node.js\u7684 fs.createReadStream('11111.md').pipe(fs.createWriteStream('123.md')); \u56e0\u4e3a\u53ef\u8bfb\u6587\u4ef6\u6d41\u5728\u6587\u4ef6\u8bfb\u5b8c\u540e\u4f1a\u8c03\u7528\u53ef\u5199\u6587\u4ef6\u7684end\u65b9\u6cd5\uff0c\u4ece\u800c\u5173\u95ed\u53ef\u8bfb\u6d41\u548c\u53ef\u5199\u6d41\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u800c\u5728\u4ee5\u4e0b\u4ee3\u7801\u4e2d\u60c5\u51b5\u5c31\u53d8\u5f97\u590d\u6742\u3002 1 2 3 const stream = fs . createWriteStream ( '123.md' ); stream . write ( 'hello' ); // stream.close \u6216 stream.end(); \u5728\u9ed8\u8ba4\u60c5\u51b5\uff0c\u6211\u4eec\u53ef\u4ee5\u8c03\u7528end\u6216\u8005close\u53bb\u901a\u77e5Node.js\u6d41\u7ed3\u675f\u3002\u4f46\u662f\u5982\u679c\u6211\u4eec\u8bbe\u7f6e\u4e86autoClose\u4e3afalse\uff0c\u90a3\u4e48\u6211\u4eec\u53ea\u80fd\u8c03\u7528close\u800c\u4e0d\u80fd\u8c03\u7528end\u3002\u5426\u5219\u4f1a\u9020\u6210\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\u3002\u56e0\u4e3aend\u53ea\u662f\u5173\u95ed\u4e86\u6d41\u3002\u4f46\u662f\u6ca1\u6709\u89e6\u53d1\u9500\u6bc1\u6d41\u7684\u903b\u8f91\u3002\u800cclose\u4f1a\u89e6\u53d1\u9500\u6bc1\u6d41\u7684\u903b\u8f91\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u4ee3\u7801\u3002 1 2 3 4 5 const fs = require ( 'fs' ); const stream = fs . createWriteStream ( '123.md' ); stream . write ( 'hello' ); // \u9632\u6b62\u8fdb\u7a0b\u9000\u51fa setInterval (() => {}); \u4ee5\u4e0a\u4ee3\u7801\u4f1a\u5bfc\u81f4\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\uff0c\u6211\u4eec\u5728Linux\u4e0b\u6267\u884c\u4ee5\u4e0b\u4ee3\u7801\uff0c\u901a\u8fc7ps aux\u627e\u5230\u8fdb\u7a0bid\uff0c\u7136\u540e\u6267\u884clsof -p pid\u5c31\u53ef\u4ee5\u770b\u5230\u8fdb\u7a0b\u6253\u5f00\u7684\u6240\u6709\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u8f93\u51fa\u598212-6\u6240\u793a\u3002 \u56fe12-6 \u6587\u4ef6\u63cf\u8ff0\u7b2617\u6307\u5411\u4e86123.md\u6587\u4ef6\u3002\u6240\u4ee5\u6587\u4ef6\u63cf\u8ff0\u7b26\u6ca1\u6709\u88ab\u5173\u95ed\uff0c\u5f15\u8d77\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\u3002\u6211\u4eec\u4fee\u6539\u4e00\u4e0b\u4ee3\u7801\u3002 1 2 3 4 const fs = require ( 'fs' ); const stream = fs . createWriteStream ( '123.md' ); stream . end ( 'hello' ); setInterval (() => {}); \u4e0b\u9762\u662f\u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa\uff0c\u6211\u4eec\u770b\u5230\u6ca1\u6709123.md\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5982\u56fe12-7\u6240\u793a\u3002 \u56fe12-7 \u6211\u4eec\u7ee7\u7eed\u4fee\u6539\u4ee3\u7801 1 2 3 4 const fs = require ( 'fs' ); const stream = fs . createWriteStream ( '123.md' , { autoClose : false }); stream . end ( 'hello' ); setInterval (() => {}); \u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa\u5982\u56fe12-8\u6240\u793a\u3002 \u56fe12-8 \u6211\u4eec\u770b\u5230\u4f7f\u7528end\u4e5f\u65e0\u6cd5\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u7ee7\u7eed\u4fee\u6539\u3002 1 2 3 4 const fs = require ( 'fs' ); const stream = fs . createWriteStream ( '123.md' , { autoClose : false }) stream . close (); setInterval (() => {}); \u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa\u5982\u56fe12-9\u6240\u793a\u3002 \u56fe12-9 \u6211\u4eec\u770b\u5230\u6210\u529f\u5173\u95ed\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002","title":"12-\u6587\u4ef6"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#121-api","text":"\u5728Node.js\u4e2d\uff0c\u540c\u6b65API\u7684\u672c\u8d28\u662f\u76f4\u63a5\u5728\u4e3b\u7ebf\u7a0b\u91cc\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\u7cfb\u7edf\u8c03\u7528\u3002\u4e0b\u9762\u4ee5readFileSync\u4e3a\u4f8b\uff0c\u770b\u4e00\u4e0b\u6574\u4f53\u7684\u6d41\u7a0b\uff0c\u5982\u56fe12-1\u6240\u793a\u3002 \u56fe12-1 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 function readFileSync ( path , options ) { options = getOptions ( options , { flag : 'r' }); // \u4f20\u7684\u662ffd\u8fd8\u662f\u6587\u4ef6\u8def\u5f84 const isUserFd = isFd ( path ); // \u4f20\u7684\u662f\u8def\u5f84\uff0c\u5219\u5148\u540c\u6b65\u6253\u5f00\u6587\u4ef6 const fd = isUserFd ? path : fs . openSync ( path , options . flag , 0o666 ); // \u67e5\u770b\u6587\u4ef6\u7684stat\u4fe1\u606f\uff0c\u62ff\u5230\u6587\u4ef6\u7684\u5927\u5c0f const stats = tryStatSync ( fd , isUserFd ); // \u662f\u5426\u662f\u4e00\u822c\u6587\u4ef6 const size = isFileType ( stats , S_IFREG ) ? stats [ 8 ] : 0 ; let pos = 0 ; let buffer ; let buffers ; // \u6587\u4ef6\u5927\u5c0f\u662f0\u6216\u8005\u4e0d\u662f\u4e00\u822c\u6587\u4ef6\uff0csize\u5219\u4e3a0 if ( size === 0 ) { buffers = []; } else { // \u4e00\u822c\u6587\u4ef6\u4e14\u6709\u5927\u5c0f\uff0c\u5219\u5206\u914d\u4e00\u4e2a\u5927\u5c0f\u4e3asize\u7684buffer\uff0csize\u9700\u8981\u5c0f\u4e8e2G buffer = tryCreateBuffer ( size , fd , isUserFd ); } let bytesRead ; // \u4e0d\u65ad\u5730\u540c\u6b65\u8bfb\u6587\u4ef6\u5185\u5bb9 if ( size !== 0 ) { do { bytesRead = tryReadSync ( fd , isUserFd , buffer , pos , size - pos ); pos += bytesRead ; } while ( bytesRead !== 0 && pos < size ); } else { do { /* \u6587\u4ef6\u5927\u5c0f\u4e3a0\uff0c\u6216\u8005\u4e0d\u662f\u4e00\u822c\u6587\u4ef6\uff0c\u4e5f\u5c1d\u8bd5\u53bb\u8bfb\uff0c \u4f46\u662f\u56e0\u4e3a\u4e0d\u77e5\u9053\u5927\u5c0f\uff0c\u6240\u4ee5\u53ea\u80fd\u5206\u914d\u4e00\u4e2a\u4e00\u5b9a\u5927\u5c0f\u7684buffer, \u6bcf\u6b21\u8bfb\u53d6\u4e00\u5b9a\u5927\u5c0f\u7684\u5185\u5bb9 */ buffer = Buffer . allocUnsafe ( 8192 ); bytesRead = tryReadSync ( fd , isUserFd , buffer , 0 , 8192 ); // \u628a\u8bfb\u53d6\u5230\u7684\u5185\u5bb9\u653e\u5230buffers\u91cc if ( bytesRead !== 0 ) { buffers . push ( buffer . slice ( 0 , bytesRead )); } // \u8bb0\u5f55\u8bfb\u53d6\u5230\u7684\u6570\u636e\u957f\u5ea6 pos += bytesRead ; } while ( bytesRead !== 0 ); } // \u7528\u6237\u4f20\u7684\u662f\u6587\u4ef6\u8def\u5f84\uff0cNode.js\u81ea\u5df1\u6253\u5f00\u4e86\u6587\u4ef6\uff0c\u6240\u4ee5\u9700\u8981\u81ea\u5df1\u5173\u95ed if ( ! isUserFd ) fs . closeSync ( fd ); // \u6587\u4ef6\u5927\u5c0f\u662f0\u6216\u8005\u975e\u4e00\u822c\u6587\u4ef6\u7684\u8bdd\uff0c\u5982\u679c\u8bfb\u5230\u4e86\u5185\u5bb9 if ( size === 0 ) { // \u628a\u8bfb\u53d6\u5230\u7684\u6240\u6709\u5185\u5bb9\u653e\u5230buffer\u4e2d buffer = Buffer . concat ( buffers , pos ); } else if ( pos < size ) { buffer = buffer . slice ( 0 , pos ); } // \u7f16\u7801 if ( options . encoding ) buffer = buffer . toString ( options . encoding ); return buffer ; } tryReadSync\u8c03\u7528\u7684\u662ffs.readSync\uff0c\u7136\u540e\u5230binding.read(node_file.cc\u4e2d\u5b9a\u4e49\u7684Read\u51fd\u6570)\u3002Read\u51fd\u6570\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 FSReqWrapSync req_wrap_sync ; const int bytesRead = SyncCall ( env , args [ 6 ], & req_wrap_sync , \"read\" , uv_fs_read , fd , & uvbuf , 1 , pos ); \u6211\u4eec\u770b\u4e00\u4e0bSyncCall\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int SyncCall ( Environment * env , v8 :: Local < v8 :: Value > ctx , FSReqWrapSync * req_wrap , const char * syscall , Func fn , Args ... args ) { /* req_wrap->req\u662f\u4e00\u4e2auv_fs_t\u7ed3\u6784\u4f53\uff0c\u5c5e\u4e8erequest\u7c7b\uff0c \u7ba1\u7406\u4e00\u6b21\u6587\u4ef6\u64cd\u4f5c\u7684\u8bf7\u6c42 */ int err = fn ( env -> event_loop (), & ( req_wrap -> req ), args ..., nullptr ); // \u5ffd\u7565\u51fa\u9519\u5904\u7406 return err ; } \u6211\u4eec\u770b\u5230\u6700\u7ec8\u8c03\u7528\u7684\u662fLibuv\u7684uv_fs_read\uff0c\u5e76\u4f7f\u7528uv_fs_t\u7ba1\u7406\u672c\u6b21\u8bf7\u6c42\u3002\u56e0\u4e3a\u662f\u963b\u585e\u5f0f\u8c03\u7528\uff0c\u6240\u4ee5Libuv\u4f1a\u76f4\u63a5\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u7cfb\u7edf\u8c03\u7528read\u51fd\u6570\u3002\u8fd9\u662fNode.js\u4e2d\u540c\u6b65API\u7684\u8fc7\u7a0b\u3002","title":"12.1 \u540c\u6b65API"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#122-api","text":"\u6587\u4ef6\u7cfb\u7edf\u7684API\u4e2d\uff0c\u5f02\u6b65\u7684\u5b9e\u73b0\u662f\u4f9d\u8d56\u4e8eLibuv\u7684\u7ebf\u7a0b\u6c60\u7684\u3002Node.js\u628a\u4efb\u52a1\u653e\u5230\u7ebf\u7a0b\u6c60\uff0c\u7136\u540e\u8fd4\u56de\u4e3b\u7ebf\u7a0b\u7ee7\u7eed\u5904\u7406\u5176\u5b83\u4e8b\u60c5\uff0c\u7b49\u5230\u6761\u4ef6\u6ee1\u8db3\u65f6\uff0c\u5c31\u4f1a\u6267\u884c\u56de\u8c03\u3002\u6211\u4eec\u4ee5readFile\u4e3a\u4f8b\u8bb2\u89e3\u8fd9\u4e2a\u8fc7\u7a0b\u3002\u5f02\u6b65\u8bfb\u53d6\u6587\u4ef6\u7684\u6d41\u7a0b\u56fe\uff0c\u5982\u56fe12-2\u6240\u793a\u3002 \u56fe12-2 \u4e0b\u9762\u6211\u4eec\u770b\u5177\u4f53\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function readFile ( path , options , callback ) { callback = maybeCallback ( callback || options ); options = getOptions ( options , { flag : 'r' }); // \u7ba1\u7406\u6587\u4ef6\u8bfb\u7684\u5bf9\u8c61 if ( ! ReadFileContext ) ReadFileContext = require ( 'internal/fs/read_file_context' ); const context = new ReadFileContext ( callback , options . encoding ) // \u4f20\u7684\u662f\u6587\u4ef6\u8def\u5f84\u8fd8\u662ffd context . isUserFd = isFd ( path ); // File descriptor ownership // C++\u5c42\u7684\u5bf9\u8c61\uff0c\u5c01\u88c5\u4e86uv_fs_t\u7ed3\u6784\u4f53\uff0c\u7ba1\u7406\u4e00\u6b21\u6587\u4ef6\u8bfb\u8bf7\u6c42 const req = new FSReqCallback (); req . context = context ; // \u8bbe\u7f6e\u56de\u8c03\uff0c\u6253\u5f00\u6587\u4ef6\u540e\uff0c\u6267\u884c req . oncomplete = readFileAfterOpen ; // \u4f20\u7684\u662ffd\uff0c\u5219\u4e0d\u9700\u8981\u6253\u5f00\u6587\u4ef6\uff0c\u4e0b\u4e00\u4e2atick\u76f4\u63a5\u6267\u884c\u56de\u8c03\u8bfb\u53d6\u6587\u4ef6 if ( context . isUserFd ) { process . nextTick ( function tick () { req . oncomplete ( null , path ); }); return ; } path = getValidatedPath ( path ); const flagsNumber = stringToFlags ( options . flags ); // \u8c03\u7528C++\u5c42open\u6253\u5f00\u6587\u4ef6 binding . open ( pathModule . toNamespacedPath ( path ), flagsNumber , 0o666 , req ); } ReadFileContext\u5bf9\u8c61\u7528\u4e8e\u7ba1\u7406\u6587\u4ef6\u8bfb\u64cd\u4f5c\u6574\u4e2a\u8fc7\u7a0b\uff0cFSReqCallback\u662f\u5bf9uv_fs_t\u7684\u5c01\u88c5\uff0c\u6bcf\u6b21\u8bfb\u64cd\u4f5c\u5bf9\u4e8eLibuv\u6765\u8bf4\u5c31\u662f\u4e00\u6b21\u8bf7\u6c42\uff0c\u8be5\u8bf7\u6c42\u7684\u4e0a\u4e0b\u6587\u5c31\u662f\u4f7f\u7528uv_fs_t\u8868\u793a\u3002\u8bf7\u6c42\u5b8c\u6210\u540e\uff0c\u4f1a\u6267\u884cFSReqCallback\u5bf9\u8c61\u7684oncomplete\u51fd\u6570\u3002\u6240\u4ee5\u6211\u4eec\u7ee7\u7eed\u770breadFileAfterOpen\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function readFileAfterOpen ( err , fd ) { const context = this . context ; // \u6253\u5f00\u51fa\u9519\u5219\u76f4\u63a5\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u4f20\u5165err if ( err ) { context . callback ( err ); return ; } // \u4fdd\u5b58\u6253\u5f00\u6587\u4ef6\u7684fd context . fd = fd ; // \u65b0\u5efa\u4e00\u4e2aFSReqCallback\u5bf9\u8c61\u7ba1\u7406\u4e0b\u4e00\u4e2a\u5f02\u6b65\u8bf7\u6c42\u548c\u56de\u8c03 const req = new FSReqCallback (); req . oncomplete = readFileAfterStat ; req . context = context ; // \u83b7\u53d6\u6587\u4ef6\u7684\u5143\u6570\u636e\uff0c\u62ff\u5230\u6587\u4ef6\u5927\u5c0f binding . fstat ( fd , false , req ); } \u62ff\u5230\u6587\u4ef6\u7684\u5143\u6570\u636e\u540e\uff0c\u6267\u884creadFileAfterStat\uff0c\u8fd9\u6bb5\u903b\u8f91\u548c\u540c\u6b65\u7684\u7c7b\u4f3c\uff0c\u6839\u636e\u5143\u6570\u636e\u4e2d\u8bb0\u5f55\u7684\u6587\u4ef6\u5927\u5c0f\uff0c\u5206\u914d\u4e00\u4e2abuffer\u7528\u4e8e\u540e\u7eed\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9\u3002\u7136\u540e\u6267\u884c\u8bfb\u64cd\u4f5c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 read () { let buffer ; let offset ; let length ; // \u7701\u7565\u90e8\u5206buffer\u5904\u7406\u7684\u903b\u8f91 const req = new FSReqCallback (); req . oncomplete = readFileAfterRead ; req . context = this ; read ( this . fd , buffer , offset , length , - 1 , req ); } \u518d\u6b21\u65b0\u5efa\u4e00\u4e2aFSReqCallback\u5bf9\u8c61\u7ba1\u7406\u5f02\u6b65\u8bfb\u53d6\u64cd\u4f5c\u548c\u56de\u8c03\u3002\u6211\u4eec\u770b\u4e00\u4e0bC++\u5c42read\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1 2 3 4 // \u62ff\u5230C++\u5c42\u7684FSReqCallback\u5bf9\u8c61 FSReqBase* req_wrap_async = GetReqWrap(env, args[5]); // \u5f02\u6b65\u8c03\u7528uv_fs_read AsyncCall(env, req_wrap_async, args, \"read\", UTF8, AfterInteger,uv_fs_read, fd, &uvbuf, 1, pos); AsyncCall\u6700\u540e\u8c03\u7528Libuv\u7684uv_fs_read\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u51fd\u6570\u7684\u5173\u952e\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 do { \\ if ( cb != NULL ) { \\ uv__req_register ( loop , req ); \\ uv__work_submit ( loop , \\ & req -> work_req , \\ UV__WORK_FAST_IO , \\ uv__fs_work , \\ uv__fs_done ); \\ return 0 ; \\ } \\ else { \\ uv__fs_work ( & req -> work_req ); \\ return req -> result ; \\ } \\ } \\ while ( 0 ) uv__work_submit\u662f\u7ed9\u7ebf\u7a0b\u6c60\u63d0\u4ea4\u4e00\u4e2a\u4efb\u52a1\uff0c\u5f53\u5b50\u7ebf\u7a0b\u6267\u884c\u8fd9\u4e2a\u4efb\u52a1\u65f6\uff0c\u5c31\u4f1a\u6267\u884cuv__fs_work\uff0cuv__fs_work\u4f1a\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u7cfb\u7edf\u8c03\u7528read\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u963b\u585e\u3002\u7b49\u5230\u8bfb\u53d6\u6210\u529f\u540e\u6267\u884cuv__fs_done\u3002uv__fs_done\u4f1a\u6267\u884cC++\u5c42\u7684\u56de\u8c03\uff0c\u4ece\u800c\u6267\u884cJS\u5c42\u7684\u56de\u8c03\u3002JS\u5c42\u7684\u56de\u8c03\u662freadFileAfterRead\uff0c\u8fd9\u91cc\u5c31\u4e0d\u5177\u4f53\u5c55\u5f00\uff0creadFileAfterRead\u7684\u903b\u8f91\u662f\u5224\u65ad\u662f\u5426\u8bfb\u53d6\u5b8c\u6bd5\uff0c\u662f\u7684\u8bdd\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u5426\u5219\u7ee7\u7eed\u53d1\u8d77\u8bfb\u53d6\u64cd\u4f5c\u3002","title":"12.2 \u5f02\u6b65API"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#123","text":"\u6587\u4ef6\u76d1\u542c\u662f\u975e\u5e38\u5e38\u7528\u7684\u529f\u80fd\uff0c\u6bd4\u5982\u6211\u4eec\u4fee\u6539\u4e86\u6587\u4ef6\u540ewebpack\u91cd\u65b0\u6253\u5305\u4ee3\u7801\u6216\u8005Node.js\u670d\u52a1\u91cd\u542f\uff0c\u90fd\u7528\u5230\u4e86\u6587\u4ef6\u76d1\u542c\u7684\u529f\u80fd\uff0cNode.js\u63d0\u4f9b\u4e86\u4e24\u5957\u6587\u4ef6\u76d1\u542c\u7684\u673a\u5236\u3002","title":"12.3 \u6587\u4ef6\u76d1\u542c"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#1231","text":"\u57fa\u4e8e\u8f6e\u8be2\u673a\u5236\u7684\u6587\u4ef6\u76d1\u542cAPI\u662fwatchFile\u3002\u6d41\u7a0b\u5982\u56fe12-3\u6240\u793a\u3002 \u56fe12-3 \u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function watchFile ( filename , options , listener ) { filename = getValidatedPath ( filename ); filename = pathModule . resolve ( filename ); let stat ; // \u7701\u7565\u90e8\u5206\u53c2\u6570\u5904\u7406\u903b\u8f91 options = { interval : 5007 , // \u4e00\u76f4\u8f6e\u8be2 persistent : true , ... options }; // \u7f13\u5b58\u5904\u7406\uff0cfilename\u662f\u5426\u5df2\u7ecf\u5f00\u542f\u8fc7\u76d1\u542c stat = statWatchers . get ( filename ); if ( stat === undefined ) { if ( ! watchers ) watchers = require ( 'internal/fs/watchers' ); stat = new watchers . StatWatcher ( options . bigint ); // \u5f00\u542f\u76d1\u542c stat [ watchers . kFSStatWatcherStart ]( filename , options . persistent , options . interval ); // \u66f4\u65b0\u7f13\u5b58 statWatchers . set ( filename , stat ); } stat . addListener ( 'change' , listener ); return stat ; } StatWatcher\u662f\u7ba1\u7406\u6587\u4ef6\u76d1\u542c\u7684\u7c7b\uff0c\u6211\u4eec\u770b\u4e00\u4e0bwatchers.kFSStatWatcherStart\u65b9\u6cd5\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 StatWatcher . prototype [ kFSStatWatcherStart ] = function ( filename , persistent , interval ) { this . _handle = new _StatWatcher ( this [ kUseBigint ]); this . _handle . onchange = onchange ; filename = getValidatedPath ( filename , ' filename ' ); const err = this . _handle . start ( toNamespacedPath ( filename ), interval ); } \u65b0\u5efa\u4e00\u4e2a_StatWatcher\u5bf9\u8c61\uff0c_StatWatcher\u662fC++\u6a21\u5757\u63d0\u4f9b\u7684\u529f\u80fd\uff08node_stat_watcher.cc\uff09\uff0c\u7136\u540e\u6267\u884c\u5b83\u7684start\u65b9\u6cd5\u3002Start\u65b9\u6cd5\u6267\u884cLibuv\u7684uv_fs_poll_start\u5f00\u59cb\u76d1\u542c\u6587\u4ef6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int uv_fs_poll_start ( uv_fs_poll_t * handle , uv_fs_poll_cb cb , const char * path , unsigned int interval ) { // \u7ba1\u7406\u6587\u4ef6\u76d1\u542c\u7684\u6570\u636e\u7ed3\u6784 struct poll_ctx * ctx ; uv_loop_t * loop ; size_t len ; int err ; loop = handle -> loop ; len = strlen ( path ); // calloc\u4f1a\u628a\u5185\u5b58\u521d\u59cb\u5316\u4e3a0 ctx = uv__calloc ( 1 , sizeof ( * ctx ) + len ); ctx -> loop = loop ; // C++\u5c42\u56de\u8c03 ctx -> poll_cb = cb ; // \u591a\u4e45\u8f6e\u8be2\u4e00\u6b21 ctx -> interval = interval ? interval : 1 ; ctx -> start_time = uv_now ( loop ); // \u5173\u8054\u7684handle ctx -> parent_handle = handle ; // \u76d1\u542c\u7684\u6587\u4ef6\u8def\u5f84 memcpy ( ctx -> path , path , len + 1 ); // \u521d\u59cb\u5316\u5b9a\u65f6\u5668\u7ed3\u6784\u4f53 err = uv_timer_init ( loop , & ctx -> timer_handle ); // \u5f02\u6b65\u67e5\u8be2\u6587\u4ef6\u5143\u6570\u636e err = uv_fs_stat ( loop , & ctx -> fs_req , ctx -> path , poll_cb ); if ( handle -> poll_ctx != NULL ) ctx -> previous = handle -> poll_ctx ; // \u5173\u8054\u8d1f\u8d23\u7ba1\u7406\u8f6e\u8be2\u7684\u5bf9\u8c61 handle -> poll_ctx = ctx ; uv__handle_start ( handle ); return 0 ; } Start\u51fd\u6570\u521d\u59cb\u5316\u4e00\u4e2apoll_ctx\u7ed3\u6784\u4f53\uff0c\u7528\u4e8e\u7ba1\u7406\u6587\u4ef6\u76d1\u542c\uff0c\u7136\u540e\u53d1\u8d77\u5f02\u6b65\u8bf7\u6c42\u6587\u4ef6\u5143\u6570\u636e\u7684\u8bf7\u6c42\uff0c\u83b7\u53d6\u5143\u6570\u636e\u540e\uff0c\u6267\u884cpoll_cb\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 static void poll_cb ( uv_fs_t * req ) { uv_stat_t * statbuf ; struct poll_ctx * ctx ; uint64_t interval ; // \u901a\u8fc7\u7ed3\u6784\u4f53\u5b57\u6bb5\u83b7\u53d6\u7ed3\u6784\u4f53\u9996\u5730\u5740 ctx = container_of ( req , struct poll_ctx , fs_req ); statbuf = & req -> statbuf ; /* \u7b2c\u4e00\u6b21\u4e0d\u6267\u884c\u56de\u8c03\uff0c\u56e0\u4e3a\u6ca1\u6709\u53ef\u5bf9\u6bd4\u7684\u5143\u6570\u636e\uff0c\u7b2c\u4e8c\u6b21\u53ca\u540e\u7eed\u7684\u64cd\u4f5c\u624d\u53ef\u80fd \u6267\u884c\u56de\u8c03\uff0cbusy_polling\u521d\u59cb\u5316\u7684\u65f6\u5019\u4e3a0\uff0c\u7b2c\u4e00\u6b21\u6267\u884c\u7684\u65f6\u5019\u7f6e busy_polling=1 */ if ( ctx -> busy_polling != 0 ) // \u51fa\u9519\u6216\u8005stat\u53d1\u751f\u4e86\u53d8\u5316\u5219\u6267\u884c\u56de\u8c03 if ( ctx -> busy_polling < 0 || ! statbuf_eq ( & ctx -> statbuf , statbuf )) ctx -> poll_cb ( ctx -> parent_handle , 0 , & ctx -> statbuf , statbuf ); // \u4fdd\u5b58\u5f53\u524d\u83b7\u53d6\u5230\u7684stat\u4fe1\u606f\uff0c\u7f6e1 ctx -> statbuf = * statbuf ; ctx -> busy_polling = 1 ; out : uv_fs_req_cleanup ( req ); if ( ctx -> parent_handle == NULL ) { uv_close (( uv_handle_t * ) & ctx -> timer_handle , timer_close_cb ); return ; } /* \u5047\u8bbe\u5728\u5f00\u59cb\u65f6\u95f4\u70b9\u4e3a1\uff0cinterval\u4e3a10\u7684\u60c5\u51b5\u4e0b\u6267\u884c\u4e86stat\uff0cstat \u5b8c\u6210\u6267\u884c\u5e76\u6267\u884cpoll_cb\u56de\u8c03\u7684\u65f6\u95f4\u70b9\u662f3\uff0c\u90a3\u4e48\u5b9a\u65f6\u5668\u7684\u8d85\u65f6\u65f6\u95f4 \u5219\u4e3a10-3=7\uff0c\u53737\u4e2a\u5355\u4f4d\u540e\u5c31\u8981\u89e6\u53d1\u8d85\u65f6\uff0c\u800c\u4e0d\u662f10\uff0c\u662f\u56e0\u4e3astat \u963b\u585e\u6d88\u8017\u4e863\u4e2a\u5355\u4f4d\u7684\u65f6\u95f4\uff0c\u6240\u4ee5\u4e0b\u6b21\u6267\u884c\u8d85\u65f6\u56de\u8c03\u51fd\u6570\u65f6\u8bf4\u660e\u4ece start\u65f6\u95f4\u70b9\u5f00\u59cb\u7b97\uff0c\u5df2\u7ecf\u7ecf\u5386\u4e86x\u5355\u4f4d\u5404interval\uff0c\u7136\u540e\u8d85\u65f6\u56de\u8c03\u91cc \u53c8\u6267\u884c\u4e86stat\u51fd\u6570\uff0c\u518d\u5230\u6267\u884cstat\u56de\u8c03\uff0c\u8fd9\u4e2a\u65f6\u95f4\u70b9\u5373now=start+x \u5355\u4f4d\u4e2ainterval+stat\u6d88\u8017\u7684\u65f6\u95f4\u3002\u5f97\u51fanow-start\u4e3ainterval\u7684 x\u500d+stat\u6d88\u8017\uff0c\u5373\u5bf9interval\u53d6\u4f59\u53ef\u5f97\u5230stat\u6d88\u8017\uff0c\u6240\u4ee5\u5f53\u524d\u8f6e\uff0c \u5b9a\u65f6\u5668\u7684\u8d85\u65f6\u65f6\u95f4\u4e3ainterval - ((now-start) % interval) */ interval = ctx -> interval ; interval = ( uv_now ( ctx -> loop ) - ctx -> start_time ) % interval ; if ( uv_timer_start ( & ctx -> timer_handle , timer_cb , interval , 0 )) abort (); } \u57fa\u4e8e\u8f6e\u8be2\u7684\u76d1\u542c\u6587\u4ef6\u673a\u5236\u672c\u8d28\u4e0a\u662f\u4e0d\u65ad\u8f6e\u8be2\u6587\u4ef6\u7684\u5143\u6570\u636e\uff0c\u7136\u540e\u548c\u4e0a\u4e00\u6b21\u7684\u5143\u6570\u636e\u8fdb\u884c\u5bf9\u6bd4\uff0c\u5982\u679c\u6709\u4e0d\u4e00\u81f4\u7684\u5c31\u8ba4\u4e3a\u6587\u4ef6\u53d8\u5316\u4e86\uff0c\u56e0\u4e3a\u7b2c\u4e00\u6b21\u83b7\u53d6\u5143\u6570\u636e\u65f6\uff0c\u8fd8\u6ca1\u6709\u53ef\u4ee5\u5bf9\u6bd4\u7684\u6570\u636e\uff0c\u6240\u4ee5\u4e0d\u8ba4\u4e3a\u662f\u6587\u4ef6\u53d8\u5316\uff0c\u8fd9\u65f6\u5019\u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\u3002\u9694\u4e00\u6bb5\u65f6\u95f4\u518d\u53bb\u83b7\u53d6\u6587\u4ef6\u7684\u5143\u6570\u636e\uff0c\u5982\u6b64\u53cd\u590d\uff0c\u76f4\u5230\u7528\u6237\u8c03stop\u51fd\u6570\u505c\u6b62\u8fd9\u4e2a\u884c\u4e3a\u3002\u4e0b\u9762\u662fLibuv\u5173\u4e8e\u6587\u4ef6\u53d8\u5316\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 static int statbuf_eq ( const uv_stat_t * a , const uv_stat_t * b ) { return a -> st_ctim . tv_nsec == b -> st_ctim . tv_nsec && a -> st_mtim . tv_nsec == b -> st_mtim . tv_nsec && a -> st_birthtim . tv_nsec == b -> st_birthtim . tv_nsec && a -> st_ctim . tv_sec == b -> st_ctim . tv_sec && a -> st_mtim . tv_sec == b -> st_mtim . tv_sec && a -> st_birthtim . tv_sec == b -> st_birthtim . tv_sec && a -> st_size == b -> st_size && a -> st_mode == b -> st_mode && a -> st_uid == b -> st_uid && a -> st_gid == b -> st_gid && a -> st_ino == b -> st_ino && a -> st_dev == b -> st_dev && a -> st_flags == b -> st_flags && a -> st_gen == b -> st_gen ; }","title":"12.3.1 \u57fa\u4e8e\u8f6e\u8be2\u7684\u6587\u4ef6\u76d1\u542c\u673a\u5236"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#1232inotify","text":"\u6211\u4eec\u770b\u5230\u57fa\u4e8e\u8f6e\u8be2\u7684\u76d1\u542c\u5176\u5b9e\u6548\u7387\u662f\u5f88\u4f4e\u7684\uff0c\u56e0\u4e3a\u9700\u8981\u6211\u4eec\u4e0d\u65ad\u53bb\u8f6e\u8be2\u6587\u4ef6\u7684\u5143\u6570\u636e\uff0c\u5982\u679c\u6587\u4ef6\u5927\u90e8\u5206\u65f6\u95f4\u91cc\u90fd\u6ca1\u6709\u53d8\u5316\uff0c\u90a3\u5c31\u4f1a\u767d\u767d\u6d6a\u8d39CPU\u3002\u5982\u679c\u6587\u4ef6\u6539\u53d8\u4e86\u4f1a\u4e3b\u52a8\u901a\u77e5\u6211\u4eec\u90a3\u5c31\u597d\u4e86\uff0c\u8fd9\u5c31\u662f\u57fa\u4e8einotify\u673a\u5236\u7684\u6587\u4ef6\u76d1\u542c\u3002Node.js\u63d0\u4f9b\u7684\u63a5\u53e3\u662fwatch\u3002watch\u7684\u5b9e\u73b0\u548cwatchFile\u7684\u6bd4\u8f83\u7c7b\u4f3c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function watch ( filename , options , listener ) { // Don't make changes directly on options object options = copyObject ( options ); // \u662f\u5426\u6301\u7eed\u76d1\u542c if ( options . persistent === undefined ) options . persistent = true ; // \u5982\u679c\u662f\u76ee\u5f55\uff0c\u662f\u5426\u76d1\u542c\u6240\u6709\u5b50\u76ee\u5f55\u548c\u6587\u4ef6\u7684\u53d8\u5316 if ( options . recursive === undefined ) options . recursive = false ; // \u6709\u4e9b\u5e73\u53f0\u4e0d\u652f\u6301 if ( options . recursive && ! ( isOSX || isWindows )) throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM ( 'watch recursively' ); if ( ! watchers ) watchers = require ( 'internal/fs/watchers' ); // \u65b0\u5efa\u4e00\u4e2aFSWatcher\u5bf9\u8c61\u7ba1\u7406\u6587\u4ef6\u76d1\u542c\uff0c\u7136\u540e\u5f00\u542f\u76d1\u542c const watcher = new watchers . FSWatcher (); watcher [ watchers . kFSWatchStart ]( filename , options . persistent , options . recursive , options . encoding ); if ( listener ) { watcher . addListener ( 'change' , listener ); } return watcher ; } FSWatcher\u51fd\u6570\u662f\u5bf9C++\u5c42FSEvent\u6a21\u5757\u7684\u5c01\u88c5\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e0bstart\u51fd\u6570\u7684\u903b\u8f91\uff0cstart\u51fd\u6570\u900f\u8fc7C++\u5c42\u8c03\u7528\u4e86Libuv\u7684uv_fs_event_start\u51fd\u6570\u3002\u5728\u8bb2\u89e3uv_fs_event_start\u51fd\u6570\u524d\uff0c\u6211\u4eec\u5148\u4e86\u89e3\u4e00\u4e0binotify\u7684\u539f\u7406\u548c\u5b83\u5728Libuv\u4e2d\u7684\u5b9e\u73b0\u3002inotify\u662fLinux\u7cfb\u7edf\u63d0\u4f9b\u7528\u4e8e\u76d1\u542c\u6587\u4ef6\u7cfb\u7edf\u7684\u673a\u5236\u3002inotify\u673a\u5236\u7684\u903b\u8f91\u5927\u81f4\u662f 1 init_inotify\u521b\u5efa\u4e00\u4e2ainotify\u7684\u5b9e\u4f8b\uff0c\u8fd4\u56de\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u7c7b\u4f3cepoll\u3002 2 inotify_add_watch\u5f80inotify\u5b9e\u4f8b\u6ce8\u518c\u4e00\u4e2a\u9700\u76d1\u542c\u7684\u6587\u4ef6\uff08inotify_rm_watch\u662f\u79fb\u9664\uff09\u3002 3 read(inotify\u5b9e\u4f8b\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26, &buf, sizeof(buf))\uff0c\u5982\u679c\u6ca1\u6709\u4e8b\u4ef6\u89e6\u53d1\uff0c\u5219\u963b\u585e\uff08\u9664\u975e\u8bbe\u7f6e\u4e86\u975e\u963b\u585e\uff09\u3002\u5426\u5219\u8fd4\u56de\u5f85\u8bfb\u53d6\u7684\u6570\u636e\u957f\u5ea6\u3002buf\u5c31\u662f\u4fdd\u5b58\u4e86\u89e6\u53d1\u4e8b\u4ef6\u7684\u4fe1\u606f\u3002 Libuv\u5728inotify\u673a\u5236\u7684\u57fa\u7840\u4e0a\u505a\u4e86\u4e00\u5c42\u5c01\u88c5\u3002\u6211\u4eec\u770b\u4e00\u4e0binotify\u5728Libuv\u7684\u67b6\u6784\u56fe\u5982\u56fe12-4\u6240\u793a\u3002 \u56fe12-4 \u6211\u4eec\u518d\u6765\u770b\u4e00\u4e0bLibuv\u4e2d\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u4ece\u4e00\u4e2a\u4f7f\u7528\u4f8b\u5b50\u5f00\u59cb\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int main ( int argc , char ** argv ) { // \u5b9e\u73b0\u5faa\u73af\u6838\u5fc3\u7ed3\u6784\u4f53loop loop = uv_default_loop (); uv_fs_event_t * fs_event_req = malloc ( sizeof ( uv_fs_event_t )); // \u521d\u59cb\u5316fs_event_req\u7ed3\u6784\u4f53\u7684\u7c7b\u578b\u4e3aUV_FS_EVENT uv_fs_event_init ( loop , fs_event_req ); /* argv[argc]\u662f\u6587\u4ef6\u8def\u5f84\uff0c uv_fs_event_start \u5411\u5e95\u5c42\u6ce8\u518c\u76d1\u542c\u6587\u4ef6argv[argc], cb\u662f\u4e8b\u4ef6\u89e6\u53d1\u65f6\u7684\u56de\u8c03 */ uv_fs_event_start ( fs_event_req , cb , argv [ argc ], UV_FS_EVENT_RECURSIVE ); // \u5f00\u542f\u4e8b\u4ef6\u5faa\u73af return uv_run ( loop , UV_RUN_DEFAULT ); } Libuv\u5728\u7b2c\u4e00\u6b21\u76d1\u542c\u6587\u4ef6\u7684\u65f6\u5019(\u8c03\u7528uv_fs_event_start\u7684\u65f6\u5019)\uff0c\u4f1a\u521b\u5efa\u4e00\u4e2ainotify\u5b9e\u4f8b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 static int init_inotify ( uv_loop_t * loop ) { int err ; // \u521d\u59cb\u5316\u8fc7\u4e86\u5219\u76f4\u63a5\u8fd4\u56de if ( loop -> inotify_fd != -1 ) return 0 ; /* \u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684inotify_init\u51fd\u6570\u7533\u8bf7\u4e00\u4e2ainotify\u5b9e\u4f8b\uff0c \u5e76\u8bbe\u7f6eUV__IN_NONBLOCK\uff0cUV__IN_CLOEXEC\u6807\u8bb0 */ err = new_inotify_fd (); if ( err < 0 ) return err ; // \u8bb0\u5f55inotify\u5b9e\u4f8b\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26,\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af\u4e00\u4e2ainotify\u5b9e\u4f8b loop -> inotify_fd = err ; /* inotify_read_watcher\u662f\u4e00\u4e2aIO\u89c2\u5bdf\u8005\uff0c uv__io_init\u8bbe\u7f6eIO\u89c2\u5bdf\u8005\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff08\u5f85\u89c2\u5bdf\u7684\u6587\u4ef6\uff09\u548c\u56de\u8c03 */ uv__io_init ( & loop -> inotify_read_watcher , uv__inotify_read , loop -> inotify_fd ); // \u5f80Libuv\u4e2d\u6ce8\u518c\u8be5IO\u89c2\u5bdf\u8005\uff0c\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u4e3a\u53ef\u8bfb uv__io_start ( loop , & loop -> inotify_read_watcher , POLLIN ); return 0 ; } Libuv\u628ainotify\u5b9e\u4f8b\u5bf9\u5e94\u7684fd\u901a\u8fc7uv__io_start\u6ce8\u518c\u5230epoll\u4e2d\uff0c\u5f53\u6709\u6587\u4ef6\u53d8\u5316\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884c\u56de\u8c03uv__inotify_read\u3002\u5206\u6790\u5b8cLibuv\u7533\u8bf7inotify\u5b9e\u4f8b\u7684\u903b\u8f91\uff0c\u6211\u4eec\u56de\u5230main\u51fd\u6570\u770b\u770buv_fs_event_start\u51fd\u6570\u3002\u7528\u6237\u4f7f\u7528uv_fs_event_start\u51fd\u6570\u6765\u5f80Libuv\u6ce8\u518c\u4e00\u4e2a\u5f85\u76d1\u542c\u7684\u6587\u4ef6\u3002\u6211\u4eec\u770b\u770b\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 int uv_fs_event_start ( uv_fs_event_t * handle , uv_fs_event_cb cb , const char * path , unsigned int flags ) { struct watcher_list * w ; int events ; int err ; int wd ; if ( uv__is_active ( handle )) return UV_EINVAL ; // \u7533\u8bf7\u4e00\u4e2ainotify\u5b9e\u4f8b err = init_inotify ( handle -> loop ); if ( err ) return err ; // \u76d1\u542c\u7684\u4e8b\u4ef6 events = UV__IN_ATTRIB | UV__IN_CREATE | UV__IN_MODIFY | UV__IN_DELETE | UV__IN_DELETE_SELF | UV__IN_MOVE_SELF | UV__IN_MOVED_FROM | UV__IN_MOVED_TO ; // \u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u51fd\u6570\u6ce8\u518c\u4e00\u4e2a\u5f85\u76d1\u542c\u7684\u6587\u4ef6\uff0c\u8fd4\u56de\u4e00\u4e2a\u5bf9\u5e94\u4e8e\u8be5\u6587\u4ef6\u7684id wd = uv__inotify_add_watch ( handle -> loop -> inotify_fd , path , events ); if ( wd == -1 ) return UV__ERR ( errno ); // \u5224\u65ad\u8be5\u6587\u4ef6\u662f\u4e0d\u662f\u5df2\u7ecf\u6ce8\u518c\u8fc7\u4e86 w = find_watcher ( handle -> loop , wd ); // \u5df2\u7ecf\u6ce8\u518c\u8fc7\u5219\u8df3\u8fc7\u63d2\u5165\u7684\u903b\u8f91 if ( w ) goto no_insert ; // \u8fd8\u6ca1\u6709\u6ce8\u518c\u8fc7\u5219\u63d2\u5165Libuv\u7ef4\u62a4\u7684\u7ea2\u9ed1\u6811 w = uv__malloc ( sizeof ( * w ) + strlen ( path ) + 1 ); if ( w == NULL ) return UV_ENOMEM ; w -> wd = wd ; w -> path = strcpy (( char * )( w + 1 ), path ); QUEUE_INIT ( & w -> watchers ); w -> iterating = 0 ; // \u63d2\u5165Libuv\u7ef4\u62a4\u7684\u7ea2\u9ed1\u6811,inotify_watchers\u662f\u6839\u8282\u70b9 RB_INSERT ( watcher_root , CAST ( & handle -> loop -> inotify_watchers ), w ); no_insert : // \u6fc0\u6d3b\u8be5handle uv__handle_start ( handle ); // \u540c\u4e00\u4e2a\u6587\u4ef6\u53ef\u80fd\u6ce8\u518c\u4e86\u5f88\u591a\u4e2a\u56de\u8c03\uff0cw\u5bf9\u5e94\u4e00\u4e2a\u6587\u4ef6\uff0c\u6ce8\u518c\u5728\u7528\u4e00\u4e2a\u6587\u4ef6\u7684\u56de\u8c03\u6392\u6210\u961f QUEUE_INSERT_TAIL ( & w -> watchers , & handle -> watchers ); // \u4fdd\u5b58\u4fe1\u606f\u548c\u56de\u8c03 handle -> path = w -> path ; handle -> cb = cb ; handle -> wd = wd ; return 0 ; } \u4e0b\u9762\u6211\u4eec\u9010\u6b65\u5206\u6790\u4e0a\u9762\u7684\u51fd\u6570\u903b\u8f91\u3002 1 \u5982\u679c\u662f\u9996\u6b21\u8c03\u7528\u8be5\u51fd\u6570\u5219\u65b0\u5efa\u4e00\u4e2ainotify\u5b9e\u4f8b\u3002\u5e76\u4e14\u5f80Libuv\u63d2\u5165\u4e00\u4e2a\u89c2\u5bdf\u8005io\uff0cLibuv\u4f1a\u5728Poll IO\u9636\u6bb5\u6ce8\u518c\u5230epoll\u4e2d\u3002 2 \u5f80\u64cd\u4f5c\u7cfb\u7edf\u6ce8\u518c\u4e00\u4e2a\u5f85\u76d1\u542c\u7684\u6587\u4ef6\u3002\u8fd4\u56de\u4e00\u4e2aid\u3002 3 Libuv\u5224\u65ad\u8be5id\u662f\u4e0d\u662f\u5728\u81ea\u5df1\u7ef4\u62a4\u7684\u7ea2\u9ed1\u6811\u4e2d\u3002\u4e0d\u5728\u7ea2\u9ed1\u6811\u4e2d\uff0c\u5219\u63d2\u5165\u7ea2\u9ed1\u6811\u3002\u8fd4\u56de\u4e00\u4e2a\u7ea2\u9ed1\u6811\u4e2d\u5bf9\u5e94\u7684\u8282\u70b9\u3002\u628a\u672c\u6b21\u8bf7\u6c42\u7684\u4fe1\u606f\u5c01\u88c5\u5230handle\u4e2d\uff08\u56de\u8c03\u65f6\u9700\u8981\uff09\u3002\u7136\u540e\u628ahandle\u63d2\u5165\u521a\u624d\u8fd4\u56de\u7684\u8282\u70b9\u7684\u961f\u5217\u4e2d\u3002 \u8fd9\u65f6\u5019\u6ce8\u518c\u8fc7\u7a0b\u5c31\u5b8c\u6210\u4e86\u3002Libuv\u5728Poll IO\u9636\u6bb5\u5982\u679c\u68c0\u6d4b\u5230\u6709\u6587\u4ef6\u53d1\u751f\u53d8\u5316\uff0c\u5219\u4f1a\u6267\u884c\u56de\u8c03uv__inotify_read\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 static void uv__inotify_read ( uv_loop_t * loop , uv__io_t * dummy , unsigned int events ) { const struct uv__inotify_event * e ; struct watcher_list * w ; uv_fs_event_t * h ; QUEUE queue ; QUEUE * q ; const char * path ; ssize_t size ; const char * p ; /* needs to be large enough for sizeof(inotify_event) + strlen(path) */ char buf [ 4096 ]; // \u4e00\u6b21\u53ef\u80fd\u6ca1\u6709\u8bfb\u5b8c while ( 1 ) { do // \u8bfb\u53d6\u89e6\u53d1\u7684\u4e8b\u4ef6\u4fe1\u606f\uff0csize\u662f\u6570\u636e\u5927\u5c0f\uff0cbuffer\u4fdd\u5b58\u6570\u636e size = read ( loop -> inotify_fd , buf , sizeof ( buf )); while ( size == -1 && errno == EINTR ); // \u6ca1\u6709\u6570\u636e\u53ef\u53d6\u4e86 if ( size == -1 ) { assert ( errno == EAGAIN || errno == EWOULDBLOCK ); break ; } // \u5904\u7406buffer\u7684\u4fe1\u606f for ( p = buf ; p < buf + size ; p += sizeof ( * e ) + e -> len ) { // buffer\u91cc\u662f\u591a\u4e2auv__inotify_event\u7ed3\u6784\u4f53\uff0c\u91cc\u9762\u4fdd\u5b58\u4e86\u4e8b\u4ef6\u4fe1\u606f\u548c\u6587\u4ef6\u5bf9\u5e94\u7684id\uff08wd\u5b57\u6bb5\uff09 e = ( const struct uv__inotify_event * ) p ; events = 0 ; if ( e -> mask & ( UV__IN_ATTRIB | UV__IN_MODIFY )) events |= UV_CHANGE ; if ( e -> mask & ~ ( UV__IN_ATTRIB | UV__IN_MODIFY )) events |= UV_RENAME ; // \u901a\u8fc7\u6587\u4ef6\u5bf9\u5e94\u7684id\uff08wd\u5b57\u6bb5\uff09\u4ece\u7ea2\u9ed1\u6811\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u8282\u70b9 w = find_watcher ( loop , e -> wd ); path = e -> len ? ( const char * ) ( e + 1 ) : uv__basename_r ( w -> path ); w -> iterating = 1 ; // \u628a\u7ea2\u9ed1\u6811\u4e2d\uff0cwd\u5bf9\u5e94\u8282\u70b9\u7684handle\u961f\u5217\u79fb\u5230queue\u53d8\u91cf\uff0c\u51c6\u5907\u5904\u7406 QUEUE_MOVE ( & w -> watchers , & queue ); while ( ! QUEUE_EMPTY ( & queue )) { // \u5934\u7ed3\u70b9 q = QUEUE_HEAD ( & queue ); // \u901a\u8fc7\u7ed3\u6784\u4f53\u504f\u79fb\u62ff\u5230\u9996\u5730\u5740 h = QUEUE_DATA ( q , uv_fs_event_t , watchers ); // \u4ece\u5904\u7406\u961f\u5217\u4e2d\u79fb\u9664 QUEUE_REMOVE ( q ); // \u653e\u56de\u539f\u961f\u5217 QUEUE_INSERT_TAIL ( & w -> watchers , q ); // \u6267\u884c\u56de\u8c03 h -> cb ( h , path , events , 0 ); } } } } uv__inotify_read\u51fd\u6570\u7684\u903b\u8f91\u5c31\u662f\u4ece\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u628a\u6570\u636e\u8bfb\u53d6\u51fa\u6765\uff0c\u8fd9\u4e9b\u6570\u636e\u4e2d\u4fdd\u5b58\u4e86\u54ea\u4e9b\u6587\u4ef6\u89e6\u53d1\u4e86\u7528\u6237\u611f\u5174\u8da3\u7684\u4e8b\u4ef6\u3002\u7136\u540e\u904d\u5386\u6bcf\u4e2a\u89e6\u53d1\u4e86\u4e8b\u4ef6\u7684\u6587\u4ef6\u3002\u4ece\u7ea2\u9ed1\u6811\u4e2d\u627e\u5230\u8be5\u6587\u4ef6\u5bf9\u5e94\u7684\u7ea2\u9ed1\u6811\u8282\u70b9\u3002\u518d\u53d6\u51fa\u7ea2\u9ed1\u6811\u8282\u70b9\u4e2d\u7ef4\u62a4\u7684\u4e00\u4e2ahandle\u961f\u5217\uff0c\u6700\u540e\u6267\u884chandle\u961f\u5217\u4e2d\u6bcf\u4e2a\u8282\u70b9\u7684\u56de\u8c03\u3002","title":"12.3.2\u57fa\u4e8einotify\u7684\u6587\u4ef6\u76d1\u542c\u673a\u5236"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#124-promiseapi","text":"Node.js\u7684API\u90fd\u662f\u9075\u5faacallback\u6a21\u5f0f\u7684\uff0c\u6bd4\u5982\u6211\u4eec\u8981\u8bfb\u53d6\u4e00\u4e2a\u6587\u4ef6\u7684\u5185\u5bb9\u3002\u6211\u4eec\u901a\u5e38\u4f1a\u8fd9\u6837\u5199 1 2 3 4 5 6 7 8 9 10 11 12 13 const fs = require ( 'fs' ); fs . readFile ( 'filename' , 'utf-8' ,( err , data ) => { console . log ( data ) }) //\u4e3a\u4e86\u652f\u6301Promise\u6a21\u5f0f\uff0c\u6211\u4eec\u901a\u5e38\u8fd9\u6837\u5199 const fs = require ( 'fs' ); function readFile ( filename ) { return new Promise (( resolve , reject ) => { fs . readFile ( filename , 'utf-8' ,( err , data ) => { err ? reject ( err ) : resolve ( data ); }); }); } \u4f46\u662f\u5728Node.js V14\u4e2d\uff0c\u6587\u4ef6\u6a21\u5757\u652f\u6301\u4e86Promise\u5316\u7684api\u3002\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528await\u8fdb\u884c\u6587\u4ef6\u64cd\u4f5c\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4f7f\u7528\u4f8b\u5b50\u3002 1 2 3 4 5 6 7 8 9 const { open , readFile } = require ( 'fs' ). promises ; async function runDemo () { try { console . log ( await readFile ( '11111.md' , { encoding : 'utf-8' })); } catch ( e ){ } } runDemo (); \u4ece\u4f8b\u5b50\u4e2d\u6211\u4eec\u770b\u5230\uff0c\u548c\u4e4b\u524d\u7684API\u8c03\u7528\u65b9\u5f0f\u7c7b\u4f3c\uff0c\u4e0d\u540c\u7684\u5730\u65b9\u5728\u4e8e\u6211\u4eec\u4e0d\u7528\u518d\u5199\u56de\u8c03\u4e86\uff0c\u800c\u662f\u901a\u8fc7await\u7684\u65b9\u5f0f\u63a5\u6536\u7ed3\u679c\u3002\u8fd9\u53ea\u662f\u65b0\u7248API\u7684\u7279\u6027\u4e4b\u4e00\u3002\u5728\u65b0\u7248API\u4e4b\u524d\uff0c\u6587\u4ef6\u6a21\u5757\u5927\u90e8\u5206API\u90fd\u662f\u7c7b\u4f3c\u5de5\u5177\u51fd\u6570\uff0c\u6bd4\u5982readFile\uff0cwriteFile\uff0c\u65b0\u7248API\u4e2d\u652f\u6301\u9762\u5411\u5bf9\u8c61\u7684\u8c03\u7528\u65b9\u5f0f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const { open , readFile } = require ( 'fs' ). promises ; async function runDemo () { let filehandle ; try { filehandle = await open ( 'filename' , 'r' ); // console.log(await readFile(filehandle, { encoding: 'utf-8' })); console . log ( await filehandle . readFile ({ encoding : 'utf-8' })); } finally { if ( filehandle ) { await filehandle . close (); } } } runDemo (); \u9762\u5411\u5bf9\u8c61\u7684\u6a21\u5f0f\u4e2d\uff0c\u6211\u4eec\u9996\u5148\u9700\u8981\u901a\u8fc7open\u51fd\u6570\u62ff\u5230\u4e00\u4e2aFileHandle\u5bf9\u8c61\uff08\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5c01\u88c5\uff09\uff0c\u7136\u540e\u5c31\u53ef\u4ee5\u5728\u8be5\u5bf9\u8c61\u4e0a\u8c03\u5404\u79cd\u6587\u4ef6\u64cd\u4f5c\u7684\u51fd\u6570\u3002\u5728\u4f7f\u7528\u9762\u5411\u5bf9\u8c61\u6a21\u5f0f\u7684API\u65f6\u6709\u4e00\u4e2a\u9700\u8981\u6ce8\u610f\u7684\u5730\u65b9\u662fNode.js\u4e0d\u4f1a\u4e3a\u6211\u4eec\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5373\u4f7f\u6587\u4ef6\u64cd\u4f5c\u51fa\u9519\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u81ea\u5df1\u624b\u52a8\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5426\u5219\u4f1a\u9020\u6210\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\uff0c\u800c\u5728\u975e\u9762\u5411\u5bf9\u8c61\u6a21\u5f0f\u4e2d\uff0c\u5728\u6587\u4ef6\u64cd\u4f5c\u5b8c\u6bd5\u540e\uff0c\u4e0d\u7ba1\u6210\u529f\u8fd8\u662f\u5931\u8d25\uff0cNode.js\u90fd\u4f1a\u4e3a\u6211\u4eec\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002\u9996\u5148\u4ecb\u7ecd\u4e00\u4e2aFileHandle\u7c7b\u3002\u8be5\u7c7b\u662f\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5c01\u88c5\uff0c\u63d0\u4f9b\u4e86\u9762\u5411\u5bf9\u8c61\u7684API\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class FileHandle { constructor ( filehandle ) { // filehandle\u4e3aC++\u5bf9\u8c61 this [ kHandle ] = filehandle ; this [ kFd ] = filehandle . fd ; } get fd () { return this [ kFd ]; } readFile ( options ) { return readFile ( this , options ); } close = () => { this [ kFd ] = - 1 ; return this [ kHandle ]. close (); } // \u7701\u7565\u90e8\u5206\u64cd\u4f5c\u6587\u4ef6\u7684api } FileHandle\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u9996\u5148\u5c01\u88c5\u4e86\u4e00\u7cfb\u5217\u6587\u4ef6\u64cd\u4f5c\u7684API\uff0c\u7136\u540e\u5b9e\u73b0\u4e86close\u51fd\u6570\u7528\u4e8e\u5173\u95ed\u5e95\u5c42\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 1 \u64cd\u4f5c\u6587\u4ef6\u7cfb\u7edfAPI \u8fd9\u91cc\u6211\u4eec\u4ee5readFile\u4e3a\u4f8b\u8fdb\u884c\u5206\u6790 1 2 3 4 5 6 7 8 9 10 async function readFile ( path , options ) { options = getOptions ( options , { flag : 'r' }); const flag = options . flag || 'r' ; // \u4ee5\u9762\u5411\u5bf9\u8c61\u7684\u65b9\u5f0f\u4f7f\u7528\uff0c\u8fd9\u65f6\u5019\u9700\u8981\u81ea\u5df1\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26 if ( path instanceof FileHandle ) return readFileHandle ( path , options ); // \u76f4\u63a5\u8c03\u7528\uff0c\u9996\u5148\u9700\u8981\u5148\u6253\u5f00\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u8bfb\u53d6\u5b8c\u6bd5\u540eNode.js\u4f1a\u4e3b\u52a8\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26 const fd = await open ( path , flag , 0o666 ); return readFileHandle ( fd , options ). finally ( fd . close ); } \u4ecereadFile\u4ee3\u7801\u4e2d\u6211\u4eec\u770b\u5230\u4e0d\u540c\u8c03\u7528\u65b9\u5f0f\u4e0b\uff0cNode.js\u7684\u5904\u7406\u662f\u4e0d\u4e00\u6837\u7684\uff0c\u5f53FileHandle\u662f\u6211\u4eec\u7ef4\u62a4\u65f6\uff0c\u5173\u95ed\u64cd\u4f5c\u4e5f\u662f\u6211\u4eec\u8d1f\u8d23\u6267\u884c\uff0c\u5f53FileHandle\u662fNode.js\u7ef4\u62a4\u65f6\uff0cNode.js\u5728\u6587\u4ef6\u64cd\u4f5c\u5b8c\u6bd5\u540e\uff0c\u4e0d\u7ba1\u6210\u529f\u8fd8\u662f\u5931\u8d25\u90fd\u4f1a\u4e3b\u52a8\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u63a5\u7740\u6211\u4eec\u770b\u5230readFileHandle\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 async function readFileHandle ( filehandle , options ) { // \u83b7\u53d6\u6587\u4ef6\u5143\u4fe1\u606f const statFields = await binding . fstat ( filehandle . fd , false , kUsePromises ); let size ; // \u662f\u4e0d\u662f\u666e\u901a\u6587\u4ef6\uff0c\u6839\u636e\u6587\u4ef6\u7c7b\u578b\u83b7\u53d6\u5bf9\u5e94\u5927\u5c0f if (( statFields [ 1 /* mode */ ] & S_IFMT ) === S_IFREG ) { size = statFields [ 8 /* size */ ]; } else { size = 0 ; } // \u592a\u5927\u4e86 if ( size > kIoMaxLength ) throw new ERR_FS_FILE_TOO_LARGE ( size ); const chunks = []; // \u8ba1\u7b97\u6bcf\u6b21\u8bfb\u53d6\u7684\u5927\u5c0f const chunkSize = size === 0 ? kReadFileMaxChunkSize : MathMin ( size , kReadFileMaxChunkSize ); let endOfFile = false ; do { // \u5206\u914d\u5185\u5b58\u627f\u8f7d\u6570\u636e const buf = Buffer . alloc ( chunkSize ); // \u8bfb\u53d6\u7684\u6570\u636e\u548c\u5927\u5c0f const { bytesRead , buffer } = await read ( filehandle , buf , 0 , chunkSize , - 1 ); // \u662f\u5426\u8bfb\u5b8c\u4e86 endOfFile = bytesRead === 0 ; // \u8bfb\u53d6\u4e86\u6709\u6548\u6570\u636e\u5219\u628a\u6709\u6548\u6570\u636e\u90e8\u5206\u5b58\u8d77\u6765 if ( bytesRead > 0 ) chunks . push ( buffer . slice ( 0 , bytesRead )); } while ( ! endOfFile ); const result = Buffer . concat ( chunks ); if ( options . encoding ) { return result . toString ( options . encoding ); } else { return result ; } } \u63a5\u7740\u6211\u4eec\u770bread\u51fd\u6570\u7684\u5b9e\u73b0 1 2 3 4 5 async function read ( handle , buffer , offset , length , position ) { // ... const bytesRead = ( await binding . read ( handle . fd , buffer , offset , length , position , kUsePromises )) || 0 ; return { bytesRead , buffer }; } Read\u6700\u7ec8\u6267\u884c\u4e86node_file.cc \u7684Read\u3002\u6211\u4eec\u770b\u4e00\u4e0bRead\u51fd\u6570\u7684\u5173\u952e\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 static void Read ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); // ... FSReqBase * req_wrap_async = GetReqWrap ( env , args [ 5 ]); // \u5f02\u6b65\u6267\u884c\uff0c\u6709\u4e24\u79cd\u60c5\u51b5 if ( req_wrap_async != nullptr ) { AsyncCall ( env , req_wrap_async , args , \"read\" , UTF8 , AfterInteger , uv_fs_read , fd , & uvbuf , 1 , pos ); } else { // \u540c\u6b65\u6267\u884c\uff0c\u6bd4\u5982fs.readFileSync CHECK_EQ ( argc , 7 ); FSReqWrapSync req_wrap_sync ; FS_SYNC_TRACE_BEGIN ( read ); const int bytesRead = SyncCall ( env , args [ 6 ], & req_wrap_sync , \"read\" , uv_fs_read , fd , & uvbuf , 1 , pos ); FS_SYNC_TRACE_END ( read , \"bytesRead\" , bytesRead ); args . GetReturnValue (). Set ( bytesRead ); } } Read\u51fd\u6570\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5\uff0c\u540c\u6b65\u548c\u5f02\u6b65\uff0c\u5176\u4e2d\u5f02\u6b65\u53c8\u5206\u4e3a\u4e24\u79cd\uff0ccallback\u6a21\u5f0f\u548cPromise\u6a21\u5f0f\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5f02\u6b65\u6a21\u5f0f\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u8fd9\u53e5\u4ee3\u7801\u3002 1 FSReqBase* req_wrap_async = GetReqWrap(env, args[5]); GetReqWrap\u6839\u636e\u7b2c\u516d\u4e2a\u53c2\u6570\u83b7\u53d6\u5bf9\u5e94\u7684\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 FSReqBase * GetReqWrap ( Environment * env , v8 :: Local < v8 :: Value > value , bool use_bigint ) { // \u662f\u5bf9\u8c61\u8bf4\u660e\u662f\u7ee7\u627fFSReqBase\u7684\u5bf9\u8c61,\u6bd4\u5982FSReqCallback\uff08\u5f02\u6b65\u6a21\u5f0f\uff09 if ( value -> IsObject ()) { return Unwrap < FSReqBase > ( value . As < v8 :: Object > ()); } else if ( value -> StrictEquals ( env -> fs_use_promises_symbol ())) { // Promise\u6a21\u5f0f\uff08\u5f02\u6b65\u6a21\u5f0f\uff09 if ( use_bigint ) { return FSReqPromise < AliasedBigUint64Array >:: New ( env , use_bigint ); } else { return FSReqPromise < AliasedFloat64Array >:: New ( env , use_bigint ); } } // \u540c\u6b65\u6a21\u5f0f return nullptr ; } \u8fd9\u91cc\u6211\u4eec\u53ea\u5173\u6ce8Promise\u6a21\u5f0f\u3002\u6240\u4ee5GetReqWrap\u8fd4\u56de\u7684\u662f\u4e00\u4e2aFSReqPromise\u5bf9\u8c61\uff0c\u6211\u4eec\u56de\u5230Read\u51fd\u6570\u3002\u770b\u5230\u4ee5\u4e0b\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 FSReqBase * req_wrap_async = GetReqWrap ( env , args [ 5 ]); AsyncCall ( env , req_wrap_async , args , \"read\" , UTF8 , AfterInteger , uv_fs_read , fd , & uvbuf , 1 , pos ); \u7ee7\u7eed\u770b AsyncCall\u51fd\u6570 \uff08 node_file - inl . h \uff09 template < typename Func , typename ... Args > FSReqBase * AsyncCall ( Environment * env , FSReqBase * req_wrap , const v8 :: FunctionCallbackInfo < v8 :: Value >& args , const char * syscall , enum encoding enc , uv_fs_cb after , Func fn , Args ... fn_args ) { return AsyncDestCall ( env , req_wrap , args , syscall , nullptr , 0 , enc , after , fn , fn_args ...); } AsyncCall\u662f\u5bf9AsyncDestCall\u7684\u5c01\u88c5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 template < typename Func , typename ... Args > FSReqBase * AsyncDestCall ( Environment * env , FSReqBase * req_wrap , const v8 :: FunctionCallbackInfo < v8 :: Value >& args , const char * syscall , const char * dest , size_t len , enum encoding enc , uv_fs_cb after , Func fn , Args ... fn_args ) { CHECK_NOT_NULL ( req_wrap ); req_wrap -> Init ( syscall , dest , len , enc ); // \u8c03\u7528libuv\u51fd\u6570 int err = req_wrap -> Dispatch ( fn , fn_args ..., after ); // \u5931\u8d25\u5219\u76f4\u63a5\u6267\u884c\u56de\u8c03\uff0c\u5426\u5219\u8fd4\u56de\u4e00\u4e2aPromise\uff0c\u89c1SetReturnValue\u51fd\u6570 if ( err < 0 ) { uv_fs_t * uv_req = req_wrap -> req (); uv_req -> result = err ; uv_req -> path = nullptr ; after ( uv_req ); // after may delete req_wrap if there is an error req_wrap = nullptr ; } else { req_wrap -> SetReturnValue ( args ); } return req_wrap ; } AsyncDestCall\u51fd\u6570\u4e3b\u8981\u505a\u4e86\u4e24\u4e2a\u64cd\u4f5c\uff0c\u9996\u5148\u901a\u8fc7Dispatch\u8c03\u7528\u5e95\u5c42Libuv\u7684\u51fd\u6570\uff0c\u6bd4\u5982\u8fd9\u91cc\u662fuv_fs_read\u3002\u5982\u679c\u51fa\u9519\u6267\u884c\u56de\u8c03\u8fd4\u56de\u9519\u8bef\uff0c\u5426\u5219\u6267\u884creq_wrap->SetReturnValue(args)\u3002\u6211\u4eec\u77e5\u9053req_wrap\u662f\u5728GetReqWrap\u51fd\u6570\u4e2d\u7531FSReqPromise ::New(env, use_bigint)\u521b\u5efa\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 template < typename AliasedBufferT > FSReqPromise < AliasedBufferT >* FSReqPromise < AliasedBufferT >:: New ( Environment * env , bool use_bigint ) { v8 :: Local < v8 :: Object > obj ; // \u521b\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\u5b58\u5230obj\u4e2d if ( ! env -> fsreqpromise_constructor_template () -> NewInstance ( env -> context ()) . ToLocal ( & obj )) { return nullptr ; } // \u8bbe\u7f6e\u4e00\u4e2apromise\u5c5e\u6027\uff0c\u503c\u662f\u4e00\u4e2aPromise::Resolver v8 :: Local < v8 :: Promise :: Resolver > resolver ; if ( ! v8 :: Promise :: Resolver :: New ( env -> context ()). ToLocal ( & resolver ) || obj -> Set ( env -> context (), env -> promise_string (), resolver ). IsNothing ()) { return nullptr ; } // \u8fd4\u56de\u53e6\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u91cc\u9762\u4fdd\u5b58\u4e86obj\uff0cobj\u4e5f\u4fdd\u5b58\u4e86\u6307\u5411FSReqPromise\u5bf9\u8c61\u7684\u6307\u9488 return new FSReqPromise ( env , obj , use_bigint ); } \u6240\u4ee5req_wrap\u662f\u4e00\u4e2aFSReqPromise\u5bf9\u8c61\u3002\u6211\u4eec\u770b\u4e00\u4e0bFSReqPromise\u5bf9\u8c61\u7684SetReturnValue\u65b9\u6cd5\u3002 1 2 3 4 5 6 7 8 9 10 11 template < typename AliasedBufferT > void FSReqPromise < AliasedBufferT >:: SetReturnValue ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ) { // \u62ff\u5230Promise::Resolver\u5bf9\u8c61 v8 :: Local < v8 :: Value > val = object () -> Get ( env () -> context (), env () -> promise_string ()). ToLocalChecked (); v8 :: Local < v8 :: Promise :: Resolver > resolver = val . As < v8 :: Promise :: Resolver > (); // \u62ff\u5230\u4e00\u4e2aPromise\u4f5c\u4e3a\u8fd4\u56de\u503c\uff0c\u5373JS\u5c42\u62ff\u5230\u7684\u503c args . GetReturnValue (). Set ( resolver -> GetPromise ()); } \u81f3\u6b64\u6211\u4eec\u770b\u5230\u4e86\u65b0\u7248API\u5b9e\u73b0\u7684\u6838\u5fc3\u903b\u8f91\uff0c\u6b63\u662f\u8fd9\u4e2aPromise\u8fd4\u56de\u503c\u3002\u901a\u8fc7\u5c42\u5c42\u8fd4\u56de\u540e\uff0c\u5728JS\u5c42\u5c31\u62ff\u5230\u8fd9\u4e2aPromise\uff0c\u7136\u540e\u5904\u4e8epending\u72b6\u6001\u7b49\u5f85\u51b3\u8bae\u3002\u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0bPromise\u51b3\u8bae\u7684\u903b\u8f91\u3002\u5728\u5206\u6790Read\u51fd\u6570\u4e2d\u6211\u4eec\u770b\u5230\u6267\u884cLibuv\u7684uv_fs_read\u51fd\u6570\u65f6\uff0c\u8bbe\u7f6e\u7684\u56de\u8c03\u662fAfterInteger\u3002\u90a3\u4e48\u5f53\u8bfb\u53d6\u6587\u4ef6\u6210\u529f\u540e\u5c31\u4f1a\u6267\u884c\u8be5\u51fd\u6570\u3002\u6240\u4ee5\u6211\u4eec\u770b\u770b\u8be5\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 void AfterInteger ( uv_fs_t * req ) { // \u901a\u8fc7\u5c5e\u6027\u62ff\u5230\u5bf9\u8c61\u7684\u5730\u5740 FSReqBase * req_wrap = FSReqBase :: from_req ( req ); FSReqAfterScope after ( req_wrap , req ); if ( after . Proceed ()) req_wrap -> Resolve ( Integer :: New ( req_wrap -> env () -> isolate (), req -> result )); } \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bResolve 1 2 3 4 5 6 7 8 9 10 11 12 template < typename AliasedBufferT > void FSReqPromise < AliasedBufferT >:: Resolve ( v8 :: Local < v8 :: Value > value ) { finished_ = true ; v8 :: HandleScope scope ( env () -> isolate ()); InternalCallbackScope callback_scope ( this ); // \u62ff\u5230\u4fdd\u5b58\u7684Promise\u5bf9\u8c61\uff0c\u4fee\u6539\u72b6\u6001\u4e3aresolve\uff0c\u5e76\u8bbe\u7f6e\u7ed3\u679c v8 :: Local < v8 :: Value > val = object () -> Get ( env () -> context (), env () -> promise_string ()). ToLocalChecked (); v8 :: Local < v8 :: Promise :: Resolver > resolver = val . As < v8 :: Promise :: Resolver > (); USE ( resolver -> Resolve ( env () -> context (), value ). FromJust ()); } Resolve\u51fd\u6570\u4fee\u6539Promise\u7684\u72b6\u6001\u548c\u8bbe\u7f6e\u8fd4\u56de\u503c\uff0c\u4ece\u800cJS\u5c42\u62ff\u5230\u8fd9\u4e2a\u51b3\u8bae\u7684\u503c\u3002\u56de\u5230fs\u5c42 1 2 3 4 5 const bytesRead = ( await binding . read ( handle . fd , buffer , offset , length , position , kUsePromises )) | 0 ; \u6211\u4eec\u5c31\u62ff\u5230\u4e86\u8fd4\u56de\u503c\u3002","title":"12.4 Promise\u5316API"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#125-api","text":"\u524d\u9762\u5206\u6790\u4e86Node.js\u4e2d\u6587\u4ef6\u6a21\u5757\u7684\u591a\u79cd\u6587\u4ef6\u64cd\u4f5c\u7684\u65b9\u5f0f\uff0c\u4e0d\u7ba1\u662f\u540c\u6b65\u3001\u5f02\u6b65\u8fd8\u662fPromise\u5316\u7684API\uff0c\u5b83\u4eec\u90fd\u6709\u4e00\u4e2a\u95ee\u9898\u5c31\u662f\u5bf9\u4e8e\u7528\u6237\u6765\u8bf4\uff0c\u6587\u4ef6\u64cd\u4f5c\u90fd\u662f\u4e00\u6b21\u6027\u5b8c\u6210\u7684\uff0c\u6bd4\u5982\u6211\u4eec\u8c03\u7528readFile\u8bfb\u53d6\u4e00\u4e2a\u6587\u4ef6\u65f6\uff0cNode.js\u4f1a\u901a\u8fc7\u4e00\u6b21\u6216\u591a\u6b21\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u63a5\u53e3\u628a\u6240\u6709\u7684\u6587\u4ef6\u5185\u5bb9\u8bfb\u5230\u5185\u5b58\u4e2d\uff0c\u540c\u6837\u6211\u4eec\u8c03\u7528writeFile\u5199\u4e00\u4e2a\u6587\u4ef6\u65f6\uff0cNode.js\u4f1a\u901a\u8fc7\u4e00\u6b21\u6216\u591a\u6b21\u8c03\u7528\u64cd\u4f5c\u7cfb\u7edf\u63a5\u53e3\u628a\u7528\u6237\u7684\u6570\u636e\u5199\u5165\u786c\u76d8\uff0c\u8fd9\u5bf9\u5185\u5b58\u6765\u8bf4\u662f\u975e\u5e38\u6709\u538b\u529b\u7684\u3002\u5047\u8bbe\u6211\u4eec\u6709\u8fd9\u6837\u7684\u4e00\u4e2a\u573a\u666f\uff0c\u6211\u4eec\u9700\u8981\u8bfb\u53d6\u4e00\u4e2a\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u7136\u540e\u8fd4\u56de\u7ed9\u524d\u7aef\uff0c\u5982\u679c\u6211\u4eec\u76f4\u63a5\u8bfb\u53d6\u6574\u4e2a\u6587\u4ef6\u5185\u5bb9\uff0c\u7136\u540e\u518d\u6267\u884c\u5199\u64cd\u4f5c\u8fd9\u65e0\u7591\u662f\u975e\u5e38\u6d88\u8017\u5185\u5b58\uff0c\u4e5f\u662f\u975e\u5e38\u4f4e\u6548\u7684\u3002 1 2 3 4 5 6 7 const http = require ( 'http' ); const fs = require ( 'fs' ); const server = http . createServer (( req , res ) => { fs . readFile ( '11111.md' , ( err , data ) => { res . end ( data ); }) }). listen ( 11111 ); \u8fd9\u65f6\u5019\u6211\u4eec\u9700\u8981\u4f7f\u7528\u6d41\u5f0f\u7684API\u3002 1 2 3 4 5 const http = require ( 'http' ); const fs = require ( 'fs' ); const server = http . createServer (( req , res ) => { fs . createReadStream ( '11111.md' ). pipe ( res ); }). listen ( 11111 ); \u6d41\u5f0fAPI\u7684\u597d\u5904\u5728\u4e8e\u6587\u4ef6\u7684\u5185\u5bb9\u5e76\u4e0d\u662f\u4e00\u6b21\u6027\u8bfb\u53d6\u5230\u5185\u5b58\u7684\uff0c\u800c\u662f\u90e8\u5206\u8bfb\u53d6\uff0c\u6d88\u8d39\u5b8c\u540e\u518d\u7ee7\u7eed\u8bfb\u53d6\u3002Node.js\u5185\u90e8\u5e2e\u6211\u4eec\u505a\u4e86\u6d41\u91cf\u7684\u63a7\u5236\uff0c\u5982\u56fe12-5\u6240\u793a\u3002 \u56fe12-5 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u6d41\u5f0fAPI\u7684\u5177\u4f53\u5b9e\u73b0\u3002","title":"12.5 \u6d41\u5f0fAPI"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#1251","text":"\u53ef\u8bfb\u6587\u4ef6\u6d41\u662f\u5bf9\u6587\u4ef6\u8fdb\u884c\u6d41\u5f0f\u8bfb\u53d6\u7684\u62bd\u8c61\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7fs.createReadStream\u521b\u5efa\u4e00\u4e2a\u6587\u4ef6\u53ef\u8bfb\u6d41\u3002\u6587\u4ef6\u53ef\u8bfb\u6d41\u7ee7\u627f\u4e8e\u53ef\u8bfb\u6d41\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4ee5\u53ef\u8bfb\u6d41\u7684\u65b9\u5f0f\u4f7f\u7528\u5b83\u3002 1 2 3 4 5 6 7 8 9 const fs = require ( 'fs' ); const { Writable } = require ( 'stream' ); class DemoWritable extends Writable { _write ( data , encoding , cb ) { console . log ( data ); cb ( null ); } } fs . createReadStream ( '11111.md' ). pipe ( new DemoWritable ); \u6216\u8005 1 2 3 4 5 const fs = require ( 'fs' ); const readStream = fs . createReadStream ( '11111.md' ); readStream . on ( 'data' , ( data ) => { console . log ( data ) }); \u6211\u4eec\u770b\u4e00\u4e0bcreateReadStream\u7684\u5b9e\u73b0\u3002 1 2 3 fs . createReadStream = function ( path , options ) { return new ReadStream ( path , options ); }; CreateReadStream\u662f\u5bf9ReadStream\u7684\u5c01\u88c5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 function ReadStream ( path , options ) { if ( ! ( this instanceof ReadStream )) return new ReadStream ( path , options ); options = copyObject ( getOptions ( options , {})); // \u53ef\u8bfb\u6d41\u7684\u9608\u503c if ( options . highWaterMark === undefined ) options . highWaterMark = 64 * 1024 ; Readable . call ( this , options ); handleError (( this . path = getPathFromURL ( path ))); // \u652f\u6301\u4f20\u6587\u4ef6\u8def\u5f84\u6216\u6587\u4ef6\u63cf\u8ff0\u7b26 this . fd = options . fd === undefined ? null : options . fd ; this . flags = options . flags === undefined ? 'r' : options . flags ; this . mode = options . mode === undefined ? 0o666 : options . mode ; // \u8bfb\u53d6\u7684\u5f00\u59cb\u548c\u7ed3\u675f\u4f4d\u7f6e this . start = typeof this . fd !== 'number' && options . start === undefined ? 0 : options . start ; this . end = options . end ; // \u6d41\u51fa\u9519\u6216\u7ed3\u675f\u65f6\u662f\u5426\u81ea\u52a8\u9500\u6bc1\u6d41 this . autoClose = options . autoClose === undefined ? true : options . autoClose ; this . pos = undefined ; // \u5df2\u8bfb\u7684\u5b57\u8282\u6570 this . bytesRead = 0 ; // \u6d41\u662f\u5426\u5df2\u7ecf\u5173\u95ed this . closed = false ; // \u53c2\u6570\u6821\u9a8c if ( this . start !== undefined ) { if ( typeof this . start !== 'number' ) { throw new errors . TypeError ( 'ERR_INVALID_ARG_TYPE' , 'start' , 'number' , this . start ); } // \u9ed8\u8ba4\u8bfb\u53d6\u5168\u90e8\u5185\u5bb9 if ( this . end === undefined ) { this . end = Infinity ; } else if ( typeof this . end !== 'number' ) { throw new errors . TypeError ( 'ERR_INVALID_ARG_TYPE' , 'end' , 'number' , this . end ); } // \u4ece\u6587\u4ef6\u7684\u54ea\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u8bfb\uff0cstart\u662f\u5f00\u59cb\u4f4d\u7f6e\uff0cpos\u662f\u5f53\u524d\u4f4d\u7f6e\uff0c\u521d\u59cb\u5316\u7b49\u4e8e\u5f00\u59cb\u4f4d\u7f6e this . pos = this . start ; } // \u5982\u679c\u662f\u6839\u636e\u4e00\u4e2a\u6587\u4ef6\u540d\u521b\u5efa\u4e00\u4e2a\u6d41\uff0c\u5219\u9996\u5148\u6253\u5f00\u8fd9\u4e2a\u6587\u4ef6 if ( typeof this . fd !== 'number' ) this . open (); this . on ( 'end' , function () { // \u6d41\u7ed3\u675f\u65f6\u81ea\u52a8\u9500\u6bc1\u6d41 if ( this . autoClose ) { this . destroy (); } }); } ReadStream\u521d\u59cb\u5316\u5b8c\u540e\u505a\u4e86\u4e24\u4e2a\u64cd\u4f5c\uff0c\u9996\u5148\u8c03\u7528open\u6253\u5f00\u6587\u4ef6\uff08\u5982\u679c\u9700\u8981\u7684\u8bdd\uff09\uff0c\u63a5\u7740\u76d1\u542c\u6d41\u7ed3\u675f\u4e8b\u4ef6\uff0c\u7528\u6237\u53ef\u4ee5\u8bbe\u7f6eautoClose\u9009\u9879\u63a7\u5236\u5f53\u6d41\u7ed3\u675f\u6216\u8005\u51fa\u9519\u65f6\u662f\u5426\u9500\u6bc1\u6d41\uff0c\u5bf9\u4e8e\u6587\u4ef6\u6d41\u6765\u8bf4\uff0c\u9500\u6bc1\u6d41\u610f\u5473\u7740\u5173\u95ed\u5730\u65b9\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u6211\u4eec\u63a5\u7740\u770b\u4e00\u4e0bopen\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // \u6253\u5f00\u6587\u4ef6 ReadStream . prototype . open = function () { var self = this ; fs . open ( this . path , this . flags , this . mode , function ( er , fd ) { if ( er ) { // \u53d1\u751f\u9519\u8bef\uff0c\u662f\u5426\u9700\u8981\u81ea\u52a8\u9500\u6bc1\u6d41 if ( self . autoClose ) { self . destroy (); } // \u901a\u77e5\u7528\u6237 self . emit ( 'error' , er ); return ; } self . fd = fd ; // \u89e6\u53d1open\uff0c\u4e00\u822c\u7528\u4e8eNode.js\u5185\u90e8\u903b\u8f91 self . emit ( 'open' , fd ); // start the flow of data. // \u6253\u5f00\u6210\u529f\u540e\u5f00\u59cb\u6d41\u5f0f\u8bfb\u53d6\u6587\u4ef6\u5185\u5bb9 self . read (); }); }; open\u51fd\u6570\u9996\u5148\u6253\u5f00\u6587\u4ef6\uff0c\u6253\u5f00\u6210\u529f\u540e\u5f00\u542f\u6d41\u5f0f\u8bfb\u53d6\u3002\u4ece\u800c\u6587\u4ef6\u5185\u5bb9\u5c31\u4f1a\u6e90\u6e90\u4e0d\u65ad\u5730\u6d41\u5411\u76ee\u7684\u6d41\u3002\u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0b\u8bfb\u53d6\u64cd\u4f5c\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // \u5b9e\u73b0\u53ef\u8bfb\u6d41\u7684\u94a9\u5b50\u51fd\u6570 ReadStream . prototype . _read = function ( n ) { // \u5982\u679c\u6ca1\u6709\u8c03\u7528open\u800c\u662f\u76f4\u63a5\u8c03\u7528\u8be5\u65b9\u6cd5\u5219\u5148\u6267\u884copen if ( typeof this . fd !== 'number' ) { return this . once ( 'open' , function () { this . _read ( n ); }); } // \u6d41\u5df2\u7ecf\u9500\u6bc1\u5219\u4e0d\u5904\u7406 if ( this . destroyed ) return ; // \u5224\u65ad\u6c60\u5b50\u7a7a\u95f4\u662f\u5426\u8db3\u591f\uff0c\u4e0d\u591f\u5219\u7533\u8bf7\u65b0\u7684 if ( ! pool || pool . length - pool . used < kMinPoolSpace ) { // discard the old pool. allocNewPool ( this . readableHighWaterMark ); } // \u8ba1\u7b97\u53ef\u8bfb\u7684\u6700\u5927\u6570\u91cf var thisPool = pool ; /* \u53ef\u8bfb\u53d6\u7684\u6700\u5927\u503c,\u53d6\u53ef\u7528\u5185\u5b58\u5927\u5c0f\u548cNode.js\u6253\u7b97\u8bfb\u53d6\u7684\u5927\u5c0f \u4e2d\u7684\u5c0f\u503c,n\u4e0d\u662f\u7528\u6237\u60f3\u8bfb\u53d6\u7684\u5927\u5c0f\uff0c\u800c\u662f\u53ef\u8bfb\u6d41\u5185\u90e8\u7684\u903b\u8f91 \u89c1_stream_readable.js\u7684this._read(state.highWaterMark) */ var toRead = Math . min ( pool . length - pool . used , n ); var start = pool . used ; // \u5df2\u7ecf\u8bfb\u53d6\u4e86\u90e8\u5206\u4e86\uff0c\u5219\u8ba1\u7b97\u5269\u4e0b\u8bfb\u53d6\u7684\u5927\u5c0f\uff0c\u548c\u8ba1\u7b97\u8bfb\u53d6\u7684toRead\u6bd4\u8f83\u53d6\u5c0f\u503c if ( this . pos !== undefined ) toRead = Math . min ( this . end - this . pos + 1 , toRead ); // \u8bfb\u7ed3\u675f if ( toRead <= 0 ) return this . push ( null ); // pool.used\u662f\u5373\u5c06\u8bfb\u53d6\u7684\u6570\u636e\u5b58\u50a8\u5728pool\u4e2d\u7684\u5f00\u59cb\u4f4d\u7f6e\uff0cthis.pos\u662f\u4ece\u6587\u4ef6\u7684\u54ea\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u8bfb\u53d6 fs . read ( this . fd , pool , pool . used , toRead , this . pos , ( er , bytesRead ) => { if ( er ) { if ( this . autoClose ) { this . destroy (); } this . emit ( 'error' , er ); } else { var b = null ; if ( bytesRead > 0 ) { // \u5df2\u8bfb\u7684\u5b57\u8282\u6570\u7d2f\u52a0 this . bytesRead += bytesRead ; // \u83b7\u53d6\u6709\u6548\u6570\u636e b = thisPool . slice ( start , start + bytesRead ); } // push\u5230\u5e95\u5c42\u6d41\u7684bufferList\u4e2d\uff0c\u5e95\u5c42\u7684push\u4f1a\u89e6\u53d1data\u4e8b\u4ef6 this . push ( b ); } }); // \u91cd\u65b0\u8bbe\u7f6e\u5df2\u8bfb\u6307\u9488\u7684\u4f4d\u7f6e if ( this . pos !== undefined ) this . pos += toRead ; pool . used += toRead ; }; \u4ee3\u7801\u770b\u8d77\u6765\u5f88\u591a\uff0c\u4e3b\u8981\u7684\u903b\u8f91\u662f\u8c03\u7528\u5f02\u6b65read\u51fd\u6570\u8bfb\u53d6\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u7136\u540e\u653e\u5230\u53ef\u8bfb\u6d41\u4e2d\uff0c\u53ef\u8bfb\u6d41\u4f1a\u89e6\u53d1data\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u6709\u6570\u636e\u5230\u6765\uff0c\u7136\u540e\u7ee7\u7eed\u6267\u884cread\u51fd\u6570\uff0c\u4ece\u800c\u4e0d\u65ad\u9a71\u52a8\u7740\u6570\u636e\u7684\u8bfb\u53d6\uff08\u53ef\u8bfb\u6d41\u4f1a\u6839\u636e\u5f53\u524d\u60c5\u51b5\u5224\u65ad\u662f\u5426\u7ee7\u7eed\u6267\u884cread\u51fd\u6570\uff0c\u4ee5\u8fbe\u5230\u6d41\u91cf\u63a7\u5236\u7684\u76ee\u7684\uff09\u3002\u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u5173\u95ed\u548c\u9500\u6bc1\u4e00\u4e2a\u6587\u4ef6\u6d41\u7684\u5b9e\u73b0\u3002 1 2 3 ReadStream.prototype.close = function(cb) { this.destroy(null, cb); }; \u5f53\u6211\u4eec\u8bbe\u7f6eautoClose\u4e3afalse\u7684\u65f6\u5019\uff0c\u6211\u4eec\u5c31\u9700\u8981\u81ea\u5df1\u624b\u52a8\u8c03\u7528close\u51fd\u6570\u5173\u95ed\u53ef\u8bfb\u6587\u4ef6\u6d41\u3002\u5173\u95ed\u6587\u4ef6\u6d41\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u6b63\u5e38\u5730\u9500\u6bc1\u6d41\u3002\u6211\u4eec\u770b\u770b\u9500\u6bc1\u6d41\u7684\u65f6\u5019\uff0cNode.js\u505a\u4e86\u4ec0\u4e48\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // \u5173\u95ed\u5e95\u5c42\u6587\u4ef6 ReadStream . prototype . _destroy = function ( err , cb ) { const isOpen = typeof this . fd !== 'number' ; if ( isOpen ) { this . once ( 'open' , closeFsStream . bind ( null , this , cb , err )); return ; } closeFsStream ( this , cb ); this . fd = null ; }; function closeFsStream ( stream , cb , err ) { fs . close ( stream . fd , ( er ) => { er = er || err ; cb ( er ); stream . closed = true ; if ( ! er ) stream . emit ( 'close' ); }); } \u9500\u6bc1\u6587\u4ef6\u6d41\u5c31\u662f\u5173\u95ed\u5e95\u5c42\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u53e6\u5916\u5982\u679c\u662f\u56e0\u4e3a\u53d1\u751f\u9519\u8bef\u5bfc\u81f4\u9500\u6bc1\u6216\u8005\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u9519\u8bef\u5219\u4e0d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u3002","title":"12.5.1 \u53ef\u8bfb\u6587\u4ef6\u6d41"},{"location":"chapter12-%E6%96%87%E4%BB%B6/#1252","text":"\u53ef\u5199\u6587\u4ef6\u6d41\u662f\u5bf9\u6587\u4ef6\u8fdb\u884c\u6d41\u5f0f\u5199\u5165\u7684\u62bd\u8c61\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7fs.createWriteStream\u521b\u5efa\u4e00\u4e2a\u6587\u4ef6\u53ef\u5199\u6d41\u3002\u6587\u4ef6\u53ef\u4e9b\u6d41\u7ee7\u627f\u4e8e\u53ef\u5199\u6d41\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u4ee5\u53ef\u5199\u6d41\u7684\u65b9\u5f0f\u4f7f\u7528\u5b83\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const fs = require ( 'fs' ); const writeStream = fs . createWriteStream ( '123.md' ); writeStream . end ( 'world' ); // \u6216\u8005 const fs = require ( 'fs' ); const { Readable } = require ( 'stream' ); class DemoReadStream extends Readable { constructor () { super (); this . i = 0 ; } _read ( n ) { this . i ++ ; if ( this . i > 10 ) { this . push ( null ); } else { this . push ( '1' . repeat ( n )); } } } new DemoReadStream (). pipe ( fs . createWriteStream ( '123.md' )); \u6211\u4eec\u770b\u4e00\u4e0bcreateWriteStream\u7684\u5b9e\u73b0\u3002 1 2 3 fs . createWriteStream = function ( path , options ) { return new WriteStream ( path , options ); }; createWriteStream\u662f\u5bf9WriteStream\u7684\u5c01\u88c5\uff0c\u6211\u4eec\u770b\u4e00\u4e0bWriteStream\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 function WriteStream ( path , options ) { if ( ! ( this instanceof WriteStream )) return new WriteStream ( path , options ); options = copyObject ( getOptions ( options , {})); Writable . call ( this , options ); handleError (( this . path = getPathFromURL ( path ))); this . fd = options . fd === undefined ? null : options . fd ; this . flags = options . flags === undefined ? 'w' : options . flags ; this . mode = options . mode === undefined ? 0o666 : options . mode ; // \u5199\u5165\u7684\u5f00\u59cb\u4f4d\u7f6e this . start = options . start ; // \u6d41\u7ed3\u675f\u548c\u89e6\u53d1\u9519\u8bef\u7684\u65f6\u5019\u662f\u5426\u9500\u6bc1\u6d41 this . autoClose = options . autoClose === undefined ? true : !! options . autoClose ; // \u5f53\u524d\u5199\u5165\u4f4d\u7f6e this . pos = undefined ; // \u5199\u6210\u529f\u7684\u5b57\u8282\u6570 this . bytesWritten = 0 ; this . closed = false ; if ( this . start !== undefined ) { if ( typeof this . start !== 'number' ) { throw new errors . TypeError ( 'ERR_INVALID_ARG_TYPE' , 'start' , 'number' , this . start ); } if ( this . start < 0 ) { const errVal = `{start: ${ this . start } }` ; throw new errors . RangeError ( 'ERR_OUT_OF_RANGE' , 'start' , '>= 0' , errVal ); } // \u8bb0\u5f55\u5199\u5165\u7684\u5f00\u59cb\u4f4d\u7f6e this . pos = this . start ; } if ( options . encoding ) this . setDefaultEncoding ( options . encoding ); // \u6ca1\u6709\u4f20\u6587\u4ef6\u63cf\u8ff0\u7b26\u5219\u6253\u5f00\u4e00\u4e2a\u65b0\u7684\u6587\u4ef6 if ( typeof this . fd !== 'number' ) this . open (); // \u76d1\u542c\u53ef\u5199\u6d41\u7684finish\u4e8b\u4ef6\uff0c\u5224\u65ad\u662f\u5426\u9700\u8981\u6267\u884c\u9500\u6bc1\u64cd\u4f5c this . once ( 'finish' , function () { if ( this . autoClose ) { this . destroy (); } }); } WriteStream\u521d\u59cb\u5316\u4e86\u4e00\u7cfb\u5217\u5b57\u6bb5\u540e\uff0c\u5982\u679c\u4f20\u7684\u662f\u6587\u4ef6\u8def\u5f84\u5219\u6253\u5f00\u6587\u4ef6\uff0c\u5982\u679c\u4f20\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5219\u4e0d\u9700\u8981\u518d\u6b21\u6253\u5f00\u6587\u4ef6\u3002\u540e\u7eed\u5bf9\u6587\u4ef6\u53ef\u5199\u6d41\u7684\u64cd\u4f5c\u5c31\u662f\u5bf9\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u64cd\u4f5c\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5199\u5165\u6587\u4ef6\u7684\u903b\u8f91\u3002\u6211\u4eec\u77e5\u9053\u53ef\u5199\u6d41\u53ea\u662f\u5b9e\u73b0\u4e86\u4e00\u4e9b\u62bd\u8c61\u7684\u903b\u8f91\uff0c\u5177\u4f53\u7684\u5199\u903b\u8f91\u662f\u5177\u4f53\u7684\u6d41\u901a\u8fc7_write\u6216\u8005_writev\u5b9e\u73b0\u7684\uff0c\u6211\u4eec\u770b\u4e00\u4e0b_write\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 WriteStream . prototype . _write = function ( data , encoding , cb ) { if ( ! ( data instanceof Buffer )) { const err = new errors . TypeError ( 'ERR_INVALID_ARG_TYPE' , 'data' , 'Buffer' , data ); return this . emit ( 'error' , err ); } // \u8fd8\u6ca1\u6253\u5f00\u6587\u4ef6\uff0c\u5219\u7b49\u5f85\u6253\u5f00\u6210\u529f\u540e\u518d\u6267\u884c\u5199\u64cd\u4f5c if ( typeof this . fd !== 'number' ) { return this . once ( 'open' , function () { this . _write ( data , encoding , cb ); }); } // \u6267\u884c\u5199\u64cd\u4f5c,0\u4ee3\u8868\u4ecedata\u7684\u54ea\u4e2a\u4f4d\u7f6e\u5f00\u59cb\u5199\uff0c\u8fd9\u91cc\u662f\u5168\u90e8\u5199\u5165\uff0c\u6240\u4ee5\u662f0\uff0cpos\u4ee3\u8868\u6587\u4ef6\u7684\u4f4d\u7f6e fs . write ( this . fd , data , 0 , data . length , this . pos , ( er , bytes ) => { if ( er ) { if ( this . autoClose ) { this . destroy (); } return cb ( er ); } // \u5199\u5165\u6210\u529f\u7684\u5b57\u8282\u957f\u5ea6 this . bytesWritten += bytes ; cb (); }); // \u4e0b\u4e00\u4e2a\u5199\u5165\u7684\u4f4d\u7f6e if ( this . pos !== undefined ) this . pos += data . length ; }; _write\u5c31\u662f\u6839\u636e\u7528\u6237\u4f20\u5165\u6570\u636e\u7684\u5927\u5c0f\uff0c\u4e0d\u65ad\u8c03\u7528fs.write\u5f80\u5e95\u5c42\u5199\u5165\u6570\u636e\uff0c\u76f4\u5230\u5199\u5b8c\u6210\u6216\u8005\u51fa\u9519\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u6279\u91cf\u5199\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // \u5b9e\u73b0\u53ef\u5199\u6d41\u6279\u91cf\u5199\u94a9\u5b50 WriteStream . prototype . _writev = function ( data , cb ) { if ( typeof this . fd !== 'number' ) { return this . once ( 'open' , function () { this . _writev ( data , cb ); }); } const self = this ; const len = data . length ; const chunks = new Array ( len ); var size = 0 ; // \u8ba1\u7b97\u5f85\u5199\u5165\u7684\u51fa\u603b\u5927\u5c0f\uff0c\u5e76\u4e14\u628a\u6570\u636e\u4fdd\u5b58\u5230chunk\u6570\u7ec4\u4e2d\uff0c\u51c6\u5907\u5199\u5165 for ( var i = 0 ; i < len ; i ++ ) { var chunk = data [ i ]. chunk ; chunks [ i ] = chunk ; size += chunk . length ; } // \u6267\u884c\u6279\u91cf\u5199 writev ( this . fd , chunks , this . pos , function ( er , bytes ) { if ( er ) { self . destroy (); return cb ( er ); } // \u5199\u6210\u529f\u7684\u5b57\u8282\u6570\uff0c\u53ef\u80fd\u5c0f\u4e8e\u5e0c\u671b\u5199\u5165\u7684\u5b57\u8282\u6570 self . bytesWritten += bytes ; cb (); }); /* \u66f4\u65b0\u4e0b\u4e00\u4e2a\u5199\u5165\u4f4d\u7f6e\uff0c\u5982\u679c\u5199\u90e8\u5206\u6210\u529f\uff0c\u8ba1\u7b97\u4e0b\u4e00\u4e2a\u5199\u5165\u4f4d\u7f6e\u65f6 \u4e5f\u4f1a\u5305\u62ec\u6ca1\u5199\u6210\u529f\u7684\u5b57\u8282\u6570\uff0c\u6240\u4ee5\u662f\u5047\u8bbesize\u800c\u4e0d\u662fbytes */ if ( this . pos !== undefined ) this . pos += size ; }; \u6279\u91cf\u5199\u5165\u7684\u903b\u8f91\u548c_write\u7c7b\u4f3c\uff0c\u53ea\u4e0d\u8fc7\u5b83\u8c03\u7528\u7684\u662f\u4e0d\u540c\u7684\u63a5\u53e3\u5f80\u5e95\u5c42\u5199\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u5173\u95ed\u6587\u4ef6\u53ef\u5199\u6d41\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 WriteStream . prototype . close = function ( cb ) { // \u5173\u95ed\u6587\u4ef6\u6210\u529f\u540e\u6267\u884c\u7684\u56de\u8c03 if ( cb ) { if ( this . closed ) { process . nextTick ( cb ); return ; } else { this . on ( 'close' , cb ); } } /* \u5982\u679cautoClose\u662ffalse\uff0c\u8bf4\u660e\u6d41\u7ed3\u675f\u89e6\u53d1finish\u4e8b\u4ef6\u65f6\uff0c\u4e0d\u4f1a\u9500\u6bc1\u6d41\uff0c \u89c1WriteStream\u521d\u59cb\u5316\u4ee3\u7801 \u4ee5\u8fd9\u91cc\u9700\u8981\u76d1\u542cfinish\u4e8b\u4ef6\uff0c\u4fdd\u8bc1\u53ef\u5199\u6d41\u7ed3\u675f\u65f6\u53ef\u4ee5\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26 */ if ( ! this . autoClose ) { this . on ( 'finish' , this . destroy . bind ( this )); } // \u7ed3\u675f\u6d41\uff0c\u4f1a\u89e6\u53d1finish\u4e8b\u4ef6 this . end (); }; \u53ef\u5199\u6587\u4ef6\u6d41\u548c\u53ef\u8bfb\u6587\u4ef6\u6d41\u4e0d\u4e00\u6837\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u53ef\u8bfb\u6d41\u5728\u8bfb\u5b8c\u6587\u4ef6\u5185\u5bb9\u540eNode.js\u4f1a\u81ea\u52a8\u9500\u6bc1\u6d41\uff08\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\uff09\uff0c\u800c\u5199\u5165\u6587\u4ef6\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0bNode.js\u662f\u65e0\u6cd5\u77e5\u9053\u4ec0\u4e48\u65f6\u5019\u6d41\u7ed3\u675f\u7684\uff0c\u8fd9\u9700\u8981\u6211\u4eec\u663e\u5f0f\u5730\u901a\u77e5Node.js\u3002\u5728\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d\uff0c\u6211\u4eec\u662f\u4e0d\u9700\u8981\u663e\u5f0f\u901a\u77e5Node.js\u7684 fs.createReadStream('11111.md').pipe(fs.createWriteStream('123.md')); \u56e0\u4e3a\u53ef\u8bfb\u6587\u4ef6\u6d41\u5728\u6587\u4ef6\u8bfb\u5b8c\u540e\u4f1a\u8c03\u7528\u53ef\u5199\u6587\u4ef6\u7684end\u65b9\u6cd5\uff0c\u4ece\u800c\u5173\u95ed\u53ef\u8bfb\u6d41\u548c\u53ef\u5199\u6d41\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u800c\u5728\u4ee5\u4e0b\u4ee3\u7801\u4e2d\u60c5\u51b5\u5c31\u53d8\u5f97\u590d\u6742\u3002 1 2 3 const stream = fs . createWriteStream ( '123.md' ); stream . write ( 'hello' ); // stream.close \u6216 stream.end(); \u5728\u9ed8\u8ba4\u60c5\u51b5\uff0c\u6211\u4eec\u53ef\u4ee5\u8c03\u7528end\u6216\u8005close\u53bb\u901a\u77e5Node.js\u6d41\u7ed3\u675f\u3002\u4f46\u662f\u5982\u679c\u6211\u4eec\u8bbe\u7f6e\u4e86autoClose\u4e3afalse\uff0c\u90a3\u4e48\u6211\u4eec\u53ea\u80fd\u8c03\u7528close\u800c\u4e0d\u80fd\u8c03\u7528end\u3002\u5426\u5219\u4f1a\u9020\u6210\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\u3002\u56e0\u4e3aend\u53ea\u662f\u5173\u95ed\u4e86\u6d41\u3002\u4f46\u662f\u6ca1\u6709\u89e6\u53d1\u9500\u6bc1\u6d41\u7684\u903b\u8f91\u3002\u800cclose\u4f1a\u89e6\u53d1\u9500\u6bc1\u6d41\u7684\u903b\u8f91\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u4ee3\u7801\u3002 1 2 3 4 5 const fs = require ( 'fs' ); const stream = fs . createWriteStream ( '123.md' ); stream . write ( 'hello' ); // \u9632\u6b62\u8fdb\u7a0b\u9000\u51fa setInterval (() => {}); \u4ee5\u4e0a\u4ee3\u7801\u4f1a\u5bfc\u81f4\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\uff0c\u6211\u4eec\u5728Linux\u4e0b\u6267\u884c\u4ee5\u4e0b\u4ee3\u7801\uff0c\u901a\u8fc7ps aux\u627e\u5230\u8fdb\u7a0bid\uff0c\u7136\u540e\u6267\u884clsof -p pid\u5c31\u53ef\u4ee5\u770b\u5230\u8fdb\u7a0b\u6253\u5f00\u7684\u6240\u6709\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u8f93\u51fa\u598212-6\u6240\u793a\u3002 \u56fe12-6 \u6587\u4ef6\u63cf\u8ff0\u7b2617\u6307\u5411\u4e86123.md\u6587\u4ef6\u3002\u6240\u4ee5\u6587\u4ef6\u63cf\u8ff0\u7b26\u6ca1\u6709\u88ab\u5173\u95ed\uff0c\u5f15\u8d77\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\u3002\u6211\u4eec\u4fee\u6539\u4e00\u4e0b\u4ee3\u7801\u3002 1 2 3 4 const fs = require ( 'fs' ); const stream = fs . createWriteStream ( '123.md' ); stream . end ( 'hello' ); setInterval (() => {}); \u4e0b\u9762\u662f\u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa\uff0c\u6211\u4eec\u770b\u5230\u6ca1\u6709123.md\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5982\u56fe12-7\u6240\u793a\u3002 \u56fe12-7 \u6211\u4eec\u7ee7\u7eed\u4fee\u6539\u4ee3\u7801 1 2 3 4 const fs = require ( 'fs' ); const stream = fs . createWriteStream ( '123.md' , { autoClose : false }); stream . end ( 'hello' ); setInterval (() => {}); \u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa\u5982\u56fe12-8\u6240\u793a\u3002 \u56fe12-8 \u6211\u4eec\u770b\u5230\u4f7f\u7528end\u4e5f\u65e0\u6cd5\u5173\u95ed\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u7ee7\u7eed\u4fee\u6539\u3002 1 2 3 4 const fs = require ( 'fs' ); const stream = fs . createWriteStream ( '123.md' , { autoClose : false }) stream . close (); setInterval (() => {}); \u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa\u5982\u56fe12-9\u6240\u793a\u3002 \u56fe12-9 \u6211\u4eec\u770b\u5230\u6210\u529f\u5173\u95ed\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002","title":"12.5.2 \u53ef\u5199\u6587\u4ef6\u6d41"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/","text":"\u8fdb\u7a0b\u662f\u64cd\u4f5c\u7cfb\u7edf\u91cc\u975e\u5e38\u91cd\u8981\u7684\u6982\u5ff5\uff0c\u4e5f\u662f\u4e0d\u5bb9\u6613\u7406\u89e3\u7684\u6982\u5ff5\uff0c\u4f46\u662f\u770b\u8d77\u6765\u5f88\u590d\u6742\u7684\u8fdb\u7a0b\uff0c\u5176\u5b9e\u5728\u64cd\u4f5c\u7cfb\u7edf\u7684\u4ee3\u7801\u91cc\uff0c\u4e5f\u53ea\u662f\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u548c\u7b97\u6cd5\uff0c\u53ea\u4e0d\u8fc7\u5b83\u6bd4\u4e00\u822c\u7684\u6570\u636e\u7ed3\u6784\u548c\u7b97\u6cd5\u66f4\u590d\u6742\u3002\u8fdb\u7a0b\u5728\u64cd\u4f5c\u7cfb\u7edf\u91cc\uff0c\u662f\u7528\u4e00\u4e2atask_struct\u7ed3\u6784\u4f53\u8868\u793a\u7684\u3002\u56e0\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u662f\u5927\u90e8\u5206\u662f\u7528C\u8bed\u8a00\u5b9e\u73b0\u7684\uff0c\u6ca1\u6709\u5bf9\u8c61\u8fd9\u4e2a\u6982\u5ff5\u3002\u5982\u679c\u6211\u4eec\u7528JS\u6765\u7406\u89e3\u7684\u8bdd\uff0c\u6bcf\u4e2a\u8fdb\u7a0b\u5c31\u662f\u4e00\u4e2a\u5bf9\u8c61\uff0c\u6bcf\u6b21\u65b0\u5efa\u4e00\u4e2a\u8fdb\u7a0b\uff0c\u5c31\u662f\u65b0\u5efa\u4e00\u4e2a\u5bf9\u8c61\u3002task_struct\u7ed3\u6784\u4f53\u91cc\u4fdd\u5b58\u4e86\u4e00\u4e2a\u8fdb\u7a0b\u6240\u9700\u8981\u7684\u4e00\u4e9b\u4fe1\u606f\uff0c\u5305\u62ec\u6267\u884c\u72b6\u6001\u3001\u6267\u884c\u4e0a\u4e0b\u6587\u3001\u6253\u5f00\u7684\u6587\u4ef6\u3001\u6839\u76ee\u5f55\u3001\u5de5\u4f5c\u76ee\u5f55\u3001\u6536\u5230\u7684\u4fe1\u53f7\u3001\u4fe1\u53f7\u5904\u7406\u51fd\u6570\u3001\u4ee3\u7801\u6bb5\u3001\u6570\u636e\u6bb5\u7684\u4fe1\u606f\u3001\u8fdb\u7a0bid\u3001\u6267\u884c\u65f6\u95f4\u3001\u9000\u51fa\u7801\u7b49\u7b49\u3002\u672c\u7ae0\u5c06\u4f1a\u4ecb\u7ecdNode.js\u8fdb\u7a0b\u6a21\u5757\u7684\u539f\u7406\u548c\u5b9e\u73b0\u3002 13.1 Node.js\u4e3b\u8fdb\u7a0b \u00b6 \u5f53\u6211\u4eec\u6267\u884cnode index.js\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u521b\u5efa\u4e00\u4e2aNode.js\u8fdb\u7a0b\uff0c\u6211\u4eec\u7684\u4ee3\u7801\u5c31\u662f\u5728\u8fd9\u4e2aNode.js\u8fdb\u7a0b\u4e2d\u6267\u884c\u3002\u4ece\u4ee3\u7801\u89d2\u5ea6\u6765\u8bf4\uff0c\u6211\u4eec\u5728Node.js\u4e2d\u611f\u77e5\u8fdb\u7a0b\u7684\u65b9\u5f0f\u662f\u901a\u8fc7process\u5bf9\u8c61\u3002\u672c\u8282\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u8fd9\u4e2a\u5bf9\u8c61\u3002 13.1.1 \u521b\u5efaprocess\u5bf9\u8c61 \u00b6 Node.js\u542f\u52a8\u7684\u65f6\u5019\u4f1a\u6267\u884c\u4ee5\u4e0b\u4ee3\u7801\u521b\u5efaprocess\u5bf9\u8c61\uff08env.cc\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Local < Object > process_object = node :: CreateProcessObject ( this ). FromMaybe ( Local < Object > ()); set_process_object ( process_object ); // process\u5bf9\u8c61\u901a\u8fc7CreateProcessObject\u521b\u5efa\uff0c\u7136\u540e\u4fdd\u5b58\u5230env\u5bf9\u8c61\u4e2d\u3002\u6211\u4eec\u770b\u4e00\u4e0bCreateProcessObject\u3002 MaybeLocal < Object > CreateProcessObject ( Environment * env ) { Isolate * isolate = env -> isolate (); EscapableHandleScope scope ( isolate ); Local < Context > context = env -> context (); Local < FunctionTemplate > process_template = FunctionTemplate :: New ( isolate ); process_template -> SetClassName ( env -> process_string ()); Local < Function > process_ctor ; Local < Object > process ; // \u65b0\u5efaprocess\u5bf9\u8c61 if ( ! process_template -> GetFunction ( context ). ToLocal ( & process_ctor ) || ! process_ctor -> NewInstance ( context ). ToLocal ( & process )) { return MaybeLocal < Object > (); } // \u8bbe\u7f6e\u4e00\u7cfb\u5217\u5c5e\u6027\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u901a\u8fc7process\u5bf9\u8c61\u8bbf\u95ee\u7684\u5c5e\u6027 // Node.js\u7684\u7248\u672c READONLY_PROPERTY ( process , \"version\" , FIXED_ONE_BYTE_STRING ( env -> isolate (), NODE_VERSION )); // \u5ffd\u7565\u5176\u4ed6\u5c5e\u6027 return scope . Escape ( process ); } \u8fd9\u662f\u4f7f\u7528V8\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u7684\u5178\u578b\u4f8b\u5b50\uff0c\u5e76\u4e14\u8bbe\u7f6e\u4e86\u4e00\u4e9b\u5c5e\u6027\u3002Node.js\u542f\u52a8\u8fc7\u7a0b\u4e2d\uff0c\u5f88\u591a\u5730\u65b9\u90fd\u4f1a\u7ed9process\u6302\u8f7d\u5c5e\u6027\u3002\u4e0b\u9762\u6211\u4eec\u770b\u6211\u4eec\u5e38\u7528\u7684process.env\u662f\u600e\u4e48\u6302\u8f7d\u7684\u3002 13.1.2 \u6302\u8f7denv\u5c5e\u6027 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 Local < String > env_string = FIXED_ONE_BYTE_STRING ( isolate_ , \"env\" ); Local < Object > env_var_proxy ; // \u8bbe\u7f6eprocess\u7684env\u5c5e\u6027 if ( ! CreateEnvVarProxy ( context (), isolate_ , as_callback_data ()) . ToLocal ( & env_var_proxy ) || process_object () -> Set ( context (), env_string , env_var_proxy ). IsNothing ()) { return MaybeLocal < Value > (); } \u4e0a\u9762\u7684\u4ee3\u7801\u901a\u8fc7CreateEnvVarProxy\u521b\u5efa\u4e86\u4e00\u4e2a\u5bf9\u8c61\uff0c\u7136\u540e\u4fdd\u5b58\u5230env_var_proxy\u4e2d\uff0c\u6700\u540e\u7ed9process\u6302\u8f7d\u4e86env\u5c5e\u6027\u3002\u5b83\u7684\u503c\u662fCreateEnvVarProxy\u521b\u5efa\u7684\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 MaybeLocal < Object > CreateEnvVarProxy ( Local < Context > context , Isolate * isolate , Local < Object > data ) { EscapableHandleScope scope ( isolate ); Local < ObjectTemplate > env_proxy_template = ObjectTemplate :: New ( isolate ); env_proxy_template -> SetHandler ( NamedPropertyHandlerConfiguration ( EnvGetter , EnvSetter , EnvQuery , EnvDeleter , EnvEnumerator , data , PropertyHandlerFlags :: kHasNoSideEffect )); return scope . EscapeMaybe ( env_proxy_template -> NewInstance ( context )); } CreateEnvVarProxy\u9996\u5148\u7533\u8bf7\u4e00\u4e2a\u5bf9\u8c61\u6a21\u677f\uff0c\u7136\u540e\u8bbe\u7f6e\u901a\u8fc7\u8be5\u5bf9\u8c61\u6a21\u677f\u521b\u5efa\u7684\u5bf9\u8c61\u7684\u8bbf\u95ee\u63cf\u8ff0\u7b26\u3002\u6211\u4eec\u770b\u4e00\u4e0bgetter\u63cf\u8ff0\u7b26\uff08EnvGetter\uff09\u7684\u5b9e\u73b0\uff0cgetter\u63cf\u8ff0\u7b26\u548c\u6211\u4eec\u5728JS\u91cc\u4f7f\u7528\u7684\u7c7b\u4f3c\u3002 1 2 3 4 5 6 7 8 static void EnvGetter ( Local < Name > property , const PropertyCallbackInfo < Value >& info ) { Environment * env = Environment :: GetCurrent ( info ); MaybeLocal < String > value_string = env -> env_vars () -> Get ( env -> isolate (), property . As < String > ()); if ( ! value_string . IsEmpty ()) { info . GetReturnValue (). Set ( value_string . ToLocalChecked ()); } } \u6211\u4eec\u770b\u5230getter\u662f\u4eceenv->env_vars()\u4e2d\u83b7\u53d6\u6570\u636e\uff0c\u90a3\u4e48env->env_vars()\u53c8\u662f\u4ec0\u4e48\u5462\uff1fenv_vars\u662f\u4e00\u4e2akv\u5b58\u50a8\u7cfb\u7edf\uff0c\u5176\u5b9e\u5c31\u662f\u4e00\u4e2amap\u3002\u5b83\u53ea\u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\uff08\u521b\u5efaenv\u5bf9\u8c61\u65f6\uff09\u3002 1 set_env_vars ( per_process :: system_environment ); \u90a3\u4e48per_process::system_environment\u53c8\u662f\u4ec0\u4e48\u5462\uff1f\u6211\u4eec\u7ee7\u7eed\u5f80\u4e0b\u770b\uff0c 1 std :: shared_ptr < KVStore > system_environment = std :: make_shared < RealEnvStore > (); \u6211\u4eec\u770b\u5230system_environment\u662f\u4e00\u4e2aRealEnvStore\u5bf9\u8c61\u3002\u6211\u4eec\u770b\u4e00\u4e0bRealEnvStore\u7c7b\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 class RealEnvStore final : public KVStore { public : MaybeLocal < String > Get ( Isolate * isolate , Local < String > key ) const override ; void Set ( Isolate * isolate , Local < String > key , Local < String > value ) override ; int32_t Query ( Isolate * isolate , Local < String > key ) const override ; void Delete ( Isolate * isolate , Local < String > key ) override ; Local < Array > Enumerate ( Isolate * isolate ) const override ; }; \u6bd4\u8f83\u7b80\u5355\uff0c\u5c31\u662f\u589e\u5220\u6539\u67e5\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u67e5\u8be2Get\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 MaybeLocal < String > RealEnvStore :: Get ( Isolate * isolate , Local < String > property ) const { Mutex :: ScopedLock lock ( per_process :: env_var_mutex ); node :: Utf8Value key ( isolate , property ); size_t init_sz = 256 ; MaybeStackBuffer < char , 256 > val ; int ret = uv_os_getenv ( * key , * val , & init_sz ); if ( ret >= 0 ) { // Env key value fetch success. MaybeLocal < String > value_string = String :: NewFromUtf8 ( isolate , * val , NewStringType :: kNormal , init_sz ); return value_string ; } return MaybeLocal < String > (); } \u6211\u4eec\u770b\u5230\u662f\u901a\u8fc7uv_os_getenv\u83b7\u53d6\u7684\u6570\u636e\u3002uv_os_getenv\u662f\u5bf9getenv\u51fd\u6570\u7684\u5c01\u88c5\uff0c\u8fdb\u7a0b\u7684\u5185\u5b58\u5e03\u5c40\u4e2d\uff0c\u6709\u4e00\u90e8\u5206\u662f\u7528\u4e8e\u5b58\u50a8\u73af\u5883\u53d8\u91cf\u7684\uff0cgetenv\u5c31\u662f\u4ece\u90a3\u4e00\u5757\u5185\u5b58\u4e2d\u628a\u6570\u636e\u8bfb\u53d6\u51fa\u6765\u3002\u6211\u4eec\u6267\u884cexecve\u7684\u65f6\u5019\u53ef\u4ee5\u8bbe\u7f6e\u73af\u5883\u53d8\u91cf\u3002\u5177\u4f53\u7684\u6211\u4eec\u5728\u5b50\u8fdb\u7a0b\u7ae0\u8282\u4f1a\u770b\u5230\u3002\u81f3\u6b64\uff0c\u6211\u4eec\u77e5\u9053process\u7684env\u5c5e\u6027\u5bf9\u5e94\u7684\u503c\u5c31\u662f\u8fdb\u7a0b\u73af\u5883\u53d8\u91cf\u7684\u5185\u5bb9\u3002 13.1.3 \u6302\u8f7d\u5176\u5b83\u5c5e\u6027 \u00b6 \u5728Node.js\u7684\u542f\u52a8\u8fc7\u7a0b\u4e2d\u4f1a\u4e0d\u65ad\u5730\u6302\u8f7d\u5c5e\u6027\u5230process\u3002\u4e3b\u8981\u5728bootstrap/node.js\u4e2d\u3002\u4e0d\u4e00\u4e00\u5217\u4e3e\u3002 1 2 3 4 const rawMethods = internalBinding ( 'process_methods' ); process . dlopen = rawMethods . dlopen ; process . uptime = rawMethods . uptime ; process . nextTick = nextTick ; \u4e0b\u9762\u662fprocess_methods\u6a21\u5757\u5bfc\u51fa\u7684\u5c5e\u6027\uff0c\u4e3b\u5217\u51fa\u5e38\u7528\u7684\u3002 1 2 3 4 5 env -> SetMethod ( target , \"memoryUsage\" , MemoryUsage ); env -> SetMethod ( target , \"cpuUsage\" , CPUUsage ); env -> SetMethod ( target , \"hrtime\" , Hrtime ); env -> SetMethod ( target , \"dlopen\" , binding :: DLOpen ); env -> SetMethodNoSideEffect ( target , \"uptime\" , Uptime ); \u6211\u4eec\u770b\u5230\u5728JS\u5c42\u8bbf\u95eeprocess\u5c5e\u6027\u7684\u65f6\u5019\uff0c\u8bbf\u95ee\u7684\u662f\u5bf9\u5e94\u7684C++\u5c42\u7684\u8fd9\u4e9b\u65b9\u6cd5\uff0c\u5927\u90e8\u5206\u4e5f\u53ea\u662f\u5bf9Libuv\u7684\u5c01\u88c5\u3002\u53e6\u5916\u5728Node.js\u521d\u59cb\u5316\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u6267\u884cPatchProcessObject\u3002PatchProcessObject\u51fd\u6570\u4f1a\u6302\u8f7d\u4e00\u4e9b\u989d\u5916\u7684\u5c5e\u6027\u7ed9process\u3002 1 2 3 4 5 6 7 8 9 10 11 12 // process.argv process -> Set ( context , FIXED_ONE_BYTE_STRING ( isolate , \"argv\" ), ToV8Value ( context , env -> argv ()). ToLocalChecked ()). Check (); READONLY_PROPERTY ( process , \"pid\" , Integer :: New ( isolate , uv_os_getpid ())); CHECK ( process -> SetAccessor ( context , FIXED_ONE_BYTE_STRING ( isolate , \"ppid\" ), GetParentProcessId ). FromJust ()) \u5728Node.js\u521d\u59cb\u5316\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5728\u591a\u4e2a\u5730\u65b9\u90fd\u4f1a\u7ed9process\u5bf9\u8c61\u6302\u8f7d\u5c5e\u6027\uff0c\u8fd9\u91cc\u53ea\u5217\u51fa\u4e86\u4e00\u90e8\u5206\uff0c\u6709\u5174\u8da3\u7684\u540c\u5b66\u53ef\u4ee5\u4ecebootstrap/node.js\u7684\u4ee3\u7801\u5f00\u59cb\u770b\u90fd\u6302\u8f7d\u4e86\u4ec0\u4e48\u5c5e\u6027\u3002\u56e0\u4e3aNode.js\u652f\u6301\u591a\u7ebf\u7a0b\uff0c\u6240\u4ee5\u9488\u5bf9\u7ebf\u7a0b\u7684\u60c5\u51b5\uff0c\u6709\u4e00\u4e9b\u7279\u6b8a\u7684\u5904\u7406\u3002 1 2 3 4 5 6 7 8 const perThreadSetup = require ( 'internal/process/per_thread' ); // rawMethods\u6765\u81eaprocess_methods\u6a21\u5757\u5bfc\u51fa\u7684\u5c5e\u6027 const wrapped = perThreadSetup . wrapProcessMethods ( rawMethods ); process . hrtime = wrapped . hrtime ; process . cpuUsage = wrapped . cpuUsage ; process . memoryUsage = wrapped . memoryUsage ; process . kill = wrapped . kill ; process . exit = wrapped . exit ; \u5927\u90e8\u5206\u51fd\u6570\u90fd\u662f\u5bf9process_methods\u6a21\u5757\uff08node_process_methods.cc\uff09\u7684\u5c01\u88c5\u3002\u4f46\u662f\u6709\u4e00\u4e2a\u5c5e\u6027\u6211\u4eec\u9700\u8981\u5173\u6ce8\u4e00\u4e0b\uff0c\u5c31\u662fexit\uff0c\u56e0\u4e3a\u5728\u7ebf\u7a0b\u4e2d\u8c03\u7528process.exit\u7684\u65f6\u5019\uff0c\u53ea\u4f1a\u9000\u51fa\u5355\u4e2a\u7ebf\u7a0b\uff0c\u800c\u4e0d\u662f\u6574\u4e2a\u8fdb\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 function exit ( code ) { if ( code || code === 0 ) process . exitCode = code ; if ( ! process . _exiting ) { process . _exiting = true ; process . emit ( 'exit' , process . exitCode || 0 ); } process . reallyExit ( process . exitCode || 0 ); } \u6211\u4eec\u7ee7\u7eed\u770breallyExit 1 2 3 4 5 6 static void ReallyExit ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); RunAtExit ( env ); int code = args [ 0 ] -> Int32Value ( env -> context ()). FromMaybe ( 0 ); env -> Exit ( code ); } \u8c03\u7528\u4e86env\u7684Exit\u3002 1 2 3 4 5 6 7 8 9 void Environment::Exit ( int exit_code ) { if ( is_main_thread ()) { stop_sub_worker_contexts (); DisposePlatform (); exit ( exit_code ); } else { worker_context_ -> Exit ( exit_code ); } } \u8fd9\u91cc\u6211\u4eec\u770b\u5230\u4e86\u91cd\u70b9\uff0c\u6839\u636e\u5f53\u524d\u662f\u4e3b\u7ebf\u7a0b\u8fd8\u662f\u5b50\u7ebf\u7a0b\u4f1a\u505a\u4e0d\u540c\u7684\u5904\u7406\u3002\u4e00\u4e2a\u7ebf\u7a0b\u4f1a\u5bf9\u5e94\u4e00\u4e2aenv\uff0cenv\u5bf9\u8c61\u4e2d\u7684worker_context_\u4fdd\u5b58\u5c31\u662f\u7ebf\u7a0b\u5bf9\u8c61\uff08Worker\uff09\u3002\u6211\u4eec\u5148\u770b\u5b50\u7ebf\u7a0b\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void Worker::Exit ( int code ) { Mutex :: ScopedLock lock ( mutex_ ); if ( env_ != nullptr ) { exit_code_ = code ; Stop ( env_ ); } else { stopped_ = true ; } } int Stop ( Environment * env ) { env -> ExitEnv (); return 0 ; } void Environment::ExitEnv () { set_can_call_into_js ( false ); set_stopping ( true ); isolate_ -> TerminateExecution (); // \u9000\u51faLibuv\u4e8b\u4ef6\u5faa\u73af SetImmediateThreadsafe ([]( Environment * env ) { uv_stop ( env -> event_loop ()); }); } \u6211\u4eec\u770b\u5230\u5b50\u7ebf\u7a0b\u6700\u540e\u8c03\u7528uv_stop\u63d0\u51fa\u4e86Libuv\u4e8b\u4ef6\u5faa\u73af\uff0c\u7136\u540e\u9000\u51fa\u3002\u6211\u4eec\u518d\u6765\u770b\u4e3b\u7ebf\u7a0b\u7684\u9000\u51fa\u903b\u8f91\u3002 1 2 3 4 5 if ( is_main_thread ()) { stop_sub_worker_contexts (); DisposePlatform (); exit ( exit_code ); } \u6211\u4eec\u770b\u5230\u6700\u540e\u4e3b\u8fdb\u7a0b\u4e2d\u8c03\u7528exit\u9000\u51fa\u8fdb\u7a0b\u3002\u4f46\u662f\u9000\u51fa\u524d\u8fd8\u6709\u4e00\u4e9b\u5904\u7406\u5de5\u4f5c\uff0c\u6211\u4eec\u770bstop_sub_worker_contexts 1 2 3 4 5 6 7 8 void Environment::stop_sub_worker_contexts () { while ( ! sub_worker_contexts_ . empty ()) { Worker * w = * sub_worker_contexts_ . begin (); remove_sub_worker_context ( w ); w -> Exit ( 1 ); w -> JoinThread (); } } sub_worker_contexts\u4fdd\u5b58\u7684\u662fWorker\u5bf9\u8c61\u5217\u8868\uff0c\u6bcf\u6b21\u521b\u5efa\u4e00\u4e2a\u7ebf\u7a0b\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u5f80\u91cc\u8ffd\u52a0\u4e00\u4e2a\u5143\u7d20\u3002\u8fd9\u91cc\u904d\u5386\u8fd9\u4e2a\u5217\u8868\uff0c\u7136\u540e\u8c03\u7528Exit\u51fd\u6570\uff0c\u8fd9\u4e2a\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u5c31\u662f\u9000\u51faLibuv\u4e8b\u4ef6\u5faa\u73af\u3002\u4e3b\u7ebf\u7a0b\u63a5\u7740\u8c03JoinThread\uff0cJoinThread\u4e3b\u8981\u662f\u4e3a\u4e86\u963b\u585e\u7b49\u5f85\u5b50\u7ebf\u7a0b\u9000\u51fa\uff0c\u56e0\u4e3a\u5b50\u7ebf\u7a0b\u5728\u9000\u51fa\u7684\u65f6\u5019\uff0c\u53ef\u80fd\u4f1a\u88ab\u64cd\u4f5c\u7cfb\u7edf\u6302\u8d77\uff08\u6267\u884c\u65f6\u95f4\u7247\u5230\u4e86\uff09\uff0c\u8fd9\u65f6\u5019\u4e3b\u7ebf\u7a0b\u88ab\u8c03\u5ea6\u6267\u884c\uff0c\u4f46\u662f\u8fd9\u65f6\u5019\u4e3b\u7ebf\u7a0b\u8fd8\u4e0d\u80fd\u9000\u51fa\uff0c\u6240\u4ee5\u8fd9\u91cc\u4f7f\u7528join\u963b\u585e\u7b49\u5f85\u5b50\u7ebf\u7a0b\u9000\u51fa\u3002Node.js\u7684JoinThread\u9664\u4e86\u5bf9\u7ebf\u7a0bjoin\u51fd\u6570\u7684\u5c01\u88c5\u3002\u8fd8\u505a\u4e86\u4e00\u4e9b\u989d\u5916\u7684\u4e8b\u60c5\uff0c\u6bd4\u5982\u89e6\u53d1exit\u4e8b\u4ef6\u3002 13.2 \u521b\u5efa\u5b50\u8fdb\u7a0b \u00b6 \u56e0\u4e3aNode.js\u662f\u5355\u8fdb\u7a0b\u7684\uff0c\u4f46\u6709\u5f88\u591a\u4e8b\u60c5\u53ef\u80fd\u4e0d\u9002\u5408\u5728\u4e3b\u8fdb\u7a0b\u91cc\u5904\u7406\u7684\uff0c\u6240\u4ee5Node.js\u63d0\u4f9b\u4e86\u5b50\u8fdb\u7a0b\u6a21\u5757\uff0c\u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u5b50\u8fdb\u7a0b\u505a\u4e00\u4e9b\u989d\u5916\u4efb\u52a1\u7684\u5904\u7406\uff0c\u53e6\u5916\uff0c\u5b50\u8fdb\u7a0b\u7684\u597d\u5904\u662f\uff0c\u4e00\u65e6\u5b50\u8fdb\u7a0b\u51fa\u95ee\u9898\u6302\u6389\u4e0d\u4f1a\u5f71\u54cd\u4e3b\u8fdb\u7a0b\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5728\u7528C\u8bed\u8a00\u5982\u4f55\u521b\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <unistd.h> #include <stdlib.h> int main ( int argc , char * argv []){ pid_t pid = fork (); if ( pid < 0 ) { // \u9519\u8bef } else if ( pid == 0 ) { // \u5b50\u8fdb\u7a0b\uff0c\u53ef\u4ee5\u4f7f\u7528exec*\u7cfb\u5217\u51fd\u6570\u6267\u884c\u65b0\u7684\u7a0b\u5e8f } else { // \u7236\u8fdb\u7a0b } } fork\u51fd\u6570\u7684\u7279\u70b9\uff0c\u6211\u4eec\u542c\u5f97\u6700\u591a\u7684\u53ef\u80fd\u662f\u6267\u884c\u4e00\u6b21\u8fd4\u56de\u4e24\u6b21\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u7591\u60d1\uff0c\u6267\u884c\u4e00\u4e2a\u51fd\u6570\u600e\u4e48\u53ef\u80fd\u8fd4\u56de\u4e86\u4e24\u6b21\u5462\uff1f\u4e4b\u524d\u6211\u4eec\u8bb2\u8fc7\uff0c\u8fdb\u7a0b\u662ftask_struct\u8868\u793a\u7684\u4e00\u4e2a\u5b9e\u4f8b\uff0c\u8c03\u7528 fork\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u65b0\u5efa\u4e00\u4e2a\u65b0\u7684task_struct\u5b9e\u4f8b\u51fa\u6765\uff08\u53d8\u6210\u4e24\u4e2a\u8fdb\u7a0b\uff09\uff0cfork\u8fd4\u56de\u4e24\u6b21\u7684\u610f\u601d\u5176\u5b9e\u662f\u5728\u5728\u4e24\u4e2a\u8fdb\u7a0b\u5206\u522b\u8fd4\u56de\u4e00\u6b21\uff0c\u6267\u884c\u7684\u90fd\u662ffork\u540e\u9762\u7684\u4e00\u884c\u4ee3\u7801\u3002\u800c\u64cd\u4f5c\u7cfb\u7edf\u6839\u636e\u5f53\u524d\u8fdb\u7a0b\u662f\u4e3b\u8fdb\u7a0b\u8fd8\u662f\u5b50\u8fdb\u7a0b\uff0c\u8bbe\u7f6e\u4e86fork\u51fd\u6570\u7684\u8fd4\u56de\u503c\u3002\u6240\u4ee5\u4e0d\u540c\u7684\u8fdb\u7a0b\uff0cfork\u8fd4\u56de\u503c\u4e0d\u4e00\u6837\uff0c\u4e5f\u5c31\u662f\u6211\u4eec\u4ee3\u7801\u4e2dif else\u6761\u4ef6\u3002\u4f46\u662ffork\u53ea\u662f\u590d\u5236\u4e3b\u8fdb\u7a0b\u7684\u5185\u5bb9\uff0c\u5982\u679c\u6211\u4eec\u60f3\u6267\u884c\u53e6\u5916\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u600e\u4e48\u529e\u5462\uff1f\u8fd9\u65f6\u5019\u5c31\u9700\u8981\u7528\u5230exec*\u7cfb\u5217\u51fd\u6570\uff0c\u8be5\u7cfb\u5217\u51fd\u6570\u4f1a\u8986\u76d6\u65e7\u8fdb\u7a0b\uff08task_struct\uff09\u7684\u90e8\u5206\u5185\u5bb9\uff0c\u91cd\u65b0\u52a0\u8f7d\u65b0\u7684\u7a0b\u5e8f\u5185\u5bb9\u3002\u8fd9\u4e5f\u662fNode.js\u4e2d\u521b\u5efa\u5b50\u8fdb\u7a0b\u7684\u5e95\u5c42\u539f\u7406\u3002Node.js\u867d\u7136\u63d0\u4f9b\u4e86\u5f88\u591a\u79cd\u521b\u5efa\u8fdb\u7a0b\u7684\u65b9\u5f0f\uff0c\u4f46\u662f\u672c\u8d28\u4e0a\u662f\u540c\u6b65\u548c\u5f02\u6b65\u4e24\u79cd\u65b9\u5f0f\u3002 13.2.1 \u5f02\u6b65\u521b\u5efa\u8fdb\u7a0b \u00b6 \u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5f02\u6b65\u65b9\u5f0f\u521b\u5efa\u8fdb\u7a0b\u65f6\u7684\u5173\u7cfb\u56fe\u5982\u56fe13-1\u6240\u793a\u3002 \u56fe13-1 \u6211\u4eec\u4ecefork\u8fd9\u4e2a\u51fd\u6570\u5f00\u59cb\uff0c\u770b\u4e00\u4e0b\u6574\u4e2a\u6d41\u7a0b\u3002 1 2 3 4 function fork ( modulePath /* , args, options */ ) { // \u4e00\u7cfb\u5217\u53c2\u6570\u5904\u7406 return spawn ( options . execPath , args , options ); } \u6211\u4eec\u63a5\u7740\u770bspawn 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var spawn = exports . spawn = function ( /*file, args, options*/ ) { var opts = normalizeSpawnArguments . apply ( null , arguments ); var options = opts . options ; var child = new ChildProcess (); child . spawn ({ file : opts . file , args : opts . args , cwd : options . cwd , windowsHide : !! options . windowsHide , windowsVerbatimArguments : !! options . windowsVerbatimArguments , detached : !! options . detached , envPairs : opts . envPairs , stdio : options . stdio , uid : options . uid , gid : options . gid }); return child ; }; \u6211\u4eec\u770b\u5230spawn\u51fd\u6570\u53ea\u662f\u5bf9ChildProcess\u7684\u5c01\u88c5\u3002\u7136\u540e\u8c03\u7528\u5b83\u7684spawn\u51fd\u6570\u3002\u6211\u4eec\u770b\u770bChildProcess\u3002 1 2 3 4 5 6 7 8 9 function ChildProcess () { // C++\u5c42\u5b9a\u4e49 this . _handle = new Process (); } ChildProcess . prototype . spawn = function ( options ) { // \u521b\u5efa\u8fdb\u7a0b const err = this . _handle . spawn ( options ); } ChildProcess\u662f\u5bf9C++\u5c42\u7684\u5c01\u88c5\uff0c\u4e0d\u8fc7Process\u5728C++\u5c42\u4e5f\u6ca1\u6709\u592a\u591a\u903b\u8f91\uff0c\u8fdb\u884c\u53c2\u6570\u7684\u5904\u7406\u7136\u540e\u8c03\u7528Libuv\u7684uv_spawn\u3002\u6211\u4eec\u901a\u8fc7uv_spawn\u6765\u5230\u4e86C\u8bed\u8a00\u5c42\u3002\u6211\u4eec\u770b\u770buv_spawn\u7684\u6574\u4f53\u6d41\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 int uv_spawn ( uv_loop_t * loop , uv_process_t * process , const uv_process_options_t * options ) { uv__handle_init ( loop , ( uv_handle_t * ) process , UV_PROCESS ); QUEUE_INIT ( & process -> queue ); // \u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1 for ( i = 0 ; i < options -> stdio_count ; i ++ ) { err = uv__process_init_stdio ( options -> stdio + i , pipes [ i ]); if ( err ) goto error ; } /* \u521b\u5efa\u4e00\u4e2a\u7ba1\u9053\u7528\u4e8e\u521b\u5efa\u8fdb\u7a0b\u671f\u95f4\u7684\u7236\u8fdb\u7a0b\u5b50\u901a\u4fe1\uff0c \u8bbe\u7f6eUV__O_CLOEXEC\u6807\u8bb0\uff0c\u5b50\u8fdb\u7a0b\u6267\u884cexecvp \u7684\u65f6\u5019\u7ba1\u9053\u7684\u4e00\u7aef\u4f1a\u88ab\u5173\u95ed */ err = uv__make_pipe ( signal_pipe , 0 ); // \u6ce8\u518c\u5b50\u8fdb\u7a0b\u9000\u51fa\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570 uv_signal_start ( & loop -> child_watcher , uv__chld , SIGCHLD ); uv_rwlock_wrlock ( & loop -> cloexec_lock ); // \u521b\u5efa\u5b50\u8fdb\u7a0b pid = fork (); // \u5b50\u8fdb\u7a0b if ( pid == 0 ) { uv__process_child_init ( options , stdio_count , pipes , signal_pipe [ 1 ]); abort (); } // \u7236\u8fdb\u7a0b uv_rwlock_wrunlock ( & loop -> cloexec_lock ); // \u5173\u95ed\u7ba1\u9053\u5199\u7aef\uff0c\u7b49\u5f85\u5b50\u8fdb\u7a0b\u5199 uv__close ( signal_pipe [ 1 ]); process -> status = 0 ; exec_errorno = 0 ; // \u5224\u65ad\u5b50\u8fdb\u7a0b\u662f\u5426\u6267\u884c\u6210\u529f do r = read ( signal_pipe [ 0 ], & exec_errorno , sizeof ( exec_errorno )); while ( r == -1 && errno == EINTR ); // \u5ffd\u7565\u5904\u7406r\u7684\u903b\u8f91 // \u4fdd\u5b58\u901a\u4fe1\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5230\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784 for ( i = 0 ; i < options -> stdio_count ; i ++ ) { uv__process_open_stream ( options -> stdio + i , pipes [ i ]); } // \u63d2\u5165Libuv\u4e8b\u4ef6\u5faa\u73af\u7684\u7ed3\u6784\u4f53 if ( exec_errorno == 0 ) { QUEUE_INSERT_TAIL ( & loop -> process_handles , & process -> queue ); uv__handle_start ( process ); } process -> pid = pid ; process -> exit_cb = options -> exit_cb ; return exec_errorno ; } uv_spawn\u7684\u903b\u8f91\u5927\u81f4\u5206\u4e3a\u4e0b\u9762\u51e0\u4e2a 1 \u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1 2 \u6ce8\u518c\u5b50\u8fdb\u7a0b\u9000\u51fa\u5904\u7406\u51fd\u6570 3 \u521b\u5efa\u5b50\u8fdb\u7a0b 4 \u63d2\u5165Libuv\u4e8b\u4ef6\u5faa\u73af\u7684process_handles\u5bf9\u8c61\uff0c\u4fdd\u5b58\u72b6\u6001\u7801\u548c\u56de\u8c03\u7b49\u3002 \u6211\u4eec\u5206\u67902,3\uff0c\u8fdb\u7a0b\u95f4\u901a\u4fe1\u6211\u4eec\u5355\u72ec\u5206\u6790\u3002 1 \u5904\u7406\u5b50\u8fdb\u7a0b\u9000\u51fa \u4e3b\u8fdb\u7a0b\u5728\u521b\u5efa\u5b50\u8fdb\u7a0b\u4e4b\u524d\uff0c\u4f1a\u6ce8\u518cSIGCHLD\u4fe1\u53f7\u3002\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\u662fuv__chld\u3002\u5f53\u8fdb\u7a0b\u9000\u51fa\u7684\u65f6\u5019\u3002Node.js\u4e3b\u8fdb\u7a0b\u4f1a\u6536\u5230SIGCHLD\u4fe1\u53f7\u3002\u7136\u540e\u6267\u884cuv__chld\u3002\u8be5\u51fd\u6570\u904d\u5386Libuv\u8fdb\u7a0b\u961f\u5217\u4e2d\u7684\u8282\u70b9\uff0c\u901a\u8fc7waitpid\u5224\u65ad\u8be5\u8282\u70b9\u5bf9\u5e94\u7684\u8fdb\u7a0b\u662f\u5426\u5df2\u7ecf\u9000\u51fa\u540e\uff0c\u4ece\u800c\u5904\u7406\u5df2\u9000\u51fa\u7684\u8282\u70b9\uff0c\u7136\u540e\u79fb\u51faLibuv\u961f\u5217\uff0c\u6700\u540e\u6267\u884c\u5df2\u9000\u51fa\u8fdb\u7a0b\u7684\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 static void uv__chld ( uv_signal_t * handle , int signum ) { uv_process_t * process ; uv_loop_t * loop ; int exit_status ; int term_signal ; int status ; pid_t pid ; QUEUE pending ; QUEUE * q ; QUEUE * h ; // \u4fdd\u5b58\u8fdb\u7a0b\uff08\u5df2\u9000\u51fa\u7684\u72b6\u6001\uff09\u7684\u961f\u5217 QUEUE_INIT ( & pending ); loop = handle -> loop ; h = & loop -> process_handles ; q = QUEUE_HEAD ( h ); // \u6536\u96c6\u5df2\u9000\u51fa\u7684\u8fdb\u7a0b while ( q != h ) { process = QUEUE_DATA ( q , uv_process_t , queue ); q = QUEUE_NEXT ( q ); do /* WNOHANG\u975e\u963b\u585e\u7b49\u5f85\u5b50\u8fdb\u7a0b\u9000\u51fa\uff0c\u5176\u5b9e\u5c31\u662f\u770b\u5b50\u8fdb\u7a0b\u662f\u5426\u9000\u51fa\u4e86\uff0c \u6ca1\u6709\u7684\u8bdd\u5c31\u76f4\u63a5\u8fd4\u56de\uff0c\u800c\u4e0d\u662f\u963b\u585e */ pid = waitpid ( process -> pid , & status , WNOHANG ); while ( pid == -1 && errno == EINTR ); if ( pid == 0 ) continue ; /* \u8fdb\u7a0b\u9000\u51fa\u4e86\uff0c\u4fdd\u5b58\u9000\u51fa\u72b6\u6001\uff0c\u79fb\u51fa\u961f\u5217\uff0c \u63d2\u5165peding\u961f\u5217\uff0c\u7b49\u5f85\u5904\u7406 */ process -> status = status ; QUEUE_REMOVE ( & process -> queue ); QUEUE_INSERT_TAIL ( & pending , & process -> queue ); } h = & pending ; q = QUEUE_HEAD ( h ); // \u662f\u5426\u6709\u9000\u51fa\u7684\u8fdb\u7a0b while ( q != h ) { process = QUEUE_DATA ( q , uv_process_t , queue ); q = QUEUE_NEXT ( q ); QUEUE_REMOVE ( & process -> queue ); QUEUE_INIT ( & process -> queue ); uv__handle_stop ( process ); if ( process -> exit_cb == NULL ) continue ; exit_status = 0 ; // \u83b7\u53d6\u9000\u51fa\u4fe1\u606f\uff0c\u6267\u884c\u4e0a\u4f20\u56de\u8c03 if ( WIFEXITED ( process -> status )) exit_status = WEXITSTATUS ( process -> status ); // \u662f\u5426\u56e0\u4e3a\u4fe1\u53f7\u800c\u9000\u51fa term_signal = 0 ; if ( WIFSIGNALED ( process -> status )) term_signal = WTERMSIG ( process -> status ); process -> exit_cb ( process , exit_status , term_signal ); } } \u5f53\u4e3b\u8fdb\u7a0b\u4e0b\u7684\u5b50\u8fdb\u7a0b\u9000\u51fa\u65f6\uff0c\u7236\u8fdb\u7a0b\u4e3b\u8981\u8d1f\u8d23\u6536\u96c6\u5b50\u8fdb\u7a0b\u9000\u51fa\u72b6\u6001\u548c\u539f\u56e0\u7b49\u4fe1\u606f\uff0c\u7136\u540e\u6267\u884c\u4e0a\u5c42\u56de\u8c03\u3002 2 \u521b\u5efa\u5b50\u8fdb\u7a0b\uff08uv__process_child_init\uff09 \u4e3b\u8fdb\u7a0b\u9996\u5148\u4f7f\u7528uv__make_pipe\u7533\u8bf7\u4e00\u4e2a\u533f\u540d\u7ba1\u9053\u7528\u4e8e\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u901a\u4fe1\uff0c\u533f\u540d\u7ba1\u9053\u662f\u8fdb\u7a0b\u95f4\u901a\u4fe1\u4e2d\u6bd4\u8f83\u7b80\u5355\u7684\u4e00\u79cd\uff0c\u5b83\u53ea\u7528\u4e8e\u6709\u7ee7\u627f\u5173\u7cfb\u7684\u8fdb\u7a0b\uff0c\u56e0\u4e3a\u533f\u540d\uff0c\u975e\u7ee7\u627f\u5173\u7cfb\u7684\u8fdb\u7a0b\u65e0\u6cd5\u627e\u5230\u8fd9\u4e2a\u7ba1\u9053\uff0c\u4e5f\u5c31\u65e0\u6cd5\u5b8c\u6210\u901a\u4fe1\uff0c\u800c\u6709\u7ee7\u627f\u5173\u7cfb\u7684\u8fdb\u7a0b\uff0c\u662f\u901a\u8fc7fork\u51fa\u6765\u7684\uff0c\u7236\u5b50\u8fdb\u7a0b\u53ef\u4ee5\u83b7\u5f97\u5f97\u5230\u7ba1\u9053\u3002\u8fdb\u4e00\u6b65\u6765\u8bf4\uff0c\u5b50\u8fdb\u7a0b\u53ef\u4ee5\u4f7f\u7528\u7ee7\u627f\u4e8e\u7236\u8fdb\u7a0b\u7684\u8d44\u6e90\uff0c\u7ba1\u9053\u901a\u4fe1\u7684\u539f\u7406\u5982\u56fe13-2\u6240\u793a\u3002 \u56fe13-2 \u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u901a\u8fc7\u5171\u4eabfile\u548cinode\u7ed3\u6784\u4f53\uff0c\u5b9e\u73b0\u5bf9\u540c\u4e00\u5757\u5185\u5b58\u7684\u8bfb\u5199\u3002\u4e3b\u8fdb\u7a0bfork\u521b\u5efa\u5b50\u8fdb\u7a0b\u540e\uff0c\u4f1a\u901a\u8fc7read\u963b\u585e\u7b49\u5f85\u5b50\u8fdb\u7a0b\u7684\u6d88\u606f\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 static void uv__process_child_init ( const uv_process_options_t * options , int stdio_count , int ( * pipes )[ 2 ], int error_fd ) { sigset_t set ; int close_fd ; int use_fd ; int err ; int fd ; int n ; // \u7701\u7565\u5904\u7406\u6587\u4ef6\u63cf\u8ff0\u7b26\u7b49\u53c2\u6570\u903b\u8f91 // \u5904\u7406\u73af\u5883\u53d8\u91cf if ( options -> env != NULL ) { environ = options -> env ; } // \u5904\u7406\u4fe1\u53f7 for ( n = 1 ; n < 32 ; n += 1 ) { // \u8fd9\u4e24\u4e2a\u4fe1\u53f7\u89e6\u53d1\u65f6\uff0c\u9ed8\u8ba4\u884c\u4e3a\u662f\u8fdb\u7a0b\u9000\u51fa\u4e14\u4e0d\u80fd\u963b\u6b62\u7684 if ( n == SIGKILL || n == SIGSTOP ) continue ; /* Can't be changed. */ // \u8bbe\u7f6e\u4e3a\u9ed8\u8ba4\u5904\u7406\u65b9\u5f0f if ( SIG_ERR != signal ( n , SIG_DFL )) continue ; // \u51fa\u9519\u5219\u901a\u77e5\u4e3b\u8fdb\u7a0b uv__write_int ( error_fd , UV__ERR ( errno )); _exit ( 127 ); } // \u52a0\u8f7d\u65b0\u7684\u6267\u884c\u6587\u4ef6 execvp ( options -> file , options -> args ); // \u52a0\u8f7d\u6210\u529f\u5219\u4e0d\u4f1a\u8d70\u5230\u8fd9\uff0c\u8d70\u5230\u8fd9\u8bf4\u660e\u52a0\u8f7d\u6267\u884c\u6587\u4ef6\u5931\u8d25 uv__write_int ( error_fd , UV__ERR ( errno )); _exit ( 127 ); } \u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\u4e3b\u8981\u662f\u5904\u7406\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u4fe1\u53f7\u3001\u8bbe\u7f6e\u73af\u5883\u53d8\u91cf\u7b49\u3002\u7136\u540e\u52a0\u8f7d\u65b0\u7684\u6267\u884c\u6587\u4ef6\u3002\u56e0\u4e3a\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u901a\u4fe1\u7684\u7ba1\u9053\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u8bbe\u7f6e\u4e86cloexec\u6807\u8bb0\u3002\u6240\u4ee5\u5f53\u5b50\u8fdb\u7a0b\u52a0\u8f7d\u65b0\u7684\u6267\u884c\u6587\u4ef6\u65f6\uff0c\u5c31\u4f1a\u5173\u95ed\u7528\u4e8e\u548c\u4e3b\u8fdb\u7a0b\u901a\u4fe1\u7684\u7ba1\u9053\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u4ece\u800c\u5bfc\u81f4\u4e3b\u8fdb\u7a0b\u8bfb\u53d6\u7ba1\u9053\u8bfb\u7aef\u7684\u65f6\u5019\u8fd4\u56de0\uff0c\u8fd9\u6837\u4e3b\u8fdb\u7a0b\u5c31\u77e5\u9053\u5b50\u8fdb\u7a0b\u6210\u529f\u6267\u884c\u4e86\u3002 13.2.2 \u540c\u6b65\u521b\u5efa\u8fdb\u7a0b \u00b6 \u540c\u6b65\u65b9\u5f0f\u521b\u5efa\u7684\u8fdb\u7a0b\uff0c\u4e3b\u8fdb\u7a0b\u4f1a\u7b49\u5f85\u5b50\u8fdb\u7a0b\u9000\u51fa\u540e\u624d\u80fd\u7ee7\u7eed\u6267\u884c\u3002\u63a5\u4e0b\u6765\u770b\u770b\u5982\u4f55\u4ee5\u540c\u6b65\u7684\u65b9\u5f0f\u521b\u5efa\u8fdb\u7a0b\u3002JS\u5c42\u5165\u53e3\u51fd\u6570\u662fspawnSync\u3002spawnSync\u8c03\u7528C++\u6a21\u5757spawn_sync\u7684spawn\u51fd\u6570\u521b\u5efa\u8fdb\u7a0b\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5bf9\u5e94\u7684C++\u6a21\u5757spawn_sync\u5bfc\u51fa\u7684\u5c5e\u6027\u3002 1 2 3 4 5 6 7 void SyncProcessRunner::Initialize ( Local < Object > target , Local < Value > unused , Local < Context > context , void * priv ) { Environment * env = Environment :: GetCurrent ( context ); env -> SetMethod ( target , \"spawn\" , Spawn ); } \u8be5\u6a21\u5757\u503c\u5bfc\u51fa\u4e86\u4e00\u4e2a\u5c5e\u6027spawn\uff0c\u5f53\u6211\u4eec\u8c03\u7528spawn\u7684\u65f6\u5019\uff0c\u6267\u884c\u7684\u662fC++\u7684Spawn\u3002 1 2 3 4 5 6 7 8 void SyncProcessRunner::Spawn ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); env -> PrintSyncTrace (); SyncProcessRunner p ( env ); Local < Value > result ; if ( ! p . Run ( args [ 0 ]). ToLocal ( & result )) return ; args . GetReturnValue (). Set ( result ); } Spawn\u4e2d\u4e3b\u8981\u662f\u65b0\u5efa\u4e86\u4e00\u4e2aSyncProcessRunner\u5bf9\u8c61\u5e76\u4e14\u6267\u884cRun\u65b9\u6cd5\u3002\u6211\u4eec\u770b\u4e00\u4e0bSyncProcessRunner\u7684Run\u505a\u4e86\u4ec0\u4e48\u3002 1 2 3 4 5 6 MaybeLocal < Object > SyncProcessRunner :: Run ( Local < Value > options ) { EscapableHandleScope scope ( env () -> isolate ()); Maybe < bool > r = TryInitializeAndRunLoop ( options ); Local < Object > result = BuildResultObject (); return scope . Escape ( result ); } \u6267\u884c\u4e86TryInitializeAndRunLoop\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 Maybe < bool > SyncProcessRunner :: TryInitializeAndRunLoop ( Local < Value > options ) { int r ; lifecycle_ = kInitialized ; // \u65b0\u5efa\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af uv_loop_ = new uv_loop_t ; if ( ! ParseOptions ( options ). To ( & r )) return Nothing < bool > (); if ( r < 0 ) { SetError ( r ); return Just ( false ); } // \u8bbe\u7f6e\u5b50\u8fdb\u7a0b\u6267\u884c\u7684\u65f6\u95f4 if ( timeout_ > 0 ) { r = uv_timer_init ( uv_loop_ , & uv_timer_ ); uv_unref ( reinterpret_cast < uv_handle_t *> ( & uv_timer_ )); uv_timer_ . data = this ; kill_timer_initialized_ = true ; // \u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u6267\u884cKillTimerCallback r = uv_timer_start ( & uv_timer_ , KillTimerCallback , timeout_ , 0 ); } // \u5b50\u8fdb\u7a0b\u9000\u51fa\u65f6\u5904\u7406\u51fd\u6570 uv_process_options_ . exit_cb = ExitCallback ; // \u4f20\u8fdb\u53bb\u65b0\u7684loop\u800c\u4e0d\u662f\u4e3b\u8fdb\u7a0b\u672c\u8eab\u7684loop r = uv_spawn ( uv_loop_ , & uv_process_ , & uv_process_options_ ); uv_process_ . data = this ; for ( const auto & pipe : stdio_pipes_ ) { if ( pipe != nullptr ) { r = pipe -> Start (); if ( r < 0 ) { SetPipeError ( r ); return Just ( false ); } } } // \u5f00\u542f\u4e00\u4e2a\u65b0\u7684\u4e8b\u4ef6\u5faa\u73af r = uv_run ( uv_loop_ , UV_RUN_DEFAULT ); return Just ( true ); } \u4ece\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u4e86\u89e3\u5230Node.js\u662f\u5982\u4f55\u5b9e\u73b0\u540c\u6b65\u521b\u5efa\u8fdb\u7a0b\u7684\u3002\u540c\u6b65\u521b\u5efa\u8fdb\u7a0b\u65f6\uff0cNode.js\u91cd\u65b0\u5f00\u542f\u4e86\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af\uff0c\u7136\u540e\u65b0\u5efa\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u5e76\u4e14\u628a\u8868\u793a\u5b50\u8fdb\u7a0b\u7ed3\u6784\u4f53\u7684handle\u63d2\u5165\u5230\u65b0\u521b\u5efa\u7684\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u63a5\u7740Libuv\u4e00\u76f4\u5904\u4e8e\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u56e0\u4e3a\u4e00\u76f4\u6709\u4e00\u4e2auv_process_t\uff08handle\uff09\uff0c\u6240\u4ee5\u65b0\u521b\u5efa\u7684uv_run\u4f1a\u4e00\u76f4\u5728\u6267\u884c\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\uff0cNode.js\u4e3b\u8fdb\u7a0b\u4f1a\u201d\u963b\u585e\u201d\u5728\u8be5uv_run\u3002\u76f4\u5230\u5b50\u8fdb\u7a0b\u9000\u51fa\uff0c\u4e3b\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u540e\uff0c\u5220\u9664\u65b0\u521b\u5efa\u7684\u4e8b\u4ef6\u5faa\u73af\u4e2d\u7684uv_process_t\u3002\u7136\u540e\u6267\u884c\u56de\u8c03ExitCallback\u3002\u63a5\u7740\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\uff0c\u518d\u6b21\u56de\u5230Node.js\u539f\u6765\u7684\u4e8b\u4ef6\u5faa\u73af\u3002\u5982\u56fe\u6240\u793a13-3\u3002 \u56fe13-3 \u8fd9\u5c31\u662f\u540c\u6b65\u7684\u672c\u8d28\u548c\u539f\u56e0\u3002\u6211\u4eec\u5206\u51e0\u6b65\u5206\u6790\u4e00\u4e0b\u4ee5\u4e0a\u4ee3\u7801 13.2.2.1 \u6267\u884c\u65f6\u95f4 \u00b6 \u56e0\u4e3a\u540c\u6b65\u65b9\u5f0f\u521b\u5efa\u5b50\u8fdb\u7a0b\u4f1a\u5bfc\u81f4Node.js\u4e3b\u8fdb\u7a0b\u963b\u585e\uff0c\u4e3a\u4e86\u907f\u514d\u5b50\u8fdb\u7a0b\u6709\u95ee\u9898\uff0c\u4ece\u800c\u5f71\u54cd\u4e3b\u8fdb\u7a0b\u7684\u6267\u884c\uff0cNode.js\u652f\u6301\u53ef\u914d\u7f6e\u5b50\u8fdb\u7a0b\u7684\u6700\u5927\u6267\u884c\u65f6\u95f4\u3002\u6211\u4eec\u770b\u5230\uff0cNode.js\u5f00\u542f\u4e86\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u5e76\u8bbe\u7f6e\u4e86\u56de\u8c03KillTimerCallback\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void SyncProcessRunner::KillTimerCallback ( uv_timer_t * handle ) { SyncProcessRunner * self = reinterpret_cast < SyncProcessRunner *> ( handle -> data ); self -> OnKillTimerTimeout (); } void SyncProcessRunner::OnKillTimerTimeout () { SetError ( UV_ETIMEDOUT ); Kill (); } void SyncProcessRunner::Kill () { if ( killed_ ) return ; killed_ = true ; if ( exit_status_ < 0 ) { // kill_signal_\u4e3a\u7528\u6237\u81ea\u5b9a\u4e49\u53d1\u9001\u7684\u6740\u6b7b\u8fdb\u7a0b\u7684\u4fe1\u53f7 int r = uv_process_kill ( & uv_process_ , kill_signal_ ); // \u4e0d\u652f\u6301\u7528\u6237\u4f20\u7684\u4fe1\u53f7 if ( r < 0 && r != UV_ESRCH ) { SetError ( r ); // \u56de\u9000\u4f7f\u7528SIGKILL\u4fe1\u53f7\u6740\u6b7b\u8fdb\u7a0b r = uv_process_kill ( & uv_process_ , SIGKILL ); CHECK ( r >= 0 || r == UV_ESRCH ); } } // Close all stdio pipes. CloseStdioPipes (); // \u6e05\u9664\u5b9a\u65f6\u5668 CloseKillTimer (); } \u5f53\u6267\u884c\u65f6\u95f4\u5230\u8fbe\u8bbe\u7f6e\u7684\u9608\u503c\uff0cNode.js\u4e3b\u8fdb\u7a0b\u4f1a\u7ed9\u5b50\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2a\u4fe1\u53f7\uff0c\u9ed8\u8ba4\u662f\u6740\u6b7b\u5b50\u8fdb\u7a0b\u3002 13.2.2.2 \u5b50\u8fdb\u7a0b\u9000\u51fa\u5904\u7406 \u00b6 \u9000\u51fa\u5904\u7406\u4e3b\u8981\u662f\u8bb0\u5f55\u5b50\u8fdb\u7a0b\u9000\u51fa\u65f6\u7684\u9519\u8bef\u7801\u548c\u88ab\u54ea\u4e2a\u4fe1\u53f7\u6740\u6b7b\u7684\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void SyncProcessRunner::ExitCallback ( uv_process_t * handle , int64_t exit_status , int term_signal ) { SyncProcessRunner * self = reinterpret_cast < SyncProcessRunner *> ( handle -> data ); uv_close ( reinterpret_cast < uv_handle_t *> ( handle ), nullptr ); self -> OnExit ( exit_status , term_signal ); } void SyncProcessRunner::OnExit ( int64_t exit_status , int term_signal ) { if ( exit_status < 0 ) return SetError ( static_cast < int > ( exit_status )); exit_status_ = exit_status ; term_signal_ = term_signal ; } 13.3 \u8fdb\u7a0b\u95f4\u901a\u4fe1 \u00b6 \u8fdb\u7a0b\u95f4\u901a\u4fe1\u662f\u591a\u8fdb\u7a0b\u7cfb\u7edf\u4e2d\u975e\u5e38\u91cd\u8981\u7684\u529f\u80fd\uff0c\u5426\u5219\u8fdb\u7a0b\u5c31\u50cf\u5b64\u5c9b\u4e00\u6837\uff0c\u4e0d\u80fd\u4ea4\u6d41\u4fe1\u606f\u3002\u56e0\u4e3a\u8fdb\u7a0b\u95f4\u7684\u5185\u5b58\u662f\u9694\u79bb\u7684\uff0c\u5982\u679c\u8fdb\u7a0b\u95f4\u60f3\u901a\u4fe1\uff0c\u5c31\u9700\u8981\u4e00\u4e2a\u516c\u5171\u7684\u5730\u65b9\uff0c\u8ba9\u591a\u4e2a\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u8bbf\u95ee\uff0c\u5b8c\u6210\u4fe1\u606f\u7684\u4f20\u9012\u3002\u5728Linux\u4e2d\uff0c\u540c\u4e3b\u673a\u7684\u8fdb\u7a0b\u95f4\u901a\u4fe1\u65b9\u5f0f\u6709\u5f88\u591a\uff0c\u4f46\u662f\u57fa\u672c\u90fd\u662f\u4f7f\u7528\u72ec\u7acb\u4e8e\u8fdb\u7a0b\u7684\u989d\u5916\u5185\u5b58\u4f5c\u4e3a\u4fe1\u606f\u627f\u8f7d\u7684\u5730\u65b9\uff0c\u7136\u540e\u5728\u901a\u8fc7\u67d0\u79cd\u65b9\u5f0f\u8ba9\u591a\u4e2a\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u8bbf\u95ee\u5230\u8fd9\u5757\u516c\u5171\u5185\u5b58\uff0c\u6bd4\u5982\u7ba1\u9053\u3001\u5171\u4eab\u5185\u5b58\u3001Unix\u57df\u3001\u6d88\u606f\u961f\u5217\u7b49\u7b49\u3002\u4e0d\u8fc7\u8fd8\u6709\u53e6\u5916\u4e00\u79cd\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u65b9\u5f0f\uff0c\u662f\u4e0d\u5c5e\u4e8e\u4ee5\u4e0a\u60c5\u51b5\u7684\uff0c\u90a3\u5c31\u662f\u4fe1\u53f7\u3002\u4fe1\u53f7\u4f5c\u4e3a\u4e00\u79cd\u7b80\u5355\u7684\u8fdb\u7a0b\u95f4\u901a\u4fe1\u65b9\u5f0f\uff0c\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u4e86\u63a5\u53e3\u8ba9\u8fdb\u7a0b\u53ef\u4ee5\u76f4\u63a5\u4fee\u6539\u53e6\u4e00\u4e2a\u8fdb\u7a0b\u7684\u6570\u636e\uff08PCB\uff09\uff0c\u4ee5\u6b64\u8fbe\u5230\u901a\u4fe1\u76ee\u7684\u3002\u672c\u8282\u4ecb\u7ecdNode.js\u4e2d\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u539f\u7406\u548c\u5b9e\u73b0\u3002 13.3.1 \u521b\u5efa\u901a\u4fe1\u901a\u9053 \u00b6 \u6211\u4eec\u4ecefork\u51fd\u6570\u5f00\u59cb\u5206\u6790Node.js\u4e2d\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function fork ( modulePath ) { // \u5ffd\u7565options\u53c2\u6570\u5904\u7406 if ( typeof options . stdio === 'string' ) { options . stdio = stdioStringToArray ( options . stdio , 'ipc' ); } else if ( ! ArrayIsArray ( options . stdio )) { // silent\u4e3atrue\u5219\u662f\u7ba1\u9053\u5f62\u5f0f\u548c\u4e3b\u8fdb\u7a0b\u901a\u4fe1\uff0c\u5426\u5219\u662f\u7ee7\u627f options . stdio = stdioStringToArray ( options . silent ? 'pipe' : 'inherit' , 'ipc' ); } else if ( ! options . stdio . includes ( 'ipc' )) { // \u5fc5\u987b\u8981IPC\uff0c\u652f\u6301\u8fdb\u7a0b\u95f4\u901a\u4fe1 throw new ERR_CHILD_PROCESS_IPC_REQUIRED ( 'options.stdio' ); } return spawn ( options . execPath , args , options ); } \u6211\u4eec\u770b\u4e00\u4e0bstdioStringToArray\u7684\u5904\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function stdioStringToArray ( stdio , channel ) { const options = []; switch ( stdio ) { case 'ignore' : case 'pipe' : options . push ( stdio , stdio , stdio ); break ; case 'inherit' : options . push ( 0 , 1 , 2 ); break ; default : throw new ERR_INVALID_OPT_VALUE ( 'stdio' , stdio ); } if ( channel ) options . push ( channel ); return options ; } stdioStringToArray\u4f1a\u8fd4\u56de\u4e00\u4e2a\u6570\u7ec4\uff0c\u6bd4\u5982['pipe', 'pipe', 'pipe', 'ipc']\u6216[0, 1, 2, 'ipc']\uff0cipc\u4ee3\u8868\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u901a\u9053\uff0c\u5e76\u4e14\u652f\u6301\u6587\u4ef6\u63cf\u8ff0\u4f20\u9012\u3002\u6211\u4eec\u63a5\u7740\u770bspawn\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ChildProcess . prototype . spawn = function ( options ) { let i = 0 ; // \u9884\u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784 stdio = getValidStdio ( stdio , false ); const ipc = stdio . ipc ; // IPC\u6587\u4ef6\u63cf\u8ff0\u7b26 const ipcFd = stdio . ipcFd ; stdio = options . stdio = stdio . stdio ; // \u901a\u8fc7\u73af\u5883\u53d8\u91cf\u544a\u8bc9\u5b50\u8fdb\u7a0bIPC\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u6570\u636e\u5904\u7406\u6a21\u5f0f if ( ipc !== undefined ) { options . envPairs . push ( `NODE_CHANNEL_FD= ${ ipcFd } ` ); options . envPairs . push ( `NODE_CHANNEL_SERIALIZATION_MODE= ${ serialization } ` ); } // \u521b\u5efa\u5b50\u8fdb\u7a0b const err = this . _handle . spawn ( options ); this . pid = this . _handle . pid ; // \u5904\u7406IPC\u901a\u4fe1 if ( ipc !== undefined ) setupChannel ( this , ipc , serialization ); return err ; } Spawn\u4e2d\u4f1a\u6267\u884cgetValidStdio\u9884\u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784\u3002\u6211\u4eec\u53ea\u5173\u6ce8ipc\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function getValidStdio ( stdio , sync ) { let ipc ; let ipcFd ; stdio = stdio . reduce (( acc , stdio , i ) => { if ( stdio === 'ipc' ) { ipc = new Pipe ( PipeConstants . IPC ); ipcFd = i ; acc . push ({ type : 'pipe' , handle : ipc , ipc : true }); } else { // \u5176\u5b83\u7c7b\u578b\u7684\u5904\u7406 } return acc ; }, []); return { stdio , ipc , ipcFd }; } \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u4f1anew Pipe(PipeConstants.IPC);\u521b\u5efa\u4e00\u4e2aUnix\u57df\u7528\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\uff0c\u4f46\u662f\u8fd9\u91cc\u53ea\u662f\u5b9a\u4e49\u4e86\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u8fd8\u6ca1\u6709\u53ef\u7528\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u6211\u4eec\u63a5\u7740\u5f80\u4e0b\u770bC++\u5c42\u7684spawn\u4e2d\u5173\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u5904\u7406\u3002C++\u5c42\u9996\u5148\u5904\u7406\u53c2\u6570\uff0c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 static void ParseStdioOptions ( Environment * env , Local < Object > js_options , uv_process_options_t * options ) { Local < Context > context = env -> context (); Local < String > stdio_key = env -> stdio_string (); // \u62ff\u5230JS\u5c42stdio\u7684\u503c Local < Array > stdios = js_options -> Get ( context , stdio_key ). ToLocalChecked (). As < Array > (); uint32_t len = stdios -> Length (); options -> stdio = new uv_stdio_container_t [ len ]; options -> stdio_count = len ; // \u904d\u5386stdio\uff0cstdio\u662f\u4e00\u4e2a\u5bf9\u8c61\u6570\u7ec4 for ( uint32_t i = 0 ; i < len ; i ++ ) { Local < Object > stdio = stdios -> Get ( context , i ). ToLocalChecked (). As < Object > (); // \u62ff\u5230stdio\u7684\u7c7b\u578b Local < Value > type = stdio -> Get ( context , env -> type_string ()). ToLocalChecked (); // \u521b\u5efaIPC\u901a\u9053 if ( type -> StrictEquals ( env -> pipe_string ())) { options -> stdio [ i ]. flags = static_cast < uv_stdio_flags > ( UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE ); // \u62ff\u5230\u5bf9\u5e94\u7684stream options -> stdio [ i ]. data . stream = StreamForWrap ( env , stdio ); } } } \u8fd9\u91cc\u4f1a\u628aStreamForWrap\u7684\u7ed3\u679c\u4fdd\u5b58\u5230stream\u4e2d\uff0c\u6211\u4eec\u770b\u770bStreamForWrap\u7684\u903b\u8f91 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static uv_stream_t * StreamForWrap ( Environment * env , Local < Object > stdio ) { Local < String > handle_key = env -> handle_string (); /* \u83b7\u53d6\u5bf9\u8c61\u4e2d\u7684key\u4e3ahandle\u7684\u503c\uff0c\u5373\u521a\u624dJS\u5c42\u7684 new Pipe(SOCKET.IPC); */ Local < Object > handle = stdio -> Get ( env -> context (), handle_key ). ToLocalChecked (). As < Object > (); // \u83b7\u53d6JS\u5c42\u4f7f\u7528\u5bf9\u8c61\u6240\u5bf9\u5e94\u7684C++\u5bf9\u8c61\u4e2d\u7684stream uv_stream_t * stream = LibuvStreamWrap :: From ( env , handle ) -> stream (); CHECK_NOT_NULL ( stream ); return stream ; } // \u4eceJS\u5c42\u4f7f\u7528\u7684object\u4e2d\u83b7\u53d6\u5173\u8054\u7684C++\u5bf9\u8c61 ibuvStreamWrap * LibuvStreamWrap::From ( Environment * env , Local < Object > object ) { return Unwrap < LibuvStreamWrap > ( object ); } \u4ee5\u4e0a\u4ee3\u7801\u83b7\u53d6\u4e86IPC\u5bf9\u5e94\u7684stream\u7ed3\u6784\u4f53\u3002\u5728Libuv\u4e2d\u4f1a\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5230stream\u4e2d\u3002\u6211\u4eec\u63a5\u7740\u770bC++\u5c42\u8c03\u7528Libuv\u7684uv_spawn\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int uv_spawn ( uv_loop_t * loop , uv_process_t * process , const uv_process_options_t * options ) { int pipes_storage [ 8 ][ 2 ]; int ( * pipes )[ 2 ]; int stdio_count ; // \u521d\u59cb\u5316\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784 stdio_count = options -> stdio_count ; if ( stdio_count < 3 ) stdio_count = 3 ; for ( i = 0 ; i < stdio_count ; i ++ ) { pipes [ i ][ 0 ] = -1 ; pipes [ i ][ 1 ] = -1 ; } // \u521b\u5efa\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 for ( i = 0 ; i < options -> stdio_count ; i ++ ) { err = uv__process_init_stdio ( options -> stdio + i , pipes [ i ]); if ( err ) goto error ; } // \u8bbe\u7f6e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u6587\u4ef6\u63cf\u8ff0\u7b26\u5230\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784 for ( i = 0 ; i < options -> stdio_count ; i ++ ) { uv__process_open_stream ( options -> stdio + i , pipes [ i ]); } } Libuv\u4e2d\u4f1a\u521b\u5efa\u7528\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u7136\u540e\u8bbe\u7f6e\u5230\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u4e2d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static int uv__process_open_stream ( uv_stdio_container_t * container , int pipefds [ 2 ]) { int flags ; int err ; if ( ! ( container -> flags & UV_CREATE_PIPE ) || pipefds [ 0 ] < 0 ) return 0 ; err = uv__close ( pipefds [ 1 ]); if ( err != 0 ) abort (); pipefds [ 1 ] = -1 ; uv__nonblock ( pipefds [ 0 ], 1 ); flags = 0 ; if ( container -> flags & UV_WRITABLE_PIPE ) flags |= UV_HANDLE_READABLE ; if ( container -> flags & UV_READABLE_PIPE ) flags |= UV_HANDLE_WRITABLE ; return uv__stream_open ( container -> data . stream , pipefds [ 0 ], flags ); } \u6267\u884c\u5b8cuv__process_open_stream\uff0c\u7528\u4e8eIPC\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5c31\u4fdd\u5b58\u5230new Pipe(SOCKET.IPC)\u4e2d\u4e86\u3002\u6709\u4e86IPC\u901a\u9053\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u8fdb\u7a0b\u8fd8\u9700\u8981\u8fdb\u4e00\u6b65\u5904\u7406\u3002\u6211\u4eec\u770b\u5230JS\u5c42\u6267\u884c\u5b8cspawn\u540e\uff0c\u4e3b\u8fdb\u7a0b\u901a\u8fc7setupChannel\u5bf9\u8fdb\u7a0b\u95f4\u901a\u4fe1\u8fdb\u884c\u4e86\u8fdb\u4e00\u6b65\u5904\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4e3b\u8fdb\u7a0bsetupChannel\u4e2d\u5173\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u5904\u7406\u3002 13.3.2 \u4e3b\u8fdb\u7a0b\u5904\u7406\u901a\u4fe1\u901a\u9053 \u00b6 1 \u8bfb\u7aef 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 function setupChannel ( target , channel , serializationMode ) { // channel\u662fnew Pipe(PipeConstants.IPC); const control = new Control ( channel ); target . channel = control ; // \u2026 channel . pendingHandle = null ; // \u6ce8\u518c\u5904\u7406\u6570\u636e\u7684\u51fd\u6570 channel . onread = function ( arrayBuffer ) { // \u6536\u5230\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 const recvHandle = channel . pendingHandle ; channel . pendingHandle = null ; if ( arrayBuffer ) { const nread = streamBaseState [ kReadBytesOrError ]; const offset = streamBaseState [ kArrayBufferOffset ]; const pool = new Uint8Array ( arrayBuffer , offset , nread ); if ( recvHandle ) pendingHandle = recvHandle ; // \u89e3\u6790\u6536\u5230\u7684\u6d88\u606f for ( const message of parseChannelMessages ( channel , pool )) { // \u662f\u5426\u662f\u5185\u90e8\u901a\u4fe1\u4e8b\u4ef6 if ( isInternal ( message )) { // \u6536\u5230handle if ( message . cmd === 'NODE_HANDLE' ) { handleMessage ( message , pendingHandle , true ); pendingHandle = null ; } else { handleMessage ( message , undefined , true ); } } else { handleMessage ( message , undefined , false ); } } } }; function handleMessage ( message , handle , internal ) { const eventName = ( internal ? 'internalMessage' : 'message' ); process . nextTick ( emit , eventName , message , handle ); } // \u5f00\u542f\u8bfb channel . readStart (); return control ; } onread\u5904\u7406\u5b8c\u540e\u4f1a\u89e6\u53d1internalMessage\u6216message\u4e8b\u4ef6\uff0cmessage\u662f\u7528\u6237\u4f7f\u7528\u7684\u3002 2\u5199\u7aef 1 2 3 4 5 6 7 8 target . _send = function ( message , handle , options , callback ) { let obj ; const req = new WriteWrap (); // \u53d1\u9001\u7ed9\u5bf9\u7aef const err = writeChannelMessage ( channel , req , message , handle ); return channel . writeQueueSize < ( 65536 * 2 ); } \u6211\u4eec\u770b\u770bwriteChannelMessage 1 2 3 4 5 6 7 8 9 10 11 12 13 writeChannelMessage ( channel , req , message , handle ) { const ser = new ChildProcessSerializer (); ser . writeHeader (); ser . writeValue ( message ); const serializedMessage = ser . releaseBuffer (); const sizeBuffer = Buffer . allocUnsafe ( 4 ); sizeBuffer . writeUInt32BE ( serializedMessage . length ); // channel\u662f\u5c01\u88c5\u4e86Unix\u57df\u7684\u5bf9\u8c61 return channel . writeBuffer ( req , Buffer . concat ([ sizeBuffer , serializedMessage ]), handle ); }, channel.writeBuffer\u901a\u8fc7\u521a\u624d\u521b\u5efa\u7684IPC\u901a\u9053\u5b8c\u6210\u6570\u636e\u7684\u53d1\u9001\uff0c\u5e76\u4e14\u652f\u6301\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002 13.3.3 \u5b50\u8fdb\u7a0b\u5904\u7406\u901a\u4fe1\u901a\u9053 \u00b6 \u63a5\u7740\u6211\u4eec\u770b\u770b\u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\uff0cNode.js\u5728\u521b\u5efa\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\uff0c\u4e3b\u8fdb\u7a0b\u4f1a\u901a\u8fc7\u73af\u5883\u53d8\u91cfNODE_CHANNEL_FD\u544a\u8bc9\u5b50\u8fdb\u7a0bUnix\u57df\u901a\u4fe1\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u5728\u6267\u884c\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\uff0c\u4f1a\u5904\u7406\u8fd9\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u5177\u4f53\u5b9e\u73b0\u5728setupChildProcessIpcChannel\u51fd\u6570\u4e2d\u3002 1 2 3 4 5 6 7 8 function setupChildProcessIpcChannel () { // \u4e3b\u8fdb\u7a0b\u901a\u8fc7\u73af\u5883\u53d8\u91cf\u8bbe\u7f6e\u8be5\u503c if ( process . env . NODE_CHANNEL_FD ) { const fd = parseInt ( process . env . NODE_CHANNEL_FD , 10 ); delete process . env . NODE_CHANNEL_FD ; require ( 'child_process' ). _forkChild ( fd , serializationMode ); } } \u63a5\u7740\u6267\u884c_forkChild\u51fd\u6570\u3002 1 2 3 4 5 function _forkChild ( fd , serializationMode ) { const p = new Pipe ( PipeConstants . IPC ); p . open ( fd ); const control = setupChannel ( process , p , serializationMode ); } \u8be5\u51fd\u6570\u521b\u5efa\u4e00\u4e2aPipe\u5bf9\u8c61\uff0c\u7136\u540e\u628a\u4e3b\u8fdb\u7a0b\u4f20\u8fc7\u6765\u7684fd\u4fdd\u5b58\u5230\u8be5Pipe\u5bf9\u8c61\u3002\u5bf9\u8be5Pipe\u5bf9\u8c61\u7684\u8bfb\u5199\uff0c\u5c31\u662f\u5730\u5bf9fd\u8fdb\u884c\u8bfb\u5199\u3002\u6700\u540e\u6267\u884csetupChannel\u3002setupChannel\u4e3b\u8981\u662f\u5b8c\u6210\u4e86Unix\u57df\u901a\u4fe1\u7684\u5c01\u88c5\uff0c\u5305\u62ec\u5904\u7406\u63a5\u6536\u7684\u6d88\u606f\u3001\u53d1\u9001\u6d88\u606f\u3001\u5904\u7406\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7b49\uff0c\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4e0d\u518d\u5177\u4f53\u5206\u6790\u3002\u6700\u540e\u901a\u8fc7\u5728process\u5bf9\u8c61\u4e2d\u6302\u8f7d\u51fd\u6570\u548c\u76d1\u542c\u4e8b\u4ef6\uff0c\u4f7f\u5f97\u5b50\u8fdb\u7a0b\u5177\u6709\u548c\u4e3b\u8fdb\u7a0b\u901a\u4fe1\u7684\u80fd\u529b\u3002\u6240\u6709\u7684\u901a\u4fe1\u90fd\u662f\u57fa\u4e8e\u4e3b\u8fdb\u7a0b\u901a\u8fc7\u73af\u5883\u53d8\u91cfNODE_CHANNEL_FD\u4f20\u9012\u8fc7\u6765\u7684fd\u8fdb\u884c\u7684\u3002 13.4 \u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012 \u00b6 \u524d\u9762\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u8fc7\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u539f\u7406\uff0c\u4e0b\u9762\u6211\u4eec\u770b\u770bNode.js\u662f\u5982\u4f55\u5904\u7406\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7684\u3002 13.4.1 \u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26 \u00b6 \u6211\u4eec\u770b\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u53d1\u9001\u51fd\u6570send\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 process . send = function ( message , handle , options , callback ) { return this . _send ( message , handle , options , callback ); }; target . _send = function ( message , handle , options , callback ) { // Support legacy function signature if ( typeof options === 'boolean' ) { options = { swallowErrors : options }; } let obj ; // \u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0chandle\u662f\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5c01\u88c5 if ( handle ) { message = { cmd : 'NODE_HANDLE' , type : null , msg : message }; // handle\u7684\u7c7b\u578b if ( handle instanceof net . Socket ) { message . type = 'net.Socket' ; } else if ( handle instanceof net . Server ) { message . type = 'net.Server' ; } else if ( handle instanceof TCP || handle instanceof Pipe ) { message . type = 'net.Native' ; } else if ( handle instanceof dgram . Socket ) { message . type = 'dgram.Socket' ; } else if ( handle instanceof UDP ) { message . type = 'dgram.Native' ; } else { throw new ERR_INVALID_HANDLE_TYPE (); } // \u6839\u636e\u7c7b\u578b\u8f6c\u6362\u5bf9\u8c61 obj = handleConversion [ message . type ]; // \u628aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u8f6c\u6210C++\u5c42\u5bf9\u8c61 handle = handleConversion [ message . type ]. send . call ( target , message , handle , options ); } // \u53d1\u9001 const req = new WriteWrap (); // \u53d1\u9001\u7ed9\u5bf9\u7aef const err = writeChannelMessage ( channel , req , message , handle ); } Node.js\u5728\u53d1\u9001\u4e00\u4e2a\u5c01\u88c5\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5bf9\u8c61\u4e4b\u524d\uff0c\u9996\u5148\u4f1a\u628aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u8f6c\u6210C++\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002\u5982TCP 1 2 3 send ( message , server , options ) { return server . _handle ; } \u6211\u4eec\u63a5\u7740\u770bwriteChannelMessage\u3002 1 2 3 4 5 // channel\u662fnew Pipe(PipeConstants.IPC); writeChannelMessage ( channel , req , message , handle ) { const string = JSONStringify ( message ) + '\\n' ; return channel . writeUtf8String ( req , string , handle ); } \u6211\u4eec\u770b\u4e00\u4e0bwriteUtf8String 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 template < enum encoding enc > int StreamBase :: WriteString ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); // new WriteWrap() Local < Object > req_wrap_obj = args [ 0 ]. As < Object > (); Local < String > string = args [ 1 ]. As < String > (); Local < Object > send_handle_obj ; // \u9700\u8981\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cC++\u5c42\u5bf9\u8c61 if ( args [ 2 ] -> IsObject ()) send_handle_obj = args [ 2 ]. As < Object > (); uv_stream_t * send_handle = nullptr ; // \u662fUnix\u57df\u5e76\u4e14\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 if ( IsIPCPipe () && ! send_handle_obj . IsEmpty ()) { HandleWrap * wrap ; /* send_handle_obj\u662f\u7531C++\u5c42\u521b\u5efa\u5728JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\uff0c \u89e3\u5305\u51fa\u771f\u6b63\u5728C++\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61 */ ASSIGN_OR_RETURN_UNWRAP ( & wrap , send_handle_obj , UV_EINVAL ); // \u62ff\u5230Libuv\u5c42\u7684handle\u7ed3\u6784\u4f53 send_handle = reinterpret_cast < uv_stream_t *> ( wrap -> GetHandle ()); /* Reference LibuvStreamWrap instance to prevent it from being garbage\uff0ccollected before`AfterWrite` is called. */ req_wrap_obj -> Set ( env -> context (), env -> handle_string (), send_handle_obj ). Check (); } Write ( & buf , 1 , send_handle , req_wrap_obj ); } Write\u4f1a\u8c03\u7528Libuv\u7684uv__write\uff0cuv__write\u4f1a\u628aLibuv\u5c42\u7684handle\u4e2d\u7684fd\u53d6\u51fa\u6765\uff0c\u4f7f\u7528sendmsg\u4f20\u9012\u5230\u5176\u5b83\u8fdb\u7a0b\u3002\u6574\u4e2a\u53d1\u9001\u7684\u8fc7\u7a0b\u672c\u8d28\u662f\u4eceJS\u5c42\u5230Libuv\u5c42\u5c42\u5c42\u63ed\u5f00\u8981\u53d1\u9001\u7684\u5bf9\u8c61\uff0c\u6700\u540e\u62ff\u5230\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u7136\u540e\u901a\u8fc7\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684API\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7ed9\u53e6\u4e00\u4e2a\u8fdb\u7a0b\uff0c\u5982\u56fe13-4\u6240\u793a\u3002 \u56fe13-4 13.4.2 \u63a5\u6536\u6587\u4ef6\u63cf\u8ff0\u7b26 \u00b6 \u5206\u6790\u5b8c\u53d1\u9001\uff0c\u6211\u4eec\u518d\u770b\u4e00\u4e0b\u63a5\u6536\u7684\u903b\u8f91\u3002\u524d\u9762\u6211\u4eec\u5206\u6790\u8fc7\uff0c\u5f53\u6587\u4ef6\u63cf\u8ff0\u7b26\u6536\u5230\u6570\u636e\u65f6\uff0c\u4f1a\u628a\u6587\u4ef6\u6587\u4ef6\u63cf\u8ff0\u7b26\u5c01\u88c5\u6210\u5bf9\u5e94\u7684\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void LibuvStreamWrap::OnUvRead ( ssize_t nread , const uv_buf_t * buf ) { HandleScope scope ( env () -> isolate ()); Context :: Scope context_scope ( env () -> context ()); uv_handle_type type = UV_UNKNOWN_HANDLE ; // \u662f\u5426\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u5e76\u4e14\u6709\u5f85\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5219\u5224\u65ad\u6587\u4ef6\u63cf\u8ff0\u7b26\u7c7b\u578b if ( is_named_pipe_ipc () && uv_pipe_pending_count ( reinterpret_cast < uv_pipe_t *> ( stream ())) > 0 ) { type = uv_pipe_pending_type ( reinterpret_cast < uv_pipe_t *> ( stream ())); } // \u8bfb\u53d6\u6210\u529f if ( nread > 0 ) { MaybeLocal < Object > pending_obj ; // \u6839\u636e\u7c7b\u578b\u521b\u5efa\u4e00\u4e2a\u65b0\u7684C++\u5bf9\u8c61\u8868\u793a\u5ba2\u6237\u7aef\uff0c\u5e76\u4e14\u4ece\u670d\u52a1\u5668\u4e2d\u6458\u4e0b\u4e00\u4e2afd\u4fdd\u5b58\u5230\u5ba2\u6237\u7aef if ( type == UV_TCP ) { pending_obj = AcceptHandle < TCPWrap > ( env (), this ); } else if ( type == UV_NAMED_PIPE ) { pending_obj = AcceptHandle < PipeWrap > ( env (), this ); } else if ( type == UV_UDP ) { pending_obj = AcceptHandle < UDPWrap > ( env (), this ); } else { CHECK_EQ ( type , UV_UNKNOWN_HANDLE ); } // \u4fdd\u5b58\u5230JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u4e2d\uff0c\u952e\u662fpendingHandle if ( ! pending_obj . IsEmpty ()) { object () -> Set ( env () -> context (), env () -> pending_handle_string (), pending_obj . ToLocalChecked ()) . Check (); } } EmitRead ( nread , * buf ); } \u63a5\u7740\u6211\u4eec\u770b\u770bJS\u5c42\u7684\u5904\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 channel . onread = function ( arrayBuffer ) { // \u6536\u5230\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 const recvHandle = channel . pendingHandle ; channel . pendingHandle = null ; if ( arrayBuffer ) { const nread = streamBaseState [ kReadBytesOrError ]; const offset = streamBaseState [ kArrayBufferOffset ]; const pool = new Uint8Array ( arrayBuffer , offset , nread ); if ( recvHandle ) pendingHandle = recvHandle ; // \u89e3\u6790\u6536\u5230\u7684\u6d88\u606f for ( const message of parseChannelMessages ( channel , pool )) { // \u662f\u5426\u662f\u5185\u90e8\u901a\u4fe1\u4e8b\u4ef6 if ( isInternal ( message )) { if ( message . cmd === 'NODE_HANDLE' ) { handleMessage ( message , pendingHandle , true ); pendingHandle = null ; } else { handleMessage ( message , undefined , true ); } } else { handleMessage ( message , undefined , false ); } } } }; \u8fd9\u91cc\u4f1a\u89e6\u53d1\u5185\u90e8\u4e8b\u4ef6internalMessage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 target . on ( 'internalMessage' , function ( message , handle ) { // \u662f\u5426\u6536\u5230\u4e86handle if ( message . cmd !== 'NODE_HANDLE' ) return ; // \u6210\u529f\u6536\u5230\uff0c\u53d1\u9001ACK target . _send ({ cmd : 'NODE_HANDLE_ACK' }, null , true ); const obj = handleConversion [ message . type ]; /* C++\u5bf9\u8c61\u8f6c\u6210JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002\u8f6c\u5b8c\u4e4b\u540e\u518d\u6839\u636e\u91cc\u5c42\u7684\u5b57\u6bb5 message.msg\u8fdb\u4e00\u6b65\u5904\u7406\uff0c\u6216\u8005\u89e6\u53d1message\u4e8b\u4ef6\u4f20\u7ed9\u7528\u6237 */ obj . got . call ( this , message , handle , ( handle ) => { handleMessage ( message . msg , handle , isInternal ( message . msg )); }); }) \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u4f1a\u628aC++\u5c42\u7684\u5bf9\u8c61\u8f6c\u6210JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002\u5982TCP 1 2 3 4 5 6 got ( message , handle , emit ) { const server = new net . Server (); server . listen ( handle , () => { emit ( server ); }); } \u8fd9\u5c31\u662f\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u5728Node.js\u4e2d\u7684\u5904\u7406\u6d41\u7a0b\uff0c\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u662f\u4e00\u4e2a\u975e\u5e38\u6709\u7528\u7684\u80fd\u529b\uff0c\u6bd4\u5982\u4e00\u4e2a\u8fdb\u7a0b\u53ef\u4ee5\u628a\u4e00\u4e2aTCP\u8fde\u63a5\u6240\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u76f4\u63a5\u53d1\u9001\u7ed9\u53e6\u4e00\u4e2a\u8fdb\u7a0b\u5904\u7406\u3002\u8fd9\u4e5f\u662fcluser\u6a21\u5757\u7684\u539f\u7406\u3002\u540e\u7eed\u6211\u4eec\u4f1a\u770b\u5230\u3002\u5728Node.js\u4e2d\uff0c\u6574\u4f53\u7684\u5904\u7406\u6d41\u7a0b\u5c31\u662f\uff0c\u53d1\u9001\u7684\u65f6\u5019\u628a\u4e00\u4e2aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u4e00\u5c42\u5c42\u5730\u5265\u5f00\uff0c\u53d8\u6210C++\u5bf9\u8c61\uff0c\u7136\u540e\u518d\u53d8\u6210fd\uff0c\u6700\u540e\u901a\u8fc7\u5e95\u5c42API\u4f20\u9012\u7ed9\u53e6\u4e00\u4e2a\u8fdb\u7a0b\u3002\u63a5\u6536\u7684\u65f6\u5019\u5c31\u662f\u628a\u4e00\u4e2afd\u4e00\u5c42\u5c42\u5730\u5305\u88f9\uff0c\u53d8\u6210\u4e00\u4e2aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002","title":"13-\u8fdb\u7a0b"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#131-nodejs","text":"\u5f53\u6211\u4eec\u6267\u884cnode index.js\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u521b\u5efa\u4e00\u4e2aNode.js\u8fdb\u7a0b\uff0c\u6211\u4eec\u7684\u4ee3\u7801\u5c31\u662f\u5728\u8fd9\u4e2aNode.js\u8fdb\u7a0b\u4e2d\u6267\u884c\u3002\u4ece\u4ee3\u7801\u89d2\u5ea6\u6765\u8bf4\uff0c\u6211\u4eec\u5728Node.js\u4e2d\u611f\u77e5\u8fdb\u7a0b\u7684\u65b9\u5f0f\u662f\u901a\u8fc7process\u5bf9\u8c61\u3002\u672c\u8282\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u8fd9\u4e2a\u5bf9\u8c61\u3002","title":"13.1 Node.js\u4e3b\u8fdb\u7a0b"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1311-process","text":"Node.js\u542f\u52a8\u7684\u65f6\u5019\u4f1a\u6267\u884c\u4ee5\u4e0b\u4ee3\u7801\u521b\u5efaprocess\u5bf9\u8c61\uff08env.cc\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Local < Object > process_object = node :: CreateProcessObject ( this ). FromMaybe ( Local < Object > ()); set_process_object ( process_object ); // process\u5bf9\u8c61\u901a\u8fc7CreateProcessObject\u521b\u5efa\uff0c\u7136\u540e\u4fdd\u5b58\u5230env\u5bf9\u8c61\u4e2d\u3002\u6211\u4eec\u770b\u4e00\u4e0bCreateProcessObject\u3002 MaybeLocal < Object > CreateProcessObject ( Environment * env ) { Isolate * isolate = env -> isolate (); EscapableHandleScope scope ( isolate ); Local < Context > context = env -> context (); Local < FunctionTemplate > process_template = FunctionTemplate :: New ( isolate ); process_template -> SetClassName ( env -> process_string ()); Local < Function > process_ctor ; Local < Object > process ; // \u65b0\u5efaprocess\u5bf9\u8c61 if ( ! process_template -> GetFunction ( context ). ToLocal ( & process_ctor ) || ! process_ctor -> NewInstance ( context ). ToLocal ( & process )) { return MaybeLocal < Object > (); } // \u8bbe\u7f6e\u4e00\u7cfb\u5217\u5c5e\u6027\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u901a\u8fc7process\u5bf9\u8c61\u8bbf\u95ee\u7684\u5c5e\u6027 // Node.js\u7684\u7248\u672c READONLY_PROPERTY ( process , \"version\" , FIXED_ONE_BYTE_STRING ( env -> isolate (), NODE_VERSION )); // \u5ffd\u7565\u5176\u4ed6\u5c5e\u6027 return scope . Escape ( process ); } \u8fd9\u662f\u4f7f\u7528V8\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\u7684\u5178\u578b\u4f8b\u5b50\uff0c\u5e76\u4e14\u8bbe\u7f6e\u4e86\u4e00\u4e9b\u5c5e\u6027\u3002Node.js\u542f\u52a8\u8fc7\u7a0b\u4e2d\uff0c\u5f88\u591a\u5730\u65b9\u90fd\u4f1a\u7ed9process\u6302\u8f7d\u5c5e\u6027\u3002\u4e0b\u9762\u6211\u4eec\u770b\u6211\u4eec\u5e38\u7528\u7684process.env\u662f\u600e\u4e48\u6302\u8f7d\u7684\u3002","title":"13.1.1 \u521b\u5efaprocess\u5bf9\u8c61"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1312-env","text":"1 2 3 4 5 6 7 8 9 10 11 12 Local < String > env_string = FIXED_ONE_BYTE_STRING ( isolate_ , \"env\" ); Local < Object > env_var_proxy ; // \u8bbe\u7f6eprocess\u7684env\u5c5e\u6027 if ( ! CreateEnvVarProxy ( context (), isolate_ , as_callback_data ()) . ToLocal ( & env_var_proxy ) || process_object () -> Set ( context (), env_string , env_var_proxy ). IsNothing ()) { return MaybeLocal < Value > (); } \u4e0a\u9762\u7684\u4ee3\u7801\u901a\u8fc7CreateEnvVarProxy\u521b\u5efa\u4e86\u4e00\u4e2a\u5bf9\u8c61\uff0c\u7136\u540e\u4fdd\u5b58\u5230env_var_proxy\u4e2d\uff0c\u6700\u540e\u7ed9process\u6302\u8f7d\u4e86env\u5c5e\u6027\u3002\u5b83\u7684\u503c\u662fCreateEnvVarProxy\u521b\u5efa\u7684\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 MaybeLocal < Object > CreateEnvVarProxy ( Local < Context > context , Isolate * isolate , Local < Object > data ) { EscapableHandleScope scope ( isolate ); Local < ObjectTemplate > env_proxy_template = ObjectTemplate :: New ( isolate ); env_proxy_template -> SetHandler ( NamedPropertyHandlerConfiguration ( EnvGetter , EnvSetter , EnvQuery , EnvDeleter , EnvEnumerator , data , PropertyHandlerFlags :: kHasNoSideEffect )); return scope . EscapeMaybe ( env_proxy_template -> NewInstance ( context )); } CreateEnvVarProxy\u9996\u5148\u7533\u8bf7\u4e00\u4e2a\u5bf9\u8c61\u6a21\u677f\uff0c\u7136\u540e\u8bbe\u7f6e\u901a\u8fc7\u8be5\u5bf9\u8c61\u6a21\u677f\u521b\u5efa\u7684\u5bf9\u8c61\u7684\u8bbf\u95ee\u63cf\u8ff0\u7b26\u3002\u6211\u4eec\u770b\u4e00\u4e0bgetter\u63cf\u8ff0\u7b26\uff08EnvGetter\uff09\u7684\u5b9e\u73b0\uff0cgetter\u63cf\u8ff0\u7b26\u548c\u6211\u4eec\u5728JS\u91cc\u4f7f\u7528\u7684\u7c7b\u4f3c\u3002 1 2 3 4 5 6 7 8 static void EnvGetter ( Local < Name > property , const PropertyCallbackInfo < Value >& info ) { Environment * env = Environment :: GetCurrent ( info ); MaybeLocal < String > value_string = env -> env_vars () -> Get ( env -> isolate (), property . As < String > ()); if ( ! value_string . IsEmpty ()) { info . GetReturnValue (). Set ( value_string . ToLocalChecked ()); } } \u6211\u4eec\u770b\u5230getter\u662f\u4eceenv->env_vars()\u4e2d\u83b7\u53d6\u6570\u636e\uff0c\u90a3\u4e48env->env_vars()\u53c8\u662f\u4ec0\u4e48\u5462\uff1fenv_vars\u662f\u4e00\u4e2akv\u5b58\u50a8\u7cfb\u7edf\uff0c\u5176\u5b9e\u5c31\u662f\u4e00\u4e2amap\u3002\u5b83\u53ea\u5728Node.js\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\uff08\u521b\u5efaenv\u5bf9\u8c61\u65f6\uff09\u3002 1 set_env_vars ( per_process :: system_environment ); \u90a3\u4e48per_process::system_environment\u53c8\u662f\u4ec0\u4e48\u5462\uff1f\u6211\u4eec\u7ee7\u7eed\u5f80\u4e0b\u770b\uff0c 1 std :: shared_ptr < KVStore > system_environment = std :: make_shared < RealEnvStore > (); \u6211\u4eec\u770b\u5230system_environment\u662f\u4e00\u4e2aRealEnvStore\u5bf9\u8c61\u3002\u6211\u4eec\u770b\u4e00\u4e0bRealEnvStore\u7c7b\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 class RealEnvStore final : public KVStore { public : MaybeLocal < String > Get ( Isolate * isolate , Local < String > key ) const override ; void Set ( Isolate * isolate , Local < String > key , Local < String > value ) override ; int32_t Query ( Isolate * isolate , Local < String > key ) const override ; void Delete ( Isolate * isolate , Local < String > key ) override ; Local < Array > Enumerate ( Isolate * isolate ) const override ; }; \u6bd4\u8f83\u7b80\u5355\uff0c\u5c31\u662f\u589e\u5220\u6539\u67e5\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u67e5\u8be2Get\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 MaybeLocal < String > RealEnvStore :: Get ( Isolate * isolate , Local < String > property ) const { Mutex :: ScopedLock lock ( per_process :: env_var_mutex ); node :: Utf8Value key ( isolate , property ); size_t init_sz = 256 ; MaybeStackBuffer < char , 256 > val ; int ret = uv_os_getenv ( * key , * val , & init_sz ); if ( ret >= 0 ) { // Env key value fetch success. MaybeLocal < String > value_string = String :: NewFromUtf8 ( isolate , * val , NewStringType :: kNormal , init_sz ); return value_string ; } return MaybeLocal < String > (); } \u6211\u4eec\u770b\u5230\u662f\u901a\u8fc7uv_os_getenv\u83b7\u53d6\u7684\u6570\u636e\u3002uv_os_getenv\u662f\u5bf9getenv\u51fd\u6570\u7684\u5c01\u88c5\uff0c\u8fdb\u7a0b\u7684\u5185\u5b58\u5e03\u5c40\u4e2d\uff0c\u6709\u4e00\u90e8\u5206\u662f\u7528\u4e8e\u5b58\u50a8\u73af\u5883\u53d8\u91cf\u7684\uff0cgetenv\u5c31\u662f\u4ece\u90a3\u4e00\u5757\u5185\u5b58\u4e2d\u628a\u6570\u636e\u8bfb\u53d6\u51fa\u6765\u3002\u6211\u4eec\u6267\u884cexecve\u7684\u65f6\u5019\u53ef\u4ee5\u8bbe\u7f6e\u73af\u5883\u53d8\u91cf\u3002\u5177\u4f53\u7684\u6211\u4eec\u5728\u5b50\u8fdb\u7a0b\u7ae0\u8282\u4f1a\u770b\u5230\u3002\u81f3\u6b64\uff0c\u6211\u4eec\u77e5\u9053process\u7684env\u5c5e\u6027\u5bf9\u5e94\u7684\u503c\u5c31\u662f\u8fdb\u7a0b\u73af\u5883\u53d8\u91cf\u7684\u5185\u5bb9\u3002","title":"13.1.2 \u6302\u8f7denv\u5c5e\u6027"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1313","text":"\u5728Node.js\u7684\u542f\u52a8\u8fc7\u7a0b\u4e2d\u4f1a\u4e0d\u65ad\u5730\u6302\u8f7d\u5c5e\u6027\u5230process\u3002\u4e3b\u8981\u5728bootstrap/node.js\u4e2d\u3002\u4e0d\u4e00\u4e00\u5217\u4e3e\u3002 1 2 3 4 const rawMethods = internalBinding ( 'process_methods' ); process . dlopen = rawMethods . dlopen ; process . uptime = rawMethods . uptime ; process . nextTick = nextTick ; \u4e0b\u9762\u662fprocess_methods\u6a21\u5757\u5bfc\u51fa\u7684\u5c5e\u6027\uff0c\u4e3b\u5217\u51fa\u5e38\u7528\u7684\u3002 1 2 3 4 5 env -> SetMethod ( target , \"memoryUsage\" , MemoryUsage ); env -> SetMethod ( target , \"cpuUsage\" , CPUUsage ); env -> SetMethod ( target , \"hrtime\" , Hrtime ); env -> SetMethod ( target , \"dlopen\" , binding :: DLOpen ); env -> SetMethodNoSideEffect ( target , \"uptime\" , Uptime ); \u6211\u4eec\u770b\u5230\u5728JS\u5c42\u8bbf\u95eeprocess\u5c5e\u6027\u7684\u65f6\u5019\uff0c\u8bbf\u95ee\u7684\u662f\u5bf9\u5e94\u7684C++\u5c42\u7684\u8fd9\u4e9b\u65b9\u6cd5\uff0c\u5927\u90e8\u5206\u4e5f\u53ea\u662f\u5bf9Libuv\u7684\u5c01\u88c5\u3002\u53e6\u5916\u5728Node.js\u521d\u59cb\u5316\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u6267\u884cPatchProcessObject\u3002PatchProcessObject\u51fd\u6570\u4f1a\u6302\u8f7d\u4e00\u4e9b\u989d\u5916\u7684\u5c5e\u6027\u7ed9process\u3002 1 2 3 4 5 6 7 8 9 10 11 12 // process.argv process -> Set ( context , FIXED_ONE_BYTE_STRING ( isolate , \"argv\" ), ToV8Value ( context , env -> argv ()). ToLocalChecked ()). Check (); READONLY_PROPERTY ( process , \"pid\" , Integer :: New ( isolate , uv_os_getpid ())); CHECK ( process -> SetAccessor ( context , FIXED_ONE_BYTE_STRING ( isolate , \"ppid\" ), GetParentProcessId ). FromJust ()) \u5728Node.js\u521d\u59cb\u5316\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5728\u591a\u4e2a\u5730\u65b9\u90fd\u4f1a\u7ed9process\u5bf9\u8c61\u6302\u8f7d\u5c5e\u6027\uff0c\u8fd9\u91cc\u53ea\u5217\u51fa\u4e86\u4e00\u90e8\u5206\uff0c\u6709\u5174\u8da3\u7684\u540c\u5b66\u53ef\u4ee5\u4ecebootstrap/node.js\u7684\u4ee3\u7801\u5f00\u59cb\u770b\u90fd\u6302\u8f7d\u4e86\u4ec0\u4e48\u5c5e\u6027\u3002\u56e0\u4e3aNode.js\u652f\u6301\u591a\u7ebf\u7a0b\uff0c\u6240\u4ee5\u9488\u5bf9\u7ebf\u7a0b\u7684\u60c5\u51b5\uff0c\u6709\u4e00\u4e9b\u7279\u6b8a\u7684\u5904\u7406\u3002 1 2 3 4 5 6 7 8 const perThreadSetup = require ( 'internal/process/per_thread' ); // rawMethods\u6765\u81eaprocess_methods\u6a21\u5757\u5bfc\u51fa\u7684\u5c5e\u6027 const wrapped = perThreadSetup . wrapProcessMethods ( rawMethods ); process . hrtime = wrapped . hrtime ; process . cpuUsage = wrapped . cpuUsage ; process . memoryUsage = wrapped . memoryUsage ; process . kill = wrapped . kill ; process . exit = wrapped . exit ; \u5927\u90e8\u5206\u51fd\u6570\u90fd\u662f\u5bf9process_methods\u6a21\u5757\uff08node_process_methods.cc\uff09\u7684\u5c01\u88c5\u3002\u4f46\u662f\u6709\u4e00\u4e2a\u5c5e\u6027\u6211\u4eec\u9700\u8981\u5173\u6ce8\u4e00\u4e0b\uff0c\u5c31\u662fexit\uff0c\u56e0\u4e3a\u5728\u7ebf\u7a0b\u4e2d\u8c03\u7528process.exit\u7684\u65f6\u5019\uff0c\u53ea\u4f1a\u9000\u51fa\u5355\u4e2a\u7ebf\u7a0b\uff0c\u800c\u4e0d\u662f\u6574\u4e2a\u8fdb\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 function exit ( code ) { if ( code || code === 0 ) process . exitCode = code ; if ( ! process . _exiting ) { process . _exiting = true ; process . emit ( 'exit' , process . exitCode || 0 ); } process . reallyExit ( process . exitCode || 0 ); } \u6211\u4eec\u7ee7\u7eed\u770breallyExit 1 2 3 4 5 6 static void ReallyExit ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); RunAtExit ( env ); int code = args [ 0 ] -> Int32Value ( env -> context ()). FromMaybe ( 0 ); env -> Exit ( code ); } \u8c03\u7528\u4e86env\u7684Exit\u3002 1 2 3 4 5 6 7 8 9 void Environment::Exit ( int exit_code ) { if ( is_main_thread ()) { stop_sub_worker_contexts (); DisposePlatform (); exit ( exit_code ); } else { worker_context_ -> Exit ( exit_code ); } } \u8fd9\u91cc\u6211\u4eec\u770b\u5230\u4e86\u91cd\u70b9\uff0c\u6839\u636e\u5f53\u524d\u662f\u4e3b\u7ebf\u7a0b\u8fd8\u662f\u5b50\u7ebf\u7a0b\u4f1a\u505a\u4e0d\u540c\u7684\u5904\u7406\u3002\u4e00\u4e2a\u7ebf\u7a0b\u4f1a\u5bf9\u5e94\u4e00\u4e2aenv\uff0cenv\u5bf9\u8c61\u4e2d\u7684worker_context_\u4fdd\u5b58\u5c31\u662f\u7ebf\u7a0b\u5bf9\u8c61\uff08Worker\uff09\u3002\u6211\u4eec\u5148\u770b\u5b50\u7ebf\u7a0b\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void Worker::Exit ( int code ) { Mutex :: ScopedLock lock ( mutex_ ); if ( env_ != nullptr ) { exit_code_ = code ; Stop ( env_ ); } else { stopped_ = true ; } } int Stop ( Environment * env ) { env -> ExitEnv (); return 0 ; } void Environment::ExitEnv () { set_can_call_into_js ( false ); set_stopping ( true ); isolate_ -> TerminateExecution (); // \u9000\u51faLibuv\u4e8b\u4ef6\u5faa\u73af SetImmediateThreadsafe ([]( Environment * env ) { uv_stop ( env -> event_loop ()); }); } \u6211\u4eec\u770b\u5230\u5b50\u7ebf\u7a0b\u6700\u540e\u8c03\u7528uv_stop\u63d0\u51fa\u4e86Libuv\u4e8b\u4ef6\u5faa\u73af\uff0c\u7136\u540e\u9000\u51fa\u3002\u6211\u4eec\u518d\u6765\u770b\u4e3b\u7ebf\u7a0b\u7684\u9000\u51fa\u903b\u8f91\u3002 1 2 3 4 5 if ( is_main_thread ()) { stop_sub_worker_contexts (); DisposePlatform (); exit ( exit_code ); } \u6211\u4eec\u770b\u5230\u6700\u540e\u4e3b\u8fdb\u7a0b\u4e2d\u8c03\u7528exit\u9000\u51fa\u8fdb\u7a0b\u3002\u4f46\u662f\u9000\u51fa\u524d\u8fd8\u6709\u4e00\u4e9b\u5904\u7406\u5de5\u4f5c\uff0c\u6211\u4eec\u770bstop_sub_worker_contexts 1 2 3 4 5 6 7 8 void Environment::stop_sub_worker_contexts () { while ( ! sub_worker_contexts_ . empty ()) { Worker * w = * sub_worker_contexts_ . begin (); remove_sub_worker_context ( w ); w -> Exit ( 1 ); w -> JoinThread (); } } sub_worker_contexts\u4fdd\u5b58\u7684\u662fWorker\u5bf9\u8c61\u5217\u8868\uff0c\u6bcf\u6b21\u521b\u5efa\u4e00\u4e2a\u7ebf\u7a0b\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u5f80\u91cc\u8ffd\u52a0\u4e00\u4e2a\u5143\u7d20\u3002\u8fd9\u91cc\u904d\u5386\u8fd9\u4e2a\u5217\u8868\uff0c\u7136\u540e\u8c03\u7528Exit\u51fd\u6570\uff0c\u8fd9\u4e2a\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u5c31\u662f\u9000\u51faLibuv\u4e8b\u4ef6\u5faa\u73af\u3002\u4e3b\u7ebf\u7a0b\u63a5\u7740\u8c03JoinThread\uff0cJoinThread\u4e3b\u8981\u662f\u4e3a\u4e86\u963b\u585e\u7b49\u5f85\u5b50\u7ebf\u7a0b\u9000\u51fa\uff0c\u56e0\u4e3a\u5b50\u7ebf\u7a0b\u5728\u9000\u51fa\u7684\u65f6\u5019\uff0c\u53ef\u80fd\u4f1a\u88ab\u64cd\u4f5c\u7cfb\u7edf\u6302\u8d77\uff08\u6267\u884c\u65f6\u95f4\u7247\u5230\u4e86\uff09\uff0c\u8fd9\u65f6\u5019\u4e3b\u7ebf\u7a0b\u88ab\u8c03\u5ea6\u6267\u884c\uff0c\u4f46\u662f\u8fd9\u65f6\u5019\u4e3b\u7ebf\u7a0b\u8fd8\u4e0d\u80fd\u9000\u51fa\uff0c\u6240\u4ee5\u8fd9\u91cc\u4f7f\u7528join\u963b\u585e\u7b49\u5f85\u5b50\u7ebf\u7a0b\u9000\u51fa\u3002Node.js\u7684JoinThread\u9664\u4e86\u5bf9\u7ebf\u7a0bjoin\u51fd\u6570\u7684\u5c01\u88c5\u3002\u8fd8\u505a\u4e86\u4e00\u4e9b\u989d\u5916\u7684\u4e8b\u60c5\uff0c\u6bd4\u5982\u89e6\u53d1exit\u4e8b\u4ef6\u3002","title":"13.1.3 \u6302\u8f7d\u5176\u5b83\u5c5e\u6027"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#132","text":"\u56e0\u4e3aNode.js\u662f\u5355\u8fdb\u7a0b\u7684\uff0c\u4f46\u6709\u5f88\u591a\u4e8b\u60c5\u53ef\u80fd\u4e0d\u9002\u5408\u5728\u4e3b\u8fdb\u7a0b\u91cc\u5904\u7406\u7684\uff0c\u6240\u4ee5Node.js\u63d0\u4f9b\u4e86\u5b50\u8fdb\u7a0b\u6a21\u5757\uff0c\u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u5b50\u8fdb\u7a0b\u505a\u4e00\u4e9b\u989d\u5916\u4efb\u52a1\u7684\u5904\u7406\uff0c\u53e6\u5916\uff0c\u5b50\u8fdb\u7a0b\u7684\u597d\u5904\u662f\uff0c\u4e00\u65e6\u5b50\u8fdb\u7a0b\u51fa\u95ee\u9898\u6302\u6389\u4e0d\u4f1a\u5f71\u54cd\u4e3b\u8fdb\u7a0b\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5728\u7528C\u8bed\u8a00\u5982\u4f55\u521b\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <unistd.h> #include <stdlib.h> int main ( int argc , char * argv []){ pid_t pid = fork (); if ( pid < 0 ) { // \u9519\u8bef } else if ( pid == 0 ) { // \u5b50\u8fdb\u7a0b\uff0c\u53ef\u4ee5\u4f7f\u7528exec*\u7cfb\u5217\u51fd\u6570\u6267\u884c\u65b0\u7684\u7a0b\u5e8f } else { // \u7236\u8fdb\u7a0b } } fork\u51fd\u6570\u7684\u7279\u70b9\uff0c\u6211\u4eec\u542c\u5f97\u6700\u591a\u7684\u53ef\u80fd\u662f\u6267\u884c\u4e00\u6b21\u8fd4\u56de\u4e24\u6b21\uff0c\u6211\u4eec\u53ef\u80fd\u4f1a\u7591\u60d1\uff0c\u6267\u884c\u4e00\u4e2a\u51fd\u6570\u600e\u4e48\u53ef\u80fd\u8fd4\u56de\u4e86\u4e24\u6b21\u5462\uff1f\u4e4b\u524d\u6211\u4eec\u8bb2\u8fc7\uff0c\u8fdb\u7a0b\u662ftask_struct\u8868\u793a\u7684\u4e00\u4e2a\u5b9e\u4f8b\uff0c\u8c03\u7528 fork\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u65b0\u5efa\u4e00\u4e2a\u65b0\u7684task_struct\u5b9e\u4f8b\u51fa\u6765\uff08\u53d8\u6210\u4e24\u4e2a\u8fdb\u7a0b\uff09\uff0cfork\u8fd4\u56de\u4e24\u6b21\u7684\u610f\u601d\u5176\u5b9e\u662f\u5728\u5728\u4e24\u4e2a\u8fdb\u7a0b\u5206\u522b\u8fd4\u56de\u4e00\u6b21\uff0c\u6267\u884c\u7684\u90fd\u662ffork\u540e\u9762\u7684\u4e00\u884c\u4ee3\u7801\u3002\u800c\u64cd\u4f5c\u7cfb\u7edf\u6839\u636e\u5f53\u524d\u8fdb\u7a0b\u662f\u4e3b\u8fdb\u7a0b\u8fd8\u662f\u5b50\u8fdb\u7a0b\uff0c\u8bbe\u7f6e\u4e86fork\u51fd\u6570\u7684\u8fd4\u56de\u503c\u3002\u6240\u4ee5\u4e0d\u540c\u7684\u8fdb\u7a0b\uff0cfork\u8fd4\u56de\u503c\u4e0d\u4e00\u6837\uff0c\u4e5f\u5c31\u662f\u6211\u4eec\u4ee3\u7801\u4e2dif else\u6761\u4ef6\u3002\u4f46\u662ffork\u53ea\u662f\u590d\u5236\u4e3b\u8fdb\u7a0b\u7684\u5185\u5bb9\uff0c\u5982\u679c\u6211\u4eec\u60f3\u6267\u884c\u53e6\u5916\u4e00\u4e2a\u7a0b\u5e8f\uff0c\u600e\u4e48\u529e\u5462\uff1f\u8fd9\u65f6\u5019\u5c31\u9700\u8981\u7528\u5230exec*\u7cfb\u5217\u51fd\u6570\uff0c\u8be5\u7cfb\u5217\u51fd\u6570\u4f1a\u8986\u76d6\u65e7\u8fdb\u7a0b\uff08task_struct\uff09\u7684\u90e8\u5206\u5185\u5bb9\uff0c\u91cd\u65b0\u52a0\u8f7d\u65b0\u7684\u7a0b\u5e8f\u5185\u5bb9\u3002\u8fd9\u4e5f\u662fNode.js\u4e2d\u521b\u5efa\u5b50\u8fdb\u7a0b\u7684\u5e95\u5c42\u539f\u7406\u3002Node.js\u867d\u7136\u63d0\u4f9b\u4e86\u5f88\u591a\u79cd\u521b\u5efa\u8fdb\u7a0b\u7684\u65b9\u5f0f\uff0c\u4f46\u662f\u672c\u8d28\u4e0a\u662f\u540c\u6b65\u548c\u5f02\u6b65\u4e24\u79cd\u65b9\u5f0f\u3002","title":"13.2 \u521b\u5efa\u5b50\u8fdb\u7a0b"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1321","text":"\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5f02\u6b65\u65b9\u5f0f\u521b\u5efa\u8fdb\u7a0b\u65f6\u7684\u5173\u7cfb\u56fe\u5982\u56fe13-1\u6240\u793a\u3002 \u56fe13-1 \u6211\u4eec\u4ecefork\u8fd9\u4e2a\u51fd\u6570\u5f00\u59cb\uff0c\u770b\u4e00\u4e0b\u6574\u4e2a\u6d41\u7a0b\u3002 1 2 3 4 function fork ( modulePath /* , args, options */ ) { // \u4e00\u7cfb\u5217\u53c2\u6570\u5904\u7406 return spawn ( options . execPath , args , options ); } \u6211\u4eec\u63a5\u7740\u770bspawn 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var spawn = exports . spawn = function ( /*file, args, options*/ ) { var opts = normalizeSpawnArguments . apply ( null , arguments ); var options = opts . options ; var child = new ChildProcess (); child . spawn ({ file : opts . file , args : opts . args , cwd : options . cwd , windowsHide : !! options . windowsHide , windowsVerbatimArguments : !! options . windowsVerbatimArguments , detached : !! options . detached , envPairs : opts . envPairs , stdio : options . stdio , uid : options . uid , gid : options . gid }); return child ; }; \u6211\u4eec\u770b\u5230spawn\u51fd\u6570\u53ea\u662f\u5bf9ChildProcess\u7684\u5c01\u88c5\u3002\u7136\u540e\u8c03\u7528\u5b83\u7684spawn\u51fd\u6570\u3002\u6211\u4eec\u770b\u770bChildProcess\u3002 1 2 3 4 5 6 7 8 9 function ChildProcess () { // C++\u5c42\u5b9a\u4e49 this . _handle = new Process (); } ChildProcess . prototype . spawn = function ( options ) { // \u521b\u5efa\u8fdb\u7a0b const err = this . _handle . spawn ( options ); } ChildProcess\u662f\u5bf9C++\u5c42\u7684\u5c01\u88c5\uff0c\u4e0d\u8fc7Process\u5728C++\u5c42\u4e5f\u6ca1\u6709\u592a\u591a\u903b\u8f91\uff0c\u8fdb\u884c\u53c2\u6570\u7684\u5904\u7406\u7136\u540e\u8c03\u7528Libuv\u7684uv_spawn\u3002\u6211\u4eec\u901a\u8fc7uv_spawn\u6765\u5230\u4e86C\u8bed\u8a00\u5c42\u3002\u6211\u4eec\u770b\u770buv_spawn\u7684\u6574\u4f53\u6d41\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 int uv_spawn ( uv_loop_t * loop , uv_process_t * process , const uv_process_options_t * options ) { uv__handle_init ( loop , ( uv_handle_t * ) process , UV_PROCESS ); QUEUE_INIT ( & process -> queue ); // \u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1 for ( i = 0 ; i < options -> stdio_count ; i ++ ) { err = uv__process_init_stdio ( options -> stdio + i , pipes [ i ]); if ( err ) goto error ; } /* \u521b\u5efa\u4e00\u4e2a\u7ba1\u9053\u7528\u4e8e\u521b\u5efa\u8fdb\u7a0b\u671f\u95f4\u7684\u7236\u8fdb\u7a0b\u5b50\u901a\u4fe1\uff0c \u8bbe\u7f6eUV__O_CLOEXEC\u6807\u8bb0\uff0c\u5b50\u8fdb\u7a0b\u6267\u884cexecvp \u7684\u65f6\u5019\u7ba1\u9053\u7684\u4e00\u7aef\u4f1a\u88ab\u5173\u95ed */ err = uv__make_pipe ( signal_pipe , 0 ); // \u6ce8\u518c\u5b50\u8fdb\u7a0b\u9000\u51fa\u4fe1\u53f7\u7684\u5904\u7406\u51fd\u6570 uv_signal_start ( & loop -> child_watcher , uv__chld , SIGCHLD ); uv_rwlock_wrlock ( & loop -> cloexec_lock ); // \u521b\u5efa\u5b50\u8fdb\u7a0b pid = fork (); // \u5b50\u8fdb\u7a0b if ( pid == 0 ) { uv__process_child_init ( options , stdio_count , pipes , signal_pipe [ 1 ]); abort (); } // \u7236\u8fdb\u7a0b uv_rwlock_wrunlock ( & loop -> cloexec_lock ); // \u5173\u95ed\u7ba1\u9053\u5199\u7aef\uff0c\u7b49\u5f85\u5b50\u8fdb\u7a0b\u5199 uv__close ( signal_pipe [ 1 ]); process -> status = 0 ; exec_errorno = 0 ; // \u5224\u65ad\u5b50\u8fdb\u7a0b\u662f\u5426\u6267\u884c\u6210\u529f do r = read ( signal_pipe [ 0 ], & exec_errorno , sizeof ( exec_errorno )); while ( r == -1 && errno == EINTR ); // \u5ffd\u7565\u5904\u7406r\u7684\u903b\u8f91 // \u4fdd\u5b58\u901a\u4fe1\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5230\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784 for ( i = 0 ; i < options -> stdio_count ; i ++ ) { uv__process_open_stream ( options -> stdio + i , pipes [ i ]); } // \u63d2\u5165Libuv\u4e8b\u4ef6\u5faa\u73af\u7684\u7ed3\u6784\u4f53 if ( exec_errorno == 0 ) { QUEUE_INSERT_TAIL ( & loop -> process_handles , & process -> queue ); uv__handle_start ( process ); } process -> pid = pid ; process -> exit_cb = options -> exit_cb ; return exec_errorno ; } uv_spawn\u7684\u903b\u8f91\u5927\u81f4\u5206\u4e3a\u4e0b\u9762\u51e0\u4e2a 1 \u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1 2 \u6ce8\u518c\u5b50\u8fdb\u7a0b\u9000\u51fa\u5904\u7406\u51fd\u6570 3 \u521b\u5efa\u5b50\u8fdb\u7a0b 4 \u63d2\u5165Libuv\u4e8b\u4ef6\u5faa\u73af\u7684process_handles\u5bf9\u8c61\uff0c\u4fdd\u5b58\u72b6\u6001\u7801\u548c\u56de\u8c03\u7b49\u3002 \u6211\u4eec\u5206\u67902,3\uff0c\u8fdb\u7a0b\u95f4\u901a\u4fe1\u6211\u4eec\u5355\u72ec\u5206\u6790\u3002 1 \u5904\u7406\u5b50\u8fdb\u7a0b\u9000\u51fa \u4e3b\u8fdb\u7a0b\u5728\u521b\u5efa\u5b50\u8fdb\u7a0b\u4e4b\u524d\uff0c\u4f1a\u6ce8\u518cSIGCHLD\u4fe1\u53f7\u3002\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\u662fuv__chld\u3002\u5f53\u8fdb\u7a0b\u9000\u51fa\u7684\u65f6\u5019\u3002Node.js\u4e3b\u8fdb\u7a0b\u4f1a\u6536\u5230SIGCHLD\u4fe1\u53f7\u3002\u7136\u540e\u6267\u884cuv__chld\u3002\u8be5\u51fd\u6570\u904d\u5386Libuv\u8fdb\u7a0b\u961f\u5217\u4e2d\u7684\u8282\u70b9\uff0c\u901a\u8fc7waitpid\u5224\u65ad\u8be5\u8282\u70b9\u5bf9\u5e94\u7684\u8fdb\u7a0b\u662f\u5426\u5df2\u7ecf\u9000\u51fa\u540e\uff0c\u4ece\u800c\u5904\u7406\u5df2\u9000\u51fa\u7684\u8282\u70b9\uff0c\u7136\u540e\u79fb\u51faLibuv\u961f\u5217\uff0c\u6700\u540e\u6267\u884c\u5df2\u9000\u51fa\u8fdb\u7a0b\u7684\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 static void uv__chld ( uv_signal_t * handle , int signum ) { uv_process_t * process ; uv_loop_t * loop ; int exit_status ; int term_signal ; int status ; pid_t pid ; QUEUE pending ; QUEUE * q ; QUEUE * h ; // \u4fdd\u5b58\u8fdb\u7a0b\uff08\u5df2\u9000\u51fa\u7684\u72b6\u6001\uff09\u7684\u961f\u5217 QUEUE_INIT ( & pending ); loop = handle -> loop ; h = & loop -> process_handles ; q = QUEUE_HEAD ( h ); // \u6536\u96c6\u5df2\u9000\u51fa\u7684\u8fdb\u7a0b while ( q != h ) { process = QUEUE_DATA ( q , uv_process_t , queue ); q = QUEUE_NEXT ( q ); do /* WNOHANG\u975e\u963b\u585e\u7b49\u5f85\u5b50\u8fdb\u7a0b\u9000\u51fa\uff0c\u5176\u5b9e\u5c31\u662f\u770b\u5b50\u8fdb\u7a0b\u662f\u5426\u9000\u51fa\u4e86\uff0c \u6ca1\u6709\u7684\u8bdd\u5c31\u76f4\u63a5\u8fd4\u56de\uff0c\u800c\u4e0d\u662f\u963b\u585e */ pid = waitpid ( process -> pid , & status , WNOHANG ); while ( pid == -1 && errno == EINTR ); if ( pid == 0 ) continue ; /* \u8fdb\u7a0b\u9000\u51fa\u4e86\uff0c\u4fdd\u5b58\u9000\u51fa\u72b6\u6001\uff0c\u79fb\u51fa\u961f\u5217\uff0c \u63d2\u5165peding\u961f\u5217\uff0c\u7b49\u5f85\u5904\u7406 */ process -> status = status ; QUEUE_REMOVE ( & process -> queue ); QUEUE_INSERT_TAIL ( & pending , & process -> queue ); } h = & pending ; q = QUEUE_HEAD ( h ); // \u662f\u5426\u6709\u9000\u51fa\u7684\u8fdb\u7a0b while ( q != h ) { process = QUEUE_DATA ( q , uv_process_t , queue ); q = QUEUE_NEXT ( q ); QUEUE_REMOVE ( & process -> queue ); QUEUE_INIT ( & process -> queue ); uv__handle_stop ( process ); if ( process -> exit_cb == NULL ) continue ; exit_status = 0 ; // \u83b7\u53d6\u9000\u51fa\u4fe1\u606f\uff0c\u6267\u884c\u4e0a\u4f20\u56de\u8c03 if ( WIFEXITED ( process -> status )) exit_status = WEXITSTATUS ( process -> status ); // \u662f\u5426\u56e0\u4e3a\u4fe1\u53f7\u800c\u9000\u51fa term_signal = 0 ; if ( WIFSIGNALED ( process -> status )) term_signal = WTERMSIG ( process -> status ); process -> exit_cb ( process , exit_status , term_signal ); } } \u5f53\u4e3b\u8fdb\u7a0b\u4e0b\u7684\u5b50\u8fdb\u7a0b\u9000\u51fa\u65f6\uff0c\u7236\u8fdb\u7a0b\u4e3b\u8981\u8d1f\u8d23\u6536\u96c6\u5b50\u8fdb\u7a0b\u9000\u51fa\u72b6\u6001\u548c\u539f\u56e0\u7b49\u4fe1\u606f\uff0c\u7136\u540e\u6267\u884c\u4e0a\u5c42\u56de\u8c03\u3002 2 \u521b\u5efa\u5b50\u8fdb\u7a0b\uff08uv__process_child_init\uff09 \u4e3b\u8fdb\u7a0b\u9996\u5148\u4f7f\u7528uv__make_pipe\u7533\u8bf7\u4e00\u4e2a\u533f\u540d\u7ba1\u9053\u7528\u4e8e\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u901a\u4fe1\uff0c\u533f\u540d\u7ba1\u9053\u662f\u8fdb\u7a0b\u95f4\u901a\u4fe1\u4e2d\u6bd4\u8f83\u7b80\u5355\u7684\u4e00\u79cd\uff0c\u5b83\u53ea\u7528\u4e8e\u6709\u7ee7\u627f\u5173\u7cfb\u7684\u8fdb\u7a0b\uff0c\u56e0\u4e3a\u533f\u540d\uff0c\u975e\u7ee7\u627f\u5173\u7cfb\u7684\u8fdb\u7a0b\u65e0\u6cd5\u627e\u5230\u8fd9\u4e2a\u7ba1\u9053\uff0c\u4e5f\u5c31\u65e0\u6cd5\u5b8c\u6210\u901a\u4fe1\uff0c\u800c\u6709\u7ee7\u627f\u5173\u7cfb\u7684\u8fdb\u7a0b\uff0c\u662f\u901a\u8fc7fork\u51fa\u6765\u7684\uff0c\u7236\u5b50\u8fdb\u7a0b\u53ef\u4ee5\u83b7\u5f97\u5f97\u5230\u7ba1\u9053\u3002\u8fdb\u4e00\u6b65\u6765\u8bf4\uff0c\u5b50\u8fdb\u7a0b\u53ef\u4ee5\u4f7f\u7528\u7ee7\u627f\u4e8e\u7236\u8fdb\u7a0b\u7684\u8d44\u6e90\uff0c\u7ba1\u9053\u901a\u4fe1\u7684\u539f\u7406\u5982\u56fe13-2\u6240\u793a\u3002 \u56fe13-2 \u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u901a\u8fc7\u5171\u4eabfile\u548cinode\u7ed3\u6784\u4f53\uff0c\u5b9e\u73b0\u5bf9\u540c\u4e00\u5757\u5185\u5b58\u7684\u8bfb\u5199\u3002\u4e3b\u8fdb\u7a0bfork\u521b\u5efa\u5b50\u8fdb\u7a0b\u540e\uff0c\u4f1a\u901a\u8fc7read\u963b\u585e\u7b49\u5f85\u5b50\u8fdb\u7a0b\u7684\u6d88\u606f\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 static void uv__process_child_init ( const uv_process_options_t * options , int stdio_count , int ( * pipes )[ 2 ], int error_fd ) { sigset_t set ; int close_fd ; int use_fd ; int err ; int fd ; int n ; // \u7701\u7565\u5904\u7406\u6587\u4ef6\u63cf\u8ff0\u7b26\u7b49\u53c2\u6570\u903b\u8f91 // \u5904\u7406\u73af\u5883\u53d8\u91cf if ( options -> env != NULL ) { environ = options -> env ; } // \u5904\u7406\u4fe1\u53f7 for ( n = 1 ; n < 32 ; n += 1 ) { // \u8fd9\u4e24\u4e2a\u4fe1\u53f7\u89e6\u53d1\u65f6\uff0c\u9ed8\u8ba4\u884c\u4e3a\u662f\u8fdb\u7a0b\u9000\u51fa\u4e14\u4e0d\u80fd\u963b\u6b62\u7684 if ( n == SIGKILL || n == SIGSTOP ) continue ; /* Can't be changed. */ // \u8bbe\u7f6e\u4e3a\u9ed8\u8ba4\u5904\u7406\u65b9\u5f0f if ( SIG_ERR != signal ( n , SIG_DFL )) continue ; // \u51fa\u9519\u5219\u901a\u77e5\u4e3b\u8fdb\u7a0b uv__write_int ( error_fd , UV__ERR ( errno )); _exit ( 127 ); } // \u52a0\u8f7d\u65b0\u7684\u6267\u884c\u6587\u4ef6 execvp ( options -> file , options -> args ); // \u52a0\u8f7d\u6210\u529f\u5219\u4e0d\u4f1a\u8d70\u5230\u8fd9\uff0c\u8d70\u5230\u8fd9\u8bf4\u660e\u52a0\u8f7d\u6267\u884c\u6587\u4ef6\u5931\u8d25 uv__write_int ( error_fd , UV__ERR ( errno )); _exit ( 127 ); } \u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\u4e3b\u8981\u662f\u5904\u7406\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u4fe1\u53f7\u3001\u8bbe\u7f6e\u73af\u5883\u53d8\u91cf\u7b49\u3002\u7136\u540e\u52a0\u8f7d\u65b0\u7684\u6267\u884c\u6587\u4ef6\u3002\u56e0\u4e3a\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u901a\u4fe1\u7684\u7ba1\u9053\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u8bbe\u7f6e\u4e86cloexec\u6807\u8bb0\u3002\u6240\u4ee5\u5f53\u5b50\u8fdb\u7a0b\u52a0\u8f7d\u65b0\u7684\u6267\u884c\u6587\u4ef6\u65f6\uff0c\u5c31\u4f1a\u5173\u95ed\u7528\u4e8e\u548c\u4e3b\u8fdb\u7a0b\u901a\u4fe1\u7684\u7ba1\u9053\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u4ece\u800c\u5bfc\u81f4\u4e3b\u8fdb\u7a0b\u8bfb\u53d6\u7ba1\u9053\u8bfb\u7aef\u7684\u65f6\u5019\u8fd4\u56de0\uff0c\u8fd9\u6837\u4e3b\u8fdb\u7a0b\u5c31\u77e5\u9053\u5b50\u8fdb\u7a0b\u6210\u529f\u6267\u884c\u4e86\u3002","title":"13.2.1 \u5f02\u6b65\u521b\u5efa\u8fdb\u7a0b"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1322","text":"\u540c\u6b65\u65b9\u5f0f\u521b\u5efa\u7684\u8fdb\u7a0b\uff0c\u4e3b\u8fdb\u7a0b\u4f1a\u7b49\u5f85\u5b50\u8fdb\u7a0b\u9000\u51fa\u540e\u624d\u80fd\u7ee7\u7eed\u6267\u884c\u3002\u63a5\u4e0b\u6765\u770b\u770b\u5982\u4f55\u4ee5\u540c\u6b65\u7684\u65b9\u5f0f\u521b\u5efa\u8fdb\u7a0b\u3002JS\u5c42\u5165\u53e3\u51fd\u6570\u662fspawnSync\u3002spawnSync\u8c03\u7528C++\u6a21\u5757spawn_sync\u7684spawn\u51fd\u6570\u521b\u5efa\u8fdb\u7a0b\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5bf9\u5e94\u7684C++\u6a21\u5757spawn_sync\u5bfc\u51fa\u7684\u5c5e\u6027\u3002 1 2 3 4 5 6 7 void SyncProcessRunner::Initialize ( Local < Object > target , Local < Value > unused , Local < Context > context , void * priv ) { Environment * env = Environment :: GetCurrent ( context ); env -> SetMethod ( target , \"spawn\" , Spawn ); } \u8be5\u6a21\u5757\u503c\u5bfc\u51fa\u4e86\u4e00\u4e2a\u5c5e\u6027spawn\uff0c\u5f53\u6211\u4eec\u8c03\u7528spawn\u7684\u65f6\u5019\uff0c\u6267\u884c\u7684\u662fC++\u7684Spawn\u3002 1 2 3 4 5 6 7 8 void SyncProcessRunner::Spawn ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); env -> PrintSyncTrace (); SyncProcessRunner p ( env ); Local < Value > result ; if ( ! p . Run ( args [ 0 ]). ToLocal ( & result )) return ; args . GetReturnValue (). Set ( result ); } Spawn\u4e2d\u4e3b\u8981\u662f\u65b0\u5efa\u4e86\u4e00\u4e2aSyncProcessRunner\u5bf9\u8c61\u5e76\u4e14\u6267\u884cRun\u65b9\u6cd5\u3002\u6211\u4eec\u770b\u4e00\u4e0bSyncProcessRunner\u7684Run\u505a\u4e86\u4ec0\u4e48\u3002 1 2 3 4 5 6 MaybeLocal < Object > SyncProcessRunner :: Run ( Local < Value > options ) { EscapableHandleScope scope ( env () -> isolate ()); Maybe < bool > r = TryInitializeAndRunLoop ( options ); Local < Object > result = BuildResultObject (); return scope . Escape ( result ); } \u6267\u884c\u4e86TryInitializeAndRunLoop\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 Maybe < bool > SyncProcessRunner :: TryInitializeAndRunLoop ( Local < Value > options ) { int r ; lifecycle_ = kInitialized ; // \u65b0\u5efa\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af uv_loop_ = new uv_loop_t ; if ( ! ParseOptions ( options ). To ( & r )) return Nothing < bool > (); if ( r < 0 ) { SetError ( r ); return Just ( false ); } // \u8bbe\u7f6e\u5b50\u8fdb\u7a0b\u6267\u884c\u7684\u65f6\u95f4 if ( timeout_ > 0 ) { r = uv_timer_init ( uv_loop_ , & uv_timer_ ); uv_unref ( reinterpret_cast < uv_handle_t *> ( & uv_timer_ )); uv_timer_ . data = this ; kill_timer_initialized_ = true ; // \u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u6267\u884cKillTimerCallback r = uv_timer_start ( & uv_timer_ , KillTimerCallback , timeout_ , 0 ); } // \u5b50\u8fdb\u7a0b\u9000\u51fa\u65f6\u5904\u7406\u51fd\u6570 uv_process_options_ . exit_cb = ExitCallback ; // \u4f20\u8fdb\u53bb\u65b0\u7684loop\u800c\u4e0d\u662f\u4e3b\u8fdb\u7a0b\u672c\u8eab\u7684loop r = uv_spawn ( uv_loop_ , & uv_process_ , & uv_process_options_ ); uv_process_ . data = this ; for ( const auto & pipe : stdio_pipes_ ) { if ( pipe != nullptr ) { r = pipe -> Start (); if ( r < 0 ) { SetPipeError ( r ); return Just ( false ); } } } // \u5f00\u542f\u4e00\u4e2a\u65b0\u7684\u4e8b\u4ef6\u5faa\u73af r = uv_run ( uv_loop_ , UV_RUN_DEFAULT ); return Just ( true ); } \u4ece\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u4e86\u89e3\u5230Node.js\u662f\u5982\u4f55\u5b9e\u73b0\u540c\u6b65\u521b\u5efa\u8fdb\u7a0b\u7684\u3002\u540c\u6b65\u521b\u5efa\u8fdb\u7a0b\u65f6\uff0cNode.js\u91cd\u65b0\u5f00\u542f\u4e86\u4e00\u4e2a\u4e8b\u4ef6\u5faa\u73af\uff0c\u7136\u540e\u65b0\u5efa\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u5e76\u4e14\u628a\u8868\u793a\u5b50\u8fdb\u7a0b\u7ed3\u6784\u4f53\u7684handle\u63d2\u5165\u5230\u65b0\u521b\u5efa\u7684\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u63a5\u7740Libuv\u4e00\u76f4\u5904\u4e8e\u4e8b\u4ef6\u5faa\u73af\u4e2d\uff0c\u56e0\u4e3a\u4e00\u76f4\u6709\u4e00\u4e2auv_process_t\uff08handle\uff09\uff0c\u6240\u4ee5\u65b0\u521b\u5efa\u7684uv_run\u4f1a\u4e00\u76f4\u5728\u6267\u884c\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\uff0cNode.js\u4e3b\u8fdb\u7a0b\u4f1a\u201d\u963b\u585e\u201d\u5728\u8be5uv_run\u3002\u76f4\u5230\u5b50\u8fdb\u7a0b\u9000\u51fa\uff0c\u4e3b\u8fdb\u7a0b\u6536\u5230\u4fe1\u53f7\u540e\uff0c\u5220\u9664\u65b0\u521b\u5efa\u7684\u4e8b\u4ef6\u5faa\u73af\u4e2d\u7684uv_process_t\u3002\u7136\u540e\u6267\u884c\u56de\u8c03ExitCallback\u3002\u63a5\u7740\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\uff0c\u518d\u6b21\u56de\u5230Node.js\u539f\u6765\u7684\u4e8b\u4ef6\u5faa\u73af\u3002\u5982\u56fe\u6240\u793a13-3\u3002 \u56fe13-3 \u8fd9\u5c31\u662f\u540c\u6b65\u7684\u672c\u8d28\u548c\u539f\u56e0\u3002\u6211\u4eec\u5206\u51e0\u6b65\u5206\u6790\u4e00\u4e0b\u4ee5\u4e0a\u4ee3\u7801","title":"13.2.2 \u540c\u6b65\u521b\u5efa\u8fdb\u7a0b"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#13221","text":"\u56e0\u4e3a\u540c\u6b65\u65b9\u5f0f\u521b\u5efa\u5b50\u8fdb\u7a0b\u4f1a\u5bfc\u81f4Node.js\u4e3b\u8fdb\u7a0b\u963b\u585e\uff0c\u4e3a\u4e86\u907f\u514d\u5b50\u8fdb\u7a0b\u6709\u95ee\u9898\uff0c\u4ece\u800c\u5f71\u54cd\u4e3b\u8fdb\u7a0b\u7684\u6267\u884c\uff0cNode.js\u652f\u6301\u53ef\u914d\u7f6e\u5b50\u8fdb\u7a0b\u7684\u6700\u5927\u6267\u884c\u65f6\u95f4\u3002\u6211\u4eec\u770b\u5230\uff0cNode.js\u5f00\u542f\u4e86\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u5e76\u8bbe\u7f6e\u4e86\u56de\u8c03KillTimerCallback\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void SyncProcessRunner::KillTimerCallback ( uv_timer_t * handle ) { SyncProcessRunner * self = reinterpret_cast < SyncProcessRunner *> ( handle -> data ); self -> OnKillTimerTimeout (); } void SyncProcessRunner::OnKillTimerTimeout () { SetError ( UV_ETIMEDOUT ); Kill (); } void SyncProcessRunner::Kill () { if ( killed_ ) return ; killed_ = true ; if ( exit_status_ < 0 ) { // kill_signal_\u4e3a\u7528\u6237\u81ea\u5b9a\u4e49\u53d1\u9001\u7684\u6740\u6b7b\u8fdb\u7a0b\u7684\u4fe1\u53f7 int r = uv_process_kill ( & uv_process_ , kill_signal_ ); // \u4e0d\u652f\u6301\u7528\u6237\u4f20\u7684\u4fe1\u53f7 if ( r < 0 && r != UV_ESRCH ) { SetError ( r ); // \u56de\u9000\u4f7f\u7528SIGKILL\u4fe1\u53f7\u6740\u6b7b\u8fdb\u7a0b r = uv_process_kill ( & uv_process_ , SIGKILL ); CHECK ( r >= 0 || r == UV_ESRCH ); } } // Close all stdio pipes. CloseStdioPipes (); // \u6e05\u9664\u5b9a\u65f6\u5668 CloseKillTimer (); } \u5f53\u6267\u884c\u65f6\u95f4\u5230\u8fbe\u8bbe\u7f6e\u7684\u9608\u503c\uff0cNode.js\u4e3b\u8fdb\u7a0b\u4f1a\u7ed9\u5b50\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2a\u4fe1\u53f7\uff0c\u9ed8\u8ba4\u662f\u6740\u6b7b\u5b50\u8fdb\u7a0b\u3002","title":"13.2.2.1 \u6267\u884c\u65f6\u95f4"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#13222","text":"\u9000\u51fa\u5904\u7406\u4e3b\u8981\u662f\u8bb0\u5f55\u5b50\u8fdb\u7a0b\u9000\u51fa\u65f6\u7684\u9519\u8bef\u7801\u548c\u88ab\u54ea\u4e2a\u4fe1\u53f7\u6740\u6b7b\u7684\uff08\u5982\u679c\u6709\u7684\u8bdd\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void SyncProcessRunner::ExitCallback ( uv_process_t * handle , int64_t exit_status , int term_signal ) { SyncProcessRunner * self = reinterpret_cast < SyncProcessRunner *> ( handle -> data ); uv_close ( reinterpret_cast < uv_handle_t *> ( handle ), nullptr ); self -> OnExit ( exit_status , term_signal ); } void SyncProcessRunner::OnExit ( int64_t exit_status , int term_signal ) { if ( exit_status < 0 ) return SetError ( static_cast < int > ( exit_status )); exit_status_ = exit_status ; term_signal_ = term_signal ; }","title":"13.2.2.2 \u5b50\u8fdb\u7a0b\u9000\u51fa\u5904\u7406"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#133","text":"\u8fdb\u7a0b\u95f4\u901a\u4fe1\u662f\u591a\u8fdb\u7a0b\u7cfb\u7edf\u4e2d\u975e\u5e38\u91cd\u8981\u7684\u529f\u80fd\uff0c\u5426\u5219\u8fdb\u7a0b\u5c31\u50cf\u5b64\u5c9b\u4e00\u6837\uff0c\u4e0d\u80fd\u4ea4\u6d41\u4fe1\u606f\u3002\u56e0\u4e3a\u8fdb\u7a0b\u95f4\u7684\u5185\u5b58\u662f\u9694\u79bb\u7684\uff0c\u5982\u679c\u8fdb\u7a0b\u95f4\u60f3\u901a\u4fe1\uff0c\u5c31\u9700\u8981\u4e00\u4e2a\u516c\u5171\u7684\u5730\u65b9\uff0c\u8ba9\u591a\u4e2a\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u8bbf\u95ee\uff0c\u5b8c\u6210\u4fe1\u606f\u7684\u4f20\u9012\u3002\u5728Linux\u4e2d\uff0c\u540c\u4e3b\u673a\u7684\u8fdb\u7a0b\u95f4\u901a\u4fe1\u65b9\u5f0f\u6709\u5f88\u591a\uff0c\u4f46\u662f\u57fa\u672c\u90fd\u662f\u4f7f\u7528\u72ec\u7acb\u4e8e\u8fdb\u7a0b\u7684\u989d\u5916\u5185\u5b58\u4f5c\u4e3a\u4fe1\u606f\u627f\u8f7d\u7684\u5730\u65b9\uff0c\u7136\u540e\u5728\u901a\u8fc7\u67d0\u79cd\u65b9\u5f0f\u8ba9\u591a\u4e2a\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u8bbf\u95ee\u5230\u8fd9\u5757\u516c\u5171\u5185\u5b58\uff0c\u6bd4\u5982\u7ba1\u9053\u3001\u5171\u4eab\u5185\u5b58\u3001Unix\u57df\u3001\u6d88\u606f\u961f\u5217\u7b49\u7b49\u3002\u4e0d\u8fc7\u8fd8\u6709\u53e6\u5916\u4e00\u79cd\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u65b9\u5f0f\uff0c\u662f\u4e0d\u5c5e\u4e8e\u4ee5\u4e0a\u60c5\u51b5\u7684\uff0c\u90a3\u5c31\u662f\u4fe1\u53f7\u3002\u4fe1\u53f7\u4f5c\u4e3a\u4e00\u79cd\u7b80\u5355\u7684\u8fdb\u7a0b\u95f4\u901a\u4fe1\u65b9\u5f0f\uff0c\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u4e86\u63a5\u53e3\u8ba9\u8fdb\u7a0b\u53ef\u4ee5\u76f4\u63a5\u4fee\u6539\u53e6\u4e00\u4e2a\u8fdb\u7a0b\u7684\u6570\u636e\uff08PCB\uff09\uff0c\u4ee5\u6b64\u8fbe\u5230\u901a\u4fe1\u76ee\u7684\u3002\u672c\u8282\u4ecb\u7ecdNode.js\u4e2d\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u539f\u7406\u548c\u5b9e\u73b0\u3002","title":"13.3 \u8fdb\u7a0b\u95f4\u901a\u4fe1"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1331","text":"\u6211\u4eec\u4ecefork\u51fd\u6570\u5f00\u59cb\u5206\u6790Node.js\u4e2d\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function fork ( modulePath ) { // \u5ffd\u7565options\u53c2\u6570\u5904\u7406 if ( typeof options . stdio === 'string' ) { options . stdio = stdioStringToArray ( options . stdio , 'ipc' ); } else if ( ! ArrayIsArray ( options . stdio )) { // silent\u4e3atrue\u5219\u662f\u7ba1\u9053\u5f62\u5f0f\u548c\u4e3b\u8fdb\u7a0b\u901a\u4fe1\uff0c\u5426\u5219\u662f\u7ee7\u627f options . stdio = stdioStringToArray ( options . silent ? 'pipe' : 'inherit' , 'ipc' ); } else if ( ! options . stdio . includes ( 'ipc' )) { // \u5fc5\u987b\u8981IPC\uff0c\u652f\u6301\u8fdb\u7a0b\u95f4\u901a\u4fe1 throw new ERR_CHILD_PROCESS_IPC_REQUIRED ( 'options.stdio' ); } return spawn ( options . execPath , args , options ); } \u6211\u4eec\u770b\u4e00\u4e0bstdioStringToArray\u7684\u5904\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function stdioStringToArray ( stdio , channel ) { const options = []; switch ( stdio ) { case 'ignore' : case 'pipe' : options . push ( stdio , stdio , stdio ); break ; case 'inherit' : options . push ( 0 , 1 , 2 ); break ; default : throw new ERR_INVALID_OPT_VALUE ( 'stdio' , stdio ); } if ( channel ) options . push ( channel ); return options ; } stdioStringToArray\u4f1a\u8fd4\u56de\u4e00\u4e2a\u6570\u7ec4\uff0c\u6bd4\u5982['pipe', 'pipe', 'pipe', 'ipc']\u6216[0, 1, 2, 'ipc']\uff0cipc\u4ee3\u8868\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u901a\u9053\uff0c\u5e76\u4e14\u652f\u6301\u6587\u4ef6\u63cf\u8ff0\u4f20\u9012\u3002\u6211\u4eec\u63a5\u7740\u770bspawn\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ChildProcess . prototype . spawn = function ( options ) { let i = 0 ; // \u9884\u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784 stdio = getValidStdio ( stdio , false ); const ipc = stdio . ipc ; // IPC\u6587\u4ef6\u63cf\u8ff0\u7b26 const ipcFd = stdio . ipcFd ; stdio = options . stdio = stdio . stdio ; // \u901a\u8fc7\u73af\u5883\u53d8\u91cf\u544a\u8bc9\u5b50\u8fdb\u7a0bIPC\u6587\u4ef6\u63cf\u8ff0\u7b26\u548c\u6570\u636e\u5904\u7406\u6a21\u5f0f if ( ipc !== undefined ) { options . envPairs . push ( `NODE_CHANNEL_FD= ${ ipcFd } ` ); options . envPairs . push ( `NODE_CHANNEL_SERIALIZATION_MODE= ${ serialization } ` ); } // \u521b\u5efa\u5b50\u8fdb\u7a0b const err = this . _handle . spawn ( options ); this . pid = this . _handle . pid ; // \u5904\u7406IPC\u901a\u4fe1 if ( ipc !== undefined ) setupChannel ( this , ipc , serialization ); return err ; } Spawn\u4e2d\u4f1a\u6267\u884cgetValidStdio\u9884\u5904\u7406\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784\u3002\u6211\u4eec\u53ea\u5173\u6ce8ipc\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function getValidStdio ( stdio , sync ) { let ipc ; let ipcFd ; stdio = stdio . reduce (( acc , stdio , i ) => { if ( stdio === 'ipc' ) { ipc = new Pipe ( PipeConstants . IPC ); ipcFd = i ; acc . push ({ type : 'pipe' , handle : ipc , ipc : true }); } else { // \u5176\u5b83\u7c7b\u578b\u7684\u5904\u7406 } return acc ; }, []); return { stdio , ipc , ipcFd }; } \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u4f1anew Pipe(PipeConstants.IPC);\u521b\u5efa\u4e00\u4e2aUnix\u57df\u7528\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\uff0c\u4f46\u662f\u8fd9\u91cc\u53ea\u662f\u5b9a\u4e49\u4e86\u4e00\u4e2aC++\u5bf9\u8c61\uff0c\u8fd8\u6ca1\u6709\u53ef\u7528\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u6211\u4eec\u63a5\u7740\u5f80\u4e0b\u770bC++\u5c42\u7684spawn\u4e2d\u5173\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u5904\u7406\u3002C++\u5c42\u9996\u5148\u5904\u7406\u53c2\u6570\uff0c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 static void ParseStdioOptions ( Environment * env , Local < Object > js_options , uv_process_options_t * options ) { Local < Context > context = env -> context (); Local < String > stdio_key = env -> stdio_string (); // \u62ff\u5230JS\u5c42stdio\u7684\u503c Local < Array > stdios = js_options -> Get ( context , stdio_key ). ToLocalChecked (). As < Array > (); uint32_t len = stdios -> Length (); options -> stdio = new uv_stdio_container_t [ len ]; options -> stdio_count = len ; // \u904d\u5386stdio\uff0cstdio\u662f\u4e00\u4e2a\u5bf9\u8c61\u6570\u7ec4 for ( uint32_t i = 0 ; i < len ; i ++ ) { Local < Object > stdio = stdios -> Get ( context , i ). ToLocalChecked (). As < Object > (); // \u62ff\u5230stdio\u7684\u7c7b\u578b Local < Value > type = stdio -> Get ( context , env -> type_string ()). ToLocalChecked (); // \u521b\u5efaIPC\u901a\u9053 if ( type -> StrictEquals ( env -> pipe_string ())) { options -> stdio [ i ]. flags = static_cast < uv_stdio_flags > ( UV_CREATE_PIPE | UV_READABLE_PIPE | UV_WRITABLE_PIPE ); // \u62ff\u5230\u5bf9\u5e94\u7684stream options -> stdio [ i ]. data . stream = StreamForWrap ( env , stdio ); } } } \u8fd9\u91cc\u4f1a\u628aStreamForWrap\u7684\u7ed3\u679c\u4fdd\u5b58\u5230stream\u4e2d\uff0c\u6211\u4eec\u770b\u770bStreamForWrap\u7684\u903b\u8f91 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static uv_stream_t * StreamForWrap ( Environment * env , Local < Object > stdio ) { Local < String > handle_key = env -> handle_string (); /* \u83b7\u53d6\u5bf9\u8c61\u4e2d\u7684key\u4e3ahandle\u7684\u503c\uff0c\u5373\u521a\u624dJS\u5c42\u7684 new Pipe(SOCKET.IPC); */ Local < Object > handle = stdio -> Get ( env -> context (), handle_key ). ToLocalChecked (). As < Object > (); // \u83b7\u53d6JS\u5c42\u4f7f\u7528\u5bf9\u8c61\u6240\u5bf9\u5e94\u7684C++\u5bf9\u8c61\u4e2d\u7684stream uv_stream_t * stream = LibuvStreamWrap :: From ( env , handle ) -> stream (); CHECK_NOT_NULL ( stream ); return stream ; } // \u4eceJS\u5c42\u4f7f\u7528\u7684object\u4e2d\u83b7\u53d6\u5173\u8054\u7684C++\u5bf9\u8c61 ibuvStreamWrap * LibuvStreamWrap::From ( Environment * env , Local < Object > object ) { return Unwrap < LibuvStreamWrap > ( object ); } \u4ee5\u4e0a\u4ee3\u7801\u83b7\u53d6\u4e86IPC\u5bf9\u5e94\u7684stream\u7ed3\u6784\u4f53\u3002\u5728Libuv\u4e2d\u4f1a\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4fdd\u5b58\u5230stream\u4e2d\u3002\u6211\u4eec\u63a5\u7740\u770bC++\u5c42\u8c03\u7528Libuv\u7684uv_spawn\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int uv_spawn ( uv_loop_t * loop , uv_process_t * process , const uv_process_options_t * options ) { int pipes_storage [ 8 ][ 2 ]; int ( * pipes )[ 2 ]; int stdio_count ; // \u521d\u59cb\u5316\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784 stdio_count = options -> stdio_count ; if ( stdio_count < 3 ) stdio_count = 3 ; for ( i = 0 ; i < stdio_count ; i ++ ) { pipes [ i ][ 0 ] = -1 ; pipes [ i ][ 1 ] = -1 ; } // \u521b\u5efa\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 for ( i = 0 ; i < options -> stdio_count ; i ++ ) { err = uv__process_init_stdio ( options -> stdio + i , pipes [ i ]); if ( err ) goto error ; } // \u8bbe\u7f6e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u6587\u4ef6\u63cf\u8ff0\u7b26\u5230\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784 for ( i = 0 ; i < options -> stdio_count ; i ++ ) { uv__process_open_stream ( options -> stdio + i , pipes [ i ]); } } Libuv\u4e2d\u4f1a\u521b\u5efa\u7528\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u7136\u540e\u8bbe\u7f6e\u5230\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u4e2d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 static int uv__process_open_stream ( uv_stdio_container_t * container , int pipefds [ 2 ]) { int flags ; int err ; if ( ! ( container -> flags & UV_CREATE_PIPE ) || pipefds [ 0 ] < 0 ) return 0 ; err = uv__close ( pipefds [ 1 ]); if ( err != 0 ) abort (); pipefds [ 1 ] = -1 ; uv__nonblock ( pipefds [ 0 ], 1 ); flags = 0 ; if ( container -> flags & UV_WRITABLE_PIPE ) flags |= UV_HANDLE_READABLE ; if ( container -> flags & UV_READABLE_PIPE ) flags |= UV_HANDLE_WRITABLE ; return uv__stream_open ( container -> data . stream , pipefds [ 0 ], flags ); } \u6267\u884c\u5b8cuv__process_open_stream\uff0c\u7528\u4e8eIPC\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u5c31\u4fdd\u5b58\u5230new Pipe(SOCKET.IPC)\u4e2d\u4e86\u3002\u6709\u4e86IPC\u901a\u9053\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u8fdb\u7a0b\u8fd8\u9700\u8981\u8fdb\u4e00\u6b65\u5904\u7406\u3002\u6211\u4eec\u770b\u5230JS\u5c42\u6267\u884c\u5b8cspawn\u540e\uff0c\u4e3b\u8fdb\u7a0b\u901a\u8fc7setupChannel\u5bf9\u8fdb\u7a0b\u95f4\u901a\u4fe1\u8fdb\u884c\u4e86\u8fdb\u4e00\u6b65\u5904\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4e3b\u8fdb\u7a0bsetupChannel\u4e2d\u5173\u4e8e\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u5904\u7406\u3002","title":"13.3.1 \u521b\u5efa\u901a\u4fe1\u901a\u9053"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1332","text":"1 \u8bfb\u7aef 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 function setupChannel ( target , channel , serializationMode ) { // channel\u662fnew Pipe(PipeConstants.IPC); const control = new Control ( channel ); target . channel = control ; // \u2026 channel . pendingHandle = null ; // \u6ce8\u518c\u5904\u7406\u6570\u636e\u7684\u51fd\u6570 channel . onread = function ( arrayBuffer ) { // \u6536\u5230\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 const recvHandle = channel . pendingHandle ; channel . pendingHandle = null ; if ( arrayBuffer ) { const nread = streamBaseState [ kReadBytesOrError ]; const offset = streamBaseState [ kArrayBufferOffset ]; const pool = new Uint8Array ( arrayBuffer , offset , nread ); if ( recvHandle ) pendingHandle = recvHandle ; // \u89e3\u6790\u6536\u5230\u7684\u6d88\u606f for ( const message of parseChannelMessages ( channel , pool )) { // \u662f\u5426\u662f\u5185\u90e8\u901a\u4fe1\u4e8b\u4ef6 if ( isInternal ( message )) { // \u6536\u5230handle if ( message . cmd === 'NODE_HANDLE' ) { handleMessage ( message , pendingHandle , true ); pendingHandle = null ; } else { handleMessage ( message , undefined , true ); } } else { handleMessage ( message , undefined , false ); } } } }; function handleMessage ( message , handle , internal ) { const eventName = ( internal ? 'internalMessage' : 'message' ); process . nextTick ( emit , eventName , message , handle ); } // \u5f00\u542f\u8bfb channel . readStart (); return control ; } onread\u5904\u7406\u5b8c\u540e\u4f1a\u89e6\u53d1internalMessage\u6216message\u4e8b\u4ef6\uff0cmessage\u662f\u7528\u6237\u4f7f\u7528\u7684\u3002 2\u5199\u7aef 1 2 3 4 5 6 7 8 target . _send = function ( message , handle , options , callback ) { let obj ; const req = new WriteWrap (); // \u53d1\u9001\u7ed9\u5bf9\u7aef const err = writeChannelMessage ( channel , req , message , handle ); return channel . writeQueueSize < ( 65536 * 2 ); } \u6211\u4eec\u770b\u770bwriteChannelMessage 1 2 3 4 5 6 7 8 9 10 11 12 13 writeChannelMessage ( channel , req , message , handle ) { const ser = new ChildProcessSerializer (); ser . writeHeader (); ser . writeValue ( message ); const serializedMessage = ser . releaseBuffer (); const sizeBuffer = Buffer . allocUnsafe ( 4 ); sizeBuffer . writeUInt32BE ( serializedMessage . length ); // channel\u662f\u5c01\u88c5\u4e86Unix\u57df\u7684\u5bf9\u8c61 return channel . writeBuffer ( req , Buffer . concat ([ sizeBuffer , serializedMessage ]), handle ); }, channel.writeBuffer\u901a\u8fc7\u521a\u624d\u521b\u5efa\u7684IPC\u901a\u9053\u5b8c\u6210\u6570\u636e\u7684\u53d1\u9001\uff0c\u5e76\u4e14\u652f\u6301\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002","title":"13.3.2 \u4e3b\u8fdb\u7a0b\u5904\u7406\u901a\u4fe1\u901a\u9053"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1333","text":"\u63a5\u7740\u6211\u4eec\u770b\u770b\u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\uff0cNode.js\u5728\u521b\u5efa\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\uff0c\u4e3b\u8fdb\u7a0b\u4f1a\u901a\u8fc7\u73af\u5883\u53d8\u91cfNODE_CHANNEL_FD\u544a\u8bc9\u5b50\u8fdb\u7a0bUnix\u57df\u901a\u4fe1\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u5728\u6267\u884c\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\uff0c\u4f1a\u5904\u7406\u8fd9\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\u3002\u5177\u4f53\u5b9e\u73b0\u5728setupChildProcessIpcChannel\u51fd\u6570\u4e2d\u3002 1 2 3 4 5 6 7 8 function setupChildProcessIpcChannel () { // \u4e3b\u8fdb\u7a0b\u901a\u8fc7\u73af\u5883\u53d8\u91cf\u8bbe\u7f6e\u8be5\u503c if ( process . env . NODE_CHANNEL_FD ) { const fd = parseInt ( process . env . NODE_CHANNEL_FD , 10 ); delete process . env . NODE_CHANNEL_FD ; require ( 'child_process' ). _forkChild ( fd , serializationMode ); } } \u63a5\u7740\u6267\u884c_forkChild\u51fd\u6570\u3002 1 2 3 4 5 function _forkChild ( fd , serializationMode ) { const p = new Pipe ( PipeConstants . IPC ); p . open ( fd ); const control = setupChannel ( process , p , serializationMode ); } \u8be5\u51fd\u6570\u521b\u5efa\u4e00\u4e2aPipe\u5bf9\u8c61\uff0c\u7136\u540e\u628a\u4e3b\u8fdb\u7a0b\u4f20\u8fc7\u6765\u7684fd\u4fdd\u5b58\u5230\u8be5Pipe\u5bf9\u8c61\u3002\u5bf9\u8be5Pipe\u5bf9\u8c61\u7684\u8bfb\u5199\uff0c\u5c31\u662f\u5730\u5bf9fd\u8fdb\u884c\u8bfb\u5199\u3002\u6700\u540e\u6267\u884csetupChannel\u3002setupChannel\u4e3b\u8981\u662f\u5b8c\u6210\u4e86Unix\u57df\u901a\u4fe1\u7684\u5c01\u88c5\uff0c\u5305\u62ec\u5904\u7406\u63a5\u6536\u7684\u6d88\u606f\u3001\u53d1\u9001\u6d88\u606f\u3001\u5904\u7406\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7b49\uff0c\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4e0d\u518d\u5177\u4f53\u5206\u6790\u3002\u6700\u540e\u901a\u8fc7\u5728process\u5bf9\u8c61\u4e2d\u6302\u8f7d\u51fd\u6570\u548c\u76d1\u542c\u4e8b\u4ef6\uff0c\u4f7f\u5f97\u5b50\u8fdb\u7a0b\u5177\u6709\u548c\u4e3b\u8fdb\u7a0b\u901a\u4fe1\u7684\u80fd\u529b\u3002\u6240\u6709\u7684\u901a\u4fe1\u90fd\u662f\u57fa\u4e8e\u4e3b\u8fdb\u7a0b\u901a\u8fc7\u73af\u5883\u53d8\u91cfNODE_CHANNEL_FD\u4f20\u9012\u8fc7\u6765\u7684fd\u8fdb\u884c\u7684\u3002","title":"13.3.3 \u5b50\u8fdb\u7a0b\u5904\u7406\u901a\u4fe1\u901a\u9053"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#134","text":"\u524d\u9762\u6211\u4eec\u5df2\u7ecf\u4ecb\u7ecd\u8fc7\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u539f\u7406\uff0c\u4e0b\u9762\u6211\u4eec\u770b\u770bNode.js\u662f\u5982\u4f55\u5904\u7406\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7684\u3002","title":"13.4 \u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1341","text":"\u6211\u4eec\u770b\u8fdb\u7a0b\u95f4\u901a\u4fe1\u7684\u53d1\u9001\u51fd\u6570send\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 process . send = function ( message , handle , options , callback ) { return this . _send ( message , handle , options , callback ); }; target . _send = function ( message , handle , options , callback ) { // Support legacy function signature if ( typeof options === 'boolean' ) { options = { swallowErrors : options }; } let obj ; // \u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0chandle\u662f\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5c01\u88c5 if ( handle ) { message = { cmd : 'NODE_HANDLE' , type : null , msg : message }; // handle\u7684\u7c7b\u578b if ( handle instanceof net . Socket ) { message . type = 'net.Socket' ; } else if ( handle instanceof net . Server ) { message . type = 'net.Server' ; } else if ( handle instanceof TCP || handle instanceof Pipe ) { message . type = 'net.Native' ; } else if ( handle instanceof dgram . Socket ) { message . type = 'dgram.Socket' ; } else if ( handle instanceof UDP ) { message . type = 'dgram.Native' ; } else { throw new ERR_INVALID_HANDLE_TYPE (); } // \u6839\u636e\u7c7b\u578b\u8f6c\u6362\u5bf9\u8c61 obj = handleConversion [ message . type ]; // \u628aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u8f6c\u6210C++\u5c42\u5bf9\u8c61 handle = handleConversion [ message . type ]. send . call ( target , message , handle , options ); } // \u53d1\u9001 const req = new WriteWrap (); // \u53d1\u9001\u7ed9\u5bf9\u7aef const err = writeChannelMessage ( channel , req , message , handle ); } Node.js\u5728\u53d1\u9001\u4e00\u4e2a\u5c01\u88c5\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5bf9\u8c61\u4e4b\u524d\uff0c\u9996\u5148\u4f1a\u628aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u8f6c\u6210C++\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002\u5982TCP 1 2 3 send ( message , server , options ) { return server . _handle ; } \u6211\u4eec\u63a5\u7740\u770bwriteChannelMessage\u3002 1 2 3 4 5 // channel\u662fnew Pipe(PipeConstants.IPC); writeChannelMessage ( channel , req , message , handle ) { const string = JSONStringify ( message ) + '\\n' ; return channel . writeUtf8String ( req , string , handle ); } \u6211\u4eec\u770b\u4e00\u4e0bwriteUtf8String 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 template < enum encoding enc > int StreamBase :: WriteString ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); // new WriteWrap() Local < Object > req_wrap_obj = args [ 0 ]. As < Object > (); Local < String > string = args [ 1 ]. As < String > (); Local < Object > send_handle_obj ; // \u9700\u8981\u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cC++\u5c42\u5bf9\u8c61 if ( args [ 2 ] -> IsObject ()) send_handle_obj = args [ 2 ]. As < Object > (); uv_stream_t * send_handle = nullptr ; // \u662fUnix\u57df\u5e76\u4e14\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26 if ( IsIPCPipe () && ! send_handle_obj . IsEmpty ()) { HandleWrap * wrap ; /* send_handle_obj\u662f\u7531C++\u5c42\u521b\u5efa\u5728JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\uff0c \u89e3\u5305\u51fa\u771f\u6b63\u5728C++\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61 */ ASSIGN_OR_RETURN_UNWRAP ( & wrap , send_handle_obj , UV_EINVAL ); // \u62ff\u5230Libuv\u5c42\u7684handle\u7ed3\u6784\u4f53 send_handle = reinterpret_cast < uv_stream_t *> ( wrap -> GetHandle ()); /* Reference LibuvStreamWrap instance to prevent it from being garbage\uff0ccollected before`AfterWrite` is called. */ req_wrap_obj -> Set ( env -> context (), env -> handle_string (), send_handle_obj ). Check (); } Write ( & buf , 1 , send_handle , req_wrap_obj ); } Write\u4f1a\u8c03\u7528Libuv\u7684uv__write\uff0cuv__write\u4f1a\u628aLibuv\u5c42\u7684handle\u4e2d\u7684fd\u53d6\u51fa\u6765\uff0c\u4f7f\u7528sendmsg\u4f20\u9012\u5230\u5176\u5b83\u8fdb\u7a0b\u3002\u6574\u4e2a\u53d1\u9001\u7684\u8fc7\u7a0b\u672c\u8d28\u662f\u4eceJS\u5c42\u5230Libuv\u5c42\u5c42\u5c42\u63ed\u5f00\u8981\u53d1\u9001\u7684\u5bf9\u8c61\uff0c\u6700\u540e\u62ff\u5230\u4e00\u4e2a\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u7136\u540e\u901a\u8fc7\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684API\u628a\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7ed9\u53e6\u4e00\u4e2a\u8fdb\u7a0b\uff0c\u5982\u56fe13-4\u6240\u793a\u3002 \u56fe13-4","title":"13.4.1 \u53d1\u9001\u6587\u4ef6\u63cf\u8ff0\u7b26"},{"location":"chapter13-%E8%BF%9B%E7%A8%8B/#1342","text":"\u5206\u6790\u5b8c\u53d1\u9001\uff0c\u6211\u4eec\u518d\u770b\u4e00\u4e0b\u63a5\u6536\u7684\u903b\u8f91\u3002\u524d\u9762\u6211\u4eec\u5206\u6790\u8fc7\uff0c\u5f53\u6587\u4ef6\u63cf\u8ff0\u7b26\u6536\u5230\u6570\u636e\u65f6\uff0c\u4f1a\u628a\u6587\u4ef6\u6587\u4ef6\u63cf\u8ff0\u7b26\u5c01\u88c5\u6210\u5bf9\u5e94\u7684\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 void LibuvStreamWrap::OnUvRead ( ssize_t nread , const uv_buf_t * buf ) { HandleScope scope ( env () -> isolate ()); Context :: Scope context_scope ( env () -> context ()); uv_handle_type type = UV_UNKNOWN_HANDLE ; // \u662f\u5426\u652f\u6301\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u5e76\u4e14\u6709\u5f85\u5904\u7406\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5219\u5224\u65ad\u6587\u4ef6\u63cf\u8ff0\u7b26\u7c7b\u578b if ( is_named_pipe_ipc () && uv_pipe_pending_count ( reinterpret_cast < uv_pipe_t *> ( stream ())) > 0 ) { type = uv_pipe_pending_type ( reinterpret_cast < uv_pipe_t *> ( stream ())); } // \u8bfb\u53d6\u6210\u529f if ( nread > 0 ) { MaybeLocal < Object > pending_obj ; // \u6839\u636e\u7c7b\u578b\u521b\u5efa\u4e00\u4e2a\u65b0\u7684C++\u5bf9\u8c61\u8868\u793a\u5ba2\u6237\u7aef\uff0c\u5e76\u4e14\u4ece\u670d\u52a1\u5668\u4e2d\u6458\u4e0b\u4e00\u4e2afd\u4fdd\u5b58\u5230\u5ba2\u6237\u7aef if ( type == UV_TCP ) { pending_obj = AcceptHandle < TCPWrap > ( env (), this ); } else if ( type == UV_NAMED_PIPE ) { pending_obj = AcceptHandle < PipeWrap > ( env (), this ); } else if ( type == UV_UDP ) { pending_obj = AcceptHandle < UDPWrap > ( env (), this ); } else { CHECK_EQ ( type , UV_UNKNOWN_HANDLE ); } // \u4fdd\u5b58\u5230JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u4e2d\uff0c\u952e\u662fpendingHandle if ( ! pending_obj . IsEmpty ()) { object () -> Set ( env () -> context (), env () -> pending_handle_string (), pending_obj . ToLocalChecked ()) . Check (); } } EmitRead ( nread , * buf ); } \u63a5\u7740\u6211\u4eec\u770b\u770bJS\u5c42\u7684\u5904\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 channel . onread = function ( arrayBuffer ) { // \u6536\u5230\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26 const recvHandle = channel . pendingHandle ; channel . pendingHandle = null ; if ( arrayBuffer ) { const nread = streamBaseState [ kReadBytesOrError ]; const offset = streamBaseState [ kArrayBufferOffset ]; const pool = new Uint8Array ( arrayBuffer , offset , nread ); if ( recvHandle ) pendingHandle = recvHandle ; // \u89e3\u6790\u6536\u5230\u7684\u6d88\u606f for ( const message of parseChannelMessages ( channel , pool )) { // \u662f\u5426\u662f\u5185\u90e8\u901a\u4fe1\u4e8b\u4ef6 if ( isInternal ( message )) { if ( message . cmd === 'NODE_HANDLE' ) { handleMessage ( message , pendingHandle , true ); pendingHandle = null ; } else { handleMessage ( message , undefined , true ); } } else { handleMessage ( message , undefined , false ); } } } }; \u8fd9\u91cc\u4f1a\u89e6\u53d1\u5185\u90e8\u4e8b\u4ef6internalMessage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 target . on ( 'internalMessage' , function ( message , handle ) { // \u662f\u5426\u6536\u5230\u4e86handle if ( message . cmd !== 'NODE_HANDLE' ) return ; // \u6210\u529f\u6536\u5230\uff0c\u53d1\u9001ACK target . _send ({ cmd : 'NODE_HANDLE_ACK' }, null , true ); const obj = handleConversion [ message . type ]; /* C++\u5bf9\u8c61\u8f6c\u6210JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002\u8f6c\u5b8c\u4e4b\u540e\u518d\u6839\u636e\u91cc\u5c42\u7684\u5b57\u6bb5 message.msg\u8fdb\u4e00\u6b65\u5904\u7406\uff0c\u6216\u8005\u89e6\u53d1message\u4e8b\u4ef6\u4f20\u7ed9\u7528\u6237 */ obj . got . call ( this , message , handle , ( handle ) => { handleMessage ( message . msg , handle , isInternal ( message . msg )); }); }) \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u4f1a\u628aC++\u5c42\u7684\u5bf9\u8c61\u8f6c\u6210JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002\u5982TCP 1 2 3 4 5 6 got ( message , handle , emit ) { const server = new net . Server (); server . listen ( handle , () => { emit ( server ); }); } \u8fd9\u5c31\u662f\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u5728Node.js\u4e2d\u7684\u5904\u7406\u6d41\u7a0b\uff0c\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u662f\u4e00\u4e2a\u975e\u5e38\u6709\u7528\u7684\u80fd\u529b\uff0c\u6bd4\u5982\u4e00\u4e2a\u8fdb\u7a0b\u53ef\u4ee5\u628a\u4e00\u4e2aTCP\u8fde\u63a5\u6240\u5bf9\u5e94\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u76f4\u63a5\u53d1\u9001\u7ed9\u53e6\u4e00\u4e2a\u8fdb\u7a0b\u5904\u7406\u3002\u8fd9\u4e5f\u662fcluser\u6a21\u5757\u7684\u539f\u7406\u3002\u540e\u7eed\u6211\u4eec\u4f1a\u770b\u5230\u3002\u5728Node.js\u4e2d\uff0c\u6574\u4f53\u7684\u5904\u7406\u6d41\u7a0b\u5c31\u662f\uff0c\u53d1\u9001\u7684\u65f6\u5019\u628a\u4e00\u4e2aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u4e00\u5c42\u5c42\u5730\u5265\u5f00\uff0c\u53d8\u6210C++\u5bf9\u8c61\uff0c\u7136\u540e\u518d\u53d8\u6210fd\uff0c\u6700\u540e\u901a\u8fc7\u5e95\u5c42API\u4f20\u9012\u7ed9\u53e6\u4e00\u4e2a\u8fdb\u7a0b\u3002\u63a5\u6536\u7684\u65f6\u5019\u5c31\u662f\u628a\u4e00\u4e2afd\u4e00\u5c42\u5c42\u5730\u5305\u88f9\uff0c\u53d8\u6210\u4e00\u4e2aJS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u3002","title":"13.4.2 \u63a5\u6536\u6587\u4ef6\u63cf\u8ff0\u7b26"},{"location":"chapter14-%E7%BA%BF%E7%A8%8B/","text":"\u7ebf\u7a0b\u662f\u64cd\u4f5c\u7cfb\u7edf\u7684\u6700\u5c0f\u8c03\u5ea6\u5355\u4f4d\uff0c\u5b83\u672c\u8d28\u4e0a\u662f\u8fdb\u7a0b\u4e2d\u7684\u4e00\u4e2a\u6267\u884c\u6d41\uff0c\u6211\u4eec\u77e5\u9053\uff0c\u8fdb\u7a0b\u6709\u4ee3\u7801\u6bb5\uff0c\u7ebf\u7a0b\u5176\u5b9e\u5c31\u662f\u8fdb\u7a0b\u4ee3\u7801\u6bb5\u4e2d\u7684\u5176\u4e2d\u4e00\u6bb5\u4ee3\u7801\u3002\u7ebf\u7a0b\u7684\u4e00\u79cd\u5b9e\u73b0\u662f\u4f5c\u4e3a\u8fdb\u7a0b\u6765\u5b9e\u73b0\u7684\uff08pthread\u7ebf\u7a0b\u5e93\uff09\uff0c\u901a\u8fc7\u8c03\u7528clone\uff0c\u65b0\u5efa\u4e00\u4e2a\u8fdb\u7a0b\uff0c\u7136\u540e\u6267\u884c\u7236\u8fdb\u7a0b\u4ee3\u7801\u6bb5\u91cc\u7684\u4e00\u4e2a\u4ee3\u7801\u7247\u6bb5\uff0c\u5176\u4e2d\u6587\u4ef6\u63cf\u8ff0\u7b26\u3001\u5185\u5b58\u7b49\u4fe1\u606f\u90fd\u662f\u5171\u4eab\u7684\u3002\u56e0\u4e3a\u5185\u5b58\u662f\u5171\u4eab\u7684\uff0c\u6240\u4ee5\u7ebf\u7a0b\u4e0d\u80fd\u5171\u4eab\u6808\uff0c\u5426\u5219\u8bbf\u95ee\u6808\u7684\u5730\u5740\u7684\u65f6\u5019\uff0c\u4f1a\u6620\u5c04\u5230\u76f8\u540c\u7684\u7269\u7406\u5730\u5740\uff0c\u90a3\u6837\u5c31\u4f1a\u4e92\u76f8\u5f71\u54cd\uff0c\u6240\u4ee5\u6bcf\u4e2a\u7ebf\u7a0b\u4f1a\u6709\u81ea\u5df1\u72ec\u7acb\u7684\u6808\u3002\u5728\u8c03\u7528clone\u51fd\u6570\u7684\u65f6\u5019\u4f1a\u8bbe\u7f6e\u6808\u7684\u8303\u56f4\uff0c\u6bd4\u5982\u5728\u5806\u4e0a\u5206\u914d\u4e00\u5757\u5185\u5b58\u7528\u4e8e\u505a\u7ebf\u7a0b\u7684\u6808\uff0c\u5e76\u4e14\u652f\u6301\u8bbe\u7f6e\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u5171\u4eab\u54ea\u4e9b\u8d44\u6e90\u3002\u5177\u4f53\u53ef\u4ee5\u53c2\u8003clone\u7cfb\u7edf\u8c03\u7528\u3002 \u7531\u4e8eNode.js\u662f\u5355\u7ebf\u7a0b\u7684\uff0c\u867d\u7136\u5e95\u5c42\u7684Libuv\u5b9e\u73b0\u4e86\u4e00\u4e2a\u7ebf\u7a0b\u6c60\uff0c\u4f46\u662f\u8fd9\u4e2a\u7ebf\u7a0b\u6c60\u53ea\u80fd\u6267\u884cC\u3001C++\u5c42\u5b9a\u4e49\u7684\u4efb\u52a1\u3002\u5982\u679c\u6211\u4eec\u60f3\u81ea\u5b9a\u4e49\u4e00\u4e9b\u8017\u65f6\u7684\u64cd\u4f5c\uff0c\u90a3\u5c31\u53ea\u80fd\u5728C++\u5c42\u5904\u7406\uff0c\u7136\u540e\u66b4\u9732\u63a5\u53e3\u7ed9JS\u5c42\u8c03\u7528\uff0c\u8fd9\u4e2a\u6210\u672c\u662f\u975e\u5e38\u9ad8\u7684\uff0c\u5728\u65e9\u671f\u7684Node.js\u7248\u672c\u91cc\uff0c\u6211\u4eec\u53ef\u4ee5\u7528\u8fdb\u7a0b\u53bb\u5b9e\u73b0\u8fd9\u6837\u7684\u9700\u6c42\u3002\u4f46\u662f\u8fdb\u7a0b\u592a\u91cd\u4e86\uff0c\u5728\u65b0\u7248\u7684Node.js\u4e2d\uff0cNode.js\u4e3a\u6211\u4eec\u63d0\u4f9b\u4e86\u591a\u7ebf\u7a0b\u7684\u529f\u80fd\u3002\u8fd9\u4e00\u7ae0\u4ee5Node.js\u591a\u7ebf\u7a0b\u6a21\u5757\u4e3a\u80cc\u666f\uff0c\u5206\u6790Node.js\u4e2d\u591a\u7ebf\u7a0b\u7684\u539f\u7406\uff0c\u4f46\u662f\u4e0d\u5206\u6790Libuv\u7684\u7ebf\u7a0b\u5b9e\u73b0\uff0c\u5b83\u672c\u8d28\u662f\u5bf9\u7ebf\u7a0b\u5e93\u7684\u7b80\u5355\u5c01\u88c5\u3002Node.js\u4e2d\uff0c\u7ebf\u7a0b\u7684\u5b9e\u73b0\u4e5f\u975e\u5e38\u590d\u6742\u3002\u867d\u7136\u5e95\u5c42\u53ea\u662f\u5bf9\u7ebf\u7a0b\u5e93\u7684\u5c01\u88c5\uff0c\u4f46\u662f\u628a\u5b83\u548cNode.js\u539f\u672c\u7684\u67b6\u6784\u7ed3\u5408\u8d77\u6765\u53d8\u5f97\u590d\u6742\u8d77\u6765\u3002 14.1 \u4f7f\u7528\u591a\u7ebf\u7a0b \u00b6 \u5bf9\u4e8e\u540c\u6b65\u6587\u4ef6\u64cd\u4f5c\u3001DNS\u89e3\u6790\u7b49\u64cd\u4f5c\uff0cNode.js\u4f7f\u7528\u4e86\u5185\u7f6e\u7684\u7ebf\u7a0b\u6c60\u652f\u6301\u4e86\u5f02\u6b65\u3002\u4f46\u662f\u4e00\u4e9b\u52a0\u89e3\u5bc6\u3001\u5b57\u7b26\u4e32\u8fd0\u7b97\u3001\u963b\u585e\u578bAPI\u7b49\u64cd\u4f5c\u3002\u6211\u4eec\u5c31\u4e0d\u80fd\u5728\u4e3b\u7ebf\u7a0b\u91cc\u5904\u7406\u4e86\uff0c\u8fd9\u65f6\u5019\u5c31\u4e0d\u5f97\u4e0d\u4f7f\u7528\u7ebf\u7a0b\uff0c\u800c\u4e14\u591a\u7ebf\u7a0b\u8fd8\u80fd\u5229\u7528\u591a\u6838\u7684\u80fd\u529b\u3002Node.js\u7684\u5b50\u7ebf\u7a0b\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u65b0\u7684\u4e8b\u4ef6\u5faa\u73af\uff0c\u4f46\u662f\u5b50\u7ebf\u7a0b\u548cNode.js\u4e3b\u7ebf\u7a0b\u5171\u4eab\u4e00\u4e2aLibuv\u7ebf\u7a0b\u6c60\uff0c\u6240\u4ee5\u5982\u679c\u5728\u5b50\u7ebf\u7a0b\u91cc\u6709\u6587\u4ef6\u3001DNS\u7b49\u64cd\u4f5c\u5c31\u4f1a\u548c\u4e3b\u7ebf\u7a0b\u7ade\u4e89Libuv\u7ebf\u7a0b\u6c60\u3002\u5982\u56fe14-1\u6240\u793a\u3002 \u56fe14-1 \u6211\u4eec\u770b\u4e00\u4e0b\u5728Node.js\u4e2d\u5982\u4f55\u4f7f\u7528\u7ebf\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 const { Worker , isMainThread , parentPort } = require ( 'worker_threads' ); if ( isMainThread ) { const worker = new Worker ( __filename ); worker . once ( 'message' , ( message ) => { ... }); worker . postMessage ( 'Hello, world!' ); } else { // \u505a\u70b9\u8017\u65f6\u7684\u4e8b\u60c5 parentPort . once ( 'message' , ( message ) => { parentPort . postMessage ( message ); }); } \u4e0a\u9762\u8fd9\u6bb5\u4ee3\u7801\u4f1a\u88ab\u6267\u884c\u4e24\u6b21\uff0c\u4e00\u6b21\u662f\u5728\u4e3b\u7ebf\u7a0b\uff0c\u4e00\u6b21\u5728\u5b50\u7ebf\u7a0b\u3002\u6240\u4ee5\u9996\u5148\u901a\u8fc7isMainThread\u5224\u65ad\u5f53\u524d\u662f\u4e3b\u7ebf\u7a0b\u8fd8\u662f\u5b50\u7ebf\u7a0b\u3002\u4e3b\u7ebf\u7a0b\u7684\u8bdd\uff0c\u5c31\u521b\u5efa\u4e00\u4e2a\u5b50\u7ebf\u7a0b\uff0c\u7136\u540e\u76d1\u542c\u5b50\u7ebf\u7a0b\u53d1\u8fc7\u6765\u7684\u6d88\u606f\u3002\u5b50\u7ebf\u7a0b\u7684\u8bdd\uff0c\u9996\u5148\u6267\u884c\u4e1a\u52a1\u76f8\u5173\u7684\u4ee3\u7801\uff0c\u8fd8\u53ef\u4ee5\u76d1\u542c\u4e3b\u7ebf\u7a0b\u4f20\u8fc7\u6765\u7684\u6d88\u606f\u3002\u6211\u4eec\u5728\u5b50\u7ebf\u7a0b\u4e2d\u53ef\u4ee5\u505a\u4e00\u4e9b\u8017\u65f6\u6216\u8005\u963b\u585e\u6027\u7684\u64cd\u4f5c\uff0c\u4e0d\u4f1a\u5f71\u54cd\u4e3b\u7ebf\u7a0b\u7684\u6267\u884c\u3002\u6211\u4eec\u4e5f\u53ef\u4ee5\u628a\u8fd9\u4e24\u4e2a\u903b\u8f91\u62c6\u5206\u5230\u4e24\u4e2a\u6587\u4ef6\u3002 \u4e3b\u7ebf\u7a0b 1 2 3 4 5 6 const { Worker , isMainThread , parentPort } = require ( 'worker_threads' ); const worker = new Worker ( \u2018 \u5b50\u7ebf\u7a0b\u6587\u4ef6\u8def\u5f84 \u2019 ); worker . once ( 'message' , ( message ) => { ... }); worker . postMessage ( 'Hello, world!' ); \u5b50\u7ebf\u7a0b 1 2 3 4 const { Worker , isMainThread , parentPort } = require ( 'worker_threads' ); parentPort . once ( 'message' , ( message ) => { parentPort . postMessage ( message ); }); 14.2 \u7ebf\u7a0b\u95f4\u901a\u4fe1\u6570\u636e\u7ed3\u6784 \u00b6 \u8fdb\u7a0b\u95f4\u7684\u901a\u4fe1\u4e00\u822c\u9700\u8981\u501f\u52a9\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u516c\u5171\u7684\u5185\u5b58\u6765\u5b8c\u6210\u3002\u56e0\u4e3a\u8fdb\u7a0b\u95f4\u7684\u5185\u5b58\u662f\u72ec\u7acb\u7684\uff0c\u548c\u8fdb\u7a0b\u95f4\u901a\u4fe1\u4e0d\u4e00\u6837\u3002\u591a\u7ebf\u7a0b\u7684\u5185\u5b58\u662f\u5171\u4eab\u7684\uff0c\u540c\u4e2a\u8fdb\u7a0b\u7684\u5185\u5b58\uff0c\u591a\u4e2a\u7ebf\u7a0b\u90fd\u53ef\u4ee5\u8bbf\u95ee\uff0c\u6240\u4ee5\u7ebf\u7a0b\u95f4\u901a\u4fe1\u53ef\u4ee5\u57fa\u4e8e\u8fdb\u7a0b\u5185\u7684\u5185\u5b58\u6765\u5b8c\u6210\u3002\u5728Node.js\u4e2d\uff0c\u7ebf\u7a0b\u95f4\u901a\u4fe1\u4f7f\u7528\u7684\u662fMessageChannel\u5b9e\u73b0\u7684\uff0c\u5b83\u662f\u5168\u53cc\u5de5\u7684\uff0c\u4efb\u610f\u4e00\u7aef\u90fd\u53ef\u4ee5\u968f\u65f6\u53d1\u9001\u4fe1\u606f\u3002MessageChannel\u7c7b\u4f3csocket\u901a\u4fe1\uff0c\u5b83\u5305\u62ec\u4e24\u4e2a\u7aef\u70b9\u3002\u5b9a\u4e49\u4e00\u4e2aMessageChannel\u76f8\u5f53\u4e8e\u5efa\u7acb\u4e00\u4e2aTCP\u8fde\u63a5\uff0c\u5b83\u9996\u5148\u7533\u8bf7\u4e24\u4e2a\u7aef\u70b9\uff08MessagePort\uff09\uff0c\u7136\u540e\u628a\u5b83\u4eec\u5173\u8054\u8d77\u6765\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u5b9e\u73b0\u4e2d\uff0c\u6bd4\u8f83\u91cd\u8981\u7684\u51e0\u4e2a\u6570\u636e\u7ed3\u6784\u3002 1 Message\u4ee3\u8868\u4e00\u4e2a\u6d88\u606f\u3002 2 MessagePortData\u662f\u5bf9\u64cd\u4f5cMessage\u7684\u5c01\u88c5\u548c\u5bf9\u6d88\u606f\u7684\u627f\u8f7d\u3002 3 MessagePort\u662f\u4ee3\u8868\u901a\u4fe1\u7684\u7aef\u70b9\u3002 4 MessageChannel\u662f\u4ee3\u8868\u901a\u4fe1\u7684\u4e24\u7aef\uff0c\u5373\u4e24\u4e2aMessagePort\u3002 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002 14.2.1 Message Message\u7c7b\u4ee3\u8868\u7684\u662f\u5b50\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u4e00\u6761\u6d88\u606f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Message : public MemoryRetainer { public : explicit Message ( MallocedBuffer < char >&& payload = MallocedBuffer < char > ()); // \u662f\u5426\u662f\u6700\u540e\u4e00\u6761\u6d88\u606f\uff0c\u7a7a\u6d88\u606f\u4ee3\u8868\u662f\u6700\u540e\u4e00\u6761\u6d88\u606f bool IsCloseMessage () const ; // \u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u6570\u636e\u9700\u8981\u901a\u8fc7\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u5904\u7406 v8 :: MaybeLocal < v8 :: Value > Deserialize ( Environment * env , v8 :: Local < v8 :: Context > context ); v8 :: Maybe < bool > Serialize ( Environment * env , v8 :: Local < v8 :: Context > context , v8 :: Local < v8 :: Value > input , const TransferList & transfer_list , v8 :: Local < v8 :: Object > source_port = v8 :: Local < v8 :: Object > ()); // \u4f20\u9012SharedArrayBuffer\u578b\u53d8\u91cf void AddSharedArrayBuffer ( std :: shared_ptr < v8 :: BackingStore > backing_store ); // \u4f20\u9012MessagePort\u578b\u53d8\u91cf void AddMessagePort ( std :: unique_ptr < MessagePortData >&& data ); // \u6d88\u606f\u6240\u5c5e\u7aef\u53e3\uff0c\u7aef\u53e3\u662f\u6d88\u606f\u5230\u8fbe\u7684\u5730\u65b9 const std :: vector < std :: unique_ptr < MessagePortData >>& message_ports () const { return message_ports_ ; } private : // \u4fdd\u5b58\u6d88\u606f\u7684\u5185\u5bb9 MallocedBuffer < char > main_message_buf_ ; std :: vector < std :: shared_ptr < v8 :: BackingStore >> array_buffers_ ; std :: vector < std :: shared_ptr < v8 :: BackingStore >> shared_array_buffers_ ; std :: vector < std :: unique_ptr < MessagePortData >> message_ports_ ; std :: vector < v8 :: CompiledWasmModule > wasm_modules_ ; }; 14.2.2 MessagePortData \u00b6 MessagePortData\u662f\u7ba1\u7406\u6d88\u606f\u53d1\u9001\u548c\u63a5\u6536\u7684\u7c7b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MessagePortData : public MemoryRetainer { public : explicit MessagePortData ( MessagePort * owner ); ~ MessagePortData () override ; // \u65b0\u589e\u4e00\u4e2a\u6d88\u606f void AddToIncomingQueue ( Message && message ); // \u5173\u8054/\u89e3\u5173\u8054\u901a\u4fe1\u4e24\u7aef\u7684\u7aef\u53e3 static void Entangle ( MessagePortData * a , MessagePortData * b ); void Disentangle (); private : // \u7528\u4e8e\u591a\u7ebf\u7a0b\u5f80\u5bf9\u7aef\u6d88\u606f\u961f\u5217\u63d2\u5165\u6d88\u606f\u65f6\u7684\u4e92\u65a5\u53d8\u91cf mutable Mutex mutex_ ; std :: list < Message > incoming_messages_ ; // \u6240\u5c5e\u7aef\u53e3 MessagePort * owner_ = nullptr ; // \u7528\u4e8e\u591a\u7ebf\u7a0b\u8bbf\u95ee\u5bf9\u7aefsibling_\u5c5e\u6027\u65f6\u7684\u4e92\u65a5\u53d8\u91cf std :: shared_ptr < Mutex > sibling_mutex_ = std :: make_shared < Mutex > (); // \u6307\u5411\u901a\u4fe1\u5bf9\u7aef\u7684\u6307\u9488 MessagePortData * sibling_ = nullptr ; }; \u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 MessagePortData :: MessagePortData ( MessagePort * owner ) : owner_ ( owner ) { } MessagePortData ::~ MessagePortData () { // \u6790\u6784\u65f6\u89e3\u9664\u548c\u5bf9\u7aef\u7684\u5173\u7cfb Disentangle (); } // \u63d2\u5165\u4e00\u4e2amessage void MessagePortData :: AddToIncomingQueue ( Message && message ) { // \u5148\u52a0\u9501\uff0c\u4fdd\u8bc1\u591a\u7ebf\u7a0b\u5b89\u5168\uff0c\u4e92\u65a5\u8bbf\u95ee Mutex :: ScopedLock lock ( mutex_ ); // \u63d2\u5165\u6d88\u606f\u961f\u5217 incoming_messages_ . emplace_back ( std :: move ( message )); // \u901a\u77e5owner if ( owner_ != nullptr ) { owner_ -> TriggerAsync (); } } // \u5173\u8054\u901a\u4fe1\u7684\u5bf9\u7aef\uff0c\u5e76\u4fdd\u6301\u5bf9\u7aef\u7684\u4e92\u65a5\u53d8\u91cf\uff0c\u8bbf\u95ee\u5bf9\u7aef\u65f6\u9700\u8981\u4f7f\u7528 void MessagePortData :: Entangle ( MessagePortData * a , MessagePortData * b ) { a -> sibling_ = b ; b -> sibling_ = a ; a -> sibling_mutex_ = b -> sibling_mutex_ ; } // \u89e3\u9664\u5173\u8054 void MessagePortData :: Disentangle () { // \u52a0\u9501\u64cd\u4f5c\u5bf9\u7aef\u7684sibling\u5b57\u6bb5 std :: shared_ptr < Mutex > sibling_mutex = sibling_mutex_ ; Mutex :: ScopedLock sibling_lock ( * sibling_mutex ); sibling_mutex_ = std :: make_shared < Mutex > (); // \u5bf9\u7aef MessagePortData * sibling = sibling_ ; // \u5bf9\u7aef\u975e\u7a7a\uff0c\u5219\u628a\u5bf9\u7aef\u7684sibling\u4e5f\u6307\u5411\u7a7a\uff0c\u81ea\u5df1\u4e5f\u6307\u5411\u7a7a if ( sibling_ != nullptr ) { sibling_ -> sibling_ = nullptr ; sibling_ = nullptr ; } // \u63d2\u5165\u4e00\u4e2a\u7a7a\u7684\u6d88\u606f\u901a\u77e5\u5bf9\u7aef\u548c\u672c\u7aef AddToIncomingQueue ( Message ()); if ( sibling != nullptr ) { sibling -> AddToIncomingQueue ( Message ()); } } 14.2.3 MessagePort \u00b6 MessagePort\u8868\u793a\u7684\u662f\u901a\u4fe1\u7684\u4e00\u7aef\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class MessagePort : public HandleWrap { public : MessagePort ( Environment * env , v8 :: Local < v8 :: Context > context , v8 :: Local < v8 :: Object > wrap ); ~ MessagePort () override ; static MessagePort * New ( Environment * env , v8 :: Local < v8 :: Context > context , std :: unique_ptr < MessagePortData > data = nullptr ); // \u53d1\u9001\u6d88\u606f v8 :: Maybe < bool > PostMessage ( Environment * env , v8 :: Local < v8 :: Value > message , const TransferList & transfer ); // \u5f00\u542f/\u5173\u95ed\u63a5\u6536\u6d88\u606f void Start (); void Stop (); static void New ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); // \u63d0\u4f9bJS\u5c42\u4f7f\u7528\u7684\u65b9\u6cd5 static void PostMessage ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static void Start ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static void Stop ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static void Drain ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static void ReceiveMessage ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); // \u5173\u8054\u5bf9\u7aef static void Entangle ( MessagePort * a , MessagePort * b ); static void Entangle ( MessagePort * a , MessagePortData * b ); // \u89e3\u9664MessagePortData\u548c\u7aef\u53e3\u7684\u5173\u7cfb std :: unique_ptr < MessagePortData > Detach (); // \u5173\u95ed\u7aef\u53e3 void Close ( v8 :: Local < v8 :: Value > close_callback = v8 :: Local < v8 :: Value > ()) override ; inline bool IsDetached () const ; private : void OnClose () override ; void OnMessage (); void TriggerAsync (); v8 :: MaybeLocal < v8 :: Value > ReceiveMessage ( v8 :: Local < v8 :: Context > context , bool only_if_receiving ); // MessagePortData\u7528\u4e8e\u7ba1\u7406\u6d88\u606f\u7684\u53d1\u9001\u548c\u63a5\u6536 std :: unique_ptr < MessagePortData > data_ = nullptr ; // \u662f\u5426\u5f00\u542f\u63a5\u6536\u6d88\u606f\u6807\u8bb0 bool receiving_messages_ = false ; // \u7528\u4e8e\u6536\u5230\u6d88\u606f\u65f6\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\uff0c\u4e8b\u4ef6\u5faa\u73af\u6267\u884c\u56de\u8c03\u5904\u7406\u6d88\u606f uv_async_t async_ ; }; \u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0\uff0c\u53ea\u5217\u51fa\u90e8\u5206\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 // \u7aef\u53e3\u662f\u5426\u4e0d\u63a5\u6536\u6d88\u606f\u4e86 bool MessagePort::IsDetached () const { return data_ == nullptr || IsHandleClosing (); } // \u6709\u6d88\u606f\u5230\u8fbe\uff0c\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\u6267\u884c\u56de\u8c03 void MessagePort::TriggerAsync () { if ( IsHandleClosing ()) return ; CHECK_EQ ( uv_async_send ( & async_ ), 0 ); } // \u5173\u95ed\u63a5\u6536\u6d88\u606f\u7684\u7aef\u53e3 void MessagePort::Close ( v8 :: Local < v8 :: Value > close_callback ) { if ( data_ ) { // \u6301\u6709\u9501\uff0c\u9632\u6b62\u518d\u63a5\u6536\u6d88\u606f Mutex :: ScopedLock sibling_lock ( data_ -> mutex_ ); HandleWrap :: Close ( close_callback ); } else { HandleWrap :: Close ( close_callback ); } } // \u65b0\u5efa\u4e00\u4e2a\u7aef\u53e3\uff0c\u5e76\u4e14\u53ef\u4ee5\u6302\u8f7d\u4e00\u4e2aMessagePortData MessagePort * MessagePort::New ( Environment * env , Local < Context > context , std :: unique_ptr < MessagePortData > data ) { Context :: Scope context_scope ( context ); Local < FunctionTemplate > ctor_templ = GetMessagePortConstructorTemplate ( env ); Local < Object > instance ; // JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61 if ( ! ctor_templ -> InstanceTemplate () -> NewInstance ( context ). ToLocal ( & instance )) return nullptr ; // \u65b0\u5efa\u4e00\u4e2a\u6d88\u606f\u7aef\u53e3 MessagePort * port = new MessagePort ( env , context , instance ); // \u9700\u8981\u6302\u8f7dMessagePortData if ( data ) { port -> Detach (); port -> data_ = std :: move ( data ); Mutex :: ScopedLock lock ( port -> data_ -> mutex_ ); // \u4fee\u6539data\u7684owner\u4e3a\u5f53\u524d\u6d88\u606f\u7aef\u53e3 port -> data_ -> owner_ = port ; // data\u4e2d\u53ef\u80fd\u6709\u6d88\u606f port -> TriggerAsync (); } return port ; } // \u5f00\u59cb\u63a5\u6536\u6d88\u606f void MessagePort::Start () { Debug ( this , \"Start receiving messages\" ); receiving_messages_ = true ; Mutex :: ScopedLock lock ( data_ -> mutex_ ); // \u6709\u7f13\u5b58\u7684\u6d88\u606f\uff0c\u901a\u77e5\u4e0a\u5c42 if ( ! data_ -> incoming_messages_ . empty ()) TriggerAsync (); } // \u505c\u6b62\u63a5\u6536\u6d88\u606f void MessagePort::Stop () { Debug ( this , \"Stop receiving messages\" ); receiving_messages_ = false ; } // JS\u5c42\u8c03\u7528 void MessagePort::Start ( const FunctionCallbackInfo < Value >& args ) { MessagePort * port ; ASSIGN_OR_RETURN_UNWRAP ( & port , args . This ()); if ( ! port -> data_ ) { return ; } port -> Start (); } void MessagePort::Stop ( const FunctionCallbackInfo < Value >& args ) { MessagePort * port ; CHECK ( args [ 0 ] -> IsObject ()); ASSIGN_OR_RETURN_UNWRAP ( & port , args [ 0 ]. As < Object > ()); if ( ! port -> data_ ) { return ; } port -> Stop (); } // \u8bfb\u53d6\u6d88\u606f void MessagePort::Drain ( const FunctionCallbackInfo < Value >& args ) { MessagePort * port ; ASSIGN_OR_RETURN_UNWRAP ( & port , args [ 0 ]. As < Object > ()); port -> OnMessage (); } // \u83b7\u53d6\u67d0\u4e2a\u7aef\u53e3\u7684\u6d88\u606f void MessagePort::ReceiveMessage ( const FunctionCallbackInfo < Value >& args ) { CHECK ( args [ 0 ] -> IsObject ()); // \u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u7aef\u53e3 MessagePort * port = Unwrap < MessagePort > ( args [ 0 ]. As < Object > ()); // \u8c03\u7528\u5bf9\u8c61\u7684ReceiverMessage\u65b9\u6cd5 MaybeLocal < Value > payload = port -> ReceiveMessage ( port -> object () -> CreationContext (), false ); if ( ! payload . IsEmpty ()) args . GetReturnValue (). Set ( payload . ToLocalChecked ()); } // \u5173\u8054\u4e24\u4e2a\u7aef\u53e3 void MessagePort::Entangle ( MessagePort * a , MessagePort * b ) { Entangle ( a , b -> data_ . get ()); } void MessagePort::Entangle ( MessagePort * a , MessagePortData * b ) { MessagePortData :: Entangle ( a -> data_ . get (), b ); } 14.2.4 MessageChannel \u00b6 MessageChannel\u8868\u793a\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u4e24\u4e2a\u7aef\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static void MessageChannel ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); Local < Context > context = args . This () -> CreationContext (); Context :: Scope context_scope ( context ); MessagePort * port1 = MessagePort :: New ( env , context ); MessagePort * port2 = MessagePort :: New ( env , context ); MessagePort :: Entangle ( port1 , port2 ); // port1->object()\u62ff\u5230JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\uff0c\u5b83\u5173\u8054\u4e86MessagePort\u5bf9\u8c61 args . This () -> Set ( context , env -> port1_string (), port1 -> object ()) . Check (); args . This () -> Set ( context , env -> port2_string (), port2 -> object ()) . Check (); } MessageChannel\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u65b0\u5efa\u4e24\u4e2a\u6d88\u606f\u7aef\u53e3\uff0c\u5e76\u4e14\u5173\u8054\u8d77\u6765\uff0c\u540e\u7eed\u5c31\u53ef\u4ee5\u57fa\u4e8e\u8fd9\u4e24\u4e2a\u7aef\u53e3\u8fdb\u884c\u901a\u4fe1\u4e86\u3002 Message\u3001MessagePortData\u3001MessagePort\u548cMessageChannel\u7684\u5173\u7cfb\u56fe\u5982\u56fe14-2\u6240\u793a\u3002 \u56fe14-2 \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u7ebf\u7a0b\u95f4\u901a\u4fe1\u6a21\u5757\u5bfc\u51fa\u7684\u4e00\u4e9b\u529f\u80fd\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 static void InitMessaging ( Local < Object > target , Local < Value > unused , Local < Context > context , void * priv ) { Environment * env = Environment :: GetCurrent ( context ); { // \u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u901a\u9053 Local < String > message_channel_string = FIXED_ONE_BYTE_STRING ( env -> isolate (), \"MessageChannel\" ); Local < FunctionTemplate > templ = env -> NewFunctionTemplate ( MessageChannel ); templ -> SetClassName ( message_channel_string ); target -> Set ( context , message_channel_string , templ -> GetFunction ( context ). ToLocalChecked ()). Check (); } // \u65b0\u5efa\u6d88\u606f\u7aef\u53e3\u7684\u6784\u9020\u51fd\u6570 target -> Set ( context , env -> message_port_constructor_string (), GetMessagePortConstructorTemplate ( env ) -> GetFunction ( context ). ToLocalChecked ()). Check (); env -> SetMethod ( target , \"stopMessagePort\" , MessagePort :: Stop ); env -> SetMethod ( target , \"drainMessagePort\" , MessagePort :: Drain ); env -> SetMethod ( target , \"receiveMessageOnPort\" , MessagePort :: ReceiveMessage ); env -> SetMethod ( target , \"moveMessagePortToContext\" , MessagePort :: MoveToContext ); } 14.3 \u591a\u7ebf\u7a0b\u7684\u5b9e\u73b0 \u00b6 \u672c\u8282\u6211\u4eec\u4eceworker_threads\u6a21\u5757\u5f00\u59cb\u5206\u6790\u591a\u7ebf\u7a0b\u7684\u5b9e\u73b0\u3002\u8fd9\u662f\u4e00\u4e2aC++\u6a21\u5757\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u5bfc\u51fa\u7684\u529f\u80fd\u3002require(\"work_threads\")\u7684\u65f6\u5019\u5c31\u662f\u5f15\u7528\u4e86InitWorker\u51fd\u6570\u5bfc\u51fa\u7684\u529f\u80fd\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 void InitWorker ( Local < Object > target , Local < Value > unused , Local < Context > context , void * priv ) { Environment * env = Environment :: GetCurrent ( context ); { Local < FunctionTemplate > w = env -> NewFunctionTemplate ( Worker :: New ); w -> InstanceTemplate () -> SetInternalFieldCount ( 1 ); w -> Inherit ( AsyncWrap :: GetConstructorTemplate ( env )); // \u8bbe\u7f6e\u4e00\u7cfb\u5217\u539f\u578b\u65b9\u6cd5\uff0c\u5c31\u4e0d\u4e00\u4e00\u5217\u4e3e env -> SetProtoMethod ( w , \"setEnvVars\" , Worker :: SetEnvVars ); // \u4e00\u7cfb\u5217\u539f\u578b\u65b9\u6cd5 /* \u5bfc\u51fa\u51fd\u6570\u6a21\u5757\u5bf9\u5e94\u7684\u51fd\u6570\uff0c\u5373\u6211\u4eec\u4ee3\u7801\u4e2d const { Worker } = require(\"worker_threads\");\u4e2d\u7684Worker */ Local < String > workerString = FIXED_ONE_BYTE_STRING ( env -> isolate (), \"Worker\" ); w -> SetClassName ( workerString ); target -> Set ( env -> context (), workerString , w -> GetFunction ( env -> context ()). ToLocalChecked ()). Check (); /* \u5bfc\u51fagetEnvMessagePort\u65b9\u6cd5\uff0c\u83b7\u53d6\u7ebf\u7a0b\u63a5\u6536\u6d88\u606f\u7684\u7aef\u53e3 const {getEnvMessagePort} = require(\"worker_threads\"); */ env -> SetMethod ( target , \"getEnvMessagePort\" , GetEnvMessagePort ); /* \u7ebf\u7a0bid\uff0c\u8fd9\u4e2a\u4e0d\u662f\u64cd\u4f5c\u7cfb\u7edf\u5206\u914d\u7684\u90a3\u4e2a\uff0c\u800c\u662fNode.js\u5206\u914d\u7684, \u5728\u521b\u5efa\u7ebf\u7a0b\u7684\u65f6\u5019\u8bbe\u7f6e const { threadId } = require(\"worker_threads\"); */ target -> Set ( env -> context (), env -> thread_id_string (), Number :: New ( env -> isolate (), static_cast < double > ( env -> thread_id ()))) . Check (); /* \u662f\u5426\u662f\u4e3b\u7ebf\u7a0b\uff0c const { isMainThread } = require(\"worker_threads\"); \u8fd9\u8fb9\u53d8\u91cf\u5728Node.js\u542f\u52a8\u7684\u65f6\u5019\u8bbe\u7f6e\u4e3atrue\uff0c\u65b0\u5f00\u5b50\u7ebf\u7a0b\u7684\u65f6\u5019\uff0c\u6ca1\u6709\u8bbe \u7f6e\uff0c\u6240\u4ee5\u662ffalse */ target -> Set ( env -> context (), FIXED_ONE_BYTE_STRING ( env -> isolate (), \"isMainThread\" ), Boolean :: New ( env -> isolate (), env -> is_main_thread ())) . Check (); /* \u5982\u679c\u4e0d\u662f\u4e3b\u7ebf\u7a0b\uff0c\u5bfc\u51fa\u8d44\u6e90\u9650\u5236\u7684\u914d\u7f6e\uff0c \u5373\u5728\u5b50\u7ebf\u7a0b\u4e2d\u8c03\u7528 const { resourceLimits } = require(\"worker_threads\"); */ if ( ! env -> is_main_thread ()) { target -> Set ( env -> context (), FIXED_ONE_BYTE_STRING ( env -> isolate (), \"resourceLimits\" ), env -> worker_context () -> GetResourceLimits ( env -> isolate ())). Check (); } // \u5bfc\u51fa\u51e0\u4e2a\u5e38\u91cf NODE_DEFINE_CONSTANT ( target , kMaxYoungGenerationSizeMb ); NODE_DEFINE_CONSTANT ( target , kMaxOldGenerationSizeMb ); NODE_DEFINE_CONSTANT ( target , kCodeRangeSizeMb ); NODE_DEFINE_CONSTANT ( target , kTotalResourceLimitCount ); } \u4e86\u89e3work_threads\u6a21\u5757\u5bfc\u51fa\u7684\u529f\u80fd\u540e\uff0c\u6211\u4eec\u770b\u5728JS\u5c42\u6267\u884cnew Worker\u7684\u65f6\u5019\u7684\u903b\u8f91\u3002\u6839\u636e\u4e0a\u9762\u4ee3\u7801\u5bfc\u51fa\u7684\u903b\u8f91\uff0c\u6211\u4eec\u77e5\u9053\u8fd9\u65f6\u5019\u9996\u5148\u4f1a\u65b0\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\u3002\u7136\u540e\u6267\u884cNew\u56de\u8c03\uff0c\u5e76\u4f20\u5165\u65b0\u5efa\u7684C++\u5bf9\u8c61\u3002\u6211\u4eec\u770bNew\u51fd\u6570\u7684\u903b\u8f91\u3002\u6211\u4eec\u7701\u7565\u4e00\u7cfb\u5217\u7684\u53c2\u6570\u5904\u7406\uff0c\u4e3b\u8981\u4ee3\u7801\u5982\u4e0b\u3002 1 2 3 4 // args.This()\u5c31\u662f\u6211\u4eec\u521a\u624d\u4f20\u8fdb\u6765\u7684this Worker * worker = new Worker ( env , args . This (), url , per_isolate_opts , std :: move ( exec_argv_out )); \u6211\u4eec\u518d\u770bWorker\u7c7b\u7684\u58f0\u660e\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Worker : public AsyncWrap { public : // \u51fd\u6570\u58f0\u660e private : std :: shared_ptr < PerIsolateOptions > per_isolate_opts_ ; std :: vector < std :: string > exec_argv_ ; std :: vector < std :: string > argv_ ; MultiIsolatePlatform * platform_ ; v8 :: Isolate * isolate_ = nullptr ; bool start_profiler_idle_notifier_ ; // \u771f\u6b63\u7684\u7ebf\u7a0bid\uff0c\u5e95\u5c42\u8fd4\u56de\u7684 uv_thread_t tid_ ; // This mutex protects access to all variables listed below it. mutable Mutex mutex_ ; bool thread_joined_ = true ; const char * custom_error_ = nullptr ; int exit_code_ = 0 ; // \u7ebf\u7a0bid\uff0cNode.js\u5206\u914d\uff0c\u4e0d\u662f\u5e95\u5c42\u8fd4\u56de\u7684 uint64_t thread_id_ = -1 ; uintptr_t stack_base_ = 0 ; // \u7ebf\u7a0b\u8d44\u6e90\u9650\u5236\u914d\u7f6e double resource_limits_ [ kTotalResourceLimitCount ]; void UpdateResourceConstraints ( v8 :: ResourceConstraints * constraints ); // \u6808\u4fe1\u606f static constexpr size_t kStackSize = 4 * 1024 * 1024 ; static constexpr size_t kStackBufferSize = 192 * 1024 ; std :: unique_ptr < MessagePortData > child_port_data_ ; std :: shared_ptr < KVStore > env_vars_ ; // \u7528\u4e8e\u7ebf\u7a0b\u95f4\u901a\u4fe1 MessagePort * child_port_ = nullptr ; MessagePort * parent_port_ = nullptr ; // \u7ebf\u7a0b\u72b6\u6001 bool stopped_ = true ; // \u662f\u5426\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa bool has_ref_ = true ; // \u5b50\u7ebf\u7a0b\u6267\u884c\u65f6\u7684\u73af\u5883\u53d8\u91cf\uff0c\u57fa\u7c7b\u4e5f\u5b9a\u4e49\u4e86 Environment * env_ = nullptr ; }; \u8fd9\u91cc\u53ea\u8bb2\u4e00\u4e0benv_\u7684\u5b9a\u4e49\uff0c\u56e0\u4e3a\u8fd9\u662f\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u5730\u65b9\u3002\u6211\u4eec\u770b\u5230Worker\u7c7b\u7ee7\u627fAsyncWrap\uff0cAsyncWrap\u7ee7\u627f\u4e86BaseObject\u3002BaseObject\u4e2d\u4e5f\u5b9a\u4e49\u4e86env_\u5c5e\u6027\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5728C++\u4e2d\u5982\u679c\u5b50\u7c7b\u7236\u7c7b\u90fd\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5c5e\u6027\u65f6\u662f\u600e\u6837\u7684\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e2a\u4f8b\u5b50 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <iostream> using namespace std ; class A { public : int value ; A () { value = 1 ; } void console () { cout << value << endl ; } }; class B : public A { public : int value ; B () : A () { value = 2 ; } }; int main () { B b ; // b.value = 3;\u53ea\u4f1a\u4fee\u6539\u5b50\u7c7b\u7684\uff0c\u4e0d\u4f1a\u4fee\u6539\u7236\u7c7b\u7684 b . console (); cout << b . value << endl << \"\u5185\u5b58\u5927\u5c0f\uff1a\" << sizeof ( b ) << endl ; return 0 ; } \u4ee5\u4e0a\u4ee3\u7801\u6267\u884c\u65f6\u8f93\u51fa 1 2 \u5185\u5b58\u5927\u5c0f\uff1a8 \u7531\u8f93\u51fa\u7ed3\u679c\u6211\u4eec\u53ef\u4ee5\u77e5\u9053\uff0cb\u5185\u5b58\u5927\u5c0f\u662f8\u4e2a\u5b57\u8282\u3002\u5373\u4e24\u4e2aint\u3002\u6240\u4ee5b\u7684\u5185\u5b58\u5e03\u5c40\u4e2d\u4e24\u4e2aa\u5c5e\u6027\u90fd\u5206\u914d\u4e86\u5185\u5b58\u3002\u5f53\u6211\u4eec\u901a\u8fc7b.console\u8f93\u51favalue\u65f6\uff0c\u56e0\u4e3aconsole\u662f\u5728A\u4e0a\u5b9a\u4e49\u7684\uff0c\u6240\u4ee5\u8f93\u51fa1\uff0c\u4f46\u662f\u6211\u4eec\u901a\u8fc7b.value\u8bbf\u95ee\u65f6\uff0c\u8f93\u51fa\u7684\u662f2\u3002\u56e0\u4e3a\u8bbf\u95ee\u7684\u662fB\u4e2d\u5b9a\u4e49\u7684value\uff0c\u540c\u7406\u5982\u679c\u6211\u4eec\u5728B\u4e2d\u5b9a\u4e49console\uff0c\u8f93\u51fa\u4e5f\u4f1a\u662f2\u3002Worker\u4e2d\u5b9a\u4e49\u7684env_\u6211\u4eec\u540e\u7eed\u4f1a\u770b\u5230\u5b83\u7684\u4f5c\u7528\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bWorker\u7c7b\u7684\u521d\u59cb\u5316\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Worker :: Worker ( Environment * env , Local < Object > wrap ,...) : AsyncWrap ( env , wrap , AsyncWrap :: PROVIDER_WORKER ), ... // \u5206\u914d\u7ebf\u7a0bid thread_id_ ( Environment :: AllocateThreadId ()), // \u7ee7\u627f\u4e3b\u7ebf\u7a0b\u7684\u73af\u5883\u53d8\u91cf env_vars_ ( env -> env_vars ()) { // \u65b0\u5efa\u4e00\u4e2a\u7aef\u53e3\u548c\u5b50\u7ebf\u7a0b\u901a\u4fe1 parent_port_ = MessagePort :: New ( env , env -> context ()); /* \u5173\u8054\u8d77\u6765\uff0c\u7528\u4e8e\u901a\u4fe1 const parent_port_ = {data: {sibling: null}}; const child_port_data_ = {sibling: null}; parent_port_.data.sibling = child_port_data_; child_port_data_.sibling = parent_port_.data; */ child_port_data_ = std :: make_unique < MessagePortData > ( nullptr ); MessagePort :: Entangle ( parent_port_ , child_port_data_ . get ()); // \u8bbe\u7f6eJS\u5c42Worker\u5bf9\u8c61\u7684messagePort\u5c5e\u6027\u4e3aparent_port_ object () -> Set ( env -> context (), env -> message_port_string (), parent_port_ -> object ()). Check (); // \u8bbe\u7f6eWorker\u5bf9\u8c61\u7684\u7ebf\u7a0bid\uff0c\u5373threadId\u5c5e\u6027 object () -> Set ( env -> context (), env -> thread_id_string (), Number :: New ( env -> isolate (), static_cast < double > ( thread_id_ ))) . Check (); } \u65b0\u5efa\u4e00\u4e2aWorker\uff0c\u7ed3\u6784\u5982\u56fe14-3\u6240\u793a\u3002 \u56fe14-3 \u4e86\u89e3\u4e86new Worker\u7684\u903b\u8f91\u540e\uff0c\u6211\u4eec\u770b\u5728JS\u5c42\u662f\u5982\u4f55\u4f7f\u7528\u7684\u3002\u6211\u4eec\u770bJS\u5c42Worker\u7c7b\u7684\u6784\u9020\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 constructor ( filename , options = {}) { super (); // \u5ffd\u7565\u4e00\u7cfb\u5217\u53c2\u6570\u5904\u7406\uff0cnew Worker\u5c31\u662f\u4e0a\u9762\u63d0\u5230\u7684C++\u5c42\u7684 this [ kHandle ] = new Worker ( url , options . execArgv , parseResourceLimits ( options . resourceLimits )); // messagePort\u6307\u5411_parent_port this [ kPort ] = this [ kHandle ]. messagePort ; this [ kPort ]. on ( 'message' , ( data ) => this [ kOnMessage ]( data )); // \u5f00\u59cb\u63a5\u6536\u6d88\u606f this [ kPort ]. start (); // \u7533\u8bf7\u4e00\u4e2a\u901a\u4fe1\u901a\u9053\uff0c\u4e24\u4e2a\u7aef\u53e3 const { port1 , port2 } = new MessageChannel (); this [ kPublicPort ] = port1 ; this [ kPublicPort ]. on ( 'message' , ( message ) => this . emit ( 'message' , message )); // \u5411\u53e6\u4e00\u7aef\u53d1\u9001\u6d88\u606f this [ kPort ]. postMessage ({ argv , type : messageTypes . LOAD_SCRIPT , filename , doEval : !! options . eval , cwdCounter : cwdCounter || workerIo . sharedCwdCounter , workerData : options . workerData , publicPort : port2 , manifestSrc : getOptionValue ( '--experimental-policy' ) ? require ( 'internal/process/policy' ). src : null , hasStdin : !! options . stdin }, [ port2 ]); // \u5f00\u542f\u7ebf\u7a0b this [ kHandle ]. startThread (); } \u4e0a\u9762\u7684\u4ee3\u7801\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 \u4fdd\u5b58messagePort\uff0c\u76d1\u542c\u8be5\u7aef\u53e3\u7684message\u4e8b\u4ef6\uff0c\u7136\u540e\u7ed9messagePort\u7684\u5bf9\u7aef\u53d1\u9001\u6d88\u606f\uff0c\u4f46\u662f\u8fd9\u65f6\u5019\u8fd8\u6ca1\u6709\u63a5\u6536\u7aef\u53e3\uff0c\u6240\u4ee5\u6d88\u606f\u4f1a\u7f13\u5b58\u5230MessagePortData\uff0c\u5373child_port_data_ \u4e2d\u3002\u53e6\u5916\u6211\u4eec\u770b\u5230\u4e3b\u7ebf\u7a0b\u628a\u901a\u4fe1\u7aef\u53e3port2\u53d1\u9001\u7ed9\u4e86\u5b50\u7ebf\u7a0b\u3002 2 \u7533\u8bf7\u4e00\u4e2a\u901a\u4fe1\u901a\u9053port1\u548cport2\uff0c\u7528\u4e8e\u4e3b\u7ebf\u7a0b\u548c\u5b50\u7ebf\u7a0b\u901a\u4fe1\u3002_parent_port\u548cchild_port\u662f\u7ed9Node.js\u4f7f\u7528\u7684\uff0c\u65b0\u7533\u8bf7\u7684\u7aef\u53e3\u662f\u7ed9\u7528\u6237\u4f7f\u7528\u7684\u3002 3 \u521b\u5efa\u5b50\u7ebf\u7a0b\u3002 \u6211\u4eec\u770b\u521b\u5efa\u7ebf\u7a0b\u7684\u65f6\u5019\uff0c\u505a\u4e86\u4ec0\u4e48\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 void Worker::StartThread ( const FunctionCallbackInfo < Value >& args ) { Worker * w ; ASSIGN_OR_RETURN_UNWRAP ( & w , args . This ()); Mutex :: ScopedLock lock ( w -> mutex_ ); // The object now owns the created thread and should not be garbage collected // until that finishes. w -> ClearWeak (); // \u52a0\u5165\u4e3b\u7ebf\u7a0b\u7ef4\u62a4\u7684\u5b50\u7ebf\u7a0b\u6570\u636e\u7ed3\u6784 w -> env () -> add_sub_worker_context ( w ); w -> stopped_ = false ; w -> thread_joined_ = false ; // \u662f\u5426\u9700\u8981\u963b\u585e\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\uff0c\u9ed8\u8ba4true if ( w -> has_ref_ ) w -> env () -> add_refs ( 1 ); // \u662f\u5426\u9700\u8981\u6808\u548c\u6808\u5927\u5c0f uv_thread_options_t thread_options ; thread_options . flags = UV_THREAD_HAS_STACK_SIZE ; thread_options . stack_size = kStackSize ; // \u521b\u5efa\u7ebf\u7a0b CHECK_EQ ( uv_thread_create_ex ( & w -> tid_ , & thread_options , []( void * arg ) { Worker * w = static_cast < Worker *> ( arg ); const uintptr_t stack_top = reinterpret_cast < uintptr_t > ( & arg ); w -> stack_base_ = stack_top - ( kStackSize - kStackBufferSize ); // \u6267\u884c\u4e3b\u903b\u8f91 w -> Run (); Mutex :: ScopedLock lock ( w -> mutex_ ); // \u7ed9\u4e3b\u7ebf\u7a0b\u63d0\u4ea4\u4e00\u4e2a\u4efb\u52a1\uff0c\u901a\u77e5\u4e3b\u7ebf\u7a0b\u5b50\u7ebf\u7a0b\u6267\u884c\u5b8c\u6bd5\uff0c\u56e0\u4e3a\u4e3b\u7ebf\u7a0b\u4e0d\u80fd\u76f4\u63a5\u6267\u884cjoin\u963b\u585e\u81ea\u5df1 w -> env () -> SetImmediateThreadsafe ( [ w = std :: unique_ptr < Worker > ( w )]( Environment * env ) { if ( w -> has_ref_ ) env -> add_refs ( -1 ); w -> JoinThread (); // implicitly delete w }); }, static_cast < void *> ( w )), 0 ); } StartThread\u65b0\u5efa\u4e86\u4e00\u4e2a\u5b50\u7ebf\u7a0b\uff0c\u7136\u540e\u5728\u5b50\u7ebf\u7a0b\u4e2d\u6267\u884cRun\uff0c\u6211\u4eec\u7ee7\u7eed\u770bRun 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 void Worker::Run () { // \u7ebf\u7a0b\u6267\u884c\u6240\u9700\u8981\u7684\u6570\u636e\u7ed3\u6784\uff0c\u6bd4\u5982loop\uff0cisolate\uff0c\u548c\u4e3b\u7ebf\u7a0b\u72ec\u7acb WorkerThreadData data ( this ); { Locker locker ( isolate_ ); Isolate :: Scope isolate_scope ( isolate_ ); SealHandleScope outer_seal ( isolate_ ); // std::unique_ptr<Environment, FreeEnvironment> env_; DeleteFnPtr < Environment , FreeEnvironment > env_ ; // \u7ebf\u7a0b\u6267\u884c\u5b8c\u540e\u6267\u884c\u7684\u6e05\u9664\u51fd\u6570 auto cleanup_env = OnScopeLeave ([ & ]() { // ... }); { HandleScope handle_scope ( isolate_ ); Local < Context > context ; // \u65b0\u5efa\u4e00\u4e2acontext\uff0c\u548c\u4e3b\u7ebf\u7a0b\u72ec\u7acb context = NewContext ( isolate_ ); Context :: Scope context_scope ( context ); { // \u65b0\u5efa\u4e00\u4e2aenv\u5e76\u521d\u59cb\u5316\uff0cenv\u4e2d\u4f1a\u548c\u65b0\u7684context\u5173\u8054 env_ . reset ( new Environment ( data . isolate_data_ . get (), context , std :: move ( argv_ ), std :: move ( exec_argv_ ), Environment :: kNoFlags , thread_id_ )); env_ -> set_env_vars ( std :: move ( env_vars_ )); env_ -> set_abort_on_uncaught_exception ( false ); env_ -> set_worker_context ( this ); env_ -> InitializeLibuv ( start_profiler_idle_notifier_ ); } { Mutex :: ScopedLock lock ( mutex_ ); // \u66f4\u65b0\u5b50\u7ebf\u7a0b\u6240\u5c5e\u7684env this -> env_ = env_ . get (); } { if ( ! env_ -> RunBootstrapping (). IsEmpty ()) { CreateEnvMessagePort ( env_ . get ()); USE ( StartExecution ( env_ . get (), \"internal/main/worker_thread\" )); } } { SealHandleScope seal ( isolate_ ); bool more ; // \u5f00\u59cb\u4e8b\u4ef6\u5faa\u73af do { if ( is_stopped ()) break ; uv_run ( & data . loop_ , UV_RUN_DEFAULT ); if ( is_stopped ()) break ; platform_ -> DrainTasks ( isolate_ ); more = uv_loop_alive ( & data . loop_ ); if ( more && ! is_stopped ()) continue ; EmitBeforeExit ( env_ . get ()); more = uv_loop_alive ( & data . loop_ ); } while ( more == true && ! is_stopped ()); } } } \u6211\u4eec\u5206\u6b65\u9aa4\u5206\u6790\u4e0a\u9762\u7684\u4ee3\u7801 1 \u65b0\u5efaIsolate\u3001context\u548cEnvironment\uff0c\u5b50\u7ebf\u7a0b\u5728\u72ec\u7acb\u7684\u73af\u5883\u6267\u884c\u3002\u7136\u540e\u521d\u59cb\u5316Environment\u3002\u8fd9\u4e2a\u5728Node.js\u542f\u52a8\u8fc7\u7a0b\u7ae0\u8282\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4e0d\u518d\u5206\u6790\u3002 2 \u66f4\u65b0\u5b50\u7ebf\u7a0b\u7684env_\u3002\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0cWorker\u7c7b\u4e2d\u5b9a\u4e49\u4e86env_\u5c5e\u6027\uff0c\u6240\u4ee5\u8fd9\u91cc\u901a\u8fc7this.env_\u66f4\u65b0\u65f6\uff0c\u662f\u4e0d\u4f1a\u5f71\u54cd\u57fa\u7c7b\uff08BaseObject\uff09\u4e2d\u7684\u503c\u7684\u3002\u56e0\u4e3a\u5b50\u7ebf\u7a0b\u662f\u5728\u65b0\u7684\u73af\u5883\u6267\u884c\u7684\uff0c\u6240\u4ee5\u5728\u65b0\u73af\u5883\u4e2d\u4f7f\u7528\u8be5Worker\u5b9e\u4f8b\u65f6\uff0c\u9700\u8981\u4f7f\u7528\u65b0\u7684\u73af\u5883\u53d8\u91cf\u3002\u800c\u5728\u4e3b\u7ebf\u7a0b\u4f7f\u7528\u8be5Worker\u5b9e\u4f8b\u65f6\uff0c\u662f\u901a\u8fc7BaseObject\u7684env()\u8bbf\u95ee\u7684\u3002\u4ece\u800c\u83b7\u53d6\u7684\u662f\u4e3b\u7ebf\u7a0b\u7684\u73af\u5883\u3002\u56e0\u4e3aWorker\u5b9e\u4f8b\u662f\u5728\u4e3b\u7ebf\u7a0b\u548c\u5b50\u7ebf\u7a0b\u4e4b\u95f4\u5171\u4eab\u7684\uff0cNode.js\u5728Worker\u7c7b\u4e2d\u91cd\u65b0\u5b9a\u4e49\u4e86\u4e00\u4e2aenv_\u5c5e\u6027\u6b63\u662f\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 3 CreateEnvMessagePort 1 2 3 4 5 6 7 void Worker::CreateEnvMessagePort ( Environment * env ) { child_port_ = MessagePort :: New ( env , env -> context (), std :: move ( child_port_data_ )); if ( child_port_ != nullptr ) env -> set_message_port ( child_port_ -> object ( isolate_ )); } child_port_data_\u8fd9\u4e2a\u53d8\u91cf\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u770b\u5230\u8fc7\uff0c\u5728\u8fd9\u91cc\u9996\u5148\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684\u7aef\u53e3\u3002\u5e76\u4e14\u548cchild_port_data_\u4e92\u76f8\u5173\u8054\u8d77\u6765\u3002\u7136\u540e\u5728env\u7f13\u5b58\u8d77\u6765\u3002\u540e\u7eed\u4f1a\u4f7f\u7528\u3002\u8fd9\u65f6\u5019\u7684\u5173\u7cfb\u56fe\u5982\u56fe14-4\u6240\u793a\u3002 \u56fe14-4 4 \u6267\u884cinternal/main/worker_thread.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // \u8bbe\u7f6eprocess\u5bf9\u8c61 patchProcessObject (); // \u83b7\u53d6\u521a\u624d\u7f13\u5b58\u7684\u7aef\u53e3child_port_ onst port = getEnvMessagePort (); port . on ( 'message' , ( message ) => { // \u52a0\u8f7d\u811a\u672c if ( message . type === LOAD_SCRIPT ) { const { argv , cwdCounter , filename , doEval , workerData , publicPort , manifestSrc , manifestURL , hasStdin } = message ; const CJSLoader = require ( 'internal/modules/cjs/loader' ); loadPreloadModules (); /* \u7531\u4e3b\u7ebf\u7a0b\u7533\u8bf7\u7684MessageChannel\u4e2d\u67d0\u4e00\u7aef\u7684\u7aef\u53e3\uff0c \u4e3b\u7ebf\u7a0b\u4f20\u9012\u8fc7\u6765\u7684\uff0c\u4fdd\u5b58\u7528\u4e8e\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1 */ publicWorker . parentPort = publicPort ; // \u6267\u884c\u65f6\u4f7f\u7528\u7684\u6570\u636e publicWorker . workerData = workerData ; // \u901a\u77e5\u4e3b\u7ebf\u7a0b\uff0c\u6b63\u5728\u6267\u884c\u811a\u672c port . postMessage ({ type : UP_AND_RUNNING }); // \u6267\u884cnew Worker(filename)\u65f6\u4f20\u5165\u7684\u6587\u4ef6 CJSLoader . Module . runMain ( filename ); }) // \u5f00\u59cb\u63a5\u6536\u6d88\u606f port . start () \u6211\u4eec\u770b\u5230worker_thread.js\u4e2d\u901a\u8fc7runMain\u5b8c\u6210\u4e86\u5b50\u7ebf\u7a0b\u7684\u4ee3\u7801\u6267\u884c\uff0c\u7136\u540e\u5f00\u59cb\u4e8b\u4ef6\u5faa\u73af\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u5f53\u4e8b\u4ef6\u5faa\u73af\u7ed3\u675f\u65f6\uff0cNode.js\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 // \u7ed9\u4e3b\u7ebf\u7a0b\u63d0\u4ea4\u4e00\u4e2a\u4efb\u52a1\uff0c\u901a\u77e5\u4e3b\u7ebf\u7a0b\u5b50\u7ebf\u7a0b\u6267\u884c\u5b8c\u6bd5\uff0c\u56e0\u4e3a\u4e3b\u7ebf\u7a0b\u4e0d\u80fd\u76f4\u63a5\u6267\u884cjoin\u963b\u585e\u81ea\u5df1 w -> env () -> SetImmediateThreadsafe ( [ w = std :: unique_ptr < Worker > ( w )]( Environment * env ) { if ( w -> has_ref_ ) env -> add_refs ( -1 ); w -> JoinThread (); // implicitly delete w }); }, static_cast < void *> ( w )), 0 ); \u901a\u8fc7w->env()\u83b7\u53d6\u7684\u662f\u4e3b\u7ebf\u7a0b\u7684\u6267\u884c\u73af\u5883\u3002\u6211\u4eec\u770b\u4e00\u4e0bSetImmediateThreadsafe\u3002 1 2 3 4 5 6 7 8 9 10 template < typename Fn > void Environment :: SetImmediateThreadsafe ( Fn && cb ) { auto callback = std :: make_unique < NativeImmediateCallbackImpl < Fn >> ( std :: move ( cb ), false ); { Mutex :: ScopedLock lock ( native_immediates_threadsafe_mutex_ ); native_immediates_threadsafe_ . Push ( std :: move ( callback )); } uv_async_send ( & task_queues_async_ ); } SetImmediateThreadsafe\u7528\u4e8e\u901a\u77e5\u6267\u884c\u73af\u5883\u6240\u5728\u7684\u4e8b\u4ef6\u5faa\u73af\u6709\u5f02\u6b65\u4efb\u52a1\u5b8c\u6210\u3002\u5e76\u4e14\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\u3002\u56e0\u4e3a\u53ef\u80fd\u6709\u591a\u4e2a\u7ebf\u7a0b\u4f1a\u64cd\u4f5cnative_immediates_threadsafe_\u3002\u5728\u4e3b\u7ebf\u7a0b\u4e8b\u4ef6\u5faa\u73af\u7684Poll IO\u9636\u6bb5\u5c31\u4f1a\u6267\u884ctask_queues_async_\u56de\u8c03\u3002\u6211\u4eec\u770b\u4e00\u4e0btask_queues_async_\u5bf9\u5e94\u7684\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 uv_async_init ( event_loop (), & task_queues_async_ , []( uv_async_t * async ) { Environment * env = ContainerOf ( & Environment :: task_queues_async_ , async ); env -> CleanupFinalizationGroups (); env -> RunAndClearNativeImmediates (); }); \u6240\u4ee5\u5728Poll IO\u9636\u6bb5\u6267\u884c\u7684\u56de\u8c03\u662fRunAndClearNativeImmediates 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void Environment::RunAndClearNativeImmediates ( bool only_refed ) { TraceEventScope trace_scope ( TRACING_CATEGORY_NODE1 ( environment ), \"RunAndClearNativeImmediates\" , this ); size_t ref_count = 0 ; if ( native_immediates_threadsafe_ . size () > 0 ) { Mutex :: ScopedLock lock ( native_immediates_threadsafe_mutex_ ); native_immediates_ . ConcatMove ( std :: move ( native_immediates_threadsafe_ )); } auto drain_list = [ & ]() { TryCatchScope try_catch ( this ); DebugSealHandleScope seal_handle_scope ( isolate ()); while ( std :: unique_ptr < NativeImmediateCallback > head = native_immediates_ . Shift ()) { if ( head -> is_refed ()) ref_count ++ ; if ( head -> is_refed () || ! only_refed ) // \u6267\u884c\u56de\u8c03 head -> Call ( this ); head . reset (); }; } RunAndClearNativeImmediates\u4f1a\u6267\u884c\u961f\u5217\u91cc\u7684\u56de\u8c03\u3002\u5bf9\u5e94Worker\u7684JoinThread 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void Worker::JoinThread () { // \u963b\u585e\u7b49\u5f85\u5b50\u7ebf\u7a0b\u7ed3\u675f\uff0c\u6267\u884c\u5230\u8fd9\u5b50\u7ebf\u7a0b\u5df2\u7ecf\u7ed3\u675f\u4e86 CHECK_EQ ( uv_thread_join ( & tid_ ), 0 ); thread_joined_ = true ; // \u4ece\u4e3b\u7ebf\u7a0b\u6570\u636e\u7ed3\u6784\u4e2d\u5220\u9664\u8be5\u7ebf\u7a0b\u5bf9\u5e94\u7684\u5b9e\u4f8b env () -> remove_sub_worker_context ( this ); { HandleScope handle_scope ( env () -> isolate ()); Context :: Scope context_scope ( env () -> context ()); // Reset the parent port as we're closing it now anyway. object () -> Set ( env () -> context (), env () -> message_port_string (), Undefined ( env () -> isolate ())). Check (); // \u5b50\u7ebf\u7a0b\u9000\u51fa\u7801 Local < Value > args [] = { Integer :: New ( env () -> isolate (), exit_code_ ), custom_error_ != nullptr ? OneByteString ( env () -> isolate (), custom_error_ ). As < Value > () : Null ( env () -> isolate ()). As < Value > (), }; // \u6267\u884cJS\u5c42\u56de\u8c03\uff0c\u89e6\u53d1exit\u4e8b\u4ef6 MakeCallback ( env () -> onexit_string (), arraysize ( args ), args ); } } \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u679c\u7ed3\u675f\u6b63\u5728\u6267\u884c\u7684\u5b50\u7ebf\u7a0b\u3002\u5728JS\u4e2d\u6211\u80fd\u53ef\u4ee5\u901a\u8fc7terminate\u51fd\u6570\u7ec8\u6b62\u7ebf\u7a0b\u7684\u6267\u884c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 terminate ( callback ) { this [ kHandle ]. stopThread (); } Terminate\u662f\u5bf9C ++ \u6a21\u5757 stopThread\u7684\u5c01\u88c5 \u3002 void Worker :: StopThread ( const FunctionCallbackInfo < Value >& args ) { Worker * w ; ASSIGN_OR_RETURN_UNWRAP ( & w , args . This ()); w -> Exit ( 1 ); } void Worker :: Exit ( int code ) { Mutex :: ScopedLock lock ( mutex_ ); // env_\u662f\u5b50\u7ebf\u7a0b\u6267\u884c\u7684env if ( env_ != nullptr ) { exit_code_ = code ; Stop ( env_ ); } else { stopped_ = true ; } } int Stop ( Environment * env ) { env -> ExitEnv (); return 0 ; } void Environment :: ExitEnv () { set_can_call_into_js ( false ); set_stopping ( true ); isolate_ -> TerminateExecution (); SetImmediateThreadsafe ([]( Environment * env ) { uv_stop ( env -> event_loop ()); }); } \u6211\u4eec\u770b\u5230\u4e3b\u7ebf\u7a0b\u6700\u7ec8\u901a\u8fc7SetImmediateThreadsafe\u7ed9\u5b50\u7ebf\u7a0b\u6240\u5c5e\u7684env\u63d0\u4ea4\u4e86\u4e00\u4e2a\u4efb\u52a1\u3002\u5b50\u7ebf\u7a0b\u5728Poll IO\u9636\u6bb5\u4f1a\u8bbe\u7f6e\u505c\u6b62\u4e8b\u4ef6\u5faa\u73af\u7684\u6807\u8bb0\uff0c\u7b49\u5230\u4e0b\u4e00\u6b21\u4e8b\u4ef6\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u8df3\u51fa\u4e8b\u4ef6\u5faa\u73af\u4ece\u800c\u7ed3\u675f\u5b50\u7ebf\u7a0b\u7684\u6267\u884c\u3002 14.4 \u7ebf\u7a0b\u95f4\u901a\u4fe1 \u00b6 \u672c\u8282\u6211\u4eec\u770b\u4e00\u4e0b\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u8fc7\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 const { Worker , isMainThread , parentPort } = require ( 'worker_threads' ); if ( isMainThread ) { const worker = new Worker ( __filename ); worker . once ( 'message' , ( message ) => { ... }); worker . postMessage ( 'Hello, world!' ); } else { // \u505a\u70b9\u8017\u65f6\u7684\u4e8b\u60c5 parentPort . once ( 'message' , ( message ) => { parentPort . postMessage ( message ); }); } \u6211\u4eec\u77e5\u9053isMainThread\u5728\u5b50\u7ebf\u7a0b\u91cc\u662ffalse\uff0cparentPort\u5c31\u662fmessageChannel\u4e2d\u7684\u4e00\u7aef\u3002\u7528\u4e8e\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\uff0c\u6240\u4ee5parentPort.postMessage\u7ed9\u5bf9\u7aef\u53d1\u9001\u6d88\u606f\uff0c\u5c31\u662f\u7ed9\u4e3b\u7ebf\u7a0b\u53d1\u9001\u6d88\u606f\uff0c\u6211\u4eec\u518d\u770b\u770bworker.postMessage('Hello, world!')\u3002 1 2 3 postMessage (... args ) { this [ kPublicPort ]. postMessage (... args ); } kPublicPort\u6307\u5411\u7684\u5c31\u662fmessageChannel\u7684\u4e00\u7aef\u3002this[kPublicPort].postMessage(...args)\u5373\u7ed9\u53e6\u4e00\u7aef\u53d1\u9001\u6d88\u606f\u3002\u6211\u4eec\u770b\u4e00\u4e0bpostMessage\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void MessagePort::PostMessage ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); Local < Object > obj = args . This (); Local < Context > context = obj -> CreationContext (); TransferList transfer_list ; if ( args [ 1 ] -> IsObject ()) { // \u5904\u7406transfer_list } // \u62ff\u5230JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u6240\u5173\u8054\u7684MessagePort MessagePort * port = Unwrap < MessagePort > ( args . This ()); port -> PostMessage ( env , args [ 0 ], transfer_list ); } \u6211\u4eec\u63a5\u7740\u770bport->PostMessage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Maybe < bool > MessagePort :: PostMessage ( Environment * env , Local < Value > message_v , const TransferList & transfer_v ) { Isolate * isolate = env -> isolate (); Local < Object > obj = object ( isolate ); Local < Context > context = obj -> CreationContext (); Message msg ; // \u5e8f\u5217\u5316 Maybe < bool > serialization_maybe = msg . Serialize ( env , context , message_v , transfer_v , obj ); // \u62ff\u5230\u64cd\u4f5c\u5bf9\u7aefsibling\u7684\u9501 Mutex :: ScopedLock lock ( * data_ -> sibling_mutex_ ); // \u628a\u6d88\u606f\u63d2\u5165\u5230\u5bf9\u7aef\u961f\u5217 data_ -> sibling_ -> AddToIncomingQueue ( std :: move ( msg )); return Just ( true ); } PostMessage\u901a\u8fc7AddToIncomingQueue\u628a\u6d88\u606f\u63d2\u5165\u5bf9\u7aef\u7684\u6d88\u606f\u961f\u5217\u6211\u4eec\u770b\u4e00\u4e0bAddToIncomingQueue 1 2 3 4 5 6 7 8 9 void MessagePortData::AddToIncomingQueue ( Message && message ) { // \u52a0\u9501\u64cd\u4f5c\u6d88\u606f\u961f\u5217 Mutex :: ScopedLock lock ( mutex_ ); incoming_messages_ . emplace_back ( std :: move ( message )); // \u901a\u77e5owner if ( owner_ != nullptr ) { owner_ -> TriggerAsync (); } } \u63d2\u5165\u6d88\u606f\u961f\u5217\u540e\uff0c\u5982\u679c\u6709\u5173\u8054\u7684\u7aef\u53e3\uff0c\u5219\u4f1a\u901a\u77e5Libuv\u3002\u6211\u4eec\u7ee7\u7eed\u770bTriggerAsync\u3002 1 2 3 4 void MessagePort::TriggerAsync () { if ( IsHandleClosing ()) return ; CHECK_EQ ( uv_async_send ( & async_ ), 0 ); } Libuv\u5728Poll IO\u9636\u6bb5\u5c31\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u3002\u56de\u8c03\u662f\u5728new MessagePort\u65f6\u8bbe\u7f6e\u7684\u3002 1 2 3 4 5 6 7 8 auto onmessage = []( uv_async_t * handle ) { MessagePort * channel = ContainerOf ( & MessagePort :: async_ , handle ); channel -> OnMessage (); }; // \u521d\u59cb\u5316async\u7ed3\u6784\u4f53\uff0c\u5b9e\u73b0\u5f02\u6b65\u901a\u4fe1 CHECK_EQ ( uv_async_init ( env -> event_loop (), & async_ , onmessage ), 0 ); \u6211\u4eec\u7ee7\u7eed\u770bOnMessage\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 void MessagePort::OnMessage () { HandleScope handle_scope ( env () -> isolate ()); Local < Context > context = object ( env () -> isolate ()) -> CreationContext (); // \u63a5\u6536\u6d88\u606f\u6761\u6570\u7684\u9608\u503c size_t processing_limit ; { // \u52a0\u9501\u64cd\u4f5c\u6d88\u606f\u961f\u5217 Mutex :: ScopedLock ( data_ -> mutex_ ); processing_limit = std :: max ( data_ -> incoming_messages_ . size (), static_cast < size_t > ( 1000 )); } while ( data_ ) { // \u8bfb\u53d6\u7684\u6761\u6570\u8fbe\u5230\u9608\u503c\uff0c\u901a\u77e5Libuv\u4e0b\u4e00\u8f6ePoll IO\u9636\u6bb5\u7ee7\u7eed\u8bfb if ( processing_limit -- == 0 ) { // \u901a\u77e5\u4e8b\u4ef6\u5faa\u73af TriggerAsync (); return ; } HandleScope handle_scope ( env () -> isolate ()); Context :: Scope context_scope ( context ); Local < Value > payload ; // \u8bfb\u53d6\u6d88\u606f if ( ! ReceiveMessage ( context , true ). ToLocal ( & payload )) break ; // \u6ca1\u6709\u4e86 if ( payload == env () -> no_message_symbol ()) break ; Local < Object > event ; Local < Value > cb_args [ 1 ]; // \u65b0\u5efa\u4e00\u4e2aMessageEvent\u5bf9\u8c61\uff0c\u56de\u8c03onmessage\u4e8b\u4ef6 if ( ! env () -> message_event_object_template () -> NewInstance ( context ) . ToLocal ( & event ) || event -> Set ( context , env () -> data_string (), payload ). IsNothing () || event -> Set ( context , env () -> target_string (), object ()). IsNothing () || ( cb_args [ 0 ] = event , false ) || MakeCallback ( env () -> onmessage_string (), arraysize ( cb_args ), cb_args ). IsEmpty ()) { // \u5982\u679c\u56de\u8c03\u5931\u8d25\uff0c\u901a\u77e5Libuv\u4e0b\u6b21\u7ee7\u7eed\u8bfb if ( data_ ) TriggerAsync (); return ; } } } \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u4f1a\u4e0d\u65ad\u5730\u8c03\u7528ReceiveMessage\u8bfb\u53d6\u6570\u636e\uff0c\u7136\u540e\u56de\u8c03JS\u5c42\u3002\u76f4\u5230\u8fbe\u5230\u9608\u503c\u6216\u8005\u56de\u8c03\u5931\u8d25\u3002\u6211\u4eec\u770b\u4e00\u4e0bReceiveMessage\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 MaybeLocal < Value > MessagePort :: ReceiveMessage ( Local < Context > context , bool only_if_receiving ) { Message received ; { // Get the head of the message queue. // \u4e92\u65a5\u8bbf\u95ee\u6d88\u606f\u961f\u5217 Mutex :: ScopedLock lock ( data_ -> mutex_ ); bool wants_message = receiving_messages_ || ! only_if_receiving ; // \u6ca1\u6709\u6d88\u606f\u3001\u4e0d\u9700\u8981\u63a5\u6536\u6d88\u606f\u3001\u6d88\u606f\u662f\u5173\u95ed\u6d88\u606f if ( data_ -> incoming_messages_ . empty () || ( ! wants_message && ! data_ -> incoming_messages_ . front (). IsCloseMessage ())) { return env () -> no_message_symbol (); } // \u83b7\u53d6\u961f\u5217\u7b2c\u4e00\u4e2a\u6d88\u606f received = std :: move ( data_ -> incoming_messages_ . front ()); data_ -> incoming_messages_ . pop_front (); } // \u662f\u5173\u95ed\u6d88\u606f\u5219\u5173\u95ed\u7aef\u53e3 if ( received . IsCloseMessage ()) { Close (); return env () -> no_message_symbol (); } // \u53cd\u5e8f\u5217\u5316\u540e\u8fd4\u56de return received . Deserialize ( env (), context ); } ReceiveMessage\u4f1a\u6d88\u606f\u8fdb\u884c\u53cd\u5e8f\u5217\u5316\u8fd4\u56de\u3002\u4ee5\u4e0a\u5c31\u662f\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u6574\u4e2a\u8fc7\u7a0b\u3002\u5177\u4f53\u6b65\u9aa4\u5982\u56fe14-5\u6240\u793a\u3002 \u56fe14-5","title":"14-\u7ebf\u7a0b"},{"location":"chapter14-%E7%BA%BF%E7%A8%8B/#141","text":"\u5bf9\u4e8e\u540c\u6b65\u6587\u4ef6\u64cd\u4f5c\u3001DNS\u89e3\u6790\u7b49\u64cd\u4f5c\uff0cNode.js\u4f7f\u7528\u4e86\u5185\u7f6e\u7684\u7ebf\u7a0b\u6c60\u652f\u6301\u4e86\u5f02\u6b65\u3002\u4f46\u662f\u4e00\u4e9b\u52a0\u89e3\u5bc6\u3001\u5b57\u7b26\u4e32\u8fd0\u7b97\u3001\u963b\u585e\u578bAPI\u7b49\u64cd\u4f5c\u3002\u6211\u4eec\u5c31\u4e0d\u80fd\u5728\u4e3b\u7ebf\u7a0b\u91cc\u5904\u7406\u4e86\uff0c\u8fd9\u65f6\u5019\u5c31\u4e0d\u5f97\u4e0d\u4f7f\u7528\u7ebf\u7a0b\uff0c\u800c\u4e14\u591a\u7ebf\u7a0b\u8fd8\u80fd\u5229\u7528\u591a\u6838\u7684\u80fd\u529b\u3002Node.js\u7684\u5b50\u7ebf\u7a0b\u672c\u8d28\u4e0a\u662f\u4e00\u4e2a\u65b0\u7684\u4e8b\u4ef6\u5faa\u73af\uff0c\u4f46\u662f\u5b50\u7ebf\u7a0b\u548cNode.js\u4e3b\u7ebf\u7a0b\u5171\u4eab\u4e00\u4e2aLibuv\u7ebf\u7a0b\u6c60\uff0c\u6240\u4ee5\u5982\u679c\u5728\u5b50\u7ebf\u7a0b\u91cc\u6709\u6587\u4ef6\u3001DNS\u7b49\u64cd\u4f5c\u5c31\u4f1a\u548c\u4e3b\u7ebf\u7a0b\u7ade\u4e89Libuv\u7ebf\u7a0b\u6c60\u3002\u5982\u56fe14-1\u6240\u793a\u3002 \u56fe14-1 \u6211\u4eec\u770b\u4e00\u4e0b\u5728Node.js\u4e2d\u5982\u4f55\u4f7f\u7528\u7ebf\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 const { Worker , isMainThread , parentPort } = require ( 'worker_threads' ); if ( isMainThread ) { const worker = new Worker ( __filename ); worker . once ( 'message' , ( message ) => { ... }); worker . postMessage ( 'Hello, world!' ); } else { // \u505a\u70b9\u8017\u65f6\u7684\u4e8b\u60c5 parentPort . once ( 'message' , ( message ) => { parentPort . postMessage ( message ); }); } \u4e0a\u9762\u8fd9\u6bb5\u4ee3\u7801\u4f1a\u88ab\u6267\u884c\u4e24\u6b21\uff0c\u4e00\u6b21\u662f\u5728\u4e3b\u7ebf\u7a0b\uff0c\u4e00\u6b21\u5728\u5b50\u7ebf\u7a0b\u3002\u6240\u4ee5\u9996\u5148\u901a\u8fc7isMainThread\u5224\u65ad\u5f53\u524d\u662f\u4e3b\u7ebf\u7a0b\u8fd8\u662f\u5b50\u7ebf\u7a0b\u3002\u4e3b\u7ebf\u7a0b\u7684\u8bdd\uff0c\u5c31\u521b\u5efa\u4e00\u4e2a\u5b50\u7ebf\u7a0b\uff0c\u7136\u540e\u76d1\u542c\u5b50\u7ebf\u7a0b\u53d1\u8fc7\u6765\u7684\u6d88\u606f\u3002\u5b50\u7ebf\u7a0b\u7684\u8bdd\uff0c\u9996\u5148\u6267\u884c\u4e1a\u52a1\u76f8\u5173\u7684\u4ee3\u7801\uff0c\u8fd8\u53ef\u4ee5\u76d1\u542c\u4e3b\u7ebf\u7a0b\u4f20\u8fc7\u6765\u7684\u6d88\u606f\u3002\u6211\u4eec\u5728\u5b50\u7ebf\u7a0b\u4e2d\u53ef\u4ee5\u505a\u4e00\u4e9b\u8017\u65f6\u6216\u8005\u963b\u585e\u6027\u7684\u64cd\u4f5c\uff0c\u4e0d\u4f1a\u5f71\u54cd\u4e3b\u7ebf\u7a0b\u7684\u6267\u884c\u3002\u6211\u4eec\u4e5f\u53ef\u4ee5\u628a\u8fd9\u4e24\u4e2a\u903b\u8f91\u62c6\u5206\u5230\u4e24\u4e2a\u6587\u4ef6\u3002 \u4e3b\u7ebf\u7a0b 1 2 3 4 5 6 const { Worker , isMainThread , parentPort } = require ( 'worker_threads' ); const worker = new Worker ( \u2018 \u5b50\u7ebf\u7a0b\u6587\u4ef6\u8def\u5f84 \u2019 ); worker . once ( 'message' , ( message ) => { ... }); worker . postMessage ( 'Hello, world!' ); \u5b50\u7ebf\u7a0b 1 2 3 4 const { Worker , isMainThread , parentPort } = require ( 'worker_threads' ); parentPort . once ( 'message' , ( message ) => { parentPort . postMessage ( message ); });","title":"14.1 \u4f7f\u7528\u591a\u7ebf\u7a0b"},{"location":"chapter14-%E7%BA%BF%E7%A8%8B/#142","text":"\u8fdb\u7a0b\u95f4\u7684\u901a\u4fe1\u4e00\u822c\u9700\u8981\u501f\u52a9\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u516c\u5171\u7684\u5185\u5b58\u6765\u5b8c\u6210\u3002\u56e0\u4e3a\u8fdb\u7a0b\u95f4\u7684\u5185\u5b58\u662f\u72ec\u7acb\u7684\uff0c\u548c\u8fdb\u7a0b\u95f4\u901a\u4fe1\u4e0d\u4e00\u6837\u3002\u591a\u7ebf\u7a0b\u7684\u5185\u5b58\u662f\u5171\u4eab\u7684\uff0c\u540c\u4e2a\u8fdb\u7a0b\u7684\u5185\u5b58\uff0c\u591a\u4e2a\u7ebf\u7a0b\u90fd\u53ef\u4ee5\u8bbf\u95ee\uff0c\u6240\u4ee5\u7ebf\u7a0b\u95f4\u901a\u4fe1\u53ef\u4ee5\u57fa\u4e8e\u8fdb\u7a0b\u5185\u7684\u5185\u5b58\u6765\u5b8c\u6210\u3002\u5728Node.js\u4e2d\uff0c\u7ebf\u7a0b\u95f4\u901a\u4fe1\u4f7f\u7528\u7684\u662fMessageChannel\u5b9e\u73b0\u7684\uff0c\u5b83\u662f\u5168\u53cc\u5de5\u7684\uff0c\u4efb\u610f\u4e00\u7aef\u90fd\u53ef\u4ee5\u968f\u65f6\u53d1\u9001\u4fe1\u606f\u3002MessageChannel\u7c7b\u4f3csocket\u901a\u4fe1\uff0c\u5b83\u5305\u62ec\u4e24\u4e2a\u7aef\u70b9\u3002\u5b9a\u4e49\u4e00\u4e2aMessageChannel\u76f8\u5f53\u4e8e\u5efa\u7acb\u4e00\u4e2aTCP\u8fde\u63a5\uff0c\u5b83\u9996\u5148\u7533\u8bf7\u4e24\u4e2a\u7aef\u70b9\uff08MessagePort\uff09\uff0c\u7136\u540e\u628a\u5b83\u4eec\u5173\u8054\u8d77\u6765\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u5b9e\u73b0\u4e2d\uff0c\u6bd4\u8f83\u91cd\u8981\u7684\u51e0\u4e2a\u6570\u636e\u7ed3\u6784\u3002 1 Message\u4ee3\u8868\u4e00\u4e2a\u6d88\u606f\u3002 2 MessagePortData\u662f\u5bf9\u64cd\u4f5cMessage\u7684\u5c01\u88c5\u548c\u5bf9\u6d88\u606f\u7684\u627f\u8f7d\u3002 3 MessagePort\u662f\u4ee3\u8868\u901a\u4fe1\u7684\u7aef\u70b9\u3002 4 MessageChannel\u662f\u4ee3\u8868\u901a\u4fe1\u7684\u4e24\u7aef\uff0c\u5373\u4e24\u4e2aMessagePort\u3002 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002 14.2.1 Message Message\u7c7b\u4ee3\u8868\u7684\u662f\u5b50\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u4e00\u6761\u6d88\u606f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Message : public MemoryRetainer { public : explicit Message ( MallocedBuffer < char >&& payload = MallocedBuffer < char > ()); // \u662f\u5426\u662f\u6700\u540e\u4e00\u6761\u6d88\u606f\uff0c\u7a7a\u6d88\u606f\u4ee3\u8868\u662f\u6700\u540e\u4e00\u6761\u6d88\u606f bool IsCloseMessage () const ; // \u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u6570\u636e\u9700\u8981\u901a\u8fc7\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u5904\u7406 v8 :: MaybeLocal < v8 :: Value > Deserialize ( Environment * env , v8 :: Local < v8 :: Context > context ); v8 :: Maybe < bool > Serialize ( Environment * env , v8 :: Local < v8 :: Context > context , v8 :: Local < v8 :: Value > input , const TransferList & transfer_list , v8 :: Local < v8 :: Object > source_port = v8 :: Local < v8 :: Object > ()); // \u4f20\u9012SharedArrayBuffer\u578b\u53d8\u91cf void AddSharedArrayBuffer ( std :: shared_ptr < v8 :: BackingStore > backing_store ); // \u4f20\u9012MessagePort\u578b\u53d8\u91cf void AddMessagePort ( std :: unique_ptr < MessagePortData >&& data ); // \u6d88\u606f\u6240\u5c5e\u7aef\u53e3\uff0c\u7aef\u53e3\u662f\u6d88\u606f\u5230\u8fbe\u7684\u5730\u65b9 const std :: vector < std :: unique_ptr < MessagePortData >>& message_ports () const { return message_ports_ ; } private : // \u4fdd\u5b58\u6d88\u606f\u7684\u5185\u5bb9 MallocedBuffer < char > main_message_buf_ ; std :: vector < std :: shared_ptr < v8 :: BackingStore >> array_buffers_ ; std :: vector < std :: shared_ptr < v8 :: BackingStore >> shared_array_buffers_ ; std :: vector < std :: unique_ptr < MessagePortData >> message_ports_ ; std :: vector < v8 :: CompiledWasmModule > wasm_modules_ ; };","title":"14.2 \u7ebf\u7a0b\u95f4\u901a\u4fe1\u6570\u636e\u7ed3\u6784"},{"location":"chapter14-%E7%BA%BF%E7%A8%8B/#1422-messageportdata","text":"MessagePortData\u662f\u7ba1\u7406\u6d88\u606f\u53d1\u9001\u548c\u63a5\u6536\u7684\u7c7b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class MessagePortData : public MemoryRetainer { public : explicit MessagePortData ( MessagePort * owner ); ~ MessagePortData () override ; // \u65b0\u589e\u4e00\u4e2a\u6d88\u606f void AddToIncomingQueue ( Message && message ); // \u5173\u8054/\u89e3\u5173\u8054\u901a\u4fe1\u4e24\u7aef\u7684\u7aef\u53e3 static void Entangle ( MessagePortData * a , MessagePortData * b ); void Disentangle (); private : // \u7528\u4e8e\u591a\u7ebf\u7a0b\u5f80\u5bf9\u7aef\u6d88\u606f\u961f\u5217\u63d2\u5165\u6d88\u606f\u65f6\u7684\u4e92\u65a5\u53d8\u91cf mutable Mutex mutex_ ; std :: list < Message > incoming_messages_ ; // \u6240\u5c5e\u7aef\u53e3 MessagePort * owner_ = nullptr ; // \u7528\u4e8e\u591a\u7ebf\u7a0b\u8bbf\u95ee\u5bf9\u7aefsibling_\u5c5e\u6027\u65f6\u7684\u4e92\u65a5\u53d8\u91cf std :: shared_ptr < Mutex > sibling_mutex_ = std :: make_shared < Mutex > (); // \u6307\u5411\u901a\u4fe1\u5bf9\u7aef\u7684\u6307\u9488 MessagePortData * sibling_ = nullptr ; }; \u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 MessagePortData :: MessagePortData ( MessagePort * owner ) : owner_ ( owner ) { } MessagePortData ::~ MessagePortData () { // \u6790\u6784\u65f6\u89e3\u9664\u548c\u5bf9\u7aef\u7684\u5173\u7cfb Disentangle (); } // \u63d2\u5165\u4e00\u4e2amessage void MessagePortData :: AddToIncomingQueue ( Message && message ) { // \u5148\u52a0\u9501\uff0c\u4fdd\u8bc1\u591a\u7ebf\u7a0b\u5b89\u5168\uff0c\u4e92\u65a5\u8bbf\u95ee Mutex :: ScopedLock lock ( mutex_ ); // \u63d2\u5165\u6d88\u606f\u961f\u5217 incoming_messages_ . emplace_back ( std :: move ( message )); // \u901a\u77e5owner if ( owner_ != nullptr ) { owner_ -> TriggerAsync (); } } // \u5173\u8054\u901a\u4fe1\u7684\u5bf9\u7aef\uff0c\u5e76\u4fdd\u6301\u5bf9\u7aef\u7684\u4e92\u65a5\u53d8\u91cf\uff0c\u8bbf\u95ee\u5bf9\u7aef\u65f6\u9700\u8981\u4f7f\u7528 void MessagePortData :: Entangle ( MessagePortData * a , MessagePortData * b ) { a -> sibling_ = b ; b -> sibling_ = a ; a -> sibling_mutex_ = b -> sibling_mutex_ ; } // \u89e3\u9664\u5173\u8054 void MessagePortData :: Disentangle () { // \u52a0\u9501\u64cd\u4f5c\u5bf9\u7aef\u7684sibling\u5b57\u6bb5 std :: shared_ptr < Mutex > sibling_mutex = sibling_mutex_ ; Mutex :: ScopedLock sibling_lock ( * sibling_mutex ); sibling_mutex_ = std :: make_shared < Mutex > (); // \u5bf9\u7aef MessagePortData * sibling = sibling_ ; // \u5bf9\u7aef\u975e\u7a7a\uff0c\u5219\u628a\u5bf9\u7aef\u7684sibling\u4e5f\u6307\u5411\u7a7a\uff0c\u81ea\u5df1\u4e5f\u6307\u5411\u7a7a if ( sibling_ != nullptr ) { sibling_ -> sibling_ = nullptr ; sibling_ = nullptr ; } // \u63d2\u5165\u4e00\u4e2a\u7a7a\u7684\u6d88\u606f\u901a\u77e5\u5bf9\u7aef\u548c\u672c\u7aef AddToIncomingQueue ( Message ()); if ( sibling != nullptr ) { sibling -> AddToIncomingQueue ( Message ()); } }","title":"14.2.2 MessagePortData"},{"location":"chapter14-%E7%BA%BF%E7%A8%8B/#1423-messageport","text":"MessagePort\u8868\u793a\u7684\u662f\u901a\u4fe1\u7684\u4e00\u7aef\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class MessagePort : public HandleWrap { public : MessagePort ( Environment * env , v8 :: Local < v8 :: Context > context , v8 :: Local < v8 :: Object > wrap ); ~ MessagePort () override ; static MessagePort * New ( Environment * env , v8 :: Local < v8 :: Context > context , std :: unique_ptr < MessagePortData > data = nullptr ); // \u53d1\u9001\u6d88\u606f v8 :: Maybe < bool > PostMessage ( Environment * env , v8 :: Local < v8 :: Value > message , const TransferList & transfer ); // \u5f00\u542f/\u5173\u95ed\u63a5\u6536\u6d88\u606f void Start (); void Stop (); static void New ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); // \u63d0\u4f9bJS\u5c42\u4f7f\u7528\u7684\u65b9\u6cd5 static void PostMessage ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static void Start ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static void Stop ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static void Drain ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static void ReceiveMessage ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); // \u5173\u8054\u5bf9\u7aef static void Entangle ( MessagePort * a , MessagePort * b ); static void Entangle ( MessagePort * a , MessagePortData * b ); // \u89e3\u9664MessagePortData\u548c\u7aef\u53e3\u7684\u5173\u7cfb std :: unique_ptr < MessagePortData > Detach (); // \u5173\u95ed\u7aef\u53e3 void Close ( v8 :: Local < v8 :: Value > close_callback = v8 :: Local < v8 :: Value > ()) override ; inline bool IsDetached () const ; private : void OnClose () override ; void OnMessage (); void TriggerAsync (); v8 :: MaybeLocal < v8 :: Value > ReceiveMessage ( v8 :: Local < v8 :: Context > context , bool only_if_receiving ); // MessagePortData\u7528\u4e8e\u7ba1\u7406\u6d88\u606f\u7684\u53d1\u9001\u548c\u63a5\u6536 std :: unique_ptr < MessagePortData > data_ = nullptr ; // \u662f\u5426\u5f00\u542f\u63a5\u6536\u6d88\u606f\u6807\u8bb0 bool receiving_messages_ = false ; // \u7528\u4e8e\u6536\u5230\u6d88\u606f\u65f6\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\uff0c\u4e8b\u4ef6\u5faa\u73af\u6267\u884c\u56de\u8c03\u5904\u7406\u6d88\u606f uv_async_t async_ ; }; \u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0\uff0c\u53ea\u5217\u51fa\u90e8\u5206\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 // \u7aef\u53e3\u662f\u5426\u4e0d\u63a5\u6536\u6d88\u606f\u4e86 bool MessagePort::IsDetached () const { return data_ == nullptr || IsHandleClosing (); } // \u6709\u6d88\u606f\u5230\u8fbe\uff0c\u901a\u77e5\u4e8b\u4ef6\u5faa\u73af\u6267\u884c\u56de\u8c03 void MessagePort::TriggerAsync () { if ( IsHandleClosing ()) return ; CHECK_EQ ( uv_async_send ( & async_ ), 0 ); } // \u5173\u95ed\u63a5\u6536\u6d88\u606f\u7684\u7aef\u53e3 void MessagePort::Close ( v8 :: Local < v8 :: Value > close_callback ) { if ( data_ ) { // \u6301\u6709\u9501\uff0c\u9632\u6b62\u518d\u63a5\u6536\u6d88\u606f Mutex :: ScopedLock sibling_lock ( data_ -> mutex_ ); HandleWrap :: Close ( close_callback ); } else { HandleWrap :: Close ( close_callback ); } } // \u65b0\u5efa\u4e00\u4e2a\u7aef\u53e3\uff0c\u5e76\u4e14\u53ef\u4ee5\u6302\u8f7d\u4e00\u4e2aMessagePortData MessagePort * MessagePort::New ( Environment * env , Local < Context > context , std :: unique_ptr < MessagePortData > data ) { Context :: Scope context_scope ( context ); Local < FunctionTemplate > ctor_templ = GetMessagePortConstructorTemplate ( env ); Local < Object > instance ; // JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61 if ( ! ctor_templ -> InstanceTemplate () -> NewInstance ( context ). ToLocal ( & instance )) return nullptr ; // \u65b0\u5efa\u4e00\u4e2a\u6d88\u606f\u7aef\u53e3 MessagePort * port = new MessagePort ( env , context , instance ); // \u9700\u8981\u6302\u8f7dMessagePortData if ( data ) { port -> Detach (); port -> data_ = std :: move ( data ); Mutex :: ScopedLock lock ( port -> data_ -> mutex_ ); // \u4fee\u6539data\u7684owner\u4e3a\u5f53\u524d\u6d88\u606f\u7aef\u53e3 port -> data_ -> owner_ = port ; // data\u4e2d\u53ef\u80fd\u6709\u6d88\u606f port -> TriggerAsync (); } return port ; } // \u5f00\u59cb\u63a5\u6536\u6d88\u606f void MessagePort::Start () { Debug ( this , \"Start receiving messages\" ); receiving_messages_ = true ; Mutex :: ScopedLock lock ( data_ -> mutex_ ); // \u6709\u7f13\u5b58\u7684\u6d88\u606f\uff0c\u901a\u77e5\u4e0a\u5c42 if ( ! data_ -> incoming_messages_ . empty ()) TriggerAsync (); } // \u505c\u6b62\u63a5\u6536\u6d88\u606f void MessagePort::Stop () { Debug ( this , \"Stop receiving messages\" ); receiving_messages_ = false ; } // JS\u5c42\u8c03\u7528 void MessagePort::Start ( const FunctionCallbackInfo < Value >& args ) { MessagePort * port ; ASSIGN_OR_RETURN_UNWRAP ( & port , args . This ()); if ( ! port -> data_ ) { return ; } port -> Start (); } void MessagePort::Stop ( const FunctionCallbackInfo < Value >& args ) { MessagePort * port ; CHECK ( args [ 0 ] -> IsObject ()); ASSIGN_OR_RETURN_UNWRAP ( & port , args [ 0 ]. As < Object > ()); if ( ! port -> data_ ) { return ; } port -> Stop (); } // \u8bfb\u53d6\u6d88\u606f void MessagePort::Drain ( const FunctionCallbackInfo < Value >& args ) { MessagePort * port ; ASSIGN_OR_RETURN_UNWRAP ( & port , args [ 0 ]. As < Object > ()); port -> OnMessage (); } // \u83b7\u53d6\u67d0\u4e2a\u7aef\u53e3\u7684\u6d88\u606f void MessagePort::ReceiveMessage ( const FunctionCallbackInfo < Value >& args ) { CHECK ( args [ 0 ] -> IsObject ()); // \u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u7aef\u53e3 MessagePort * port = Unwrap < MessagePort > ( args [ 0 ]. As < Object > ()); // \u8c03\u7528\u5bf9\u8c61\u7684ReceiverMessage\u65b9\u6cd5 MaybeLocal < Value > payload = port -> ReceiveMessage ( port -> object () -> CreationContext (), false ); if ( ! payload . IsEmpty ()) args . GetReturnValue (). Set ( payload . ToLocalChecked ()); } // \u5173\u8054\u4e24\u4e2a\u7aef\u53e3 void MessagePort::Entangle ( MessagePort * a , MessagePort * b ) { Entangle ( a , b -> data_ . get ()); } void MessagePort::Entangle ( MessagePort * a , MessagePortData * b ) { MessagePortData :: Entangle ( a -> data_ . get (), b ); }","title":"14.2.3 MessagePort"},{"location":"chapter14-%E7%BA%BF%E7%A8%8B/#1424-messagechannel","text":"MessageChannel\u8868\u793a\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u4e24\u4e2a\u7aef\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static void MessageChannel ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); Local < Context > context = args . This () -> CreationContext (); Context :: Scope context_scope ( context ); MessagePort * port1 = MessagePort :: New ( env , context ); MessagePort * port2 = MessagePort :: New ( env , context ); MessagePort :: Entangle ( port1 , port2 ); // port1->object()\u62ff\u5230JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\uff0c\u5b83\u5173\u8054\u4e86MessagePort\u5bf9\u8c61 args . This () -> Set ( context , env -> port1_string (), port1 -> object ()) . Check (); args . This () -> Set ( context , env -> port2_string (), port2 -> object ()) . Check (); } MessageChannel\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u65b0\u5efa\u4e24\u4e2a\u6d88\u606f\u7aef\u53e3\uff0c\u5e76\u4e14\u5173\u8054\u8d77\u6765\uff0c\u540e\u7eed\u5c31\u53ef\u4ee5\u57fa\u4e8e\u8fd9\u4e24\u4e2a\u7aef\u53e3\u8fdb\u884c\u901a\u4fe1\u4e86\u3002 Message\u3001MessagePortData\u3001MessagePort\u548cMessageChannel\u7684\u5173\u7cfb\u56fe\u5982\u56fe14-2\u6240\u793a\u3002 \u56fe14-2 \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u7ebf\u7a0b\u95f4\u901a\u4fe1\u6a21\u5757\u5bfc\u51fa\u7684\u4e00\u4e9b\u529f\u80fd\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 static void InitMessaging ( Local < Object > target , Local < Value > unused , Local < Context > context , void * priv ) { Environment * env = Environment :: GetCurrent ( context ); { // \u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u901a\u9053 Local < String > message_channel_string = FIXED_ONE_BYTE_STRING ( env -> isolate (), \"MessageChannel\" ); Local < FunctionTemplate > templ = env -> NewFunctionTemplate ( MessageChannel ); templ -> SetClassName ( message_channel_string ); target -> Set ( context , message_channel_string , templ -> GetFunction ( context ). ToLocalChecked ()). Check (); } // \u65b0\u5efa\u6d88\u606f\u7aef\u53e3\u7684\u6784\u9020\u51fd\u6570 target -> Set ( context , env -> message_port_constructor_string (), GetMessagePortConstructorTemplate ( env ) -> GetFunction ( context ). ToLocalChecked ()). Check (); env -> SetMethod ( target , \"stopMessagePort\" , MessagePort :: Stop ); env -> SetMethod ( target , \"drainMessagePort\" , MessagePort :: Drain ); env -> SetMethod ( target , \"receiveMessageOnPort\" , MessagePort :: ReceiveMessage ); env -> SetMethod ( target , \"moveMessagePortToContext\" , MessagePort :: MoveToContext ); }","title":"14.2.4 MessageChannel"},{"location":"chapter14-%E7%BA%BF%E7%A8%8B/#143","text":"\u672c\u8282\u6211\u4eec\u4eceworker_threads\u6a21\u5757\u5f00\u59cb\u5206\u6790\u591a\u7ebf\u7a0b\u7684\u5b9e\u73b0\u3002\u8fd9\u662f\u4e00\u4e2aC++\u6a21\u5757\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b83\u5bfc\u51fa\u7684\u529f\u80fd\u3002require(\"work_threads\")\u7684\u65f6\u5019\u5c31\u662f\u5f15\u7528\u4e86InitWorker\u51fd\u6570\u5bfc\u51fa\u7684\u529f\u80fd\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 void InitWorker ( Local < Object > target , Local < Value > unused , Local < Context > context , void * priv ) { Environment * env = Environment :: GetCurrent ( context ); { Local < FunctionTemplate > w = env -> NewFunctionTemplate ( Worker :: New ); w -> InstanceTemplate () -> SetInternalFieldCount ( 1 ); w -> Inherit ( AsyncWrap :: GetConstructorTemplate ( env )); // \u8bbe\u7f6e\u4e00\u7cfb\u5217\u539f\u578b\u65b9\u6cd5\uff0c\u5c31\u4e0d\u4e00\u4e00\u5217\u4e3e env -> SetProtoMethod ( w , \"setEnvVars\" , Worker :: SetEnvVars ); // \u4e00\u7cfb\u5217\u539f\u578b\u65b9\u6cd5 /* \u5bfc\u51fa\u51fd\u6570\u6a21\u5757\u5bf9\u5e94\u7684\u51fd\u6570\uff0c\u5373\u6211\u4eec\u4ee3\u7801\u4e2d const { Worker } = require(\"worker_threads\");\u4e2d\u7684Worker */ Local < String > workerString = FIXED_ONE_BYTE_STRING ( env -> isolate (), \"Worker\" ); w -> SetClassName ( workerString ); target -> Set ( env -> context (), workerString , w -> GetFunction ( env -> context ()). ToLocalChecked ()). Check (); /* \u5bfc\u51fagetEnvMessagePort\u65b9\u6cd5\uff0c\u83b7\u53d6\u7ebf\u7a0b\u63a5\u6536\u6d88\u606f\u7684\u7aef\u53e3 const {getEnvMessagePort} = require(\"worker_threads\"); */ env -> SetMethod ( target , \"getEnvMessagePort\" , GetEnvMessagePort ); /* \u7ebf\u7a0bid\uff0c\u8fd9\u4e2a\u4e0d\u662f\u64cd\u4f5c\u7cfb\u7edf\u5206\u914d\u7684\u90a3\u4e2a\uff0c\u800c\u662fNode.js\u5206\u914d\u7684, \u5728\u521b\u5efa\u7ebf\u7a0b\u7684\u65f6\u5019\u8bbe\u7f6e const { threadId } = require(\"worker_threads\"); */ target -> Set ( env -> context (), env -> thread_id_string (), Number :: New ( env -> isolate (), static_cast < double > ( env -> thread_id ()))) . Check (); /* \u662f\u5426\u662f\u4e3b\u7ebf\u7a0b\uff0c const { isMainThread } = require(\"worker_threads\"); \u8fd9\u8fb9\u53d8\u91cf\u5728Node.js\u542f\u52a8\u7684\u65f6\u5019\u8bbe\u7f6e\u4e3atrue\uff0c\u65b0\u5f00\u5b50\u7ebf\u7a0b\u7684\u65f6\u5019\uff0c\u6ca1\u6709\u8bbe \u7f6e\uff0c\u6240\u4ee5\u662ffalse */ target -> Set ( env -> context (), FIXED_ONE_BYTE_STRING ( env -> isolate (), \"isMainThread\" ), Boolean :: New ( env -> isolate (), env -> is_main_thread ())) . Check (); /* \u5982\u679c\u4e0d\u662f\u4e3b\u7ebf\u7a0b\uff0c\u5bfc\u51fa\u8d44\u6e90\u9650\u5236\u7684\u914d\u7f6e\uff0c \u5373\u5728\u5b50\u7ebf\u7a0b\u4e2d\u8c03\u7528 const { resourceLimits } = require(\"worker_threads\"); */ if ( ! env -> is_main_thread ()) { target -> Set ( env -> context (), FIXED_ONE_BYTE_STRING ( env -> isolate (), \"resourceLimits\" ), env -> worker_context () -> GetResourceLimits ( env -> isolate ())). Check (); } // \u5bfc\u51fa\u51e0\u4e2a\u5e38\u91cf NODE_DEFINE_CONSTANT ( target , kMaxYoungGenerationSizeMb ); NODE_DEFINE_CONSTANT ( target , kMaxOldGenerationSizeMb ); NODE_DEFINE_CONSTANT ( target , kCodeRangeSizeMb ); NODE_DEFINE_CONSTANT ( target , kTotalResourceLimitCount ); } \u4e86\u89e3work_threads\u6a21\u5757\u5bfc\u51fa\u7684\u529f\u80fd\u540e\uff0c\u6211\u4eec\u770b\u5728JS\u5c42\u6267\u884cnew Worker\u7684\u65f6\u5019\u7684\u903b\u8f91\u3002\u6839\u636e\u4e0a\u9762\u4ee3\u7801\u5bfc\u51fa\u7684\u903b\u8f91\uff0c\u6211\u4eec\u77e5\u9053\u8fd9\u65f6\u5019\u9996\u5148\u4f1a\u65b0\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\u3002\u7136\u540e\u6267\u884cNew\u56de\u8c03\uff0c\u5e76\u4f20\u5165\u65b0\u5efa\u7684C++\u5bf9\u8c61\u3002\u6211\u4eec\u770bNew\u51fd\u6570\u7684\u903b\u8f91\u3002\u6211\u4eec\u7701\u7565\u4e00\u7cfb\u5217\u7684\u53c2\u6570\u5904\u7406\uff0c\u4e3b\u8981\u4ee3\u7801\u5982\u4e0b\u3002 1 2 3 4 // args.This()\u5c31\u662f\u6211\u4eec\u521a\u624d\u4f20\u8fdb\u6765\u7684this Worker * worker = new Worker ( env , args . This (), url , per_isolate_opts , std :: move ( exec_argv_out )); \u6211\u4eec\u518d\u770bWorker\u7c7b\u7684\u58f0\u660e\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Worker : public AsyncWrap { public : // \u51fd\u6570\u58f0\u660e private : std :: shared_ptr < PerIsolateOptions > per_isolate_opts_ ; std :: vector < std :: string > exec_argv_ ; std :: vector < std :: string > argv_ ; MultiIsolatePlatform * platform_ ; v8 :: Isolate * isolate_ = nullptr ; bool start_profiler_idle_notifier_ ; // \u771f\u6b63\u7684\u7ebf\u7a0bid\uff0c\u5e95\u5c42\u8fd4\u56de\u7684 uv_thread_t tid_ ; // This mutex protects access to all variables listed below it. mutable Mutex mutex_ ; bool thread_joined_ = true ; const char * custom_error_ = nullptr ; int exit_code_ = 0 ; // \u7ebf\u7a0bid\uff0cNode.js\u5206\u914d\uff0c\u4e0d\u662f\u5e95\u5c42\u8fd4\u56de\u7684 uint64_t thread_id_ = -1 ; uintptr_t stack_base_ = 0 ; // \u7ebf\u7a0b\u8d44\u6e90\u9650\u5236\u914d\u7f6e double resource_limits_ [ kTotalResourceLimitCount ]; void UpdateResourceConstraints ( v8 :: ResourceConstraints * constraints ); // \u6808\u4fe1\u606f static constexpr size_t kStackSize = 4 * 1024 * 1024 ; static constexpr size_t kStackBufferSize = 192 * 1024 ; std :: unique_ptr < MessagePortData > child_port_data_ ; std :: shared_ptr < KVStore > env_vars_ ; // \u7528\u4e8e\u7ebf\u7a0b\u95f4\u901a\u4fe1 MessagePort * child_port_ = nullptr ; MessagePort * parent_port_ = nullptr ; // \u7ebf\u7a0b\u72b6\u6001 bool stopped_ = true ; // \u662f\u5426\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa bool has_ref_ = true ; // \u5b50\u7ebf\u7a0b\u6267\u884c\u65f6\u7684\u73af\u5883\u53d8\u91cf\uff0c\u57fa\u7c7b\u4e5f\u5b9a\u4e49\u4e86 Environment * env_ = nullptr ; }; \u8fd9\u91cc\u53ea\u8bb2\u4e00\u4e0benv_\u7684\u5b9a\u4e49\uff0c\u56e0\u4e3a\u8fd9\u662f\u4e00\u4e2a\u975e\u5e38\u91cd\u8981\u7684\u5730\u65b9\u3002\u6211\u4eec\u770b\u5230Worker\u7c7b\u7ee7\u627fAsyncWrap\uff0cAsyncWrap\u7ee7\u627f\u4e86BaseObject\u3002BaseObject\u4e2d\u4e5f\u5b9a\u4e49\u4e86env_\u5c5e\u6027\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5728C++\u4e2d\u5982\u679c\u5b50\u7c7b\u7236\u7c7b\u90fd\u5b9a\u4e49\u4e86\u4e00\u4e2a\u5c5e\u6027\u65f6\u662f\u600e\u6837\u7684\u3002\u6211\u4eec\u6765\u770b\u4e00\u4e2a\u4f8b\u5b50 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <iostream> using namespace std ; class A { public : int value ; A () { value = 1 ; } void console () { cout << value << endl ; } }; class B : public A { public : int value ; B () : A () { value = 2 ; } }; int main () { B b ; // b.value = 3;\u53ea\u4f1a\u4fee\u6539\u5b50\u7c7b\u7684\uff0c\u4e0d\u4f1a\u4fee\u6539\u7236\u7c7b\u7684 b . console (); cout << b . value << endl << \"\u5185\u5b58\u5927\u5c0f\uff1a\" << sizeof ( b ) << endl ; return 0 ; } \u4ee5\u4e0a\u4ee3\u7801\u6267\u884c\u65f6\u8f93\u51fa 1 2 \u5185\u5b58\u5927\u5c0f\uff1a8 \u7531\u8f93\u51fa\u7ed3\u679c\u6211\u4eec\u53ef\u4ee5\u77e5\u9053\uff0cb\u5185\u5b58\u5927\u5c0f\u662f8\u4e2a\u5b57\u8282\u3002\u5373\u4e24\u4e2aint\u3002\u6240\u4ee5b\u7684\u5185\u5b58\u5e03\u5c40\u4e2d\u4e24\u4e2aa\u5c5e\u6027\u90fd\u5206\u914d\u4e86\u5185\u5b58\u3002\u5f53\u6211\u4eec\u901a\u8fc7b.console\u8f93\u51favalue\u65f6\uff0c\u56e0\u4e3aconsole\u662f\u5728A\u4e0a\u5b9a\u4e49\u7684\uff0c\u6240\u4ee5\u8f93\u51fa1\uff0c\u4f46\u662f\u6211\u4eec\u901a\u8fc7b.value\u8bbf\u95ee\u65f6\uff0c\u8f93\u51fa\u7684\u662f2\u3002\u56e0\u4e3a\u8bbf\u95ee\u7684\u662fB\u4e2d\u5b9a\u4e49\u7684value\uff0c\u540c\u7406\u5982\u679c\u6211\u4eec\u5728B\u4e2d\u5b9a\u4e49console\uff0c\u8f93\u51fa\u4e5f\u4f1a\u662f2\u3002Worker\u4e2d\u5b9a\u4e49\u7684env_\u6211\u4eec\u540e\u7eed\u4f1a\u770b\u5230\u5b83\u7684\u4f5c\u7528\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bWorker\u7c7b\u7684\u521d\u59cb\u5316\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 Worker :: Worker ( Environment * env , Local < Object > wrap ,...) : AsyncWrap ( env , wrap , AsyncWrap :: PROVIDER_WORKER ), ... // \u5206\u914d\u7ebf\u7a0bid thread_id_ ( Environment :: AllocateThreadId ()), // \u7ee7\u627f\u4e3b\u7ebf\u7a0b\u7684\u73af\u5883\u53d8\u91cf env_vars_ ( env -> env_vars ()) { // \u65b0\u5efa\u4e00\u4e2a\u7aef\u53e3\u548c\u5b50\u7ebf\u7a0b\u901a\u4fe1 parent_port_ = MessagePort :: New ( env , env -> context ()); /* \u5173\u8054\u8d77\u6765\uff0c\u7528\u4e8e\u901a\u4fe1 const parent_port_ = {data: {sibling: null}}; const child_port_data_ = {sibling: null}; parent_port_.data.sibling = child_port_data_; child_port_data_.sibling = parent_port_.data; */ child_port_data_ = std :: make_unique < MessagePortData > ( nullptr ); MessagePort :: Entangle ( parent_port_ , child_port_data_ . get ()); // \u8bbe\u7f6eJS\u5c42Worker\u5bf9\u8c61\u7684messagePort\u5c5e\u6027\u4e3aparent_port_ object () -> Set ( env -> context (), env -> message_port_string (), parent_port_ -> object ()). Check (); // \u8bbe\u7f6eWorker\u5bf9\u8c61\u7684\u7ebf\u7a0bid\uff0c\u5373threadId\u5c5e\u6027 object () -> Set ( env -> context (), env -> thread_id_string (), Number :: New ( env -> isolate (), static_cast < double > ( thread_id_ ))) . Check (); } \u65b0\u5efa\u4e00\u4e2aWorker\uff0c\u7ed3\u6784\u5982\u56fe14-3\u6240\u793a\u3002 \u56fe14-3 \u4e86\u89e3\u4e86new Worker\u7684\u903b\u8f91\u540e\uff0c\u6211\u4eec\u770b\u5728JS\u5c42\u662f\u5982\u4f55\u4f7f\u7528\u7684\u3002\u6211\u4eec\u770bJS\u5c42Worker\u7c7b\u7684\u6784\u9020\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 constructor ( filename , options = {}) { super (); // \u5ffd\u7565\u4e00\u7cfb\u5217\u53c2\u6570\u5904\u7406\uff0cnew Worker\u5c31\u662f\u4e0a\u9762\u63d0\u5230\u7684C++\u5c42\u7684 this [ kHandle ] = new Worker ( url , options . execArgv , parseResourceLimits ( options . resourceLimits )); // messagePort\u6307\u5411_parent_port this [ kPort ] = this [ kHandle ]. messagePort ; this [ kPort ]. on ( 'message' , ( data ) => this [ kOnMessage ]( data )); // \u5f00\u59cb\u63a5\u6536\u6d88\u606f this [ kPort ]. start (); // \u7533\u8bf7\u4e00\u4e2a\u901a\u4fe1\u901a\u9053\uff0c\u4e24\u4e2a\u7aef\u53e3 const { port1 , port2 } = new MessageChannel (); this [ kPublicPort ] = port1 ; this [ kPublicPort ]. on ( 'message' , ( message ) => this . emit ( 'message' , message )); // \u5411\u53e6\u4e00\u7aef\u53d1\u9001\u6d88\u606f this [ kPort ]. postMessage ({ argv , type : messageTypes . LOAD_SCRIPT , filename , doEval : !! options . eval , cwdCounter : cwdCounter || workerIo . sharedCwdCounter , workerData : options . workerData , publicPort : port2 , manifestSrc : getOptionValue ( '--experimental-policy' ) ? require ( 'internal/process/policy' ). src : null , hasStdin : !! options . stdin }, [ port2 ]); // \u5f00\u542f\u7ebf\u7a0b this [ kHandle ]. startThread (); } \u4e0a\u9762\u7684\u4ee3\u7801\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 \u4fdd\u5b58messagePort\uff0c\u76d1\u542c\u8be5\u7aef\u53e3\u7684message\u4e8b\u4ef6\uff0c\u7136\u540e\u7ed9messagePort\u7684\u5bf9\u7aef\u53d1\u9001\u6d88\u606f\uff0c\u4f46\u662f\u8fd9\u65f6\u5019\u8fd8\u6ca1\u6709\u63a5\u6536\u7aef\u53e3\uff0c\u6240\u4ee5\u6d88\u606f\u4f1a\u7f13\u5b58\u5230MessagePortData\uff0c\u5373child_port_data_ \u4e2d\u3002\u53e6\u5916\u6211\u4eec\u770b\u5230\u4e3b\u7ebf\u7a0b\u628a\u901a\u4fe1\u7aef\u53e3port2\u53d1\u9001\u7ed9\u4e86\u5b50\u7ebf\u7a0b\u3002 2 \u7533\u8bf7\u4e00\u4e2a\u901a\u4fe1\u901a\u9053port1\u548cport2\uff0c\u7528\u4e8e\u4e3b\u7ebf\u7a0b\u548c\u5b50\u7ebf\u7a0b\u901a\u4fe1\u3002_parent_port\u548cchild_port\u662f\u7ed9Node.js\u4f7f\u7528\u7684\uff0c\u65b0\u7533\u8bf7\u7684\u7aef\u53e3\u662f\u7ed9\u7528\u6237\u4f7f\u7528\u7684\u3002 3 \u521b\u5efa\u5b50\u7ebf\u7a0b\u3002 \u6211\u4eec\u770b\u521b\u5efa\u7ebf\u7a0b\u7684\u65f6\u5019\uff0c\u505a\u4e86\u4ec0\u4e48\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 void Worker::StartThread ( const FunctionCallbackInfo < Value >& args ) { Worker * w ; ASSIGN_OR_RETURN_UNWRAP ( & w , args . This ()); Mutex :: ScopedLock lock ( w -> mutex_ ); // The object now owns the created thread and should not be garbage collected // until that finishes. w -> ClearWeak (); // \u52a0\u5165\u4e3b\u7ebf\u7a0b\u7ef4\u62a4\u7684\u5b50\u7ebf\u7a0b\u6570\u636e\u7ed3\u6784 w -> env () -> add_sub_worker_context ( w ); w -> stopped_ = false ; w -> thread_joined_ = false ; // \u662f\u5426\u9700\u8981\u963b\u585e\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\uff0c\u9ed8\u8ba4true if ( w -> has_ref_ ) w -> env () -> add_refs ( 1 ); // \u662f\u5426\u9700\u8981\u6808\u548c\u6808\u5927\u5c0f uv_thread_options_t thread_options ; thread_options . flags = UV_THREAD_HAS_STACK_SIZE ; thread_options . stack_size = kStackSize ; // \u521b\u5efa\u7ebf\u7a0b CHECK_EQ ( uv_thread_create_ex ( & w -> tid_ , & thread_options , []( void * arg ) { Worker * w = static_cast < Worker *> ( arg ); const uintptr_t stack_top = reinterpret_cast < uintptr_t > ( & arg ); w -> stack_base_ = stack_top - ( kStackSize - kStackBufferSize ); // \u6267\u884c\u4e3b\u903b\u8f91 w -> Run (); Mutex :: ScopedLock lock ( w -> mutex_ ); // \u7ed9\u4e3b\u7ebf\u7a0b\u63d0\u4ea4\u4e00\u4e2a\u4efb\u52a1\uff0c\u901a\u77e5\u4e3b\u7ebf\u7a0b\u5b50\u7ebf\u7a0b\u6267\u884c\u5b8c\u6bd5\uff0c\u56e0\u4e3a\u4e3b\u7ebf\u7a0b\u4e0d\u80fd\u76f4\u63a5\u6267\u884cjoin\u963b\u585e\u81ea\u5df1 w -> env () -> SetImmediateThreadsafe ( [ w = std :: unique_ptr < Worker > ( w )]( Environment * env ) { if ( w -> has_ref_ ) env -> add_refs ( -1 ); w -> JoinThread (); // implicitly delete w }); }, static_cast < void *> ( w )), 0 ); } StartThread\u65b0\u5efa\u4e86\u4e00\u4e2a\u5b50\u7ebf\u7a0b\uff0c\u7136\u540e\u5728\u5b50\u7ebf\u7a0b\u4e2d\u6267\u884cRun\uff0c\u6211\u4eec\u7ee7\u7eed\u770bRun 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 void Worker::Run () { // \u7ebf\u7a0b\u6267\u884c\u6240\u9700\u8981\u7684\u6570\u636e\u7ed3\u6784\uff0c\u6bd4\u5982loop\uff0cisolate\uff0c\u548c\u4e3b\u7ebf\u7a0b\u72ec\u7acb WorkerThreadData data ( this ); { Locker locker ( isolate_ ); Isolate :: Scope isolate_scope ( isolate_ ); SealHandleScope outer_seal ( isolate_ ); // std::unique_ptr<Environment, FreeEnvironment> env_; DeleteFnPtr < Environment , FreeEnvironment > env_ ; // \u7ebf\u7a0b\u6267\u884c\u5b8c\u540e\u6267\u884c\u7684\u6e05\u9664\u51fd\u6570 auto cleanup_env = OnScopeLeave ([ & ]() { // ... }); { HandleScope handle_scope ( isolate_ ); Local < Context > context ; // \u65b0\u5efa\u4e00\u4e2acontext\uff0c\u548c\u4e3b\u7ebf\u7a0b\u72ec\u7acb context = NewContext ( isolate_ ); Context :: Scope context_scope ( context ); { // \u65b0\u5efa\u4e00\u4e2aenv\u5e76\u521d\u59cb\u5316\uff0cenv\u4e2d\u4f1a\u548c\u65b0\u7684context\u5173\u8054 env_ . reset ( new Environment ( data . isolate_data_ . get (), context , std :: move ( argv_ ), std :: move ( exec_argv_ ), Environment :: kNoFlags , thread_id_ )); env_ -> set_env_vars ( std :: move ( env_vars_ )); env_ -> set_abort_on_uncaught_exception ( false ); env_ -> set_worker_context ( this ); env_ -> InitializeLibuv ( start_profiler_idle_notifier_ ); } { Mutex :: ScopedLock lock ( mutex_ ); // \u66f4\u65b0\u5b50\u7ebf\u7a0b\u6240\u5c5e\u7684env this -> env_ = env_ . get (); } { if ( ! env_ -> RunBootstrapping (). IsEmpty ()) { CreateEnvMessagePort ( env_ . get ()); USE ( StartExecution ( env_ . get (), \"internal/main/worker_thread\" )); } } { SealHandleScope seal ( isolate_ ); bool more ; // \u5f00\u59cb\u4e8b\u4ef6\u5faa\u73af do { if ( is_stopped ()) break ; uv_run ( & data . loop_ , UV_RUN_DEFAULT ); if ( is_stopped ()) break ; platform_ -> DrainTasks ( isolate_ ); more = uv_loop_alive ( & data . loop_ ); if ( more && ! is_stopped ()) continue ; EmitBeforeExit ( env_ . get ()); more = uv_loop_alive ( & data . loop_ ); } while ( more == true && ! is_stopped ()); } } } \u6211\u4eec\u5206\u6b65\u9aa4\u5206\u6790\u4e0a\u9762\u7684\u4ee3\u7801 1 \u65b0\u5efaIsolate\u3001context\u548cEnvironment\uff0c\u5b50\u7ebf\u7a0b\u5728\u72ec\u7acb\u7684\u73af\u5883\u6267\u884c\u3002\u7136\u540e\u521d\u59cb\u5316Environment\u3002\u8fd9\u4e2a\u5728Node.js\u542f\u52a8\u8fc7\u7a0b\u7ae0\u8282\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4e0d\u518d\u5206\u6790\u3002 2 \u66f4\u65b0\u5b50\u7ebf\u7a0b\u7684env_\u3002\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0cWorker\u7c7b\u4e2d\u5b9a\u4e49\u4e86env_\u5c5e\u6027\uff0c\u6240\u4ee5\u8fd9\u91cc\u901a\u8fc7this.env_\u66f4\u65b0\u65f6\uff0c\u662f\u4e0d\u4f1a\u5f71\u54cd\u57fa\u7c7b\uff08BaseObject\uff09\u4e2d\u7684\u503c\u7684\u3002\u56e0\u4e3a\u5b50\u7ebf\u7a0b\u662f\u5728\u65b0\u7684\u73af\u5883\u6267\u884c\u7684\uff0c\u6240\u4ee5\u5728\u65b0\u73af\u5883\u4e2d\u4f7f\u7528\u8be5Worker\u5b9e\u4f8b\u65f6\uff0c\u9700\u8981\u4f7f\u7528\u65b0\u7684\u73af\u5883\u53d8\u91cf\u3002\u800c\u5728\u4e3b\u7ebf\u7a0b\u4f7f\u7528\u8be5Worker\u5b9e\u4f8b\u65f6\uff0c\u662f\u901a\u8fc7BaseObject\u7684env()\u8bbf\u95ee\u7684\u3002\u4ece\u800c\u83b7\u53d6\u7684\u662f\u4e3b\u7ebf\u7a0b\u7684\u73af\u5883\u3002\u56e0\u4e3aWorker\u5b9e\u4f8b\u662f\u5728\u4e3b\u7ebf\u7a0b\u548c\u5b50\u7ebf\u7a0b\u4e4b\u95f4\u5171\u4eab\u7684\uff0cNode.js\u5728Worker\u7c7b\u4e2d\u91cd\u65b0\u5b9a\u4e49\u4e86\u4e00\u4e2aenv_\u5c5e\u6027\u6b63\u662f\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\u3002 3 CreateEnvMessagePort 1 2 3 4 5 6 7 void Worker::CreateEnvMessagePort ( Environment * env ) { child_port_ = MessagePort :: New ( env , env -> context (), std :: move ( child_port_data_ )); if ( child_port_ != nullptr ) env -> set_message_port ( child_port_ -> object ( isolate_ )); } child_port_data_\u8fd9\u4e2a\u53d8\u91cf\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u770b\u5230\u8fc7\uff0c\u5728\u8fd9\u91cc\u9996\u5148\u7533\u8bf7\u4e00\u4e2a\u65b0\u7684\u7aef\u53e3\u3002\u5e76\u4e14\u548cchild_port_data_\u4e92\u76f8\u5173\u8054\u8d77\u6765\u3002\u7136\u540e\u5728env\u7f13\u5b58\u8d77\u6765\u3002\u540e\u7eed\u4f1a\u4f7f\u7528\u3002\u8fd9\u65f6\u5019\u7684\u5173\u7cfb\u56fe\u5982\u56fe14-4\u6240\u793a\u3002 \u56fe14-4 4 \u6267\u884cinternal/main/worker_thread.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // \u8bbe\u7f6eprocess\u5bf9\u8c61 patchProcessObject (); // \u83b7\u53d6\u521a\u624d\u7f13\u5b58\u7684\u7aef\u53e3child_port_ onst port = getEnvMessagePort (); port . on ( 'message' , ( message ) => { // \u52a0\u8f7d\u811a\u672c if ( message . type === LOAD_SCRIPT ) { const { argv , cwdCounter , filename , doEval , workerData , publicPort , manifestSrc , manifestURL , hasStdin } = message ; const CJSLoader = require ( 'internal/modules/cjs/loader' ); loadPreloadModules (); /* \u7531\u4e3b\u7ebf\u7a0b\u7533\u8bf7\u7684MessageChannel\u4e2d\u67d0\u4e00\u7aef\u7684\u7aef\u53e3\uff0c \u4e3b\u7ebf\u7a0b\u4f20\u9012\u8fc7\u6765\u7684\uff0c\u4fdd\u5b58\u7528\u4e8e\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1 */ publicWorker . parentPort = publicPort ; // \u6267\u884c\u65f6\u4f7f\u7528\u7684\u6570\u636e publicWorker . workerData = workerData ; // \u901a\u77e5\u4e3b\u7ebf\u7a0b\uff0c\u6b63\u5728\u6267\u884c\u811a\u672c port . postMessage ({ type : UP_AND_RUNNING }); // \u6267\u884cnew Worker(filename)\u65f6\u4f20\u5165\u7684\u6587\u4ef6 CJSLoader . Module . runMain ( filename ); }) // \u5f00\u59cb\u63a5\u6536\u6d88\u606f port . start () \u6211\u4eec\u770b\u5230worker_thread.js\u4e2d\u901a\u8fc7runMain\u5b8c\u6210\u4e86\u5b50\u7ebf\u7a0b\u7684\u4ee3\u7801\u6267\u884c\uff0c\u7136\u540e\u5f00\u59cb\u4e8b\u4ef6\u5faa\u73af\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u5f53\u4e8b\u4ef6\u5faa\u73af\u7ed3\u675f\u65f6\uff0cNode.js\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 // \u7ed9\u4e3b\u7ebf\u7a0b\u63d0\u4ea4\u4e00\u4e2a\u4efb\u52a1\uff0c\u901a\u77e5\u4e3b\u7ebf\u7a0b\u5b50\u7ebf\u7a0b\u6267\u884c\u5b8c\u6bd5\uff0c\u56e0\u4e3a\u4e3b\u7ebf\u7a0b\u4e0d\u80fd\u76f4\u63a5\u6267\u884cjoin\u963b\u585e\u81ea\u5df1 w -> env () -> SetImmediateThreadsafe ( [ w = std :: unique_ptr < Worker > ( w )]( Environment * env ) { if ( w -> has_ref_ ) env -> add_refs ( -1 ); w -> JoinThread (); // implicitly delete w }); }, static_cast < void *> ( w )), 0 ); \u901a\u8fc7w->env()\u83b7\u53d6\u7684\u662f\u4e3b\u7ebf\u7a0b\u7684\u6267\u884c\u73af\u5883\u3002\u6211\u4eec\u770b\u4e00\u4e0bSetImmediateThreadsafe\u3002 1 2 3 4 5 6 7 8 9 10 template < typename Fn > void Environment :: SetImmediateThreadsafe ( Fn && cb ) { auto callback = std :: make_unique < NativeImmediateCallbackImpl < Fn >> ( std :: move ( cb ), false ); { Mutex :: ScopedLock lock ( native_immediates_threadsafe_mutex_ ); native_immediates_threadsafe_ . Push ( std :: move ( callback )); } uv_async_send ( & task_queues_async_ ); } SetImmediateThreadsafe\u7528\u4e8e\u901a\u77e5\u6267\u884c\u73af\u5883\u6240\u5728\u7684\u4e8b\u4ef6\u5faa\u73af\u6709\u5f02\u6b65\u4efb\u52a1\u5b8c\u6210\u3002\u5e76\u4e14\u662f\u7ebf\u7a0b\u5b89\u5168\u7684\u3002\u56e0\u4e3a\u53ef\u80fd\u6709\u591a\u4e2a\u7ebf\u7a0b\u4f1a\u64cd\u4f5cnative_immediates_threadsafe_\u3002\u5728\u4e3b\u7ebf\u7a0b\u4e8b\u4ef6\u5faa\u73af\u7684Poll IO\u9636\u6bb5\u5c31\u4f1a\u6267\u884ctask_queues_async_\u56de\u8c03\u3002\u6211\u4eec\u770b\u4e00\u4e0btask_queues_async_\u5bf9\u5e94\u7684\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 uv_async_init ( event_loop (), & task_queues_async_ , []( uv_async_t * async ) { Environment * env = ContainerOf ( & Environment :: task_queues_async_ , async ); env -> CleanupFinalizationGroups (); env -> RunAndClearNativeImmediates (); }); \u6240\u4ee5\u5728Poll IO\u9636\u6bb5\u6267\u884c\u7684\u56de\u8c03\u662fRunAndClearNativeImmediates 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void Environment::RunAndClearNativeImmediates ( bool only_refed ) { TraceEventScope trace_scope ( TRACING_CATEGORY_NODE1 ( environment ), \"RunAndClearNativeImmediates\" , this ); size_t ref_count = 0 ; if ( native_immediates_threadsafe_ . size () > 0 ) { Mutex :: ScopedLock lock ( native_immediates_threadsafe_mutex_ ); native_immediates_ . ConcatMove ( std :: move ( native_immediates_threadsafe_ )); } auto drain_list = [ & ]() { TryCatchScope try_catch ( this ); DebugSealHandleScope seal_handle_scope ( isolate ()); while ( std :: unique_ptr < NativeImmediateCallback > head = native_immediates_ . Shift ()) { if ( head -> is_refed ()) ref_count ++ ; if ( head -> is_refed () || ! only_refed ) // \u6267\u884c\u56de\u8c03 head -> Call ( this ); head . reset (); }; } RunAndClearNativeImmediates\u4f1a\u6267\u884c\u961f\u5217\u91cc\u7684\u56de\u8c03\u3002\u5bf9\u5e94Worker\u7684JoinThread 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void Worker::JoinThread () { // \u963b\u585e\u7b49\u5f85\u5b50\u7ebf\u7a0b\u7ed3\u675f\uff0c\u6267\u884c\u5230\u8fd9\u5b50\u7ebf\u7a0b\u5df2\u7ecf\u7ed3\u675f\u4e86 CHECK_EQ ( uv_thread_join ( & tid_ ), 0 ); thread_joined_ = true ; // \u4ece\u4e3b\u7ebf\u7a0b\u6570\u636e\u7ed3\u6784\u4e2d\u5220\u9664\u8be5\u7ebf\u7a0b\u5bf9\u5e94\u7684\u5b9e\u4f8b env () -> remove_sub_worker_context ( this ); { HandleScope handle_scope ( env () -> isolate ()); Context :: Scope context_scope ( env () -> context ()); // Reset the parent port as we're closing it now anyway. object () -> Set ( env () -> context (), env () -> message_port_string (), Undefined ( env () -> isolate ())). Check (); // \u5b50\u7ebf\u7a0b\u9000\u51fa\u7801 Local < Value > args [] = { Integer :: New ( env () -> isolate (), exit_code_ ), custom_error_ != nullptr ? OneByteString ( env () -> isolate (), custom_error_ ). As < Value > () : Null ( env () -> isolate ()). As < Value > (), }; // \u6267\u884cJS\u5c42\u56de\u8c03\uff0c\u89e6\u53d1exit\u4e8b\u4ef6 MakeCallback ( env () -> onexit_string (), arraysize ( args ), args ); } } \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u679c\u7ed3\u675f\u6b63\u5728\u6267\u884c\u7684\u5b50\u7ebf\u7a0b\u3002\u5728JS\u4e2d\u6211\u80fd\u53ef\u4ee5\u901a\u8fc7terminate\u51fd\u6570\u7ec8\u6b62\u7ebf\u7a0b\u7684\u6267\u884c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 terminate ( callback ) { this [ kHandle ]. stopThread (); } Terminate\u662f\u5bf9C ++ \u6a21\u5757 stopThread\u7684\u5c01\u88c5 \u3002 void Worker :: StopThread ( const FunctionCallbackInfo < Value >& args ) { Worker * w ; ASSIGN_OR_RETURN_UNWRAP ( & w , args . This ()); w -> Exit ( 1 ); } void Worker :: Exit ( int code ) { Mutex :: ScopedLock lock ( mutex_ ); // env_\u662f\u5b50\u7ebf\u7a0b\u6267\u884c\u7684env if ( env_ != nullptr ) { exit_code_ = code ; Stop ( env_ ); } else { stopped_ = true ; } } int Stop ( Environment * env ) { env -> ExitEnv (); return 0 ; } void Environment :: ExitEnv () { set_can_call_into_js ( false ); set_stopping ( true ); isolate_ -> TerminateExecution (); SetImmediateThreadsafe ([]( Environment * env ) { uv_stop ( env -> event_loop ()); }); } \u6211\u4eec\u770b\u5230\u4e3b\u7ebf\u7a0b\u6700\u7ec8\u901a\u8fc7SetImmediateThreadsafe\u7ed9\u5b50\u7ebf\u7a0b\u6240\u5c5e\u7684env\u63d0\u4ea4\u4e86\u4e00\u4e2a\u4efb\u52a1\u3002\u5b50\u7ebf\u7a0b\u5728Poll IO\u9636\u6bb5\u4f1a\u8bbe\u7f6e\u505c\u6b62\u4e8b\u4ef6\u5faa\u73af\u7684\u6807\u8bb0\uff0c\u7b49\u5230\u4e0b\u4e00\u6b21\u4e8b\u4ef6\u5faa\u73af\u5f00\u59cb\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u8df3\u51fa\u4e8b\u4ef6\u5faa\u73af\u4ece\u800c\u7ed3\u675f\u5b50\u7ebf\u7a0b\u7684\u6267\u884c\u3002","title":"14.3 \u591a\u7ebf\u7a0b\u7684\u5b9e\u73b0"},{"location":"chapter14-%E7%BA%BF%E7%A8%8B/#144","text":"\u672c\u8282\u6211\u4eec\u770b\u4e00\u4e0b\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u8fc7\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 const { Worker , isMainThread , parentPort } = require ( 'worker_threads' ); if ( isMainThread ) { const worker = new Worker ( __filename ); worker . once ( 'message' , ( message ) => { ... }); worker . postMessage ( 'Hello, world!' ); } else { // \u505a\u70b9\u8017\u65f6\u7684\u4e8b\u60c5 parentPort . once ( 'message' , ( message ) => { parentPort . postMessage ( message ); }); } \u6211\u4eec\u77e5\u9053isMainThread\u5728\u5b50\u7ebf\u7a0b\u91cc\u662ffalse\uff0cparentPort\u5c31\u662fmessageChannel\u4e2d\u7684\u4e00\u7aef\u3002\u7528\u4e8e\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\uff0c\u6240\u4ee5parentPort.postMessage\u7ed9\u5bf9\u7aef\u53d1\u9001\u6d88\u606f\uff0c\u5c31\u662f\u7ed9\u4e3b\u7ebf\u7a0b\u53d1\u9001\u6d88\u606f\uff0c\u6211\u4eec\u518d\u770b\u770bworker.postMessage('Hello, world!')\u3002 1 2 3 postMessage (... args ) { this [ kPublicPort ]. postMessage (... args ); } kPublicPort\u6307\u5411\u7684\u5c31\u662fmessageChannel\u7684\u4e00\u7aef\u3002this[kPublicPort].postMessage(...args)\u5373\u7ed9\u53e6\u4e00\u7aef\u53d1\u9001\u6d88\u606f\u3002\u6211\u4eec\u770b\u4e00\u4e0bpostMessage\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void MessagePort::PostMessage ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); Local < Object > obj = args . This (); Local < Context > context = obj -> CreationContext (); TransferList transfer_list ; if ( args [ 1 ] -> IsObject ()) { // \u5904\u7406transfer_list } // \u62ff\u5230JS\u5c42\u4f7f\u7528\u7684\u5bf9\u8c61\u6240\u5173\u8054\u7684MessagePort MessagePort * port = Unwrap < MessagePort > ( args . This ()); port -> PostMessage ( env , args [ 0 ], transfer_list ); } \u6211\u4eec\u63a5\u7740\u770bport->PostMessage 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Maybe < bool > MessagePort :: PostMessage ( Environment * env , Local < Value > message_v , const TransferList & transfer_v ) { Isolate * isolate = env -> isolate (); Local < Object > obj = object ( isolate ); Local < Context > context = obj -> CreationContext (); Message msg ; // \u5e8f\u5217\u5316 Maybe < bool > serialization_maybe = msg . Serialize ( env , context , message_v , transfer_v , obj ); // \u62ff\u5230\u64cd\u4f5c\u5bf9\u7aefsibling\u7684\u9501 Mutex :: ScopedLock lock ( * data_ -> sibling_mutex_ ); // \u628a\u6d88\u606f\u63d2\u5165\u5230\u5bf9\u7aef\u961f\u5217 data_ -> sibling_ -> AddToIncomingQueue ( std :: move ( msg )); return Just ( true ); } PostMessage\u901a\u8fc7AddToIncomingQueue\u628a\u6d88\u606f\u63d2\u5165\u5bf9\u7aef\u7684\u6d88\u606f\u961f\u5217\u6211\u4eec\u770b\u4e00\u4e0bAddToIncomingQueue 1 2 3 4 5 6 7 8 9 void MessagePortData::AddToIncomingQueue ( Message && message ) { // \u52a0\u9501\u64cd\u4f5c\u6d88\u606f\u961f\u5217 Mutex :: ScopedLock lock ( mutex_ ); incoming_messages_ . emplace_back ( std :: move ( message )); // \u901a\u77e5owner if ( owner_ != nullptr ) { owner_ -> TriggerAsync (); } } \u63d2\u5165\u6d88\u606f\u961f\u5217\u540e\uff0c\u5982\u679c\u6709\u5173\u8054\u7684\u7aef\u53e3\uff0c\u5219\u4f1a\u901a\u77e5Libuv\u3002\u6211\u4eec\u7ee7\u7eed\u770bTriggerAsync\u3002 1 2 3 4 void MessagePort::TriggerAsync () { if ( IsHandleClosing ()) return ; CHECK_EQ ( uv_async_send ( & async_ ), 0 ); } Libuv\u5728Poll IO\u9636\u6bb5\u5c31\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\u3002\u56de\u8c03\u662f\u5728new MessagePort\u65f6\u8bbe\u7f6e\u7684\u3002 1 2 3 4 5 6 7 8 auto onmessage = []( uv_async_t * handle ) { MessagePort * channel = ContainerOf ( & MessagePort :: async_ , handle ); channel -> OnMessage (); }; // \u521d\u59cb\u5316async\u7ed3\u6784\u4f53\uff0c\u5b9e\u73b0\u5f02\u6b65\u901a\u4fe1 CHECK_EQ ( uv_async_init ( env -> event_loop (), & async_ , onmessage ), 0 ); \u6211\u4eec\u7ee7\u7eed\u770bOnMessage\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 void MessagePort::OnMessage () { HandleScope handle_scope ( env () -> isolate ()); Local < Context > context = object ( env () -> isolate ()) -> CreationContext (); // \u63a5\u6536\u6d88\u606f\u6761\u6570\u7684\u9608\u503c size_t processing_limit ; { // \u52a0\u9501\u64cd\u4f5c\u6d88\u606f\u961f\u5217 Mutex :: ScopedLock ( data_ -> mutex_ ); processing_limit = std :: max ( data_ -> incoming_messages_ . size (), static_cast < size_t > ( 1000 )); } while ( data_ ) { // \u8bfb\u53d6\u7684\u6761\u6570\u8fbe\u5230\u9608\u503c\uff0c\u901a\u77e5Libuv\u4e0b\u4e00\u8f6ePoll IO\u9636\u6bb5\u7ee7\u7eed\u8bfb if ( processing_limit -- == 0 ) { // \u901a\u77e5\u4e8b\u4ef6\u5faa\u73af TriggerAsync (); return ; } HandleScope handle_scope ( env () -> isolate ()); Context :: Scope context_scope ( context ); Local < Value > payload ; // \u8bfb\u53d6\u6d88\u606f if ( ! ReceiveMessage ( context , true ). ToLocal ( & payload )) break ; // \u6ca1\u6709\u4e86 if ( payload == env () -> no_message_symbol ()) break ; Local < Object > event ; Local < Value > cb_args [ 1 ]; // \u65b0\u5efa\u4e00\u4e2aMessageEvent\u5bf9\u8c61\uff0c\u56de\u8c03onmessage\u4e8b\u4ef6 if ( ! env () -> message_event_object_template () -> NewInstance ( context ) . ToLocal ( & event ) || event -> Set ( context , env () -> data_string (), payload ). IsNothing () || event -> Set ( context , env () -> target_string (), object ()). IsNothing () || ( cb_args [ 0 ] = event , false ) || MakeCallback ( env () -> onmessage_string (), arraysize ( cb_args ), cb_args ). IsEmpty ()) { // \u5982\u679c\u56de\u8c03\u5931\u8d25\uff0c\u901a\u77e5Libuv\u4e0b\u6b21\u7ee7\u7eed\u8bfb if ( data_ ) TriggerAsync (); return ; } } } \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u4f1a\u4e0d\u65ad\u5730\u8c03\u7528ReceiveMessage\u8bfb\u53d6\u6570\u636e\uff0c\u7136\u540e\u56de\u8c03JS\u5c42\u3002\u76f4\u5230\u8fbe\u5230\u9608\u503c\u6216\u8005\u56de\u8c03\u5931\u8d25\u3002\u6211\u4eec\u770b\u4e00\u4e0bReceiveMessage\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 MaybeLocal < Value > MessagePort :: ReceiveMessage ( Local < Context > context , bool only_if_receiving ) { Message received ; { // Get the head of the message queue. // \u4e92\u65a5\u8bbf\u95ee\u6d88\u606f\u961f\u5217 Mutex :: ScopedLock lock ( data_ -> mutex_ ); bool wants_message = receiving_messages_ || ! only_if_receiving ; // \u6ca1\u6709\u6d88\u606f\u3001\u4e0d\u9700\u8981\u63a5\u6536\u6d88\u606f\u3001\u6d88\u606f\u662f\u5173\u95ed\u6d88\u606f if ( data_ -> incoming_messages_ . empty () || ( ! wants_message && ! data_ -> incoming_messages_ . front (). IsCloseMessage ())) { return env () -> no_message_symbol (); } // \u83b7\u53d6\u961f\u5217\u7b2c\u4e00\u4e2a\u6d88\u606f received = std :: move ( data_ -> incoming_messages_ . front ()); data_ -> incoming_messages_ . pop_front (); } // \u662f\u5173\u95ed\u6d88\u606f\u5219\u5173\u95ed\u7aef\u53e3 if ( received . IsCloseMessage ()) { Close (); return env () -> no_message_symbol (); } // \u53cd\u5e8f\u5217\u5316\u540e\u8fd4\u56de return received . Deserialize ( env (), context ); } ReceiveMessage\u4f1a\u6d88\u606f\u8fdb\u884c\u53cd\u5e8f\u5217\u5316\u8fd4\u56de\u3002\u4ee5\u4e0a\u5c31\u662f\u7ebf\u7a0b\u95f4\u901a\u4fe1\u7684\u6574\u4e2a\u8fc7\u7a0b\u3002\u5177\u4f53\u6b65\u9aa4\u5982\u56fe14-5\u6240\u793a\u3002 \u56fe14-5","title":"14.4 \u7ebf\u7a0b\u95f4\u901a\u4fe1"},{"location":"chapter15-Cluster/","text":"Node.js\u662f\u5355\u8fdb\u7a0b\u5355\u7ebf\u7a0b\u7684\u5e94\u7528\uff0c\u8fd9\u79cd\u67b6\u6784\u5e26\u6765\u7684\u7f3a\u70b9\u662f\u4e0d\u80fd\u5f88\u597d\u5730\u5229\u7528\u591a\u6838\u7684\u80fd\u529b\uff0c\u56e0\u4e3a\u4e00\u4e2a\u7ebf\u7a0b\u540c\u65f6\u53ea\u80fd\u5728\u4e00\u4e2a\u6838\u4e0a\u6267\u884c\u3002child_process\u6a21\u5757\u4e00\u5b9a\u7a0b\u5ea6\u5730\u89e3\u51b3\u4e86\u8fd9\u4e2a\u95ee\u9898\uff0cchild_process\u6a21\u5757\u4f7f\u5f97Node.js\u5e94\u7528\u53ef\u4ee5\u5728\u591a\u4e2a\u6838\u4e0a\u6267\u884c\uff0c\u800ccluster\u6a21\u5757\u5728child_process\u6a21\u5757\u7684\u57fa\u7840\u4e0a\u4f7f\u5f97\u591a\u4e2a\u8fdb\u7a0b\u53ef\u4ee5\u76d1\u542c\u7684\u540c\u4e00\u4e2a\u7aef\u53e3\uff0c\u5b9e\u73b0\u670d\u52a1\u5668\u7684\u591a\u8fdb\u7a0b\u67b6\u6784\u3002\u672c\u7ae0\u5206\u6790cluster\u6a21\u5757\u7684\u4f7f\u7528\u548c\u539f\u7406\u3002 15.1 cluster\u4f7f\u7528\u4f8b\u5b50 \u00b6 \u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bcluster\u7684\u4e00\u4e2a\u4f7f\u7528\u4f8b\u5b50\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const cluster = require ( 'cluster' ); const http = require ( 'http' ); const numCPUs = require ( 'os' ). cpus (). length ; if ( cluster . isMaster ) { for ( let i = 0 ; i < numCPUs ; i ++ ) { cluster . fork (); } } else { http . createServer (( req , res ) => { res . writeHead ( 200 ); res . end ( 'hello world\\n' ); }). listen ( 8888 ); } \u4ee5\u4e0a\u4ee3\u7801\u5728\u7b2c\u4e00\u6b21\u6267\u884c\u7684\u65f6\u5019\uff0ccluster.isMaster\u4e3atrue\uff0c\u8bf4\u660e\u662f\u4e3b\u8fdb\u7a0b\uff0c\u7136\u540e\u901a\u8fc7fork\u8c03\u7528\u521b\u5efa\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u5728\u5b50\u8fdb\u7a0b\u91cc\u540c\u6837\u6267\u884c\u4ee5\u4e0a\u4ee3\u7801\uff0c\u4f46\u662fcluster.isMaster\u4e3afalse\uff0c\u4ece\u800c\u6267\u884celse\u7684\u903b\u8f91\uff0c\u6211\u4eec\u770b\u5230\u6bcf\u4e2a\u5b50\u8fdb\u7a0b\u90fd\u4f1a\u76d1\u542c8888\u8fd9\u4e2a\u7aef\u53e3\u4f46\u662f\u53c8\u4e0d\u4f1a\u5f15\u8d77EADDRINUSE\u9519\u8bef\u3002\u4e0b\u9762\u6211\u4eec\u6765\u5206\u6790\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002 15.2 \u4e3b\u8fdb\u7a0b\u521d\u59cb\u5316 \u00b6 \u6211\u4eec\u5148\u770b\u4e3b\u8fdb\u7a0b\u65f6\u7684\u903b\u8f91\u3002\u6211\u4eec\u770b\u4e00\u4e0brequire(\u2018cluster\u2019)\u7684\u65f6\u5019\uff0cNode.js\u662f\u600e\u4e48\u5904\u7406\u7684\u3002 1 2 const childOrMaster = 'NODE_UNIQUE_ID' in process . env ? 'child' : 'master' ; module . exports = require ( `internal/cluster/ ${ childOrMaster } ` ) \u6211\u4eec\u770b\u5230Node.js\u4f1a\u6839\u636e\u5f53\u524d\u73af\u5883\u53d8\u91cf\u7684\u503c\u52a0\u8f7d\u4e0d\u540c\u7684\u6a21\u5757\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u770b\u5230NODE_UNIQUE_ID\u662f\u4e3b\u8fdb\u7a0b\u7ed9\u5b50\u8fdb\u7a0b\u8bbe\u7f6e\u7684\uff0c\u5728\u4e3b\u8fdb\u7a0b\u4e2d\uff0cNODE_UNIQUE_ID\u662f\u4e0d\u5b58\u5728\u7684\uff0c\u6240\u4ee5\u4e3b\u8fdb\u7a0b\u65f6\uff0c\u4f1a\u52a0\u8f7dmaster\u6a21\u5757\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 cluster . isWorker = false ; cluster . isMaster = true ; // \u8c03\u5ea6\u7b56\u7565 cluster . SCHED_NONE = SCHED_NONE ; cluster . SCHED_RR = SCHED_RR ; // \u8c03\u5ea6\u7b56\u7565\u7684\u9009\u62e9 let schedulingPolicy = { 'none' : SCHED_NONE , 'rr' : SCHED_RR }[ process . env . NODE_CLUSTER_SCHED_POLICY ]; if ( schedulingPolicy === undefined ) { schedulingPolicy = ( process . platform === 'win32' ) ? SCHED_NONE : SCHED_RR ; } cluster . schedulingPolicy = schedulingPolicy ; // \u521b\u5efa\u5b50\u8fdb\u7a0b cluster . fork = function ( env ) { // \u53c2\u6570\u5904\u7406 cluster . setupMaster (); const id = ++ ids ; // \u8c03\u7528child_process\u6a21\u5757\u7684fork const workerProcess = createWorkerProcess ( id , env ); const worker = new Worker ({ id : id , process : workerProcess }); // ... worker . process . on ( 'internalMessage' , internal ( worker , onmessage )); process . nextTick ( emitForkNT , worker ); cluster . workers [ worker . id ] = worker ; return worker ; }; cluster.fork\u662f\u5bf9child_process\u6a21\u5757fork\u7684\u5c01\u88c5\uff0c\u6bcf\u6b21cluster.fork\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u65b0\u5efa\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u6240\u4ee5cluster\u4e0b\u9762\u4f1a\u6709\u591a\u4e2a\u5b50\u8fdb\u7a0b\uff0cNode.js\u63d0\u4f9b\u7684\u5de5\u4f5c\u6a21\u5f0f\u6709\u8f6e\u8be2\u548c\u5171\u4eab\u4e24\u79cd\uff0c\u4e0b\u9762\u4f1a\u5177\u4f53\u4ecb\u7ecd\u3002Worker\u662f\u5bf9\u5b50\u8fdb\u7a0b\u7684\u5c01\u88c5\uff0c\u901a\u8fc7process\u6301\u6709\u5b50\u8fdb\u7a0b\u7684\u5b9e\u4f8b\uff0c\u5e76\u901a\u8fc7\u76d1\u542cinternalMessage\u548cmessage\u4e8b\u4ef6\u5b8c\u6210\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u7684\u901a\u4fe1\uff0cinternalMessage\u8fd9\u662fNode.js\u5b9a\u4e49\u7684\u5185\u90e8\u901a\u4fe1\u4e8b\u4ef6\uff0c\u5904\u7406\u51fd\u6570\u662finternal(worker, onmessage)\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0binternal\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const callbacks = new Map (); let seq = 0 ; function internal ( worker , cb ) { return function onInternalMessage ( message , handle ) { if ( message . cmd !== 'NODE_CLUSTER' ) return ; let fn = cb ; if ( message . ack !== undefined ) { const callback = callbacks . get ( message . ack ); if ( callback !== undefined ) { fn = callback ; callbacks . delete ( message . ack ); } } fn . apply ( worker , arguments ); }; } internal\u51fd\u6570\u5bf9\u5f02\u6b65\u6d88\u606f\u901a\u4fe1\u505a\u4e86\u4e00\u5c42\u5c01\u88c5\uff0c\u56e0\u4e3a\u8fdb\u7a0b\u95f4\u901a\u4fe1\u662f\u5f02\u6b65\u7684\uff0c\u5f53\u6211\u4eec\u53d1\u9001\u591a\u4e2a\u6d88\u606f\u540e\uff0c\u5982\u679c\u6536\u5230\u4e00\u4e2a\u56de\u590d\uff0c\u6211\u4eec\u65e0\u6cd5\u8fa8\u522b\u51fa\u8be5\u56de\u590d\u662f\u9488\u5bf9\u54ea\u4e00\u4e2a\u8bf7\u6c42\u7684\uff0cNode.js\u901a\u8fc7seq\u7684\u65b9\u5f0f\u5bf9\u6bcf\u4e00\u4e2a\u8bf7\u6c42\u548c\u54cd\u5e94\u505a\u4e86\u4e00\u4e2a\u7f16\u53f7\uff0c\u4ece\u800c\u533a\u5206\u54cd\u5e94\u5bf9\u5e94\u7684\u8bf7\u6c42\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bmessage\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function onmessage ( message , handle ) { const worker = this ; if ( message . act === 'online' ) online ( worker ); else if ( message . act === 'queryServer' ) queryServer ( worker , message ); else if ( message . act === 'listening' ) listening ( worker , message ); else if ( message . act === 'exitedAfterDisconnect' ) exitedAfterDisconnect ( worker , message ); else if ( message . act === 'close' ) close ( worker , message ); } onmessage\u6839\u636e\u6536\u5230\u6d88\u606f\u7684\u4e0d\u540c\u7c7b\u578b\u8fdb\u884c\u76f8\u5e94\u7684\u5904\u7406\u3002\u540e\u9762\u6211\u4eec\u518d\u5177\u4f53\u5206\u6790\u3002\u81f3\u6b64\uff0c\u4e3b\u8fdb\u7a0b\u7684\u903b\u8f91\u5c31\u5206\u6790\u5b8c\u4e86\u3002 15.3 \u5b50\u8fdb\u7a0b\u521d\u59cb\u5316 \u00b6 \u6211\u4eec\u6765\u770b\u4e00\u4e0b\u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\u3002\u5f53\u6267\u884c\u5b50\u8fdb\u7a0b\u65f6\uff0c\u4f1a\u52a0\u8f7dchild\u6a21\u5757\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const cluster = new EventEmitter (); const handles = new Map (); const indexes = new Map (); const noop = () => {}; module . exports = cluster ; cluster . isWorker = true ; cluster . isMaster = false ; cluster . worker = null ; cluster . Worker = Worker ; cluster . _setupWorker = function () { const worker = new Worker ({ id : + process . env . NODE_UNIQUE_ID | 0 , process : process , state : 'online' }); cluster . worker = worker ; process . on ( 'internalMessage' , internal ( worker , onmessage )); // \u901a\u77e5\u4e3b\u8fdb\u7a0b\u5b50\u8fdb\u7a0b\u542f\u52a8\u6210\u529f send ({ act : 'online' }); function onmessage ( message , handle ) { if ( message . act === 'newconn' ) onconnection ( message , handle ); else if ( message . act === 'disconnect' ) _disconnect . call ( worker , true ); } }; _setupWorker\u51fd\u6570\u5728\u5b50\u8fdb\u7a0b\u521d\u59cb\u5316\u65f6\u88ab\u6267\u884c\uff0c\u548c\u4e3b\u8fdb\u7a0b\u7c7b\u4f3c\uff0c\u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\u4e5f\u4e0d\u591a\uff0c\u76d1\u542cinternalMessage\u4e8b\u4ef6\uff0c\u5e76\u4e14\u901a\u77e5\u4e3b\u7ebf\u7a0b\u81ea\u5df1\u542f\u52a8\u6210\u529f\u3002 15.4 http.createServer\u7684\u5904\u7406 \u00b6 \u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u6267\u884c\u5b8c\u521d\u59cb\u5316\u4ee3\u7801\u540e\uff0c\u5b50\u8fdb\u7a0b\u5f00\u59cb\u6267\u884c\u4e1a\u52a1\u4ee3\u7801http.createServer\uff0c\u5728HTTP\u6a21\u5757\u7ae0\u8282\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7http.createServer\u7684\u8fc7\u7a0b\uff0c\u8fd9\u91cc\u5c31\u4e0d\u5177\u4f53\u5206\u6790\uff0c\u6211\u4eec\u77e5\u9053http.createServer\u6700\u540e\u4f1a\u8c03\u7528net\u6a21\u5757\u7684listen\uff0c\u7136\u540e\u8c03\u7528listenIncluster\u3002\u6211\u4eec\u4ece\u8be5\u51fd\u6570\u5f00\u59cb\u5206\u6790\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 function listenIncluster ( server , address , port , addressType , backlog , fd , exclusive , flags ) { const serverQuery = { address : address , port : port , addressType : addressType , fd : fd , flags , }; cluster . _getServer ( server , serverQuery , listenOnMasterHandle ); function listenOnMasterHandle ( err , handle ) { err = checkBindError ( err , port , handle ); if ( err ) { const ex = exceptionWithHostPort ( err , 'bind' , address , port ); return server . emit ( 'error' , ex ); } server . _handle = handle ; server . _listen2 ( address , port , addressType , backlog , fd , flags ); } } listenIncluster\u51fd\u6570\u4f1a\u8c03\u7528\u5b50\u8fdb\u7a0bcluster\u6a21\u5757\u7684_getServer\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 cluster . _getServer = function ( obj , options , cb ) { let address = options . address ; // \u5ffd\u7565index\u7684\u5904\u7406\u903b\u8f91 const message = { act : 'queryServer' , index , data : null , ... options }; message . address = address ; // \u7ed9\u4e3b\u8fdb\u7a0b\u53d1\u9001\u6d88\u606f send ( message , ( reply , handle ) => { // \u6839\u636e\u4e0d\u540c\u6a21\u5f0f\u505a\u5904\u7406 if ( handle ) shared ( reply , handle , indexesKey , cb ); else rr ( reply , indexesKey , cb ); }); }; _getServer\u4f1a\u7ed9\u4e3b\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2aqueryServer\u7684\u8bf7\u6c42\u3002\u6211\u4eec\u770b\u4e00\u4e0bsend\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function send ( message , cb ) { return sendHelper ( process , message , null , cb ); } function sendHelper ( proc , message , handle , cb ) { if ( ! proc . connected ) return false ; message = { cmd : 'NODE_CLUSTER' , ... message , seq }; if ( typeof cb === 'function' ) callbacks . set ( seq , cb ); seq += 1 ; return proc . send ( message , handle ); } send\u8c03\u7528\u4e86sendHelper\uff0csendHelper\u662f\u5bf9\u5f02\u6b65\u8bf7\u6c42\u505a\u4e86\u4e00\u4e2a\u5c01\u88c5\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u4e3b\u8fdb\u7a0b\u662f\u5982\u4f55\u5904\u7406queryServer\u8bf7\u6c42\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 function queryServer ( worker , message ) { const key = ` ${ message . address } : ${ message . port } : ${ message . addressType } :` + ` ${ message . fd } : ${ message . index } ` ; let handle = handles . get ( key ); if ( handle === undefined ) { let address = message . address ; let constructor = RoundRobinHandle ; // \u6839\u636e\u7b56\u7565\u9009\u53d6\u4e0d\u540c\u7684\u6784\u9020\u51fd\u6570 if ( schedulingPolicy !== SCHED_RR || message . addressType === 'udp4' || message . addressType === 'udp6' ) { constructor = SharedHandle ; } handle = new constructor ( key , address , message . port , message . addressType , message . fd , message . flags ); handles . set ( key , handle ); } handle . add ( worker , ( errno , reply , handle ) => { const { data } = handles . get ( key ); send ( worker , { errno , key , ack : message . seq , data , ... reply }, handle ); }); } queryServer\u9996\u5148\u6839\u636e\u8c03\u5ea6\u7b56\u7565\u9009\u62e9\u6784\u9020\u51fd\u6570\uff0c\u7136\u540e\u6267\u884c\u5bf9\u5e94\u7684add\u65b9\u6cd5\u5e76\u4e14\u4f20\u5165\u4e00\u4e2a\u56de\u8c03\u3002\u4e0b\u9762\u6211\u4eec\u770b\u770b\u4e0d\u540c\u6a21\u5f0f\u4e0b\u7684\u5904\u7406\u3002 15.5 \u5171\u4eab\u6a21\u5f0f \u00b6 \u4e0b\u9762\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5171\u4eab\u6a21\u5f0f\u7684\u5904\u7406\uff0c\u903b\u8f91\u5982\u56fe19-1\u6240\u793a\u3002 \u56fe19-1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 function SharedHandle ( key , address , port , addressType , fd , flags ) { this . key = key ; this . workers = []; this . handle = null ; this . errno = 0 ; let rval ; if ( addressType === 'udp4' || addressType === 'udp6' ) rval = dgram . _createSocketHandle ( address , port , addressType , fd , flags ); else rval = net . _createServerHandle ( address , port , addressType , fd , flags ); if ( typeof rval === 'number' ) this . errno = rval ; else this . handle = rval ; } SharedHandle\u662f\u5171\u4eab\u6a21\u5f0f\uff0c\u5373\u4e3b\u8fdb\u7a0b\u521b\u5efa\u597dhandle\uff0c\u4ea4\u7ed9\u5b50\u8fdb\u7a0b\u5904\u7406\u3002 1 2 3 4 SharedHandle.prototype.add = function(worker, send) { this.workers.push(worker); send(this.errno, null, this.handle); }; SharedHandle\u7684add\u628aSharedHandle\u4e2d\u521b\u5efa\u7684handle\u8fd4\u56de\u7ed9\u5b50\u8fdb\u7a0b\uff0c\u63a5\u7740\u6211\u4eec\u770b\u770b\u5b50\u8fdb\u7a0b\u62ff\u5230handle\u540e\u7684\u5904\u7406 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function shared ( message , handle , indexesKey , cb ) { const key = message . key ; const close = handle . close ; handle . close = function () { send ({ act : 'close' , key }); handles . delete ( key ); indexes . delete ( indexesKey ); return close . apply ( handle , arguments ); }; handles . set ( key , handle ); // \u6267\u884cnet\u6a21\u5757\u7684\u56de\u8c03 cb ( message . errno , handle ); } Shared\u51fd\u6570\u628a\u63a5\u6536\u5230\u7684handle\u518d\u56de\u4f20\u5230\u8c03\u7528\u65b9\u3002\u5373net\u6a21\u5757\u3002net\u6a21\u5757\u4f1a\u6267\u884clisten\u5f00\u59cb\u76d1\u542c\u5730\u5740\uff0c\u4f46\u662f\u6709\u8fde\u63a5\u5230\u6765\u65f6\uff0c\u7cfb\u7edf\u53ea\u4f1a\u6709\u4e00\u4e2a\u8fdb\u7a0b\u62ff\u5230\u8be5\u8fde\u63a5\u3002\u6240\u4ee5\u6240\u6709\u5b50\u8fdb\u7a0b\u5b58\u5728\u7ade\u4e89\u5173\u7cfb\u5bfc\u81f4\u8d1f\u8f7d\u4e0d\u5747\u8861\uff0c\u8fd9\u53d6\u51b3\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u7684\u5b9e\u73b0\u3002 \u5171\u4eab\u6a21\u5f0f\u5b9e\u73b0\u7684\u6838\u5fc3\u903b\u8f91\u4e3b\u8fdb\u7a0b\u5728_createServerHandle\u521b\u5efahandle\u65f6\u6267\u884cbind\u7ed1\u5b9a\u4e86\u5730\u5740\uff08\u4f46\u6ca1\u6709listen\uff09\uff0c\u7136\u540e\u901a\u8fc7\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7684\u65b9\u5f0f\u4f20\u7ed9\u5b50\u8fdb\u7a0b\uff0c\u5b50\u8fdb\u7a0b\u6267\u884clisten\u7684\u65f6\u5019\u5c31\u4e0d\u4f1a\u62a5\u7aef\u53e3\u5df2\u7ecf\u88ab\u76d1\u542c\u7684\u9519\u8bef\u4e86\u3002\u56e0\u4e3a\u7aef\u53e3\u88ab\u76d1\u542c\u7684\u9519\u8bef\u662f\u6267\u884cbind\u7684\u65f6\u5019\u8fd4\u56de\u7684\u3002 15.6 \u8f6e\u8be2\u6a21\u5f0f \u00b6 \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bRoundRobinHandle\u7684\u5904\u7406\uff0c\u903b\u8f91\u5982\u56fe19-2\u6240\u793a\u3002 \u56fe19-2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function RoundRobinHandle ( key , address , port , addressType , fd , flags ) { this . key = key ; this . all = new Map (); this . free = []; this . handles = []; this . handle = null ; this . server = net . createServer ( assert . fail ); if ( fd >= 0 ) this . server . listen ({ fd }); else if ( port >= 0 ) { this . server . listen ({ port , host : address , ipv6Only : Boolean ( flags & constants . UV_TCP_IPV6ONLY ), }); } else this . server . listen ( address ); // UNIX socket path. // \u76d1\u542c\u6210\u529f\u540e\uff0c\u6ce8\u518conconnection\u56de\u8c03\uff0c\u6709\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c this . server . once ( 'listening' , () => { this . handle = this . server . _handle ; this . handle . onconnection = ( err , handle ) => this . distribute ( err , handle ); this . server . _handle = null ; this . server = null ; }); } RoundRobinHandle\u7684\u5de5\u4f5c\u6a21\u5f0f\u662f\u4e3b\u8fdb\u7a0b\u8d1f\u8d23\u76d1\u542c\uff0c\u6536\u5230\u8fde\u63a5\u540e\u5206\u53d1\u7ed9\u5b50\u8fdb\u7a0b\u3002\u6211\u4eec\u770b\u4e00\u4e0bRoundRobinHandle\u7684add 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 RoundRobinHandle . prototype . add = function ( worker , send ) { this . all . set ( worker . id , worker ); const done = () => { if ( this . handle . getsockname ) { const out = {}; this . handle . getsockname ( out ); send ( null , { sockname : out }, null ); } else { send ( null , null , null ); // UNIX socket. } // In case there are connections pending. this . handoff ( worker ); }; // \u8bf4\u660elisten\u6210\u529f\u4e86 if ( this . server === null ) return done (); // \u5426\u5219\u7b49\u5f85listen\u6210\u529f\u540e\u6267\u884c\u56de\u8c03 this . server . once ( 'listening' , done ); this . server . once ( 'error' , ( err ) => { send ( err . errno , null ); }); }; RoundRobinHandle\u4f1a\u5728listen\u6210\u529f\u540e\u6267\u884c\u56de\u8c03\u3002\u6211\u4eec\u56de\u987e\u4e00\u4e0b\u6267\u884cadd\u51fd\u6570\u65f6\u7684\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 handle . add ( worker , ( errno , reply , handle ) => { const { data } = handles . get ( key ); send ( worker , { errno , key , ack : message . seq , data , ... reply }, handle ); }); \u56de\u8c03\u51fd\u6570\u4f1a\u628ahandle\u7b49\u4fe1\u606f\u8fd4\u56de\u7ed9\u5b50\u8fdb\u7a0b\u3002\u4f46\u662f\u5728RoundRobinHandle\u548cSharedHandle\u4e2d\u8fd4\u56de\u7684handle\u662f\u4e0d\u4e00\u6837\u7684\u3002\u5206\u522b\u662fnull\u548cnet.createServer\u5b9e\u4f8b\u3002\u63a5\u7740\u6211\u4eec\u56de\u5230\u5b50\u8fdb\u7a0b\u7684\u4e0a\u4e0b\u6587\u3002\u770b\u5b50\u8fdb\u7a0b\u662f\u5982\u4f55\u5904\u7406\u54cd\u5e94\u7684\u3002\u521a\u624d\u6211\u4eec\u8bb2\u8fc7\uff0c\u4e0d\u540c\u7684\u8c03\u5ea6\u7b56\u7565\uff0c\u8fd4\u56de\u7684handle\u662f\u4e0d\u4e00\u6837\u7684\uff0c\u6211\u4eec\u770b\u8f6e\u8be2\u6a21\u5f0f\u4e0b\u7684\u5904\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function rr ( message , indexesKey , cb ) { let key = message . key ; function listen ( backlog ) { return 0 ; } function close () { // ... } const handle = { close , listen , ref : noop , unref : noop }; if ( message . sockname ) { handle . getsockname = getsockname ; // TCP handles only. } handles . set ( key , handle ); // \u6267\u884cnet\u6a21\u5757\u7684\u56de\u8c03 cb ( 0 , handle ); } round-robin\u6a21\u5f0f\u4e0b\uff0c\u6784\u9020\u4e00\u4e2a\u5047\u7684handle\u8fd4\u56de\u7ed9\u8c03\u7528\u65b9\uff0c\u56e0\u4e3a\u8c03\u7528\u65b9\u4f1a\u8c03\u7528\u8fd9\u4e9b\u51fd\u6570\u3002\u6700\u540e\u56de\u5230net\u6a21\u5757\u3002net\u6a21\u5757\u9996\u5148\u4fdd\u5b58handle\uff0c\u7136\u540e\u8c03\u7528listen\u51fd\u6570\u3002\u5f53\u6709\u8bf7\u6c42\u5230\u6765\u65f6\uff0cround-bobin\u6a21\u5757\u4f1a\u6267\u884cdistribute\u5206\u53d1\u8bf7\u6c42\u7ed9\u5b50\u8fdb\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 RoundRobinHandle . prototype . distribute = function ( err , handle ) { // \u9996\u5148\u4fdd\u5b58handle\u5230\u961f\u5217 this . handles . push ( handle ); // \u4ece\u7a7a\u95f2\u961f\u5217\u83b7\u53d6\u4e00\u4e2a\u5b50\u8fdb\u7a0b const worker = this . free . shift (); // \u5206\u53d1 if ( worker ) this . handoff ( worker ); }; RoundRobinHandle . prototype . handoff = function ( worker ) { // \u62ff\u5230\u4e00\u4e2ahandle const handle = this . handles . shift (); // \u6ca1\u6709handle\uff0c\u5219\u5b50\u8fdb\u7a0b\u91cd\u65b0\u5165\u961f if ( handle === undefined ) { this . free . push ( worker ); // Add to ready queue again. return ; } // \u901a\u77e5\u5b50\u8fdb\u7a0b\u6709\u65b0\u8fde\u63a5 const message = { act : 'newconn' , key : this . key }; sendHelper ( worker . process , message , handle , ( reply ) => { // \u63a5\u6536\u6210\u529f if ( reply . accepted ) handle . close (); else // \u7ed3\u675f\u5931\u8d25\uff0c\u5219\u91cd\u65b0\u5206\u53d1 this . distribute ( 0 , handle ); // Worker is shutting down. Send to another. this . handoff ( worker ); }); }; \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u5b50\u8fdb\u7a0b\u662f\u600e\u4e48\u5904\u7406\u8be5\u8bf7\u6c42\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function onmessage ( message , handle ) { if ( message . act === 'newconn' ) onconnection ( message , handle ); } function onconnection ( message , handle ) { const key = message . key ; const server = handles . get ( key ); const accepted = server !== undefined ; // \u56de\u590d\u63a5\u6536\u6210\u529f send ({ ack : message . seq , accepted }); if ( accepted ) // \u5728net\u6a21\u5757\u8bbe\u7f6e server . onconnection ( 0 , handle ); } \u6211\u4eec\u770b\u5230\u5b50\u8fdb\u7a0b\u4f1a\u6267\u884cserver.onconnection\uff0c\u8fd9\u4e2a\u548c\u6211\u4eec\u5206\u6790net\u6a21\u5757\u65f6\u89e6\u53d1onconnection\u4e8b\u4ef6\u662f\u4e00\u6837\u7684\u3002 15.7\u5b9e\u73b0\u81ea\u5df1\u7684cluster\u6a21\u5757 \u00b6 Node.js\u7684cluster\u5728\u8bf7\u6c42\u5206\u53d1\u65f6\u662f\u6309\u7167\u8f6e\u8be2\u7684\uff0c\u65e0\u6cd5\u6839\u636e\u8fdb\u7a0b\u5f53\u524d\u60c5\u51b5\u505a\u76f8\u5e94\u7684\u5904\u7406\u3002\u4e86\u89e3\u4e86cluster\u6a21\u5757\u7684\u539f\u7406\u540e\uff0c\u6211\u4eec\u81ea\u5df1\u6765\u5b9e\u73b0\u4e00\u4e2acluster\u6a21\u5757\u3002 15.7.1 \u8f6e\u8be2\u6a21\u5f0f \u00b6 \u6574\u4f53\u67b6\u6784\u5982\u56fe15-3\u6240\u793a\u3002 \u56fe15-3 Parent.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const childProcess = require ( 'child_process' ); const net = require ( 'net' ); const workers = []; const workerNum = 10 ; let index = 0 ; for ( let i = 0 ; i < workerNum ; i ++ ) { workers . push ( childProcess . fork ( 'child.js' , { env : { index : i }})); } const server = net . createServer (( client ) => { workers [ index ]. send ( null , client ); console . log ( 'dispatch to' , index ); index = ( index + 1 ) % workerNum ; }); server . listen ( 11111 ); child.js 1 2 3 process . on ( 'message' , ( message , client ) => { console . log ( 'receive connection from master' ); }); \u4e3b\u8fdb\u7a0b\u8d1f\u8d23\u76d1\u542c\u8bf7\u6c42\uff0c\u4e3b\u8fdb\u7a0b\u6536\u5230\u8bf7\u6c42\u540e\uff0c\u6309\u7167\u4e00\u5b9a\u7684\u7b97\u6cd5\u628a\u8bf7\u6c42\u901a\u8fc7\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u65b9\u5f0f\u4f20\u7ed9worker\u8fdb\u7a0b\uff0cworker\u8fdb\u7a0b\u5c31\u53ef\u4ee5\u5904\u7406\u8fde\u63a5\u4e86\u3002\u5728\u5206\u53d1\u7b97\u6cd5\u8fd9\u91cc\uff0c\u6211\u4eec\u53ef\u4ee5\u6839\u636e\u81ea\u5df1\u7684\u9700\u6c42\u8fdb\u884c\u81ea\u5b9a\u4e49\uff0c\u6bd4\u5982\u6839\u636e\u5f53\u524d\u8fdb\u7a0b\u7684\u8d1f\u8f7d\uff0c\u6b63\u5728\u5904\u7406\u7684\u8fde\u63a5\u6570\u3002 15.7.2 \u5171\u4eab\u6a21\u5f0f \u00b6 \u6574\u4f53\u67b6\u6784\u5982\u56fe15-4\u6240\u793a\u3002 \u56fe15-4 Parent.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const childProcess = require ( 'child_process' ); const net = require ( 'net' ); const workers = []; const workerNum = 10 ; const handle = net . _createServerHandle ( '127.0.0.1' , 11111 , 4 ); for ( let i = 0 ; i < workerNum ; i ++ ) { const worker = childProcess . fork ( 'child.js' , { env : { index : i }}); workers . push ( worker ); worker . send ( null , handle ); /* \u9632\u6b62\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\uff0c\u4f46\u662f\u91cd\u65b0fork\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\u5c31\u65e0\u6cd5 \u518d\u4f20\u9012\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e86 */ handle . close (); } Child.js 1 2 3 4 5 6 const net = require ( 'net' ); process . on ( 'message' , ( message , handle ) => { net . createServer (() => { console . log ( process . env . index , 'receive connection' ); }). listen ({ handle }); }); \u6211\u4eec\u770b\u5230\u4e3b\u8fdb\u7a0b\u8d1f\u8d23\u7ed1\u5b9a\u7aef\u53e3\uff0c\u7136\u540e\u628ahandle\u4f20\u7ed9worker\u8fdb\u7a0b\uff0cworker\u8fdb\u7a0b\u5404\u81ea\u6267\u884clisten\u76d1\u542csocket\u3002\u5f53\u6709\u8fde\u63a5\u5230\u6765\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u9009\u62e9\u67d0\u4e00\u4e2aworker\u8fdb\u7a0b\u5904\u7406\u8be5\u8fde\u63a5\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5171\u4eab\u6a21\u5f0f\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u67b6\u6784\uff0c\u5982\u56fe15-5\u6240\u793a\u3002 \u56fe15-5 \u5b9e\u73b0\u5171\u4eab\u6a21\u5f0f\u7684\u91cd\u70b9\u5728\u4e8e\u7406\u89e3EADDRINUSE\u9519\u8bef\u662f\u600e\u4e48\u6765\u7684\u3002\u5f53\u4e3b\u8fdb\u7a0b\u6267\u884cbind\u7684\u65f6\u5019\uff0c\u7ed3\u6784\u5982\u56fe15-6\u6240\u793a\u3002 \u56fe15-6 \u5982\u679c\u5176\u5b83\u8fdb\u7a0b\u4e5f\u6267\u884cbind\u5e76\u4e14\u7aef\u53e3\u4e5f\u4e00\u6837\uff0c\u5219\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u544a\u8bc9\u6211\u4eec\u7aef\u53e3\u5df2\u7ecf\u88ab\u76d1\u542c\u4e86\uff08EADDRINUSE\uff09\u3002\u4f46\u662f\u5982\u679c\u6211\u4eec\u5728\u5b50\u8fdb\u7a0b\u91cc\u4e0d\u6267\u884cbind\u7684\u8bdd\uff0c\u5c31\u53ef\u4ee5\u7ed5\u8fc7\u8fd9\u4e2a\u9650\u5236\u3002\u90a3\u4e48\u91cd\u70b9\u5728\u4e8e\uff0c\u5982\u4f55\u5728\u5b50\u8fdb\u7a0b\u4e2d\u4e0d\u6267\u884cbind\uff0c\u4f46\u662f\u53c8\u53ef\u4ee5\u7ed1\u5b9a\u5230\u540c\u6837\u7684\u7aef\u53e3\u5462\uff1f\u6709\u4e24\u79cd\u65b9\u5f0f\u3002 1 fork \u6211\u4eec\u77e5\u9053fork\u7684\u65f6\u5019\uff0c\u5b50\u8fdb\u7a0b\u4f1a\u7ee7\u627f\u4e3b\u8fdb\u7a0b\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5982\u56fe15-7\u6240\u793a\u3002 \u56fe15-7 \u8fd9\u65f6\u5019\uff0c\u4e3b\u8fdb\u7a0b\u53ef\u4ee5\u6267\u884cbind\u548clisten\uff0c\u7136\u540efork\u5b50\u8fdb\u7a0b\uff0c\u6700\u540eclose\u6389\u81ea\u5df1\u7684fd\uff0c\u8ba9\u6240\u6709\u7684\u8fde\u63a5\u90fd\u7531\u5b50\u8fdb\u7a0b\u5904\u7406\u5c31\u884c\u3002\u4f46\u662f\u5728Node.js\u4e2d\uff0c\u6211\u4eec\u65e0\u6cd5\u5b9e\u73b0\uff0c\u6240\u4ee5\u8fd9\u79cd\u65b9\u5f0f\u4e0d\u80fd\u6ee1\u8db3\u9700\u6c42\u3002 2 \u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012 Node.js\u7684\u5b50\u8fdb\u7a0b\u662f\u901a\u8fc7fork+exec\u6a21\u5f0f\u521b\u5efa\u7684\uff0c\u5e76\u4e14Node.js\u6587\u4ef6\u63cf\u8ff0\u7b26\u8bbe\u7f6e\u4e86close_on_exec\u6807\u8bb0\uff0c\u8fd9\u5c31\u610f\u5473\u7740\uff0c\u5728Node.js\u4e2d\uff0c\u521b\u5efa\u5b50\u8fdb\u7a0b\u540e\uff0c\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u7ed3\u6784\u4f53\u5982\u56fe15-8\u6240\u793a\uff08\u6709\u6807\u51c6\u8f93\u5165\u3001\u6807\u51c6\u8f93\u51fa\u3001\u6807\u51c6\u9519\u8bef\u4e09\u4e2afd\uff09\u3002 \u56fe15-8 \u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7684\u65b9\u5f0f\u3002\u628a\u65b9\u5f0f1\u4e2d\u62ff\u4e0d\u5230\u7684fd\u4f20\u7ed9\u5b50\u8fdb\u7a0b\u3002\u56e0\u4e3a\u5728Node.js\u4e2d\uff0c\u867d\u7136\u6211\u4eec\u62ff\u4e0d\u5230fd\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u62ff\u5f97\u5230fd\u5bf9\u5e94\u7684handle\uff0c\u6211\u4eec\u901a\u8fc7IPC\u4f20\u8f93handle\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u4e3a\u6211\u4eec\u5904\u7406fd\u7684\u95ee\u9898\u3002\u6700\u540e\u901a\u8fc7\u64cd\u4f5c\u7cfb\u7edf\u5bf9\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5904\u7406\u3002\u7ed3\u6784\u5982\u56fe15-9\u6240\u793a\u3002 \u56fe15-9 \u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\uff0c\u6211\u4eec\u5c31\u7ed5\u8fc7\u4e86bind\u540c\u4e00\u4e2a\u7aef\u53e3\u7684\u95ee\u9898\u3002\u901a\u8fc7\u4ee5\u4e0a\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u77e5\u9053\u7ed5\u8fc7bind\u7684\u95ee\u9898\u91cd\u70b9\u5728\u4e8e\u8ba9\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u5171\u4eabsocket\u800c\u4e0d\u662f\u5355\u72ec\u6267\u884cbind\u3002\u5bf9\u4e8e\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cNode.js\u4e2d\u652f\u6301\u5f88\u591a\u79cd\u65b9\u5f0f\u3002\u4e0a\u9762\u7684\u65b9\u5f0f\u662f\u5b50\u8fdb\u7a0b\u5404\u81ea\u6267\u884clisten\u3002\u8fd8\u6709\u53e6\u4e00\u79cd\u6a21\u5f0f\u5982\u4e0b parent.js 1 2 3 4 5 6 7 8 9 10 11 12 13 const childProcess = require ( 'child_process' ); const net = require ( 'net' ); const workers = []; const workerNum = 10 ; const server = net . createServer (() => { console . log ( 'master receive connection' ); }) server . listen ( 11111 ); for ( let i = 0 ; i < workerNum ; i ++ ) { const worker = childProcess . fork ( 'child.js' , { env : { index : i }}); workers . push ( worker ); worker . send ( null , server ); } child.js 1 2 3 4 5 6 const net = require ( 'net' ); process . on ( 'message' , ( message , server ) => { server . on ( 'connection' , () => { console . log ( process . env . index , 'receive connection' ); }) }); \u4e0a\u9762\u7684\u65b9\u5f0f\u4e2d\uff0c\u4e3b\u8fdb\u7a0b\u5b8c\u6210\u4e86bind\u548clisten\u3002\u7136\u540e\u628aserver\u5b9e\u4f8b\u4f20\u7ed9\u5b50\u8fdb\u7a0b\uff0c\u5b50\u8fdb\u7a0b\u5c31\u53ef\u4ee5\u76d1\u542c\u8fde\u63a5\u7684\u5230\u6765\u4e86\u3002\u8fd9\u65f6\u5019\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u5904\u7406\u8fde\u63a5\u3002 \u6700\u540e\u5199\u4e00\u4e2a\u5ba2\u6237\u7aef\u6d4b\u8bd5\u3002 \u5ba2\u6237\u7aef 1 2 3 4 const net = require ( 'net' ); for ( let i = 0 ; i < 50 ; i ++ ) { net . connect ({ port : 11111 }); } \u6267\u884cclient\u6211\u4eec\u5c31\u53ef\u4ee5\u770b\u5230\u591a\u8fdb\u7a0b\u5904\u7406\u8fde\u63a5\u7684\u60c5\u51b5\u3002","title":"15-Cluster"},{"location":"chapter15-Cluster/#151-cluster","text":"\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bcluster\u7684\u4e00\u4e2a\u4f7f\u7528\u4f8b\u5b50\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const cluster = require ( 'cluster' ); const http = require ( 'http' ); const numCPUs = require ( 'os' ). cpus (). length ; if ( cluster . isMaster ) { for ( let i = 0 ; i < numCPUs ; i ++ ) { cluster . fork (); } } else { http . createServer (( req , res ) => { res . writeHead ( 200 ); res . end ( 'hello world\\n' ); }). listen ( 8888 ); } \u4ee5\u4e0a\u4ee3\u7801\u5728\u7b2c\u4e00\u6b21\u6267\u884c\u7684\u65f6\u5019\uff0ccluster.isMaster\u4e3atrue\uff0c\u8bf4\u660e\u662f\u4e3b\u8fdb\u7a0b\uff0c\u7136\u540e\u901a\u8fc7fork\u8c03\u7528\u521b\u5efa\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u5728\u5b50\u8fdb\u7a0b\u91cc\u540c\u6837\u6267\u884c\u4ee5\u4e0a\u4ee3\u7801\uff0c\u4f46\u662fcluster.isMaster\u4e3afalse\uff0c\u4ece\u800c\u6267\u884celse\u7684\u903b\u8f91\uff0c\u6211\u4eec\u770b\u5230\u6bcf\u4e2a\u5b50\u8fdb\u7a0b\u90fd\u4f1a\u76d1\u542c8888\u8fd9\u4e2a\u7aef\u53e3\u4f46\u662f\u53c8\u4e0d\u4f1a\u5f15\u8d77EADDRINUSE\u9519\u8bef\u3002\u4e0b\u9762\u6211\u4eec\u6765\u5206\u6790\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002","title":"15.1 cluster\u4f7f\u7528\u4f8b\u5b50"},{"location":"chapter15-Cluster/#152","text":"\u6211\u4eec\u5148\u770b\u4e3b\u8fdb\u7a0b\u65f6\u7684\u903b\u8f91\u3002\u6211\u4eec\u770b\u4e00\u4e0brequire(\u2018cluster\u2019)\u7684\u65f6\u5019\uff0cNode.js\u662f\u600e\u4e48\u5904\u7406\u7684\u3002 1 2 const childOrMaster = 'NODE_UNIQUE_ID' in process . env ? 'child' : 'master' ; module . exports = require ( `internal/cluster/ ${ childOrMaster } ` ) \u6211\u4eec\u770b\u5230Node.js\u4f1a\u6839\u636e\u5f53\u524d\u73af\u5883\u53d8\u91cf\u7684\u503c\u52a0\u8f7d\u4e0d\u540c\u7684\u6a21\u5757\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u770b\u5230NODE_UNIQUE_ID\u662f\u4e3b\u8fdb\u7a0b\u7ed9\u5b50\u8fdb\u7a0b\u8bbe\u7f6e\u7684\uff0c\u5728\u4e3b\u8fdb\u7a0b\u4e2d\uff0cNODE_UNIQUE_ID\u662f\u4e0d\u5b58\u5728\u7684\uff0c\u6240\u4ee5\u4e3b\u8fdb\u7a0b\u65f6\uff0c\u4f1a\u52a0\u8f7dmaster\u6a21\u5757\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 cluster . isWorker = false ; cluster . isMaster = true ; // \u8c03\u5ea6\u7b56\u7565 cluster . SCHED_NONE = SCHED_NONE ; cluster . SCHED_RR = SCHED_RR ; // \u8c03\u5ea6\u7b56\u7565\u7684\u9009\u62e9 let schedulingPolicy = { 'none' : SCHED_NONE , 'rr' : SCHED_RR }[ process . env . NODE_CLUSTER_SCHED_POLICY ]; if ( schedulingPolicy === undefined ) { schedulingPolicy = ( process . platform === 'win32' ) ? SCHED_NONE : SCHED_RR ; } cluster . schedulingPolicy = schedulingPolicy ; // \u521b\u5efa\u5b50\u8fdb\u7a0b cluster . fork = function ( env ) { // \u53c2\u6570\u5904\u7406 cluster . setupMaster (); const id = ++ ids ; // \u8c03\u7528child_process\u6a21\u5757\u7684fork const workerProcess = createWorkerProcess ( id , env ); const worker = new Worker ({ id : id , process : workerProcess }); // ... worker . process . on ( 'internalMessage' , internal ( worker , onmessage )); process . nextTick ( emitForkNT , worker ); cluster . workers [ worker . id ] = worker ; return worker ; }; cluster.fork\u662f\u5bf9child_process\u6a21\u5757fork\u7684\u5c01\u88c5\uff0c\u6bcf\u6b21cluster.fork\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u65b0\u5efa\u4e00\u4e2a\u5b50\u8fdb\u7a0b\uff0c\u6240\u4ee5cluster\u4e0b\u9762\u4f1a\u6709\u591a\u4e2a\u5b50\u8fdb\u7a0b\uff0cNode.js\u63d0\u4f9b\u7684\u5de5\u4f5c\u6a21\u5f0f\u6709\u8f6e\u8be2\u548c\u5171\u4eab\u4e24\u79cd\uff0c\u4e0b\u9762\u4f1a\u5177\u4f53\u4ecb\u7ecd\u3002Worker\u662f\u5bf9\u5b50\u8fdb\u7a0b\u7684\u5c01\u88c5\uff0c\u901a\u8fc7process\u6301\u6709\u5b50\u8fdb\u7a0b\u7684\u5b9e\u4f8b\uff0c\u5e76\u901a\u8fc7\u76d1\u542cinternalMessage\u548cmessage\u4e8b\u4ef6\u5b8c\u6210\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u7684\u901a\u4fe1\uff0cinternalMessage\u8fd9\u662fNode.js\u5b9a\u4e49\u7684\u5185\u90e8\u901a\u4fe1\u4e8b\u4ef6\uff0c\u5904\u7406\u51fd\u6570\u662finternal(worker, onmessage)\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0binternal\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const callbacks = new Map (); let seq = 0 ; function internal ( worker , cb ) { return function onInternalMessage ( message , handle ) { if ( message . cmd !== 'NODE_CLUSTER' ) return ; let fn = cb ; if ( message . ack !== undefined ) { const callback = callbacks . get ( message . ack ); if ( callback !== undefined ) { fn = callback ; callbacks . delete ( message . ack ); } } fn . apply ( worker , arguments ); }; } internal\u51fd\u6570\u5bf9\u5f02\u6b65\u6d88\u606f\u901a\u4fe1\u505a\u4e86\u4e00\u5c42\u5c01\u88c5\uff0c\u56e0\u4e3a\u8fdb\u7a0b\u95f4\u901a\u4fe1\u662f\u5f02\u6b65\u7684\uff0c\u5f53\u6211\u4eec\u53d1\u9001\u591a\u4e2a\u6d88\u606f\u540e\uff0c\u5982\u679c\u6536\u5230\u4e00\u4e2a\u56de\u590d\uff0c\u6211\u4eec\u65e0\u6cd5\u8fa8\u522b\u51fa\u8be5\u56de\u590d\u662f\u9488\u5bf9\u54ea\u4e00\u4e2a\u8bf7\u6c42\u7684\uff0cNode.js\u901a\u8fc7seq\u7684\u65b9\u5f0f\u5bf9\u6bcf\u4e00\u4e2a\u8bf7\u6c42\u548c\u54cd\u5e94\u505a\u4e86\u4e00\u4e2a\u7f16\u53f7\uff0c\u4ece\u800c\u533a\u5206\u54cd\u5e94\u5bf9\u5e94\u7684\u8bf7\u6c42\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bmessage\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function onmessage ( message , handle ) { const worker = this ; if ( message . act === 'online' ) online ( worker ); else if ( message . act === 'queryServer' ) queryServer ( worker , message ); else if ( message . act === 'listening' ) listening ( worker , message ); else if ( message . act === 'exitedAfterDisconnect' ) exitedAfterDisconnect ( worker , message ); else if ( message . act === 'close' ) close ( worker , message ); } onmessage\u6839\u636e\u6536\u5230\u6d88\u606f\u7684\u4e0d\u540c\u7c7b\u578b\u8fdb\u884c\u76f8\u5e94\u7684\u5904\u7406\u3002\u540e\u9762\u6211\u4eec\u518d\u5177\u4f53\u5206\u6790\u3002\u81f3\u6b64\uff0c\u4e3b\u8fdb\u7a0b\u7684\u903b\u8f91\u5c31\u5206\u6790\u5b8c\u4e86\u3002","title":"15.2 \u4e3b\u8fdb\u7a0b\u521d\u59cb\u5316"},{"location":"chapter15-Cluster/#153","text":"\u6211\u4eec\u6765\u770b\u4e00\u4e0b\u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\u3002\u5f53\u6267\u884c\u5b50\u8fdb\u7a0b\u65f6\uff0c\u4f1a\u52a0\u8f7dchild\u6a21\u5757\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const cluster = new EventEmitter (); const handles = new Map (); const indexes = new Map (); const noop = () => {}; module . exports = cluster ; cluster . isWorker = true ; cluster . isMaster = false ; cluster . worker = null ; cluster . Worker = Worker ; cluster . _setupWorker = function () { const worker = new Worker ({ id : + process . env . NODE_UNIQUE_ID | 0 , process : process , state : 'online' }); cluster . worker = worker ; process . on ( 'internalMessage' , internal ( worker , onmessage )); // \u901a\u77e5\u4e3b\u8fdb\u7a0b\u5b50\u8fdb\u7a0b\u542f\u52a8\u6210\u529f send ({ act : 'online' }); function onmessage ( message , handle ) { if ( message . act === 'newconn' ) onconnection ( message , handle ); else if ( message . act === 'disconnect' ) _disconnect . call ( worker , true ); } }; _setupWorker\u51fd\u6570\u5728\u5b50\u8fdb\u7a0b\u521d\u59cb\u5316\u65f6\u88ab\u6267\u884c\uff0c\u548c\u4e3b\u8fdb\u7a0b\u7c7b\u4f3c\uff0c\u5b50\u8fdb\u7a0b\u7684\u903b\u8f91\u4e5f\u4e0d\u591a\uff0c\u76d1\u542cinternalMessage\u4e8b\u4ef6\uff0c\u5e76\u4e14\u901a\u77e5\u4e3b\u7ebf\u7a0b\u81ea\u5df1\u542f\u52a8\u6210\u529f\u3002","title":"15.3 \u5b50\u8fdb\u7a0b\u521d\u59cb\u5316"},{"location":"chapter15-Cluster/#154-httpcreateserver","text":"\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u6267\u884c\u5b8c\u521d\u59cb\u5316\u4ee3\u7801\u540e\uff0c\u5b50\u8fdb\u7a0b\u5f00\u59cb\u6267\u884c\u4e1a\u52a1\u4ee3\u7801http.createServer\uff0c\u5728HTTP\u6a21\u5757\u7ae0\u8282\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7http.createServer\u7684\u8fc7\u7a0b\uff0c\u8fd9\u91cc\u5c31\u4e0d\u5177\u4f53\u5206\u6790\uff0c\u6211\u4eec\u77e5\u9053http.createServer\u6700\u540e\u4f1a\u8c03\u7528net\u6a21\u5757\u7684listen\uff0c\u7136\u540e\u8c03\u7528listenIncluster\u3002\u6211\u4eec\u4ece\u8be5\u51fd\u6570\u5f00\u59cb\u5206\u6790\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 function listenIncluster ( server , address , port , addressType , backlog , fd , exclusive , flags ) { const serverQuery = { address : address , port : port , addressType : addressType , fd : fd , flags , }; cluster . _getServer ( server , serverQuery , listenOnMasterHandle ); function listenOnMasterHandle ( err , handle ) { err = checkBindError ( err , port , handle ); if ( err ) { const ex = exceptionWithHostPort ( err , 'bind' , address , port ); return server . emit ( 'error' , ex ); } server . _handle = handle ; server . _listen2 ( address , port , addressType , backlog , fd , flags ); } } listenIncluster\u51fd\u6570\u4f1a\u8c03\u7528\u5b50\u8fdb\u7a0bcluster\u6a21\u5757\u7684_getServer\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 cluster . _getServer = function ( obj , options , cb ) { let address = options . address ; // \u5ffd\u7565index\u7684\u5904\u7406\u903b\u8f91 const message = { act : 'queryServer' , index , data : null , ... options }; message . address = address ; // \u7ed9\u4e3b\u8fdb\u7a0b\u53d1\u9001\u6d88\u606f send ( message , ( reply , handle ) => { // \u6839\u636e\u4e0d\u540c\u6a21\u5f0f\u505a\u5904\u7406 if ( handle ) shared ( reply , handle , indexesKey , cb ); else rr ( reply , indexesKey , cb ); }); }; _getServer\u4f1a\u7ed9\u4e3b\u8fdb\u7a0b\u53d1\u9001\u4e00\u4e2aqueryServer\u7684\u8bf7\u6c42\u3002\u6211\u4eec\u770b\u4e00\u4e0bsend\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function send ( message , cb ) { return sendHelper ( process , message , null , cb ); } function sendHelper ( proc , message , handle , cb ) { if ( ! proc . connected ) return false ; message = { cmd : 'NODE_CLUSTER' , ... message , seq }; if ( typeof cb === 'function' ) callbacks . set ( seq , cb ); seq += 1 ; return proc . send ( message , handle ); } send\u8c03\u7528\u4e86sendHelper\uff0csendHelper\u662f\u5bf9\u5f02\u6b65\u8bf7\u6c42\u505a\u4e86\u4e00\u4e2a\u5c01\u88c5\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u4e3b\u8fdb\u7a0b\u662f\u5982\u4f55\u5904\u7406queryServer\u8bf7\u6c42\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 function queryServer ( worker , message ) { const key = ` ${ message . address } : ${ message . port } : ${ message . addressType } :` + ` ${ message . fd } : ${ message . index } ` ; let handle = handles . get ( key ); if ( handle === undefined ) { let address = message . address ; let constructor = RoundRobinHandle ; // \u6839\u636e\u7b56\u7565\u9009\u53d6\u4e0d\u540c\u7684\u6784\u9020\u51fd\u6570 if ( schedulingPolicy !== SCHED_RR || message . addressType === 'udp4' || message . addressType === 'udp6' ) { constructor = SharedHandle ; } handle = new constructor ( key , address , message . port , message . addressType , message . fd , message . flags ); handles . set ( key , handle ); } handle . add ( worker , ( errno , reply , handle ) => { const { data } = handles . get ( key ); send ( worker , { errno , key , ack : message . seq , data , ... reply }, handle ); }); } queryServer\u9996\u5148\u6839\u636e\u8c03\u5ea6\u7b56\u7565\u9009\u62e9\u6784\u9020\u51fd\u6570\uff0c\u7136\u540e\u6267\u884c\u5bf9\u5e94\u7684add\u65b9\u6cd5\u5e76\u4e14\u4f20\u5165\u4e00\u4e2a\u56de\u8c03\u3002\u4e0b\u9762\u6211\u4eec\u770b\u770b\u4e0d\u540c\u6a21\u5f0f\u4e0b\u7684\u5904\u7406\u3002","title":"15.4 http.createServer\u7684\u5904\u7406"},{"location":"chapter15-Cluster/#155","text":"\u4e0b\u9762\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5171\u4eab\u6a21\u5f0f\u7684\u5904\u7406\uff0c\u903b\u8f91\u5982\u56fe19-1\u6240\u793a\u3002 \u56fe19-1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 function SharedHandle ( key , address , port , addressType , fd , flags ) { this . key = key ; this . workers = []; this . handle = null ; this . errno = 0 ; let rval ; if ( addressType === 'udp4' || addressType === 'udp6' ) rval = dgram . _createSocketHandle ( address , port , addressType , fd , flags ); else rval = net . _createServerHandle ( address , port , addressType , fd , flags ); if ( typeof rval === 'number' ) this . errno = rval ; else this . handle = rval ; } SharedHandle\u662f\u5171\u4eab\u6a21\u5f0f\uff0c\u5373\u4e3b\u8fdb\u7a0b\u521b\u5efa\u597dhandle\uff0c\u4ea4\u7ed9\u5b50\u8fdb\u7a0b\u5904\u7406\u3002 1 2 3 4 SharedHandle.prototype.add = function(worker, send) { this.workers.push(worker); send(this.errno, null, this.handle); }; SharedHandle\u7684add\u628aSharedHandle\u4e2d\u521b\u5efa\u7684handle\u8fd4\u56de\u7ed9\u5b50\u8fdb\u7a0b\uff0c\u63a5\u7740\u6211\u4eec\u770b\u770b\u5b50\u8fdb\u7a0b\u62ff\u5230handle\u540e\u7684\u5904\u7406 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function shared ( message , handle , indexesKey , cb ) { const key = message . key ; const close = handle . close ; handle . close = function () { send ({ act : 'close' , key }); handles . delete ( key ); indexes . delete ( indexesKey ); return close . apply ( handle , arguments ); }; handles . set ( key , handle ); // \u6267\u884cnet\u6a21\u5757\u7684\u56de\u8c03 cb ( message . errno , handle ); } Shared\u51fd\u6570\u628a\u63a5\u6536\u5230\u7684handle\u518d\u56de\u4f20\u5230\u8c03\u7528\u65b9\u3002\u5373net\u6a21\u5757\u3002net\u6a21\u5757\u4f1a\u6267\u884clisten\u5f00\u59cb\u76d1\u542c\u5730\u5740\uff0c\u4f46\u662f\u6709\u8fde\u63a5\u5230\u6765\u65f6\uff0c\u7cfb\u7edf\u53ea\u4f1a\u6709\u4e00\u4e2a\u8fdb\u7a0b\u62ff\u5230\u8be5\u8fde\u63a5\u3002\u6240\u4ee5\u6240\u6709\u5b50\u8fdb\u7a0b\u5b58\u5728\u7ade\u4e89\u5173\u7cfb\u5bfc\u81f4\u8d1f\u8f7d\u4e0d\u5747\u8861\uff0c\u8fd9\u53d6\u51b3\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u7684\u5b9e\u73b0\u3002 \u5171\u4eab\u6a21\u5f0f\u5b9e\u73b0\u7684\u6838\u5fc3\u903b\u8f91\u4e3b\u8fdb\u7a0b\u5728_createServerHandle\u521b\u5efahandle\u65f6\u6267\u884cbind\u7ed1\u5b9a\u4e86\u5730\u5740\uff08\u4f46\u6ca1\u6709listen\uff09\uff0c\u7136\u540e\u901a\u8fc7\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7684\u65b9\u5f0f\u4f20\u7ed9\u5b50\u8fdb\u7a0b\uff0c\u5b50\u8fdb\u7a0b\u6267\u884clisten\u7684\u65f6\u5019\u5c31\u4e0d\u4f1a\u62a5\u7aef\u53e3\u5df2\u7ecf\u88ab\u76d1\u542c\u7684\u9519\u8bef\u4e86\u3002\u56e0\u4e3a\u7aef\u53e3\u88ab\u76d1\u542c\u7684\u9519\u8bef\u662f\u6267\u884cbind\u7684\u65f6\u5019\u8fd4\u56de\u7684\u3002","title":"15.5 \u5171\u4eab\u6a21\u5f0f"},{"location":"chapter15-Cluster/#156","text":"\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bRoundRobinHandle\u7684\u5904\u7406\uff0c\u903b\u8f91\u5982\u56fe19-2\u6240\u793a\u3002 \u56fe19-2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function RoundRobinHandle ( key , address , port , addressType , fd , flags ) { this . key = key ; this . all = new Map (); this . free = []; this . handles = []; this . handle = null ; this . server = net . createServer ( assert . fail ); if ( fd >= 0 ) this . server . listen ({ fd }); else if ( port >= 0 ) { this . server . listen ({ port , host : address , ipv6Only : Boolean ( flags & constants . UV_TCP_IPV6ONLY ), }); } else this . server . listen ( address ); // UNIX socket path. // \u76d1\u542c\u6210\u529f\u540e\uff0c\u6ce8\u518conconnection\u56de\u8c03\uff0c\u6709\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c this . server . once ( 'listening' , () => { this . handle = this . server . _handle ; this . handle . onconnection = ( err , handle ) => this . distribute ( err , handle ); this . server . _handle = null ; this . server = null ; }); } RoundRobinHandle\u7684\u5de5\u4f5c\u6a21\u5f0f\u662f\u4e3b\u8fdb\u7a0b\u8d1f\u8d23\u76d1\u542c\uff0c\u6536\u5230\u8fde\u63a5\u540e\u5206\u53d1\u7ed9\u5b50\u8fdb\u7a0b\u3002\u6211\u4eec\u770b\u4e00\u4e0bRoundRobinHandle\u7684add 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 RoundRobinHandle . prototype . add = function ( worker , send ) { this . all . set ( worker . id , worker ); const done = () => { if ( this . handle . getsockname ) { const out = {}; this . handle . getsockname ( out ); send ( null , { sockname : out }, null ); } else { send ( null , null , null ); // UNIX socket. } // In case there are connections pending. this . handoff ( worker ); }; // \u8bf4\u660elisten\u6210\u529f\u4e86 if ( this . server === null ) return done (); // \u5426\u5219\u7b49\u5f85listen\u6210\u529f\u540e\u6267\u884c\u56de\u8c03 this . server . once ( 'listening' , done ); this . server . once ( 'error' , ( err ) => { send ( err . errno , null ); }); }; RoundRobinHandle\u4f1a\u5728listen\u6210\u529f\u540e\u6267\u884c\u56de\u8c03\u3002\u6211\u4eec\u56de\u987e\u4e00\u4e0b\u6267\u884cadd\u51fd\u6570\u65f6\u7684\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 handle . add ( worker , ( errno , reply , handle ) => { const { data } = handles . get ( key ); send ( worker , { errno , key , ack : message . seq , data , ... reply }, handle ); }); \u56de\u8c03\u51fd\u6570\u4f1a\u628ahandle\u7b49\u4fe1\u606f\u8fd4\u56de\u7ed9\u5b50\u8fdb\u7a0b\u3002\u4f46\u662f\u5728RoundRobinHandle\u548cSharedHandle\u4e2d\u8fd4\u56de\u7684handle\u662f\u4e0d\u4e00\u6837\u7684\u3002\u5206\u522b\u662fnull\u548cnet.createServer\u5b9e\u4f8b\u3002\u63a5\u7740\u6211\u4eec\u56de\u5230\u5b50\u8fdb\u7a0b\u7684\u4e0a\u4e0b\u6587\u3002\u770b\u5b50\u8fdb\u7a0b\u662f\u5982\u4f55\u5904\u7406\u54cd\u5e94\u7684\u3002\u521a\u624d\u6211\u4eec\u8bb2\u8fc7\uff0c\u4e0d\u540c\u7684\u8c03\u5ea6\u7b56\u7565\uff0c\u8fd4\u56de\u7684handle\u662f\u4e0d\u4e00\u6837\u7684\uff0c\u6211\u4eec\u770b\u8f6e\u8be2\u6a21\u5f0f\u4e0b\u7684\u5904\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function rr ( message , indexesKey , cb ) { let key = message . key ; function listen ( backlog ) { return 0 ; } function close () { // ... } const handle = { close , listen , ref : noop , unref : noop }; if ( message . sockname ) { handle . getsockname = getsockname ; // TCP handles only. } handles . set ( key , handle ); // \u6267\u884cnet\u6a21\u5757\u7684\u56de\u8c03 cb ( 0 , handle ); } round-robin\u6a21\u5f0f\u4e0b\uff0c\u6784\u9020\u4e00\u4e2a\u5047\u7684handle\u8fd4\u56de\u7ed9\u8c03\u7528\u65b9\uff0c\u56e0\u4e3a\u8c03\u7528\u65b9\u4f1a\u8c03\u7528\u8fd9\u4e9b\u51fd\u6570\u3002\u6700\u540e\u56de\u5230net\u6a21\u5757\u3002net\u6a21\u5757\u9996\u5148\u4fdd\u5b58handle\uff0c\u7136\u540e\u8c03\u7528listen\u51fd\u6570\u3002\u5f53\u6709\u8bf7\u6c42\u5230\u6765\u65f6\uff0cround-bobin\u6a21\u5757\u4f1a\u6267\u884cdistribute\u5206\u53d1\u8bf7\u6c42\u7ed9\u5b50\u8fdb\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 RoundRobinHandle . prototype . distribute = function ( err , handle ) { // \u9996\u5148\u4fdd\u5b58handle\u5230\u961f\u5217 this . handles . push ( handle ); // \u4ece\u7a7a\u95f2\u961f\u5217\u83b7\u53d6\u4e00\u4e2a\u5b50\u8fdb\u7a0b const worker = this . free . shift (); // \u5206\u53d1 if ( worker ) this . handoff ( worker ); }; RoundRobinHandle . prototype . handoff = function ( worker ) { // \u62ff\u5230\u4e00\u4e2ahandle const handle = this . handles . shift (); // \u6ca1\u6709handle\uff0c\u5219\u5b50\u8fdb\u7a0b\u91cd\u65b0\u5165\u961f if ( handle === undefined ) { this . free . push ( worker ); // Add to ready queue again. return ; } // \u901a\u77e5\u5b50\u8fdb\u7a0b\u6709\u65b0\u8fde\u63a5 const message = { act : 'newconn' , key : this . key }; sendHelper ( worker . process , message , handle , ( reply ) => { // \u63a5\u6536\u6210\u529f if ( reply . accepted ) handle . close (); else // \u7ed3\u675f\u5931\u8d25\uff0c\u5219\u91cd\u65b0\u5206\u53d1 this . distribute ( 0 , handle ); // Worker is shutting down. Send to another. this . handoff ( worker ); }); }; \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u5b50\u8fdb\u7a0b\u662f\u600e\u4e48\u5904\u7406\u8be5\u8bf7\u6c42\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function onmessage ( message , handle ) { if ( message . act === 'newconn' ) onconnection ( message , handle ); } function onconnection ( message , handle ) { const key = message . key ; const server = handles . get ( key ); const accepted = server !== undefined ; // \u56de\u590d\u63a5\u6536\u6210\u529f send ({ ack : message . seq , accepted }); if ( accepted ) // \u5728net\u6a21\u5757\u8bbe\u7f6e server . onconnection ( 0 , handle ); } \u6211\u4eec\u770b\u5230\u5b50\u8fdb\u7a0b\u4f1a\u6267\u884cserver.onconnection\uff0c\u8fd9\u4e2a\u548c\u6211\u4eec\u5206\u6790net\u6a21\u5757\u65f6\u89e6\u53d1onconnection\u4e8b\u4ef6\u662f\u4e00\u6837\u7684\u3002","title":"15.6 \u8f6e\u8be2\u6a21\u5f0f"},{"location":"chapter15-Cluster/#157cluster","text":"Node.js\u7684cluster\u5728\u8bf7\u6c42\u5206\u53d1\u65f6\u662f\u6309\u7167\u8f6e\u8be2\u7684\uff0c\u65e0\u6cd5\u6839\u636e\u8fdb\u7a0b\u5f53\u524d\u60c5\u51b5\u505a\u76f8\u5e94\u7684\u5904\u7406\u3002\u4e86\u89e3\u4e86cluster\u6a21\u5757\u7684\u539f\u7406\u540e\uff0c\u6211\u4eec\u81ea\u5df1\u6765\u5b9e\u73b0\u4e00\u4e2acluster\u6a21\u5757\u3002","title":"15.7\u5b9e\u73b0\u81ea\u5df1\u7684cluster\u6a21\u5757"},{"location":"chapter15-Cluster/#1571","text":"\u6574\u4f53\u67b6\u6784\u5982\u56fe15-3\u6240\u793a\u3002 \u56fe15-3 Parent.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const childProcess = require ( 'child_process' ); const net = require ( 'net' ); const workers = []; const workerNum = 10 ; let index = 0 ; for ( let i = 0 ; i < workerNum ; i ++ ) { workers . push ( childProcess . fork ( 'child.js' , { env : { index : i }})); } const server = net . createServer (( client ) => { workers [ index ]. send ( null , client ); console . log ( 'dispatch to' , index ); index = ( index + 1 ) % workerNum ; }); server . listen ( 11111 ); child.js 1 2 3 process . on ( 'message' , ( message , client ) => { console . log ( 'receive connection from master' ); }); \u4e3b\u8fdb\u7a0b\u8d1f\u8d23\u76d1\u542c\u8bf7\u6c42\uff0c\u4e3b\u8fdb\u7a0b\u6536\u5230\u8bf7\u6c42\u540e\uff0c\u6309\u7167\u4e00\u5b9a\u7684\u7b97\u6cd5\u628a\u8bf7\u6c42\u901a\u8fc7\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u65b9\u5f0f\u4f20\u7ed9worker\u8fdb\u7a0b\uff0cworker\u8fdb\u7a0b\u5c31\u53ef\u4ee5\u5904\u7406\u8fde\u63a5\u4e86\u3002\u5728\u5206\u53d1\u7b97\u6cd5\u8fd9\u91cc\uff0c\u6211\u4eec\u53ef\u4ee5\u6839\u636e\u81ea\u5df1\u7684\u9700\u6c42\u8fdb\u884c\u81ea\u5b9a\u4e49\uff0c\u6bd4\u5982\u6839\u636e\u5f53\u524d\u8fdb\u7a0b\u7684\u8d1f\u8f7d\uff0c\u6b63\u5728\u5904\u7406\u7684\u8fde\u63a5\u6570\u3002","title":"15.7.1 \u8f6e\u8be2\u6a21\u5f0f"},{"location":"chapter15-Cluster/#1572","text":"\u6574\u4f53\u67b6\u6784\u5982\u56fe15-4\u6240\u793a\u3002 \u56fe15-4 Parent.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const childProcess = require ( 'child_process' ); const net = require ( 'net' ); const workers = []; const workerNum = 10 ; const handle = net . _createServerHandle ( '127.0.0.1' , 11111 , 4 ); for ( let i = 0 ; i < workerNum ; i ++ ) { const worker = childProcess . fork ( 'child.js' , { env : { index : i }}); workers . push ( worker ); worker . send ( null , handle ); /* \u9632\u6b62\u6587\u4ef6\u63cf\u8ff0\u7b26\u6cc4\u6f0f\uff0c\u4f46\u662f\u91cd\u65b0fork\u5b50\u8fdb\u7a0b\u7684\u65f6\u5019\u5c31\u65e0\u6cd5 \u518d\u4f20\u9012\u4e86\u6587\u4ef6\u63cf\u8ff0\u7b26\u4e86 */ handle . close (); } Child.js 1 2 3 4 5 6 const net = require ( 'net' ); process . on ( 'message' , ( message , handle ) => { net . createServer (() => { console . log ( process . env . index , 'receive connection' ); }). listen ({ handle }); }); \u6211\u4eec\u770b\u5230\u4e3b\u8fdb\u7a0b\u8d1f\u8d23\u7ed1\u5b9a\u7aef\u53e3\uff0c\u7136\u540e\u628ahandle\u4f20\u7ed9worker\u8fdb\u7a0b\uff0cworker\u8fdb\u7a0b\u5404\u81ea\u6267\u884clisten\u76d1\u542csocket\u3002\u5f53\u6709\u8fde\u63a5\u5230\u6765\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u9009\u62e9\u67d0\u4e00\u4e2aworker\u8fdb\u7a0b\u5904\u7406\u8be5\u8fde\u63a5\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5171\u4eab\u6a21\u5f0f\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7684\u67b6\u6784\uff0c\u5982\u56fe15-5\u6240\u793a\u3002 \u56fe15-5 \u5b9e\u73b0\u5171\u4eab\u6a21\u5f0f\u7684\u91cd\u70b9\u5728\u4e8e\u7406\u89e3EADDRINUSE\u9519\u8bef\u662f\u600e\u4e48\u6765\u7684\u3002\u5f53\u4e3b\u8fdb\u7a0b\u6267\u884cbind\u7684\u65f6\u5019\uff0c\u7ed3\u6784\u5982\u56fe15-6\u6240\u793a\u3002 \u56fe15-6 \u5982\u679c\u5176\u5b83\u8fdb\u7a0b\u4e5f\u6267\u884cbind\u5e76\u4e14\u7aef\u53e3\u4e5f\u4e00\u6837\uff0c\u5219\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u544a\u8bc9\u6211\u4eec\u7aef\u53e3\u5df2\u7ecf\u88ab\u76d1\u542c\u4e86\uff08EADDRINUSE\uff09\u3002\u4f46\u662f\u5982\u679c\u6211\u4eec\u5728\u5b50\u8fdb\u7a0b\u91cc\u4e0d\u6267\u884cbind\u7684\u8bdd\uff0c\u5c31\u53ef\u4ee5\u7ed5\u8fc7\u8fd9\u4e2a\u9650\u5236\u3002\u90a3\u4e48\u91cd\u70b9\u5728\u4e8e\uff0c\u5982\u4f55\u5728\u5b50\u8fdb\u7a0b\u4e2d\u4e0d\u6267\u884cbind\uff0c\u4f46\u662f\u53c8\u53ef\u4ee5\u7ed1\u5b9a\u5230\u540c\u6837\u7684\u7aef\u53e3\u5462\uff1f\u6709\u4e24\u79cd\u65b9\u5f0f\u3002 1 fork \u6211\u4eec\u77e5\u9053fork\u7684\u65f6\u5019\uff0c\u5b50\u8fdb\u7a0b\u4f1a\u7ee7\u627f\u4e3b\u8fdb\u7a0b\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0c\u5982\u56fe15-7\u6240\u793a\u3002 \u56fe15-7 \u8fd9\u65f6\u5019\uff0c\u4e3b\u8fdb\u7a0b\u53ef\u4ee5\u6267\u884cbind\u548clisten\uff0c\u7136\u540efork\u5b50\u8fdb\u7a0b\uff0c\u6700\u540eclose\u6389\u81ea\u5df1\u7684fd\uff0c\u8ba9\u6240\u6709\u7684\u8fde\u63a5\u90fd\u7531\u5b50\u8fdb\u7a0b\u5904\u7406\u5c31\u884c\u3002\u4f46\u662f\u5728Node.js\u4e2d\uff0c\u6211\u4eec\u65e0\u6cd5\u5b9e\u73b0\uff0c\u6240\u4ee5\u8fd9\u79cd\u65b9\u5f0f\u4e0d\u80fd\u6ee1\u8db3\u9700\u6c42\u3002 2 \u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012 Node.js\u7684\u5b50\u8fdb\u7a0b\u662f\u901a\u8fc7fork+exec\u6a21\u5f0f\u521b\u5efa\u7684\uff0c\u5e76\u4e14Node.js\u6587\u4ef6\u63cf\u8ff0\u7b26\u8bbe\u7f6e\u4e86close_on_exec\u6807\u8bb0\uff0c\u8fd9\u5c31\u610f\u5473\u7740\uff0c\u5728Node.js\u4e2d\uff0c\u521b\u5efa\u5b50\u8fdb\u7a0b\u540e\uff0c\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u7ed3\u6784\u4f53\u5982\u56fe15-8\u6240\u793a\uff08\u6709\u6807\u51c6\u8f93\u5165\u3001\u6807\u51c6\u8f93\u51fa\u3001\u6807\u51c6\u9519\u8bef\u4e09\u4e2afd\uff09\u3002 \u56fe15-8 \u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f20\u9012\u7684\u65b9\u5f0f\u3002\u628a\u65b9\u5f0f1\u4e2d\u62ff\u4e0d\u5230\u7684fd\u4f20\u7ed9\u5b50\u8fdb\u7a0b\u3002\u56e0\u4e3a\u5728Node.js\u4e2d\uff0c\u867d\u7136\u6211\u4eec\u62ff\u4e0d\u5230fd\uff0c\u4f46\u662f\u6211\u4eec\u53ef\u4ee5\u62ff\u5f97\u5230fd\u5bf9\u5e94\u7684handle\uff0c\u6211\u4eec\u901a\u8fc7IPC\u4f20\u8f93handle\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u4e3a\u6211\u4eec\u5904\u7406fd\u7684\u95ee\u9898\u3002\u6700\u540e\u901a\u8fc7\u64cd\u4f5c\u7cfb\u7edf\u5bf9\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\u7684\u5904\u7406\u3002\u7ed3\u6784\u5982\u56fe15-9\u6240\u793a\u3002 \u56fe15-9 \u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\uff0c\u6211\u4eec\u5c31\u7ed5\u8fc7\u4e86bind\u540c\u4e00\u4e2a\u7aef\u53e3\u7684\u95ee\u9898\u3002\u901a\u8fc7\u4ee5\u4e0a\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u77e5\u9053\u7ed5\u8fc7bind\u7684\u95ee\u9898\u91cd\u70b9\u5728\u4e8e\u8ba9\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u5171\u4eabsocket\u800c\u4e0d\u662f\u5355\u72ec\u6267\u884cbind\u3002\u5bf9\u4e8e\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\uff0cNode.js\u4e2d\u652f\u6301\u5f88\u591a\u79cd\u65b9\u5f0f\u3002\u4e0a\u9762\u7684\u65b9\u5f0f\u662f\u5b50\u8fdb\u7a0b\u5404\u81ea\u6267\u884clisten\u3002\u8fd8\u6709\u53e6\u4e00\u79cd\u6a21\u5f0f\u5982\u4e0b parent.js 1 2 3 4 5 6 7 8 9 10 11 12 13 const childProcess = require ( 'child_process' ); const net = require ( 'net' ); const workers = []; const workerNum = 10 ; const server = net . createServer (() => { console . log ( 'master receive connection' ); }) server . listen ( 11111 ); for ( let i = 0 ; i < workerNum ; i ++ ) { const worker = childProcess . fork ( 'child.js' , { env : { index : i }}); workers . push ( worker ); worker . send ( null , server ); } child.js 1 2 3 4 5 6 const net = require ( 'net' ); process . on ( 'message' , ( message , server ) => { server . on ( 'connection' , () => { console . log ( process . env . index , 'receive connection' ); }) }); \u4e0a\u9762\u7684\u65b9\u5f0f\u4e2d\uff0c\u4e3b\u8fdb\u7a0b\u5b8c\u6210\u4e86bind\u548clisten\u3002\u7136\u540e\u628aserver\u5b9e\u4f8b\u4f20\u7ed9\u5b50\u8fdb\u7a0b\uff0c\u5b50\u8fdb\u7a0b\u5c31\u53ef\u4ee5\u76d1\u542c\u8fde\u63a5\u7684\u5230\u6765\u4e86\u3002\u8fd9\u65f6\u5019\u4e3b\u8fdb\u7a0b\u548c\u5b50\u8fdb\u7a0b\u90fd\u53ef\u4ee5\u5904\u7406\u8fde\u63a5\u3002 \u6700\u540e\u5199\u4e00\u4e2a\u5ba2\u6237\u7aef\u6d4b\u8bd5\u3002 \u5ba2\u6237\u7aef 1 2 3 4 const net = require ( 'net' ); for ( let i = 0 ; i < 50 ; i ++ ) { net . connect ({ port : 11111 }); } \u6267\u884cclient\u6211\u4eec\u5c31\u53ef\u4ee5\u770b\u5230\u591a\u8fdb\u7a0b\u5904\u7406\u8fde\u63a5\u7684\u60c5\u51b5\u3002","title":"15.7.2 \u5171\u4eab\u6a21\u5f0f"},{"location":"chapter16-UDP/","text":"\u672c\u7ae0\u4ecb\u7ecdNode.js\u4e2d\u7684UDP\u6a21\u5757\uff0cUDP\u662f\u4f20\u8f93\u5c42\u975e\u9762\u5411\u8fde\u63a5\u7684\u4e0d\u53ef\u9760\u534f\u8bae\uff0c\u4f7f\u7528UDP\u65f6,\u4e0d\u9700\u8981\u5efa\u7acb\u8fde\u63a5\u5c31\u53ef\u4ee5\u5f80\u5bf9\u7aef\u76f4\u63a5\u53d1\u9001\u6570\u636e\uff0c\u51cf\u5c11\u4e86\u4e09\u6b21\u63e1\u624b\u5e26\u6765\u7684\u65f6\u5ef6\uff0c\u4f46\u662fUDP\u7684\u4e0d\u53ef\u9760\u53ef\u80fd\u4f1a\u5bfc\u81f4\u6570\u636e\u4e22\u5931\uff0c\u6240\u4ee5\u6bd4\u8f83\u9002\u5408\u8981\u6c42\u65f6\u5ef6\u4f4e\uff0c\u5c11\u91cf\u4e22\u5305\u4e0d\u5f71\u54cd\u6574\u4f53\u529f\u80fd\u7684\u573a\u666f\uff0c\u53e6\u5916UDP\u652f\u6301\u591a\u64ad\u3001\u7aef\u53e3\u590d\u7528\uff0c\u53ef\u4ee5\u5b9e\u73b0\u4e00\u6b21\u7ed9\u591a\u4e2a\u4e3b\u673a\u7684\u591a\u4e2a\u8fdb\u7a0b\u53d1\u9001\u6570\u636e\u3002\u4e0b\u9762\u6211\u4eec\u5f00\u59cb\u5206\u6790\u4e00\u4e0bUDP\u7684\u76f8\u5173\u5185\u5bb9\u3002 16.1 \u5728C\u8bed\u8a00\u4e2d\u4f7f\u7528UDP \u00b6 \u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5728C\u8bed\u8a00\u4e2d\u5982\u4f55\u4f7f\u7528UDP\u529f\u80fd\uff0c\u8fd9\u662fNode.js\u7684\u5e95\u5c42\u57fa\u7840\u3002 16.1.1 \u670d\u52a1\u5668\u6d41\u7a0b\uff08\u4f2a\u4ee3\u7801\uff09 \u00b6 1 2 3 4 5 6 // \u7533\u8bf7\u4e00\u4e2asocket int fd = socket (...); // \u7ed1\u5b9a\u4e00\u4e2a\u4f17\u6240\u5468\u77e5\u7684\u5730\u5740\uff0c\u50cfTCP\u4e00\u6837 bind ( fd , ip \uff0c port ); // \u76f4\u63a5\u963b\u585e\u7b49\u5f85\u6d88\u606f\u7684\u5230\u6765\uff0cUDP\u4e0d\u9700\u8981listen recvmsg () \uff1b 16.1.2 \u5ba2\u6237\u7aef\u6d41\u7a0b \u00b6 \u5ba2\u6237\u7aef\u7684\u6d41\u7a0b\u6709\u591a\u79cd\u65b9\u5f0f\uff0c\u539f\u56e0\u5728\u4e8e\u6e90IP\u3001\u7aef\u53e3\u548c\u76ee\u7684IP\u3001\u7aef\u53e3\u53ef\u4ee5\u6709\u591a\u79cd\u8bbe\u7f6e\u65b9\u5f0f\u3002\u4e0d\u50cf\u670d\u52a1\u5668\u4e00\u6837\uff0c\u670d\u52a1\u5668\u7aef\u53e3\u662f\u9700\u8981\u5bf9\u5916\u516c\u5e03\u7684\uff0c\u5426\u5219\u5ba2\u6237\u7aef\u5c31\u65e0\u6cd5\u627e\u5230\u76ee\u7684\u5730\u8fdb\u884c\u901a\u4fe1\u3002\u8fd9\u5c31\u610f\u5473\u7740\u670d\u52a1\u5668\u7684\u7aef\u53e3\u662f\u9700\u8981\u7528\u6237\u663e\u5f0f\u6307\u5b9a\u7684\uff0c\u800c\u5ba2\u6237\u7aef\u5219\u4e0d\u7136\uff0c\u5ba2\u6237\u7aef\u7684IP\u548c\u7aef\u53e3\uff0c\u7528\u6237\u53ef\u4ee5\u81ea\u5df1\u6307\u5b9a\uff0c\u4e5f\u53ef\u4ee5\u7531\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a\uff0c\u4e0b\u9762\u6211\u4eec\u770b\u770b\u5404\u79cd\u4f7f\u7528\u65b9\u5f0f\u3002 16.1.2.1 \u663e\u5f0f\u6307\u5b9a\u6e90IP\u548c\u7aef\u53e3 \u00b6 1 2 3 4 5 6 // \u7533\u8bf7\u4e00\u4e2asocket int fd = socket (...); // \u7ed1\u5b9a\u4e00\u4e2a\u5ba2\u6237\u7aef\u7684\u5730\u5740 bind ( fd , ip \uff0c port ); // \u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e sendto ( fd , \u670d\u52a1\u5668 ip , \u670d\u52a1\u5668\u7aef\u53e3 , data ); \u56e0\u4e3aUDP\u4e0d\u662f\u9762\u5411\u8fde\u63a5\u7684\uff0c\u6240\u4ee5\u4f7f\u7528UDP\u65f6\uff0c\u4e0d\u9700\u8981\u8c03\u7528connect\u5efa\u7acb\u8fde\u63a5\uff0c\u53ea\u8981\u6211\u4eec\u77e5\u9053\u670d\u52a1\u5668\u7684\u5730\u5740\uff0c\u76f4\u63a5\u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e\u5373\u53ef\u3002\u800c\u9762\u5411\u8fde\u63a5\u7684TCP\uff0c\u9996\u5148\u9700\u8981\u901a\u8fc7connect\u53d1\u8d77\u4e09\u6b21\u63e1\u624b\u5efa\u7acb\u8fde\u63a5\uff0c\u5efa\u7acb\u8fde\u63a5\u7684\u672c\u8d28\u662f\u5728\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u8bb0\u5f55\u5bf9\u7aef\u7684\u4fe1\u606f\uff0c\u8fd9\u662f\u540e\u9762\u901a\u4fe1\u7684\u901a\u884c\u8bc1\u3002 16.1.2.2 \u7531\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a\u6e90ip\u548c\u7aef\u53e3 \u00b6 1 2 3 4 // \u7533\u8bf7\u4e00\u4e2asocket int fd = socket (...); // \u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e sendto ( fd , \u670d\u52a1\u5668 ip , \u670d\u52a1\u5668\u7aef\u53e3 , data ) \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u6ca1\u6709\u7ed1\u5b9a\u5ba2\u6237\u7aef\u7684\u6e90ip\u548c\u7aef\u53e3\uff0c\u800c\u662f\u76f4\u63a5\u5c31\u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e\u3002\u5982\u679c\u7528\u6237\u4e0d\u6307\u5b9aip\u548c\u7aef\u53e3\uff0c\u5219\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u63d0\u4f9b\u9ed8\u8ba4\u7684\u6e90ip\u548c\u7aef\u53e3\u3002\u5bf9\u4e8eip\uff0c\u5982\u679c\u662f\u591a\u5bbf\u4e3b\u4e3b\u673a\uff0c\u6bcf\u6b21\u8c03\u7528sendto\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u52a8\u6001\u9009\u62e9\u6e90ip\u3002\u5bf9\u4e8e\u7aef\u53e3\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u5728\u7b2c\u4e00\u6b21\u8c03\u7528sendto\u7684\u65f6\u5019\u968f\u673a\u9009\u62e9\u4e00\u4e2a\u7aef\u53e3\uff0c\u5e76\u4e14\u4e0d\u80fd\u4fee\u6539\u3002\u53e6\u5916\u8fd8\u6709\u4e00\u79cd\u4f7f\u7528\u65b9\u5f0f\u3002 1 2 3 4 5 6 7 8 // \u7533\u8bf7\u4e00\u4e2asocket int fd = socket (...); connect ( fd , \u670d\u52a1\u5668 ip \uff0c\u670d\u52a1\u5668\u7aef\u53e3 ); /* \u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e,\u6216\u8005sendto(fd, null,null, data)\uff0c \u8c03\u7528sendto\u5219\u4e0d\u9700\u8981\u518d\u6307\u5b9a\u670d\u52a1\u5668ip\u548c\u7aef\u53e3 */ write ( fd , data ); \u6211\u4eec\u53ef\u4ee5\u5148\u8c03\u7528connect\u7ed1\u5b9a\u670d\u52a1\u5668ip\u548c\u7aef\u53e3\u5230fd\uff0c\u7136\u540e\u76f4\u63a5\u8c03\u7528write\u53d1\u9001\u6570\u636e\u3002 \u867d\u7136\u4f7f\u7528\u65b9\u5f0f\u5f88\u591a\uff0c\u4f46\u662f\u5f52\u6839\u5230\u5e95\u8fd8\u662f\u5bf9\u56db\u5143\u7ec4\u8bbe\u7f6e\u7684\u7ba1\u7406\u3002bind\u662f\u7ed1\u5b9a\u6e90ip\u7aef\u53e3\u5230fd\uff0cconnect\u662f\u7ed1\u5b9a\u670d\u52a1\u5668ip\u7aef\u53e3\u5230fd\u3002\u5bf9\u4e8e\u6e90ip\u548c\u7aef\u53e3\uff0c\u6211\u4eec\u53ef\u4ee5\u4e3b\u52a8\u8bbe\u7f6e\uff0c\u4e5f\u53ef\u4ee5\u8ba9\u64cd\u4f5c\u7cfb\u7edf\u968f\u673a\u9009\u62e9\u3002\u5bf9\u4e8e\u76ee\u7684ip\u548c\u7aef\u53e3\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u53d1\u9001\u6570\u636e\u524d\u8bbe\u7f6e\uff0c\u4e5f\u53ef\u4ee5\u5728\u53d1\u9001\u6570\u636e\u65f6\u8bbe\u7f6e\u3002\u8fd9\u5c31\u5f62\u6210\u4e86\u591a\u79cd\u4f7f\u7528\u65b9\u5f0f\u3002 16.1.3 \u53d1\u9001\u6570\u636e \u00b6 \u6211\u4eec\u521a\u624d\u770b\u5230\u4f7f\u7528UDP\u4e4b\u524d\u90fd\u9700\u8981\u8c03\u7528socket\u51fd\u6570\u7533\u8bf7\u4e00\u4e2asocket\uff0c\u867d\u7136\u8c03\u7528socket\u51fd\u6570\u8fd4\u56de\u7684\u662f\u4e00\u4e2afd\uff0c\u4f46\u662f\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e2d\uff0c\u7684\u786e\u662f\u65b0\u5efa\u4e86\u4e00\u4e2asocket\u7ed3\u6784\u4f53\uff0cfd\u53ea\u662f\u4e00\u4e2a\u7d22\u5f15\uff0c\u64cd\u4f5c\u8fd9\u4e2afd\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6839\u636e\u8fd9\u4e2afd\u627e\u5230\u5bf9\u5e94\u7684socket\u3002socket\u662f\u4e00\u4e2a\u975e\u5e38\u590d\u6742\u7684\u7ed3\u6784\u4f53\uff0c\u6211\u4eec\u53ef\u4ee5\u7406\u89e3\u4e3a\u4e00\u4e2a\u5bf9\u8c61\u3002\u8fd9\u4e2a\u5bf9\u8c61\u4e2d\u6709\u4e24\u4e2a\u5c5e\u6027\uff0c\u4e00\u4e2a\u662f\u8bfb\u7f13\u51b2\u533a\u5927\u5c0f\uff0c\u4e00\u4e2a\u662f\u5199\u7f13\u51b2\u533a\u5927\u5c0f\u3002\u5f53\u6211\u4eec\u53d1\u9001\u6570\u636e\u7684\u65f6\u5019\uff0c\u867d\u7136\u7406\u8bba\u4e0a\u53ef\u4ee5\u53d1\u9001\u4efb\u610f\u5927\u5c0f\u7684\u6570\u636e\uff0c\u4f46\u662f\u56e0\u4e3a\u53d7\u9650\u4e8e\u53d1\u9001\u7f13\u51b2\u533a\u7684\u5927\u5c0f\uff0c\u5982\u679c\u9700\u8981\u53d1\u9001\u7684\u6570\u636e\u6bd4\u5f53\u524d\u7f13\u51b2\u533a\u5927\u5c0f\u5927\u5219\u4f1a\u5bfc\u81f4\u4e00\u4e9b\u95ee\u9898\uff0c\u6211\u4eec\u5206\u60c5\u51b5\u5206\u6790\u4e00\u4e0b\u3002 1 \u53d1\u9001\u7684\u6570\u636e\u5927\u5c0f\u6bd4\u5f53\u524d\u7f13\u51b2\u533a\u5927\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86\u975e\u963b\u585e\u6a21\u5f0f\uff0c\u5219\u8fd4\u56deEAGAIN\uff0c\u5982\u679c\u662f\u963b\u585e\u6a21\u5f0f\uff0c\u5219\u4f1a\u5f15\u8d77\u8fdb\u7a0b\u7684\u963b\u585e\u3002 2 \u5982\u679c\u53d1\u9001\u7684\u6570\u636e\u5927\u5c0f\u6bd4\u7f13\u51b2\u533a\u7684\u6700\u5927\u503c\u8fd8\u5927\uff0c\u5219\u4f1a\u5bfc\u81f4\u62a5\u9519EMSGSIZE\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u9700\u8981\u5206\u5305\u53d1\u9001\u3002\u6211\u4eec\u53ef\u80fd\u4f1a\u60f3\u5230\u4fee\u6539\u7f13\u51b2\u533a\u6700\u5927\u503c\u7684\u5927\u5c0f\uff0c\u4f46\u662f\u8fd9\u4e2a\u5927\u5c0f\u4e5f\u662f\u6709\u9650\u5236\u7684\u3002 \u8bb2\u5b8c\u4e00\u4e9b\u8fb9\u754c\u60c5\u51b5\uff0c\u6211\u4eec\u518d\u6765\u770b\u770b\u6b63\u5e38\u7684\u6d41\u7a0b\uff0c\u6211\u4eec\u770b\u770b\u53d1\u9001\u4e00\u4e2a\u6570\u636e\u5305\u7684\u6d41\u7a0b 1 \u9996\u5148\u5728socket\u7684\u5199\u7f13\u51b2\u533a\u7533\u8bf7\u4e00\u5757\u5185\u5b58\u7528\u4e8e\u6570\u636e\u53d1\u9001\u3002 2 \u8c03\u7528IP\u5c42\u53d1\u9001\u63a5\u53e3\uff0c\u5982\u679c\u6570\u636e\u5305\u5927\u5c0f\u8d85\u8fc7\u4e86IP\u5c42\u7684\u9650\u5236\uff0c\u5219\u9700\u8981\u5206\u5305\u3002 3 \u7ee7\u7eed\u8c03\u7528\u5e95\u5c42\u7684\u63a5\u53e3\u628a\u6570\u636e\u53d1\u5230\u7f51\u7edc\u4e0a\u3002 \u56e0\u4e3aUDP\u4e0d\u662f\u53ef\u9760\u7684\uff0c\u6240\u4ee5\u4e0d\u9700\u8981\u7f13\u5b58\u8fd9\u4e2a\u6570\u636e\u5305\uff08TCP\u534f\u8bae\u5219\u9700\u8981\u7f13\u5b58\u8fd9\u4e2a\u6570\u636e\u5305\uff0c\u7528\u4e8e\u8d85\u65f6\u91cd\u4f20\uff09\u3002 \u8fd9\u5c31\u662fUDP\u53d1\u9001\u6570\u636e\u7684\u6d41\u7a0b\u3002 16.1.4 \u63a5\u6536\u6570\u636e \u00b6 \u5f53\u6536\u5230\u4e00\u4e2aUDP\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u9996\u5148\u4f1a\u628a\u8fd9\u4e2a\u6570\u636e\u5305\u7f13\u5b58\u5230socket\u7684\u7f13\u51b2\u533a\uff0c\u5982\u679c\u6536\u5230\u7684\u6570\u636e\u5305\u6bd4\u5f53\u524d\u7f13\u51b2\u533a\u5927\u5c0f\u5927\uff0c\u5219\u4e22\u5f03\u6570\u636e\u5305\uff0c\u5426\u5219\u628a\u6570\u636e\u5305\u6302\u8f7d\u5230\u63a5\u6536\u961f\u5217\uff0c\u7b49\u7528\u6237\u6765\u8bfb\u53d6\u7684\u65f6\u5019\uff0c\u5c31\u9010\u4e2a\u6458\u4e0b\u63a5\u6536\u961f\u5217\u7684\u8282\u70b9\u3002UDP\u548cTCP\u4e0d\u4e00\u6837\uff0c\u867d\u7136\u5b83\u4eec\u90fd\u6709\u4e00\u4e2a\u7f13\u5b58\u4e86\u6d88\u606f\u7684\u961f\u5217\uff0c\u4f46\u662f\u5f53\u7528\u6237\u8bfb\u53d6\u6570\u636e\u65f6\uff0cUDP\u6bcf\u6b21\u53ea\u4f1a\u8fd4\u56de\u4e00\u4e2aUDP\u6570\u636e\u5305\uff0c\u800cTCP\u662f\u4f1a\u6839\u636e\u7528\u6237\u8bbe\u7f6e\u7684\u5927\u5c0f\u8fd4\u56de\u4e00\u4e2a\u6216\u591a\u4e2a\u5305\u91cc\u7684\u6570\u636e\u3002\u56e0\u4e3aTCP\u662f\u9762\u5411\u5b57\u8282\u6d41\u7684\uff0c\u800cUDP\u662f\u9762\u5411\u6570\u636e\u5305\u7684\u3002 16.2 UDP\u6a21\u5757\u5728Node.js\u4e2d\u7684\u5b9e\u73b0 \u00b6 \u4e86\u89e3\u4e86UDP\u7684\u4e00\u4e9b\u57fa\u7840\u548c\u4f7f\u7528\u540e\uff0c\u6211\u4eec\u5f00\u59cb\u5206\u6790\u5728Node.js\u4e2d\u662f\u5982\u4f55\u4f7f\u7528UDP\u7684\uff0cNode.js\u53c8\u662f\u5982\u4f55\u5b9e\u73b0UDP\u6a21\u5757\u7684\u3002 16.2.1 \u670d\u52a1\u5668 \u00b6 \u6211\u4eec\u4ece\u4e00\u4e2a\u4f7f\u7528\u4f8b\u5b50\u5f00\u59cb\u770b\u770bUDP\u6a21\u5757\u7684\u4f7f\u7528\u3002 1 2 3 4 5 6 7 8 9 const dgram = require ( 'dgram' ); // \u521b\u5efa\u4e00\u4e2aUDP\u670d\u52a1\u5668 const server = dgram . createSocket ( 'udp4' ); // \u76d1\u542cUDP\u6570\u636e\u7684\u5230\u6765 server . on ( 'message' , ( msg , rinfo ) => { // \u5904\u7406\u6570\u636e }); // \u7ed1\u5b9a\u7aef\u53e3 server . bind ( 41234 ); \u6211\u4eec\u770b\u5230\u521b\u5efa\u4e00\u4e2aUDP\u670d\u52a1\u5668\u5f88\u7b80\u5355\uff0c\u9996\u5148\u7533\u8bf7\u4e00\u4e2asocket\u5bf9\u8c61\uff0c\u5728Node.js\u4e2d\u548c\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u4e00\u6837\uff0csocket\u662f\u5bf9\u7f51\u7edc\u901a\u4fe1\u7684\u4e00\u4e2a\u62bd\u8c61\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u5b83\u7406\u89e3\u6210\u5bf9\u4f20\u8f93\u5c42\u7684\u62bd\u8c61\uff0c\u5b83\u53ef\u4ee5\u4ee3\u8868TCP\u4e5f\u53ef\u4ee5\u4ee3\u8868UDP\u3002\u6211\u4eec\u770b\u4e00\u4e0bcreateSocket\u505a\u4e86\u4ec0\u4e48\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 function createSocket ( type , listener ) { return new Socket ( type , listener ); } function Socket ( type , listener ) { EventEmitter . call ( this ); let lookup ; let recvBufferSize ; let sendBufferSize ; let options ; if ( type !== null && typeof type === 'object' ) { options = type ; type = options . type ; lookup = options . lookup ; recvBufferSize = options . recvBufferSize ; sendBufferSize = options . sendBufferSize ; } const handle = newHandle ( type , lookup ); this . type = type ; if ( typeof listener === 'function' ) this . on ( 'message' , listener ); // \u4fdd\u5b58\u4e0a\u4e0b\u6587 this [ kStateSymbol ] = { handle , receiving : false , // \u8fd8\u6ca1\u6709\u6267\u884cbind bindState : BIND_STATE_UNBOUND , connectState : CONNECT_STATE_DISCONNECTED , queue : undefined , // \u7aef\u53e3\u590d\u7528\uff0c\u53ea\u4f7f\u4e8e\u591a\u64ad reuseAddr : options && options . reuseAddr , ipv6Only : options && options . ipv6Only , // \u53d1\u9001\u7f13\u51b2\u533a\u548c\u63a5\u6536\u7f13\u51b2\u533a\u5927\u5c0f recvBufferSize , sendBufferSize }; } \u6211\u4eec\u770b\u5230\u4e00\u4e2asocket\u5bf9\u8c61\u662f\u5bf9handle\u7684\u4e00\u4e2a\u5c01\u88c5\u3002\u6211\u4eec\u770b\u770bhandle\u662f\u4ec0\u4e48\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function newHandle ( type , lookup ) { // \u7528\u4e8edns\u89e3\u6790\u7684\u51fd\u6570\uff0c\u6bd4\u5982\u6211\u4eec\u8c03send\u7684\u65f6\u5019\uff0c\u4f20\u7684\u662f\u4e00\u4e2a\u57df\u540d if ( lookup === undefined ) { if ( dns === undefined ) { dns = require ( 'dns' ); } lookup = dns . lookup ; } if ( type === 'udp4' ) { const handle = new UDP (); handle . lookup = lookup4 . bind ( handle , lookup ); return handle ; } // \u5ffd\u7565ipv6\u7684\u5904\u7406 } handle\u53c8\u662f\u5bf9UDP\u6a21\u5757\u7684\u5c01\u88c5\uff0cUDP\u662fC++\u6a21\u5757\uff0c\u5728\u4e4b\u524d\u7ae0\u8282\u4e2d\u6211\u4eec\u8bb2\u8fc7\u76f8\u5173\u7684\u77e5\u8bc6\uff0c\u8fd9\u91cc\u5c31\u4e0d\u8be6\u7ec6\u8bb2\u8ff0\u4e86\uff0c\u5f53\u6211\u4eec\u5728JS\u5c42new UDP\u7684\u65f6\u5019\uff0c\u4f1a\u65b0\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 UDPWrap :: UDPWrap ( Environment * env , Local < Object > object ) : HandleWrap ( env , object , reinterpret_cast < uv_handle_t *> ( & handle_ ), AsyncWrap :: PROVIDER_UDPWRAP ) { int r = uv_udp_init ( env -> event_loop (), & handle_ ); } \u6267\u884c\u4e86uv_udp_init\u521d\u59cb\u5316udp\u5bf9\u5e94\u7684handle\uff08uv_udp_t\uff09\u3002\u6211\u4eec\u770b\u4e00\u4e0bLibuv\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int uv_udp_init_ex ( uv_loop_t * loop , uv_udp_t * handle , unsigned int flags ) { int domain ; int err ; int fd ; /* Use the lower 8 bits for the domain */ domain = flags & 0xFF ; // \u7533\u8bf7\u4e00\u4e2asocket\uff0c\u8fd4\u56de\u4e00\u4e2afd fd = uv__socket ( domain , SOCK_DGRAM , 0 ); uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_UDP ); handle -> alloc_cb = NULL ; handle -> recv_cb = NULL ; handle -> send_queue_size = 0 ; handle -> send_queue_count = 0 ; /* \u521d\u59cb\u5316IO\u89c2\u5bdf\u8005\uff08\u8fd8\u6ca1\u6709\u6ce8\u518c\u5230\u4e8b\u4ef6\u5faa\u73af\u7684Poll IO\u9636\u6bb5\uff09\uff0c \u76d1\u542c\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u662ffd\uff0c\u56de\u8c03\u662fuv__udp_io */ uv__io_init ( & handle -> io_watcher , uv__udp_io , fd ); // \u521d\u59cb\u5316\u5199\u961f\u5217 QUEUE_INIT ( & handle -> write_queue ); QUEUE_INIT ( & handle -> write_completed_queue ); return 0 ; } \u5c31\u662f\u6211\u4eec\u5728JS\u5c42\u6267\u884cdgram.createSocket('udp4')\u7684\u65f6\u5019\uff0c\u5728Node.js\u4e2d\u4e3b\u8981\u7684\u6267\u884c\u8fc7\u7a0b\u3002\u56de\u5230\u6700\u5f00\u59cb\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u6267\u884cbind\u7684\u65f6\u5019\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Socket . prototype . bind = function ( port_ , address_ /* , callback */ ) { let port = port_ ; // socket\u7684\u4e0a\u4e0b\u6587 const state = this [ kStateSymbol ]; // \u5df2\u7ecf\u7ed1\u5b9a\u8fc7\u4e86\u5219\u62a5\u9519 if ( state . bindState !== BIND_STATE_UNBOUND ) throw new ERR_SOCKET_ALREADY_BOUND (); // \u5426\u5219\u6807\u8bb0\u5df2\u7ecf\u7ed1\u5b9a\u4e86 state . bindState = BIND_STATE_BINDING ; // \u6ca1\u4f20\u5730\u5740\u5219\u9ed8\u8ba4\u7ed1\u5b9a\u6240\u6709\u5730\u5740 if ( ! address ) { if ( this . type === 'udp4' ) address = '0.0.0.0' ; else address = '::' ; } // dns\u89e3\u6790\u540e\u5728\u7ed1\u5b9a\uff0c\u5982\u679c\u9700\u8981\u7684\u8bdd state . handle . lookup ( address , ( err , ip ) => { if ( err ) { state . bindState = BIND_STATE_UNBOUND ; this . emit ( 'error' , err ); return ; } const err = state . handle . bind ( ip , port || 0 , flags ); if ( err ) { const ex = exceptionWithHostPort ( err , 'bind' , ip , port ); state . bindState = BIND_STATE_UNBOUND ; this . emit ( 'error' , ex ); // Todo: close? return ; } startListening ( this ); return this ; } bind\u51fd\u6570\u4e3b\u8981\u7684\u903b\u8f91\u662fhandle.bind\u548cstartListening\u3002\u6211\u4eec\u4e00\u4e2a\u4e2a\u770b\u3002\u6211\u4eec\u770b\u4e00\u4e0bC++\u5c42\u7684bind\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void UDPWrap::DoBind ( const FunctionCallbackInfo < Value >& args , int family ) { UDPWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder (), args . GetReturnValue (). Set ( UV_EBADF )); // bind(ip, port, flags) CHECK_EQ ( args . Length (), 3 ); node :: Utf8Value address ( args . GetIsolate (), args [ 0 ]); Local < Context > ctx = args . GetIsolate () -> GetCurrentContext (); uint32_t port , flags ; struct sockaddr_storage addr_storage ; int err = sockaddr_for_family ( family , address . out (), port , & addr_storage ); if ( err == 0 ) { err = uv_udp_bind ( & wrap -> handle_ , reinterpret_cast < const sockaddr *> ( & addr_storage ), flags ); } args . GetReturnValue (). Set ( err ); } \u4e5f\u6ca1\u6709\u592a\u591a\u903b\u8f91\uff0c\u5904\u7406\u53c2\u6570\u7136\u540e\u6267\u884cuv_udp_bind\u8bbe\u7f6e\u4e00\u4e9b\u6807\u8bb0\u3001\u5c5e\u6027\u548c\u7aef\u53e3\u590d\u7528\uff08\u7aef\u53e3\u590d\u7528\u540e\u7eed\u4f1a\u5355\u72ec\u5206\u6790\uff09\uff0c\u7136\u540e\u6267\u884c\u64cd\u4f5c\u7cfb\u7edfbind\u7684\u51fd\u6570\u628a\u672c\u7aef\u7684ip\u548c\u7aef\u53e3\u4fdd\u5b58\u5230socket\u4e2d\u3002\u6211\u4eec\u7ee7\u7eed\u770bstartListening\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function startListening ( socket ) { const state = socket [ kStateSymbol ]; // \u6709\u6570\u636e\u65f6\u7684\u56de\u8c03\uff0c\u89e6\u53d1message\u4e8b\u4ef6 state . handle . onmessage = onMessage ; // \u91cd\u70b9\uff0c\u5f00\u59cb\u76d1\u542c\u6570\u636e state . handle . recvStart (); state . receiving = true ; state . bindState = BIND_STATE_BOUND ; // \u8bbe\u7f6e\u64cd\u4f5c\u7cfb\u7edf\u7684\u63a5\u6536\u548c\u53d1\u9001\u7f13\u51b2\u533a\u5927\u5c0f if ( state . recvBufferSize ) bufferSize ( socket , state . recvBufferSize , RECV_BUFFER ); if ( state . sendBufferSize ) bufferSize ( socket , state . sendBufferSize , SEND_BUFFER ); socket . emit ( 'listening' ); } \u91cd\u70b9\u662frecvStart\u51fd\u6570\uff0c\u6211\u4eec\u770bC++\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 void UDPWrap::RecvStart ( const FunctionCallbackInfo < Value >& args ) { UDPWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder (), args . GetReturnValue (). Set ( UV_EBADF )); int err = uv_udp_recv_start ( & wrap -> handle_ , OnAlloc , OnRecv ); // UV_EALREADY means that the socket is already bound but that's okay if ( err == UV_EALREADY ) err = 0 ; args . GetReturnValue (). Set ( err ); } OnAlloc, OnRecv\u5206\u522b\u662f\u5206\u914d\u5185\u5b58\u63a5\u6536\u6570\u636e\u7684\u51fd\u6570\u548c\u6570\u636e\u5230\u6765\u65f6\u6267\u884c\u7684\u56de\u8c03\u3002\u7ee7\u7eed\u770bLibuv 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int uv__udp_recv_start ( uv_udp_t * handle , uv_alloc_cb alloc_cb , uv_udp_recv_cb recv_cb ) { int err ; err = uv__udp_maybe_deferred_bind ( handle , AF_INET , 0 ); if ( err ) return err ; // \u4fdd\u5b58\u4e00\u4e9b\u4e0a\u4e0b\u6587 handle -> alloc_cb = alloc_cb ; handle -> recv_cb = recv_cb ; // \u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230loop\uff0c\u5982\u679c\u4e8b\u4ef6\u5230\u6765\uff0c\u7b49\u5230Poll IO\u9636\u6bb5\u5904\u7406 uv__io_start ( handle -> loop , & handle -> io_watcher , POLLIN ); uv__handle_start ( handle ); return 0 ; } uv__udp_recv_start\u4e3b\u8981\u662f\u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230loop\uff0c\u7b49\u5f85\u4e8b\u4ef6\u5230\u6765\u7684\u65f6\u5019\uff0c\u5230\u8fd9\uff0c\u670d\u52a1\u5668\u5c31\u542f\u52a8\u4e86\u3002 16.2.2 \u5ba2\u6237\u7aef \u00b6 \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u5ba2\u6237\u7aef\u7684\u4f7f\u7528\u65b9\u5f0f\u548c\u6d41\u7a0b 1 2 3 4 5 6 7 8 const dgram = require ( 'dgram' ); const message = Buffer . from ( 'Some bytes' ); const client = dgram . createSocket ( 'udp4' ); client . connect ( 41234 , 'localhost' , ( err ) => { client . send ( message , ( err ) => { client . close (); }); }); \u6211\u4eec\u770b\u5230Node.js\u9996\u5148\u8c03\u7528connect\u7ed1\u5b9a\u670d\u52a1\u5668\u7684\u5730\u5740\uff0c\u7136\u540e\u8c03\u7528send\u53d1\u9001\u4fe1\u606f\uff0c\u6700\u540e\u8c03\u7528close\u3002\u6211\u4eec\u4e00\u4e2a\u4e2a\u5206\u6790\u3002\u9996\u5148\u770bconnect\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Socket . prototype . connect = function ( port , address , callback ) { port = validatePort ( port ); // \u53c2\u6570\u5904\u7406 if ( typeof address === 'function' ) { callback = address ; address = '' ; } else if ( address === undefined ) { address = '' ; } const state = this [ kStateSymbol ]; // \u4e0d\u662f\u521d\u59cb\u5316\u72b6\u6001 if ( state . connectState !== CONNECT_STATE_DISCONNECTED ) throw new ERR_SOCKET_DGRAM_IS_CONNECTED (); // \u8bbe\u7f6esocket\u72b6\u6001 state . connectState = CONNECT_STATE_CONNECTING ; // \u8fd8\u6ca1\u6709\u7ed1\u5b9a\u5ba2\u6237\u7aef\u5730\u5740\u4fe1\u606f\uff0c\u5219\u5148\u7ed1\u5b9a\u968f\u673a\u5730\u5740\uff08\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a\uff09 if ( state . bindState === BIND_STATE_UNBOUND ) this . bind ({ port : 0 , exclusive : true }, null ); // \u6267\u884cbind\u7684\u65f6\u5019\uff0cstate.bindState\u4e0d\u662f\u540c\u6b65\u8bbe\u7f6e\u7684 if ( state . bindState !== BIND_STATE_BOUND ) { enqueue ( this , _connect . bind ( this , port , address , callback )); return ; } _connect . call ( this , port , address , callback ); }; \u8fd9\u91cc\u5206\u4e3a\u4e24\u79cd\u60c5\u51b5\uff0c\u4e00\u79cd\u662f\u5728connect\u4e4b\u524d\u5df2\u7ecf\u8c03\u7528\u4e86bind\uff0c\u7b2c\u4e8c\u79cd\u662f\u6ca1\u6709\u8c03\u7528bind\uff0c\u5982\u679c\u6ca1\u6709\u8c03\u7528bind\uff0c\u5219\u5728connect\u4e4b\u524d\u5148\u8981\u8c03\u7528bind\uff08\u56e0\u4e3abind\u4e2d\u4e0d\u4ec5\u4ec5\u7ed1\u5b9a\u4e86ip\u7aef\u53e3\uff0c\u8fd8\u6709\u7aef\u53e3\u590d\u7528\u7684\u5904\u7406\uff09\u3002\u8fd9\u91cc\u53ea\u5206\u6790\u6ca1\u6709\u8c03\u7528bind\u7684\u60c5\u51b5\uff0c\u56e0\u4e3a\u8fd9\u662f\u6700\u957f\u7684\u8def\u5f84\u3002bind\u521a\u624d\u6211\u4eec\u5206\u6790\u8fc7\u4e86\uff0c\u6211\u4eec\u4ece\u4ee5\u4e0b\u4ee3\u7801\u7ee7\u7eed\u5206\u6790 1 2 3 4 if ( state . bindState !== BIND_STATE_BOUND ) { enqueue ( this , _connect . bind ( this , port , address , callback )); return ; } enqueue\u628a\u4efb\u52a1\u52a0\u5165\u4efb\u52a1\u961f\u5217\uff0c\u5e76\u4e14\u76d1\u542c\u4e86listening\u4e8b\u4ef6\uff08\u8be5\u4e8b\u4ef6\u5728bind\u6210\u529f\u540e\u89e6\u53d1\uff09\u3002 1 2 3 4 5 6 7 8 9 function enqueue ( self , toEnqueue ) { const state = self [ kStateSymbol ]; if ( state . queue === undefined ) { state . queue = []; self . once ( 'error' , onListenError ); self . once ( 'listening' , onListenSuccess ); } state . queue . push ( toEnqueue ); } \u8fd9\u65f6\u5019connect\u51fd\u6570\u5c31\u6267\u884c\u5b8c\u4e86\uff0c\u7b49\u5f85bind\u6210\u529f\u540e\uff08nextTick\uff09\u4f1a\u6267\u884c startListening\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function startListening ( socket ) { const state = socket [ kStateSymbol ]; state . handle . onmessage = onMessage ; // \u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 state . handle . recvStart (); state . receiving = true ; // \u6807\u8bb0\u5df2bind\u6210\u529f state . bindState = BIND_STATE_BOUND ; // \u8bbe\u7f6e\u8bfb\u5199\u7f13\u51b2\u533a\u5927\u5c0f if ( state . recvBufferSize ) bufferSize ( socket , state . recvBufferSize , RECV_BUFFER ); if ( state . sendBufferSize ) bufferSize ( socket , state . sendBufferSize , SEND_BUFFER ); // \u89e6\u53d1listening\u4e8b\u4ef6 socket . emit ( 'listening' ); } \u6211\u4eec\u770b\u5230startListening\u89e6\u53d1\u4e86listening\u4e8b\u4ef6\uff0c\u4ece\u800c\u6267\u884c\u6211\u4eec\u521a\u624d\u5165\u961f\u7684\u56de\u8c03onListenSuccess\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 function onListenSuccess () { this . removeListener ( 'error' , onListenError ); clearQueue . call ( this ); } function clearQueue () { const state = this [ kStateSymbol ]; const queue = state . queue ; state . queue = undefined ; for ( const queueEntry of queue ) queueEntry (); } \u56de\u8c03\u5c31\u662f\u628a\u961f\u5217\u4e2d\u7684\u56de\u8c03\u6267\u884c\u4e00\u904d\uff0cconnect\u51fd\u6570\u8bbe\u7f6e\u7684\u56de\u8c03\u662f_connect\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function _connect ( port , address , callback ) { const state = this [ kStateSymbol ]; if ( callback ) this . once ( 'connect' , callback ); const afterDns = ( ex , ip ) => { defaultTriggerAsyncIdScope ( this [ async_id_symbol ], doConnect , ex , this , ip , address , port , callback ); }; state . handle . lookup ( address , afterDns ); } \u8fd9\u91cc\u7684address\u662f\u670d\u52a1\u5668\u5730\u5740\uff0c_connect\u51fd\u6570\u4e3b\u8981\u903b\u8f91\u662f 1 \u76d1\u542cconnect\u4e8b\u4ef6 2 \u5bf9\u670d\u52a1\u5668\u5730\u5740\u8fdb\u884cdns\u89e3\u6790\uff08\u53ea\u80fd\u662f\u672c\u5730\u7684\u914d\u7684\u57df\u540d\uff09\u3002\u89e3\u6790\u6210\u529f\u540e\u6267\u884cafterDns\uff0c\u6700\u540e\u6267\u884cdoConnect\uff0c\u5e76\u4f20\u5165\u89e3\u6790\u51fa\u6765\u7684ip\u3002\u6211\u4eec\u770b\u770bdoConnect 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function doConnect ( ex , self , ip , address , port , callback ) { const state = self [ kStateSymbol ]; // dns\u89e3\u6790\u6210\u529f\uff0c\u6267\u884c\u5e95\u5c42\u7684connect if ( ! ex ) { const err = state . handle . connect ( ip , port ); if ( err ) { ex = exceptionWithHostPort ( err , 'connect' , address , port ); } } // connect\u6210\u529f\uff0c\u89e6\u53d1connect\u4e8b\u4ef6 state . connectState = CONNECT_STATE_CONNECTED ; process . nextTick (() => self . emit ( 'connect' )); } connect\u51fd\u6570\u901a\u8fc7C++\u5c42\uff0c\u7136\u540e\u8c03\u7528Libuv\uff0c\u5230\u64cd\u4f5c\u7cfb\u7edf\u7684connect\u3002\u4f5c\u7528\u662f\u628a\u670d\u52a1\u5668\u5730\u5740\u4fdd\u5b58\u5230socket\u4e2d\u3002connect\u7684\u6d41\u7a0b\u5c31\u8d70\u5b8c\u4e86\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u5c31\u53ef\u4ee5\u8c03\u7528send\u548crecv\u53d1\u9001\u548c\u63a5\u6536\u6570\u636e\u3002 16.2.3 \u53d1\u9001\u6570\u636e \u00b6 \u53d1\u9001\u6570\u636e\u63a5\u53e3\u662fsendto\uff0c\u5b83\u662f\u5bf9send\u7684\u5c01\u88c5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 Socket . prototype . send = function ( buffer , offset , length , port , address , callback ) { let list ; const state = this [ kStateSymbol ]; const connected = state . connectState === CONNECT_STATE_CONNECTED ; // \u6ca1\u6709\u8c03\u7528connect\u7ed1\u5b9a\u8fc7\u670d\u52a1\u7aef\u5730\u5740\uff0c\u5219\u9700\u8981\u4f20\u670d\u52a1\u7aef\u5730\u5740\u4fe1\u606f if ( ! connected ) { if ( address || ( port && typeof port !== 'function' )) { buffer = sliceBuffer ( buffer , offset , length ); } else { callback = port ; port = offset ; address = length ; } } else { if ( typeof length === 'number' ) { buffer = sliceBuffer ( buffer , offset , length ); if ( typeof port === 'function' ) { callback = port ; port = null ; } } else { callback = offset ; } // \u5df2\u7ecf\u7ed1\u5b9a\u4e86\u670d\u52a1\u7aef\u5730\u5740\uff0c\u5219\u4e0d\u80fd\u518d\u4f20\u4e86 if ( port || address ) throw new ERR_SOCKET_DGRAM_IS_CONNECTED (); } // \u5982\u679c\u6ca1\u6709\u7ed1\u5b9a\u670d\u52a1\u5668\u7aef\u53e3\uff0c\u5219\u8fd9\u91cc\u9700\u8981\u4f20\uff0c\u5e76\u4e14\u6821\u9a8c if ( ! connected ) port = validatePort ( port ); // \u5ffd\u7565\u4e00\u4e9b\u53c2\u6570\u5904\u7406\u903b\u8f91 // \u6ca1\u6709\u7ed1\u5b9a\u5ba2\u6237\u7aef\u5730\u5740\u4fe1\u606f\uff0c\u5219\u9700\u8981\u5148\u7ed1\u5b9a\uff0c\u503c\u7531\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a if ( state . bindState === BIND_STATE_UNBOUND ) this . bind ({ port : 0 , exclusive : true }, null ); // bind\u8fd8\u6ca1\u6709\u5b8c\u6210\uff0c\u5219\u5148\u5165\u961f\uff0c\u7b49\u5f85bind\u5b8c\u6210\u518d\u6267\u884c if ( state . bindState !== BIND_STATE_BOUND ) { enqueue ( this , this . send . bind ( this , list , port , address , callback )); return ; } // \u5df2\u7ecf\u7ed1\u5b9a\u4e86\uff0c\u8bbe\u7f6e\u670d\u52a1\u7aef\u5730\u5740\u540e\u53d1\u9001\u6570\u636e const afterDns = ( ex , ip ) => { defaultTriggerAsyncIdScope ( this [ async_id_symbol ], doSend , ex , this , ip , list , address , port , callback ); }; // \u4f20\u4e86\u5730\u5740\u5219\u53ef\u80fd\u9700\u8981dns\u89e3\u6790 if ( ! connected ) { state . handle . lookup ( address , afterDns ); } else { afterDns ( null , null ); } } \u6211\u4eec\u7ee7\u7eed\u770bdoSend\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 function doSend ( ex , self , ip , list , address , port , callback ) { const state = self [ kStateSymbol ]; // dns\u89e3\u6790\u51fa\u9519 if ( ex ) { if ( typeof callback === 'function' ) { process . nextTick ( callback , ex ); return ; } process . nextTick (() => self . emit ( 'error' , ex )); return ; } // \u5b9a\u4e49\u4e00\u4e2a\u8bf7\u6c42\u5bf9\u8c61 const req = new SendWrap (); req . list = list ; // Keep reference alive. req . address = address ; req . port = port ; /* \u8bbe\u7f6eNode.js\u548c\u7528\u6237\u7684\u56de\u8c03\uff0concomplete\u7531C++\u5c42\u8c03\u7528\uff0c callback\u7531oncomplete\u8c03\u7528 */ if ( callback ) { req . callback = callback ; req . oncomplete = afterSend ; } let err ; // \u6839\u636e\u662f\u5426\u9700\u8981\u8bbe\u7f6e\u670d\u52a1\u7aef\u5730\u5740\uff0c\u8c03C++\u5c42\u51fd\u6570 if ( port ) err = state . handle . send ( req , list , list . length , port , ip , !! callback ); else err = state . handle . send ( req , list , list . length , !! callback ); /* err\u5927\u4e8e\u7b49\u4e8e1\u8bf4\u660e\u540c\u6b65\u53d1\u9001\u6210\u529f\u4e86\uff0c\u76f4\u63a5\u6267\u884c\u56de\u8c03\uff0c \u5426\u5219\u7b49\u5f85\u5f02\u6b65\u56de\u8c03 */ if ( err >= 1 ) { if ( callback ) process . nextTick ( callback , null , err - 1 ); return ; } // \u53d1\u9001\u5931\u8d25 if ( err && callback ) { const ex = exceptionWithHostPort ( err , 'send' , address , port ); process . nextTick ( callback , ex ); } } \u6211\u4eec\u7a7f\u8fc7C++\u5c42\uff0c\u76f4\u63a5\u770bLibuv\u7684\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 int uv__udp_send ( uv_udp_send_t * req , uv_udp_t * handle , const uv_buf_t bufs [], unsigned int nbufs , const struct sockaddr * addr , unsigned int addrlen , uv_udp_send_cb send_cb ) { int err ; int empty_queue ; assert ( nbufs > 0 ); // \u8fd8\u6ca1\u6709\u7ed1\u5b9a\u670d\u52a1\u7aef\u5730\u5740\uff0c\u5219\u7ed1\u5b9a if ( addr ) { err = uv__udp_maybe_deferred_bind ( handle , addr -> sa_family , 0 ); if ( err ) return err ; } // \u5f53\u524d\u5199\u961f\u5217\u662f\u5426\u4e3a\u7a7a empty_queue = ( handle -> send_queue_count == 0 ); // \u521d\u59cb\u5316\u4e00\u4e2a\u5199\u8bf7\u6c42 uv__req_init ( handle -> loop , req , UV_UDP_SEND ); if ( addr == NULL ) req -> addr . ss_family = AF_UNSPEC ; else memcpy ( & req -> addr , addr , addrlen ); // \u4fdd\u5b58\u4e0a\u4e0b\u6587 req -> send_cb = send_cb ; req -> handle = handle ; req -> nbufs = nbufs ; // \u521d\u59cb\u5316\u6570\u636e\uff0c\u9884\u5206\u914d\u7684\u5185\u5b58\u4e0d\u591f\uff0c\u5219\u5206\u914d\u65b0\u7684\u5806\u5185\u5b58 req -> bufs = req -> bufsml ; if ( nbufs > ARRAY_SIZE ( req -> bufsml )) req -> bufs = uv__malloc ( nbufs * sizeof ( bufs [ 0 ])); // \u590d\u5236\u8fc7\u53bb\u5806\u4e2d memcpy ( req -> bufs , bufs , nbufs * sizeof ( bufs [ 0 ])); // \u66f4\u65b0\u5199\u961f\u5217\u6570\u636e handle -> send_queue_size += uv__count_bufs ( req -> bufs , req -> nbufs ); handle -> send_queue_count ++ ; // \u63d2\u5165\u5199\u961f\u5217\uff0c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\u7684\u53d1\u751f QUEUE_INSERT_TAIL ( & handle -> write_queue , & req -> queue ); uv__handle_start ( handle ); // \u5f53\u524d\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u76f4\u63a5\u5f00\u59cb\u5199\uff0c\u5426\u5219\u8bbe\u7f6e\u7b49\u5f85\u53ef\u5199\u961f\u5217 if ( empty_queue && ! ( handle -> flags & UV_HANDLE_UDP_PROCESSING )) { // \u53d1\u9001\u6570\u636e uv__udp_sendmsg ( handle ); // \u5199\u961f\u5217\u662f\u5426\u975e\u7a7a\uff0c\u5219\u8bbe\u7f6e\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u53ef\u5199\u7684\u65f6\u5019\u63a5\u7740\u5199 if ( ! QUEUE_EMPTY ( & handle -> write_queue )) uv__io_start ( handle -> loop , & handle -> io_watcher , POLLOUT ); } else { uv__io_start ( handle -> loop , & handle -> io_watcher , POLLOUT ); } return 0 ; } \u8be5\u51fd\u6570\u9996\u5148\u8bb0\u5f55\u5199\u8bf7\u6c42\u7684\u4e0a\u4e0b\u6587\uff0c\u7136\u540e\u628a\u5199\u8bf7\u6c42\u63d2\u5165\u5199\u961f\u5217\u4e2d\uff0c\u5f53\u5f85\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u76f4\u63a5\u6267\u884cuv__udp_sendmsg\u8fdb\u884c\u5199\u64cd\u4f5c\uff0c\u5426\u5219\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\u7684\u5230\u6765\uff0c\u5f53\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u6267\u884c\u7684\u51fd\u6570\u662fuv__udp_io\u3002 1 2 3 4 5 6 7 static void uv__udp_io ( uv_loop_t * loop , uv__io_t * w , unsigned int revents ) { uv_udp_t * handle ; if ( revents & POLLOUT ) { uv__udp_sendmsg ( handle ); uv__udp_run_completed ( handle ); } } \u6211\u4eec\u5148\u770buv__udp_sendmsg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 static void uv__udp_sendmsg ( uv_udp_t * handle ) { uv_udp_send_t * req ; QUEUE * q ; struct msghdr h ; ssize_t size ; // \u9010\u4e2a\u8282\u70b9\u53d1\u9001 while ( ! QUEUE_EMPTY ( & handle -> write_queue )) { q = QUEUE_HEAD ( & handle -> write_queue ); req = QUEUE_DATA ( q , uv_udp_send_t , queue ); memset ( & h , 0 , sizeof h ); // \u5ffd\u7565\u53c2\u6570\u5904\u7406 h . msg_iov = ( struct iovec * ) req -> bufs ; h . msg_iovlen = req -> nbufs ; do { size = sendmsg ( handle -> io_watcher . fd , & h , 0 ); } while ( size == -1 && errno == EINTR ); if ( size == -1 ) { // \u7e41\u5fd9\u5219\u5148\u4e0d\u53d1\u4e86\uff0c\u7b49\u5230\u53ef\u5199\u4e8b\u4ef6 if ( errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS ) break ; } // \u8bb0\u5f55\u53d1\u9001\u7ed3\u679c req -> status = ( size == -1 ? UV__ERR ( errno ) : size ); // \u53d1\u9001\u201c\u5b8c\u201d\u79fb\u51fa\u5199\u961f\u5217 QUEUE_REMOVE ( & req -> queue ); // \u52a0\u5165\u5199\u5b8c\u6210\u961f\u5217 QUEUE_INSERT_TAIL ( & handle -> write_completed_queue , & req -> queue ); /* \u6709\u8282\u70b9\u6570\u636e\u5199\u5b8c\u4e86\uff0c\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0c pending\u9636\u6bb5\u6267\u884c\u56de\u8c03uv__udp_io */ uv__io_feed ( handle -> loop , & handle -> io_watcher ); } } \u8be5\u51fd\u6570\u904d\u5386\u5199\u961f\u5217\uff0c\u7136\u540e\u9010\u4e2a\u53d1\u9001\u8282\u70b9\u4e2d\u7684\u6570\u636e\uff0c\u5e76\u8bb0\u5f55\u53d1\u9001\u7ed3\u679c\u3002 1 \u5982\u679c\u5199\u7e41\u5fd9\u5219\u7ed3\u675f\u5199\u903b\u8f91\uff0c\u7b49\u5f85\u4e0b\u4e00\u6b21\u5199\u4e8b\u4ef6\u89e6\u53d1\u3002 2 \u5982\u679c\u5199\u6210\u529f\u5219\u628a\u8282\u70b9\u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217\u4e2d\uff0c\u5e76\u4e14\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\u3002 \u7b49\u5f85pending\u9636\u6bb5\u6267\u884c\u56de\u8c03\u65f6\uff0c\u6267\u884c\u7684\u51fd\u6570\u662fuv__udp_io\u3002 \u6211\u4eec\u518d\u6b21\u56de\u5230uv__udp_io\u4e2d 1 2 3 4 if ( revents & POLLOUT ) { uv__udp_sendmsg ( handle ); uv__udp_run_completed ( handle ); } \u6211\u4eec\u770b\u5230\u8fd9\u65f6\u5019\u4f1a\u7ee7\u7eed\u6267\u884c\u6570\u636e\u53d1\u9001\u7684\u903b\u8f91\uff0c\u7136\u540e\u5904\u7406\u5199\u5b8c\u6210\u961f\u5217\u3002\u6211\u4eec\u770buv__udp_run_completed\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 static void uv__udp_run_completed ( uv_udp_t * handle ) { uv_udp_send_t * req ; QUEUE * q ; handle -> flags |= UV_HANDLE_UDP_PROCESSING ; // \u9010\u4e2a\u8282\u70b9\u5904\u7406 while ( ! QUEUE_EMPTY ( & handle -> write_completed_queue )) { q = QUEUE_HEAD ( & handle -> write_completed_queue ); QUEUE_REMOVE ( q ); req = QUEUE_DATA ( q , uv_udp_send_t , queue ); uv__req_unregister ( handle -> loop , req ); // \u66f4\u65b0\u5f85\u5199\u6570\u636e\u5927\u5c0f handle -> send_queue_size -= uv__count_bufs ( req -> bufs , req -> nbufs ); handle -> send_queue_count -- ; // \u5982\u679c\u91cd\u65b0\u7533\u8bf7\u4e86\u5806\u5185\u5b58\uff0c\u5219\u9700\u8981\u91ca\u653e if ( req -> bufs != req -> bufsml ) uv__free ( req -> bufs ); req -> bufs = NULL ; if ( req -> send_cb == NULL ) continue ; // \u6267\u884c\u56de\u8c03 if ( req -> status >= 0 ) req -> send_cb ( req , 0 ); else req -> send_cb ( req , req -> status ); } // \u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u6ce8\u9500\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6 if ( QUEUE_EMPTY ( & handle -> write_queue )) { uv__io_stop ( handle -> loop , & handle -> io_watcher , POLLOUT ); if ( ! uv__io_active ( & handle -> io_watcher , POLLIN )) uv__handle_stop ( handle ); } handle -> flags &= ~ UV_HANDLE_UDP_PROCESSING ; } \u8fd9\u5c31\u662f\u53d1\u9001\u7684\u903b\u8f91\uff0c\u53d1\u9001\u5b8c\u540eLibuv\u4f1a\u8c03\u7528C++\u56de\u8c03\uff0c\u6700\u540e\u56de\u8c03JS\u5c42\u56de\u8c03\u3002\u5177\u4f53\u5230\u64cd\u4f5c\u7cfb\u7edf\u4e5f\u662f\u7c7b\u4f3c\u7684\u5b9e\u73b0\uff0c\u64cd\u4f5c\u7cfb\u7edf\u9996\u5148\u5224\u65ad\u6570\u636e\u7684\u5927\u5c0f\u662f\u5426\u5c0f\u4e8e\u5199\u7f13\u51b2\u533a\uff0c\u662f\u7684\u8bdd\u7533\u8bf7\u4e00\u5757\u5185\u5b58\uff0c\u7136\u540e\u6784\u9020UDP\u534f\u8bae\u6570\u636e\u5305\uff0c\u518d\u9010\u5c42\u5f80\u4e0b\u8c03\uff0c\u6700\u540e\u53d1\u9001\u51fa\u6765\uff0c\u4f46\u662f\u5982\u679c\u6570\u636e\u8d85\u8fc7\u4e86\u5e95\u5c42\u7684\u62a5\u6587\u5927\u5c0f\u9650\u5236\uff0c\u5219\u4f1a\u88ab\u5206\u7247\u3002 16.2.4 \u63a5\u6536\u6570\u636e \u00b6 UDP\u670d\u52a1\u5668\u542f\u52a8\u7684\u65f6\u5019\uff0c\u5c31\u6ce8\u518c\u4e86\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\u7684\u53d1\u9001\uff0c\u5982\u679c\u6536\u5230\u4e86\u6570\u636e\uff0c\u5219\u5728Poll IO\u9636\u6bb5\u5c31\u4f1a\u88ab\u5904\u7406\u3002\u524d\u9762\u6211\u4eec\u8bb2\u8fc7\uff0c\u56de\u8c03\u51fd\u6570\u662fuv__udp_io\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u8be5\u51fd\u6570\u600e\u4e48\u5904\u7406\u7684\u3002 1 2 3 4 5 6 7 8 static void uv__udp_io ( uv_loop_t * loop , uv__io_t * w , unsigned int revents ) { uv_udp_t * handle ; handle = container_of ( w , uv_udp_t , io_watcher ); // \u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1 if ( revents & POLLIN ) uv__udp_recvmsg ( handle ); } \u6211\u4eec\u770buv__udp_recvmsg\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 static void uv__udp_recvmsg ( uv_udp_t * handle ) { struct sockaddr_storage peer ; struct msghdr h ; ssize_t nread ; uv_buf_t buf ; int flags ; int count ; count = 32 ; do { // \u5206\u914d\u5185\u5b58\u63a5\u6536\u6570\u636e\uff0cC++\u5c42\u8bbe\u7f6e\u7684 buf = uv_buf_init ( NULL , 0 ); handle -> alloc_cb (( uv_handle_t * ) handle , 64 * 1024 , & buf ); memset ( & h , 0 , sizeof ( h )); memset ( & peer , 0 , sizeof ( peer )); h . msg_name = & peer ; h . msg_namelen = sizeof ( peer ); h . msg_iov = ( void * ) & buf ; h . msg_iovlen = 1 ; // \u8c03\u64cd\u4f5c\u7cfb\u7edf\u7684\u51fd\u6570\u8bfb\u53d6\u6570\u636e do { nread = recvmsg ( handle -> io_watcher . fd , & h , 0 ); } while ( nread == -1 && errno == EINTR ); // \u8c03\u7528C++\u5c42\u56de\u8c03 handle -> recv_cb ( handle , nread , & buf , ( const struct sockaddr * ) & peer , flags ); } } \u6700\u7ec8\u901a\u8fc7\u64cd\u4f5c\u7cfb\u7edf\u8c03\u7528recvmsg\u8bfb\u53d6\u6570\u636e\uff0c\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230\u4e00\u4e2audp\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u4f1a\u6302\u8f7d\u5230socket\u7684\u63a5\u6536\u961f\u5217\uff0c\u5982\u679c\u63a5\u6536\u961f\u5217\u6ee1\u4e86\u5219\u4f1a\u4e22\u5f03\uff0c\u5f53\u7528\u6237\u8c03\u7528recvmsg\u51fd\u6570\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u628a\u63a5\u6536\u961f\u5217\u4e2d\u8282\u70b9\u9010\u4e2a\u8fd4\u56de\u7ed9\u7528\u6237\u3002\u8bfb\u53d6\u5b8c\u540e\uff0cLibuv\u4f1a\u56de\u8c03C++\u5c42\uff0c\u7136\u540eC++\u5c42\u56de\u8c03\u5230JS\u5c42\uff0c\u6700\u540e\u89e6\u53d1message\u4e8b\u4ef6\uff0c\u8fd9\u5c31\u662f\u5bf9\u5e94\u5f00\u59cb\u90a3\u6bb5\u4ee3\u7801\u7684message\u4e8b\u4ef6\u3002 16.2.5 \u591a\u64ad \u00b6 \u6211\u4eec\u77e5\u9053\uff0cTCP\u662f\u57fa\u4e8e\u8fde\u63a5\u548c\u53ef\u9760\u7684\uff0c\u591a\u64ad\u5219\u4f1a\u5e26\u6765\u8fc7\u591a\u7684\u8fde\u63a5\u548c\u6d41\u91cf\uff0c\u6240\u4ee5TCP\u662f\u4e0d\u652f\u6301\u591a\u64ad\u7684\uff0c\u800cUDP\u5219\u652f\u6301\u591a\u64ad\u3002\u591a\u64ad\u5206\u4e3a\u5c40\u57df\u7f51\u591a\u64ad\u548c\u5e7f\u57df\u7f51\u591a\u64ad\uff0c\u6211\u4eec\u77e5\u9053\u5728\u5c40\u57df\u7f51\u5185\u53d1\u751f\u4e00\u4e2a\u6570\u636e\uff0c\u662f\u4f1a\u4ee5\u5e7f\u64ad\u7684\u5f62\u5f0f\u53d1\u9001\u5230\u5404\u4e2a\u4e3b\u673a\u7684\uff0c\u4e3b\u673a\u6839\u636e\u76ee\u7684\u5730\u5740\u5224\u65ad\u662f\u5426\u9700\u8981\u5904\u7406\u8be5\u6570\u636e\u5305\u3002\u5982\u679cUDP\u662f\u5355\u64ad\u7684\u6a21\u5f0f\uff0c\u5219\u53ea\u4f1a\u6709\u4e00\u4e2a\u4e3b\u673a\u4f1a\u5904\u7406\u8be5\u6570\u636e\u5305\u3002\u5982\u679cUDP\u662f\u591a\u64ad\u7684\u6a21\u5f0f\uff0c\u5219\u6709\u591a\u4e2a\u4e3b\u673a\u5904\u7406\u8be5\u6570\u636e\u5305\u3002\u591a\u64ad\u7684\u65f6\u5019\uff0c\u5b58\u5728\u4e00\u4e2a\u591a\u64ad\u7ec4\u7684\u6982\u5ff5\uff0c\u8fd9\u5c31\u662fIGMP\u505a\u7684\u4e8b\u60c5\u3002\u5b83\u5b9a\u4e49\u4e86\u7ec4\u7684\u6982\u5ff5\u3002\u53ea\u6709\u52a0\u5165\u8fd9\u4e2a\u7ec4\u7684\u4e3b\u673a\u624d\u80fd\u5904\u7406\u8be5\u7ec4\u7684\u6570\u636e\u5305\u3002\u5047\u8bbe\u6709\u4ee5\u4e0b\u5c40\u57df\u7f51\uff0c\u5982\u56fe16-1\u6240\u793a\u3002 \u56fe16-1 \u5f53\u4e3b\u673a1\u7ed9\u591a\u64ad\u7ec41\u53d1\u9001\u6570\u636e\u7684\u65f6\u5019\uff0c\u4e3b\u673a4\u53ef\u4ee5\u6536\u5230\uff0c\u4e3b\u673a2\uff0c3\u5219\u65e0\u6cd5\u6536\u5230\u3002 \u6211\u4eec\u518d\u6765\u770b\u770b\u5e7f\u57df\u7f51\u7684\u591a\u64ad\u3002\u5e7f\u57df\u7f51\u7684\u591a\u64ad\u9700\u8981\u8def\u7531\u5668\u7684\u652f\u6301\uff0c\u591a\u4e2a\u8def\u7531\u5668\u4e4b\u95f4\u4f1a\u4f7f\u7528\u591a\u64ad\u8def\u7531\u534f\u8bae\u4ea4\u6362\u591a\u64ad\u7ec4\u7684\u4fe1\u606f\u3002\u5047\u8bbe\u6709\u4ee5\u4e0b\u5e7f\u57df\u7f51\uff0c\u5982\u56fe16-2\u6240\u793a\u3002 \u56fe16-2 \u5f53\u4e3b\u673a1\u7ed9\u591a\u64ad\u7ec41\u53d1\u9001\u6570\u636e\u7684\u65f6\u5019\uff0c\u8def\u7531\u56681\u4f1a\u7ed9\u8def\u7531\u56682\u53d1\u9001\u4e00\u4efd\u6570\u636e\uff08\u901a\u8fc7\u591a\u64ad\u8def\u7531\u534f\u8bae\u4ea4\u6362\u4e86\u4fe1\u606f\uff0c\u8def\u75311\u77e5\u9053\u8def\u7531\u56682\u7684\u4e3b\u673a7\u5728\u591a\u64ad\u7ec41\u4e2d\uff09\uff0c\u4f46\u662f\u8def\u7531\u56682\u4e0d\u4f1a\u7ed9\u8def\u7531\u56683\u53d1\u9001\u6570\u636e\uff0c\u56e0\u4e3a\u5b83\u77e5\u9053\u8def\u7531\u56683\u5bf9\u5e94\u7684\u7f51\u7edc\u4e2d\u6ca1\u6709\u4e3b\u673a\u5728\u591a\u64ad\u7ec41\u3002 \u4ee5\u4e0a\u662f\u591a\u64ad\u7684\u4e00\u4e9b\u6982\u5ff5\u3002Node.js\u4e2d\u5173\u4e8e\u591a\u64ad\u7684\u5b9e\u73b0\uff0c\u57fa\u672c\u662f\u5bf9\u64cd\u4f5c\u7cfb\u7edfAPI\u7684\u5c01\u88c5\uff0c\u6240\u4ee5\u5c31\u4e0d\u6253\u7b97\u8bb2\u89e3\uff0c\u6211\u4eec\u76f4\u63a5\u770b\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u5bf9\u4e8e\u591a\u64ad\u7684\u5b9e\u73b0\u3002 16.2.5.1 \u52a0\u5165\u4e00\u4e2a\u591a\u64ad\u7ec4 \u00b6 \u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u63a5\u53e3\u52a0\u5165\u4e00\u4e2a\u591a\u64ad\u7ec4\u3002 1 2 3 4 5 setsockopt ( fd , IPPROTO_IP , IP_ADD_MEMBERSHIP , & mreq , // \u8bb0\u5f55\u51fa\u53e3ip\u548c\u52a0\u5165\u591a\u64ad\u7ec4\u7684ip sizeof ( mreq )); mreq\u7684\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b 1 2 3 4 5 6 7 struct ip_mreq { // \u52a0\u5165\u7684\u591a\u64ad\u7ec4ip struct in_addr imr_multiaddr ; // \u51fa\u53e3ip struct in_addr imr_interface ; }; \u6211\u4eec\u770b\u4e00\u4e0bsetsockopt\u7684\u5b9e\u73b0\uff08\u53ea\u5217\u51fa\u76f8\u5173\u90e8\u5206\u4ee3\u7801\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 case IP_ADD_MEMBERSHIP : { struct ip_mreq mreq ; static struct options optmem ; unsigned long route_src ; struct rtable * rt ; struct device * dev = NULL ; err = verify_area ( VERIFY_READ , optval , sizeof ( mreq )); memcpy_fromfs ( & mreq , optval , sizeof ( mreq )); // \u6ca1\u6709\u8bbe\u7f6edevice\u5219\u6839\u636e\u591a\u64ad\u7ec4ip\u9009\u62e9\u4e00\u4e2adevice if ( mreq . imr_interface . s_addr == INADDR_ANY ) { if (( rt = ip_rt_route ( mreq . imr_multiaddr . s_addr , & optmem , & route_src )) != NULL ) { dev = rt -> rt_dev ; rt -> rt_use -- ; } } else { // \u6839\u636e\u8bbe\u7f6e\u7684ip\u627e\u5230\u5bf9\u5e94\u7684device for ( dev = dev_base ; dev ; dev = dev -> next ) { // \u5728\u5de5\u4f5c\u72b6\u6001\u3001\u652f\u6301\u591a\u64ad\uff0cip\u4e00\u6837 if (( dev -> flags & IFF_UP ) && ( dev -> flags & IFF_MULTICAST ) && ( dev -> pa_addr == mreq . imr_interface . s_addr )) break ; } } // \u52a0\u5165\u591a\u64ad\u7ec4 return ip_mc_join_group ( sk , dev , mreq . imr_multiaddr . s_addr ); } \u9996\u5148\u62ff\u5230\u52a0\u5165\u7684\u591a\u64ad\u7ec4IP\u548c\u51fa\u53e3IP\u5bf9\u5e94\u7684device\u540e\uff0c\u8c03\u7528ip_mc_join_group\uff0c\u5728socket\u7ed3\u6784\u4f53\u4e2d\uff0c\u6709\u4e00\u4e2a\u5b57\u6bb5\u7ef4\u62a4\u4e86\u8be5socket\u52a0\u5165\u7684\u591a\u64ad\u7ec4\u4fe1\u606f\uff0c\u5982\u56fe16-3\u6240\u793a\u3002 \u56fe16-3 \u6211\u4eec\u63a5\u7740\u770b\u4e00\u4e0bip_mc_join_group 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 int ip_mc_join_group ( struct sock * sk , struct device * dev , unsigned long addr ) { int unused = -1 ; int i ; // \u8fd8\u6ca1\u6709\u52a0\u5165\u8fc7\u591a\u64ad\u7ec4\u5219\u5206\u914d\u4e00\u4e2aip_mc_socklist\u7ed3\u6784\u4f53 if ( sk -> ip_mc_list == NULL ) { if (( sk -> ip_mc_list = ( struct ip_mc_socklist * ) kmalloc ( sizeof ( * sk -> ip_mc_list ), GFP_KERNEL )) == NULL ) return - ENOMEM ; memset ( sk -> ip_mc_list , '\\0' , sizeof ( * sk -> ip_mc_list )); } // \u904d\u5386\u52a0\u5165\u7684\u591a\u64ad\u7ec4\u961f\u5217\uff0c\u5224\u65ad\u662f\u5426\u5df2\u7ecf\u52a0\u5165\u8fc7 for ( i = 0 ; i < IP_MAX_MEMBERSHIPS ; i ++ ) { if ( sk -> ip_mc_list -> multiaddr [ i ] == addr && sk -> ip_mc_list -> multidev [ i ] == dev ) return - EADDRINUSE ; if ( sk -> ip_mc_list -> multidev [ i ] == NULL ) // \u8bb0\u5f55\u53ef\u7528\u4f4d\u7f6e\u7684\u7d22\u5f15 unused = i ; } // \u5230\u8fd9\u8bf4\u660e\u6ca1\u6709\u52a0\u5165\u8fc7\u5f53\u524d\u8bbe\u7f6e\u7684\u591a\u64ad\u7ec4\uff0c\u5219\u8bb0\u5f55\u5e76\u4e14\u52a0\u5165 if ( unused == -1 ) return - ENOBUFS ; sk -> ip_mc_list -> multiaddr [ unused ] = addr ; sk -> ip_mc_list -> multidev [ unused ] = dev ; // addr\u4e3a\u591a\u64ad\u7ec4ip ip_mc_inc_group ( dev , addr ); return 0 ; } ip_mc_join_group\u51fd\u6570\u7684\u4e3b\u8981\u903b\u8f91\u662f\u628asocket\u60f3\u52a0\u5165\u7684\u591a\u64ad\u7ec4\u4fe1\u606f\u8bb0\u5f55\u5230socket\u7684ip_mc_list\u5b57\u6bb5\u4e2d\uff08\u5982\u679c\u8fd8\u6ca1\u6709\u52a0\u5165\u8fc7\u8be5\u591a\u64ad\u7ec4\u7684\u8bdd\uff09\u3002\u63a5\u7740\u8c03ip_mc_inc_group\u5f80\u4e0b\u8d70\u3002device\u7684ip_mc_list\u5b57\u6bb5\u7ef4\u62a4\u4e86\u4e3b\u673a\u4e2d\u4f7f\u7528\u4e86\u8be5device\u7684\u591a\u64ad\u7ec4\u4fe1\u606f\uff0c\u5982\u56fe16-4\u6240\u793a\u3002 \u56fe16-4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 static void ip_mc_inc_group ( struct device * dev , unsigned long addr ) { struct ip_mc_list * i ; /* \u904d\u5386\u8be5\u8bbe\u5907\u7ef4\u62a4\u7684\u591a\u64ad\u7ec4\u961f\u5217\uff0c \u5224\u65ad\u662f\u5426\u5df2\u7ecf\u6709socket\u52a0\u5165\u8fc7\u8be5\u591a\u64ad\u7ec4\uff0c\u662f\u5219\u5f15\u7528\u6570\u52a0\u4e00 */ for ( i = dev -> ip_mc_list ; i != NULL ; i = i -> next ) { if ( i -> multiaddr == addr ) { i -> users ++ ; return ; } } // \u5230\u8fd9\u8bf4\u660e\uff0c\u8fd8\u6ca1\u6709socket\u52a0\u5165\u8fc7\u5f53\u524d\u591a\u64ad\u7ec4\uff0c\u5219\u8bb0\u5f55\u5e76\u52a0\u5165 i = ( struct ip_mc_list * ) kmalloc ( sizeof ( * i ), GFP_KERNEL ); if ( ! i ) return ; i -> users = 1 ; i -> interface = dev ; i -> multiaddr = addr ; i -> next = dev -> ip_mc_list ; // \u901a\u8fc7igmp\u901a\u77e5\u5176\u5b83\u65b9 igmp_group_added ( i ); dev -> ip_mc_list = i ; } ip_mc_inc_group\u51fd\u6570\u7684\u4e3b\u8981\u903b\u8f91\u662f\u5224\u65adsocket\u60f3\u8981\u52a0\u5165\u7684\u591a\u64ad\u7ec4\u662f\u4e0d\u662f\u5df2\u7ecf\u5b58\u5728\u4e8e\u5f53\u524ddevice\u4e2d\uff0c\u5982\u679c\u4e0d\u662f\u5219\u65b0\u589e\u4e00\u4e2a\u8282\u70b9\u3002\u7ee7\u7eed\u8c03\u7528igmp_group_added 1 2 3 4 5 6 7 8 9 10 11 12 13 14 static void igmp_group_added ( struct ip_mc_list * im ) { // \u521d\u59cb\u5316\u5b9a\u65f6\u5668 igmp_init_timer ( im ); /* \u53d1\u9001\u4e00\u4e2aigmp\u6570\u636e\u5305\uff0c\u540c\u6b65\u591a\u64ad\u7ec4\u4fe1\u606f\uff08socket\u52a0\u5165 \u4e86\u4e00\u4e2a\u65b0\u7684\u591a\u64ad\u7ec4\uff09 */ igmp_send_report ( im -> interface , im -> multiaddr , IGMP_HOST_MEMBERSHIP_REPORT ); // \u8f6c\u6362\u591a\u64ad\u7ec4ip\u5230\u591a\u64admac\u5730\u5740\uff0c\u5e76\u8bb0\u5f55\u5230device\u4e2d ip_mc_filter_add ( im -> interface , im -> multiaddr ); } \u6211\u4eec\u770b\u770bigmp_send_report\u548cip_mc_filter_add\u7684\u5177\u4f53\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 static void igmp_send_report ( struct device * dev , unsigned long address , int type ) { // \u7533\u8bf7\u4e00\u4e2askb\u8868\u793a\u4e00\u4e2a\u6570\u636e\u5305 struct sk_buff * skb = alloc_skb ( MAX_IGMP_SIZE , GFP_ATOMIC ); int tmp ; struct igmphdr * igh ; /* \u6784\u5efaip\u5934\uff0cip\u534f\u8bae\u5934\u7684\u6e90ip\u662fINADDR_ANY\uff0c \u5373\u968f\u673a\u9009\u62e9\u4e00\u4e2a\u672c\u673a\u7684\uff0c\u76ee\u7684ip\u4e3a\u591a\u64ad\u7ec4ip\uff08address\uff09 */ tmp = ip_build_header ( skb , INADDR_ANY , address , & dev , IPPROTO_IGMP , NULL , skb -> mem_len , 0 , 1 ); /* data\u8868\u793a\u6240\u6709\u7684\u6570\u636e\u90e8\u5206\uff0ctmp\u8868\u793aip\u5934\u5927\u5c0f\uff0c\u6240\u4ee5igh \u5c31\u662fip\u534f\u8bae\u7684\u6570\u636e\u90e8\u5206\uff0c\u5373igmp\u62a5\u6587\u7684\u5185\u5bb9 */ igh = ( struct igmphdr * )( skb -> data + tmp ); skb -> len = tmp + sizeof ( * igh ); igh -> csum = 0 ; igh -> unused = 0 ; igh -> type = type ; igh -> group = address ; igh -> csum = ip_compute_csum (( void * ) igh , sizeof ( * igh )); // \u8c03\u7528ip\u5c42\u53d1\u9001\u51fa\u53bb ip_queue_xmit ( NULL , dev , skb , 1 ); } igmp_send_report\u5176\u5b9e\u5c31\u662f\u6784\u9020\u4e00\u4e2aIGMP\u534f\u8bae\u6570\u636e\u5305\uff0c\u7136\u540e\u53d1\u9001\u51fa\u53bb\uff0c\u544a\u8bc9\u8def\u7531\u5668\u67d0\u4e2a\u4e3b\u673a\u52a0\u5165\u4e86\u591a\u64ad\u7ec4\uff0cIGMP\u7684\u534f\u8bae\u683c\u5f0f\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 struct igmphdr { // \u7c7b\u578b unsigned char type ; unsigned char unused ; // \u6821\u9a8c\u548c unsigned short csum ; // igmp\u7684\u6570\u636e\u90e8\u5206\uff0c\u6bd4\u5982\u52a0\u5165\u591a\u64ad\u7ec4\u7684\u65f6\u5019\uff0cgroup\u8868\u793a\u591a\u64ad\u7ec4ip unsigned long group ; }; \u63a5\u7740\u6211\u4eec\u770bip_mc_filter_add 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void ip_mc_filter_add ( struct device * dev , unsigned long addr ) { char buf [ 6 ]; // \u628a\u591a\u64ad\u7ec4ip\u8f6c\u6210mac\u591a\u64ad\u5730\u5740 addr = ntohl ( addr ); buf [ 0 ] = 0x01 ; buf [ 1 ] = 0x00 ; buf [ 2 ] = 0x5e ; buf [ 5 ] = addr & 0xFF ; addr >>= 8 ; buf [ 4 ] = addr & 0xFF ; addr >>= 8 ; buf [ 3 ] = addr & 0x7F ; dev_mc_add ( dev , buf , ETH_ALEN , 0 ); } \u6211\u4eec\u77e5\u9053IP\u5730\u5740\u662f32\u4f4d\uff0cmac\u5730\u5740\u662f48\u4f4d\uff0c\u4f46\u662fIANA\u89c4\u5b9a\uff0cIP V4\u7ec4\u64adMAC\u5730\u5740\u7684\u9ad824\u4f4d\u662f0x01005E\uff0c\u7b2c25\u4f4d\u662f0\uff0c\u4f4e23\u4f4d\u662fipv4\u7ec4\u64ad\u5730\u5740\u7684\u4f4e23\u4f4d\u3002\u800c\u591a\u64ad\u7684IP\u5730\u5740\u9ad8\u56db\u4f4d\u56fa\u5b9a\u662f1110\u3002\u53e6\u5916\u4f4e23\u4f4d\u88ab\u6620\u5c04\u5230MAC\u591a\u64ad\u5730\u5740\u768423\u4f4d\uff0c\u6240\u4ee5\u591a\u64adIP\u5730\u5740\u4e2d\uff0c\u67095\u4f4d\u662f\u53ef\u4ee5\u968f\u673a\u7ec4\u5408\u7684\u3002\u8fd9\u5c31\u610f\u5473\u7740\uff0c\u6bcf32\u4e2a\u591a\u64adIP\u5730\u5740\uff0c\u6620\u5c04\u5230\u4e00\u4e2aMAC\u5730\u5740\u3002\u8fd9\u4f1a\u5e26\u6765\u4e00\u4e9b\u95ee\u9898\uff0c\u5047\u8bbe\u4e3b\u673ax\u52a0\u5165\u4e86\u591a\u64ad\u7ec4a\uff0c\u4e3b\u673ay\u52a0\u5165\u4e86\u591a\u64ad\u7ec4b\uff0c\u800ca\u548cb\u5bf9\u5e94\u7684mac\u591a\u64ad\u5730\u5740\u662f\u4e00\u6837\u7684\u3002\u5f53\u4e3b\u673az\u7ed9\u591a\u64ad\u7ec4a\u53d1\u9001\u4e00\u4e2a\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u8fd9\u65f6\u5019\u4e3b\u673ax\u548cy\u7684\u7f51\u5361\u90fd\u4f1a\u5904\u7406\u8be5\u6570\u636e\u5305\uff0c\u5e76\u4e0a\u62a5\u5230\u4e0a\u5c42\uff0c\u4f46\u662f\u591a\u64ad\u7ec4a\u5bf9\u5e94\u7684MAC\u591a\u64ad\u5730\u5740\u548c\u591a\u64ad\u7ec4b\u662f\u4e00\u6837\u7684\u3002\u6211\u4eec\u62ff\u5230\u4e00\u4e2a\u591a\u64ad\u7ec4ip\u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u8ba1\u7b97\u51fa\u5b83\u7684\u591a\u64adMAC\u5730\u5740\uff0c\u4f46\u662f\u53cd\u8fc7\u6765\u5c31\u4e0d\u884c\uff0c\u56e0\u4e3a\u4e00\u4e2a\u591a\u64admac\u5730\u5740\u5bf9\u5e94\u4e8632\u4e2a\u591a\u64adip\u5730\u5740\u3002\u90a3\u4e3b\u673ax\u548cy\u600e\u4e48\u5224\u65ad\u662f\u4e0d\u662f\u53d1\u7ed9\u81ea\u5df1\u7684\u6570\u636e\u5305\uff1f\u56e0\u4e3adevice\u7ef4\u62a4\u4e86\u4e00\u4e2a\u672cdevice\u4e0a\u7684\u591a\u64adIP\u5217\u8868\uff0c\u64cd\u4f5c\u7cfb\u7edf\u6839\u636e\u6536\u5230\u7684\u6570\u636e\u5305\u4e2d\u7684IP\u76ee\u7684\u5730\u5740\u548cdevice\u7684\u591a\u64adIP\u5217\u8868\u5bf9\u6bd4\u3002\u5982\u679c\u5728\u5217\u8868\u4e2d\uff0c\u5219\u8bf4\u660e\u662f\u53d1\u7ed9\u81ea\u5df1\u7684\u3002\u6700\u540e\u6211\u4eec\u770b\u770bdev_mc_add\u3002device\u4e2d\u7ef4\u62a4\u4e86\u5f53\u524d\u7684mac\u591a\u64ad\u5730\u5740\u5217\u8868\uff0c\u5b83\u4f1a\u628a\u8fd9\u4e2a\u5217\u8868\u4fe1\u606f\u540c\u6b65\u5230\u7f51\u5361\u4e2d\uff0c\u4f7f\u5f97\u7f51\u5361\u53ef\u4ee5\u5904\u7406\u8be5\u5217\u8868\u4e2d\u591a\u64admac\u5730\u5740\u7684\u6570\u636e\u5305\uff0c\u5982\u56fe16-5\u6240\u793a\u3002 \u56fe16-5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void dev_mc_add ( struct device * dev , void * addr , int alen , int newonly ) { struct dev_mc_list * dmi ; // device\u7ef4\u62a4\u7684\u591a\u64admac\u5730\u5740\u5217\u8868 for ( dmi = dev -> mc_list ; dmi != NULL ; dmi = dmi -> next ) { // \u5df2\u5b58\u5728\uff0c\u5219\u5f15\u7528\u8ba1\u6570\u52a0\u4e00 if ( memcmp ( dmi -> dmi_addr , addr , dmi -> dmi_addrlen ) == 0 && dmi -> dmi_addrlen == alen ) { if ( ! newonly ) dmi -> dmi_users ++ ; return ; } } // \u4e0d\u5b58\u5728\u5219\u65b0\u589e\u4e00\u4e2a\u9879\u5230device\u5217\u8868\u4e2d dmi = ( struct dev_mc_list * ) kmalloc ( sizeof ( * dmi ), GFP_KERNEL ); memcpy ( dmi -> dmi_addr , addr , alen ); dmi -> dmi_addrlen = alen ; dmi -> next = dev -> mc_list ; dmi -> dmi_users = 1 ; dev -> mc_list = dmi ; dev -> mc_count ++ ; // \u901a\u77e5\u7f51\u5361\u9700\u8981\u5904\u7406\u8be5\u591a\u64admac\u5730\u5740 dev_mc_upload ( dev ); } \u7f51\u5361\u7684\u5de5\u4f5c\u6a21\u5f0f\u6709\u51e0\u79cd\uff0c\u5206\u522b\u662f\u6b63\u5e38\u6a21\u5f0f\uff08\u53ea\u63a5\u6536\u53d1\u7ed9\u81ea\u5df1\u7684\u6570\u636e\u5305\uff09\u3001\u6df7\u6742\u6a21\u5f0f\uff08\u63a5\u6536\u6240\u6709\u6570\u636e\u5305\uff09\u3001\u591a\u64ad\u6a21\u5f0f\uff08\u63a5\u6536\u4e00\u822c\u6570\u636e\u5305\u548c\u591a\u64ad\u6570\u636e\u5305\uff09\u3002\u7f51\u5361\u9ed8\u8ba4\u662f\u53ea\u5904\u7406\u53d1\u7ed9\u81ea\u5df1\u7684\u6570\u636e\u5305\uff0c\u6240\u4ee5\u5f53\u6211\u4eec\u52a0\u5165\u4e00\u4e2a\u591a\u64ad\u7ec4\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u544a\u8bc9\u7f51\u5361\uff0c\u5f53\u6536\u5230\u8be5\u591a\u64ad\u7ec4\u7684\u6570\u636e\u5305\u65f6\uff0c\u9700\u8981\u5904\u7406\uff0c\u800c\u4e0d\u662f\u5ffd\u7565\u3002dev_mc_upload\u51fd\u6570\u5c31\u662f\u901a\u77e5\u7f51\u5361\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 void dev_mc_upload ( struct device * dev ) { struct dev_mc_list * dmi ; char * data , * tmp ; // \u4e0d\u5de5\u4f5c\u4e86 if ( ! ( dev -> flags & IFF_UP )) return ; /* \u5f53\u524d\u662f\u6df7\u6742\u6a21\u5f0f\uff0c\u5219\u4e0d\u9700\u8981\u8bbe\u7f6e\u591a\u64ad\u4e86\uff0c\u56e0\u4e3a\u7f51\u5361\u4f1a\u5904\u7406\u6240\u6709 \u6536\u5230\u7684\u6570\u636e\uff0c\u4e0d\u7ba1\u662f\u4e0d\u662f\u53d1\u7ed9\u81ea\u5df1\u7684 */ if ( dev -> flags & IFF_PROMISC ) { dev -> set_multicast_list ( dev , -1 , NULL ); return ; } /* \u591a\u64ad\u5730\u5740\u4e2a\u6570\uff0c\u4e3a0\uff0c\u5219\u8bbe\u7f6e\u7f51\u5361\u5de5\u4f5c\u6a21\u5f0f\u4e3a\u6b63\u5e38\u6a21\u5f0f\uff0c \u56e0\u4e3a\u4e0d\u9700\u8981\u5904\u7406\u591a\u64ad\u4e86 */ if ( dev -> mc_count == 0 ) { dev -> set_multicast_list ( dev , 0 , NULL ); return ; } data = kmalloc ( dev -> mc_count * dev -> addr_len , GFP_KERNEL ); // \u590d\u5236\u6240\u6709\u7684\u591a\u64admac\u5730\u5740\u4fe1\u606f for ( tmp = data , dmi = dev -> mc_list ; dmi != NULL ; dmi = dmi -> next ) { memcpy ( tmp , dmi -> dmi_addr , dmi -> dmi_addrlen ); tmp += dev -> addr_len ; } // \u544a\u8bc9\u7f51\u5361 dev -> set_multicast_list ( dev , dev -> mc_count , data ); kfree ( data ); } \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0bset_multicast_list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static void set_multicast_list ( struct device * dev , int num_addrs , void * addrs ) { int ioaddr = dev -> base_addr ; // \u591a\u64ad\u6a21\u5f0f if ( num_addrs > 0 ) { outb ( RX_MULT , RX_CMD ); inb ( RX_STATUS ); /* Clear status. */ } else if ( num_addrs < 0 ) { // \u6df7\u6742\u6a21\u5f0f outb ( RX_PROM , RX_CMD ); inb ( RX_STATUS ); } else { // \u6b63\u5e38\u6a21\u5f0f outb ( RX_NORM , RX_CMD ); inb ( RX_STATUS ); } } set_multicast_list\u5c31\u662f\u8bbe\u7f6e\u7f51\u5361\u5de5\u4f5c\u6a21\u5f0f\u7684\u51fd\u6570\u3002\u81f3\u6b64\uff0c\u6211\u4eec\u5c31\u6210\u529f\u52a0\u5165\u4e86\u4e00\u4e2a\u591a\u64ad\u7ec4\u3002\u79bb\u5f00\u4e00\u4e2a\u591a\u64ad\u7ec4\u4e5f\u662f\u7c7b\u4f3c\u7684\u8fc7\u7a0b\u3002 16.2.5.2 \u7ef4\u62a4\u591a\u64ad\u7ec4\u4fe1\u606f \u00b6 \u52a0\u5165\u591a\u64ad\u7ec4\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u4e3b\u52a8\u9000\u51fa\u591a\u64ad\u7ec4\uff0c\u4f46\u662f\u5982\u679c\u4e3b\u673a\u6302\u4e86\uff0c\u5c31\u65e0\u6cd5\u4e3b\u52a8\u9000\u51fa\u4e86\uff0c\u6240\u4ee5\u591a\u64ad\u8def\u7531\u4e5f\u4f1a\u5b9a\u671f\u5411\u6240\u6709\u591a\u64ad\u7ec4\u7684\u6240\u6709\u4e3b\u673a\u53d1\u9001\u63a2\u6d4b\u62a5\u6587\uff0c\u6240\u4ee5\u4e3b\u673a\u9700\u8981\u76d1\u542c\u6765\u81ea\u591a\u64ad\u8def\u7531\u7684\u63a2\u6d4b\u62a5\u6587\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void ip_mc_allhost ( struct device * dev ) { struct ip_mc_list * i ; for ( i = dev -> ip_mc_list ; i != NULL ; i = i -> next ) if ( i -> multiaddr == IGMP_ALL_HOSTS ) return ; i = ( struct ip_mc_list * ) kmalloc ( sizeof ( * i ), GFP_KERNEL ); if ( ! i ) return ; I -> users = 1 ; i -> interface = dev ; i -> multiaddr = IGMP_ALL_HOSTS ; i -> next = dev -> ip_mc_list ; dev -> ip_mc_list = i ; ip_mc_filter_add ( i -> interface , i -> multiaddr ); } \u8bbe\u5907\u542f\u52a8\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u8bbe\u7f6e\u7f51\u5361\u76d1\u542c\u76ee\u7684IP\u662f224.0.0.1\u7684\u62a5\u6587\uff0c\u4f7f\u5f97\u53ef\u4ee5\u5904\u7406\u76ee\u7684IP\u662f224.0.0.1\u7684\u591a\u64ad\u6d88\u606f\u3002\u8be5\u7c7b\u578b\u7684\u62a5\u6587\u662f\u591a\u64ad\u8def\u7531\u7528\u4e8e\u67e5\u8be2\u5c40\u57df\u7f51\u5f53\u524d\u591a\u64ad\u7ec4\u60c5\u51b5\u7684\uff0c\u6bd4\u5982\u67e5\u8be2\u54ea\u4e9b\u591a\u64ad\u7ec4\u5df2\u7ecf\u6ca1\u6709\u6210\u5458\u4e86\uff0c\u5982\u679c\u6ca1\u6709\u6210\u5458\u5219\u5220\u9664\u8def\u7531\u4fe1\u606f\u3002\u6211\u4eec\u770b\u770b\u5982\u4f55\u5904\u7406\u67d0\u8bbe\u5907\u7684IGMP\u62a5\u6587\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int igmp_rcv ( struct sk_buff * skb , struct device * dev , struct options * opt , unsigned long daddr , unsigned short len , unsigned long saddr , int redo , struct inet_protocol * protocol ) { // IGMP\u62a5\u5934 struct igmphdr * igh = ( struct igmphdr * ) skb -> h . raw ; // \u8be5\u6570\u636e\u5305\u662f\u53d1\u7ed9\u6240\u6709\u591a\u64ad\u4e3b\u673a\u7684\uff0c\u7528\u4e8e\u67e5\u8be2\u672c\u591a\u64ad\u7ec4\u4e2d\u662f\u5426\u8fd8\u6709\u6210\u5458 if ( igh -> type == IGMP_HOST_MEMBERSHIP_QUERY && daddr == IGMP_ALL_HOSTS ) igmp_heard_query ( dev ); // \u8be5\u6570\u636e\u5305\u662f\u5176\u5b83\u6210\u5458\u5bf9\u591a\u64ad\u8def\u7531\u67e5\u8be2\u62a5\u6587\u7684\u56de\u590d\uff0c\u540c\u591a\u64ad\u7ec4\u7684\u4e3b\u673a\u4e5f\u4f1a\u6536\u5230 if ( igh -> type == IGMP_HOST_MEMBERSHIP_REPORT && daddr == igh -> group ) igmp_heard_report ( dev , igh -> group ); kfree_skb ( skb , FREE_READ ); return 0 ; } IGMP V1\u53ea\u5904\u7406\u4e24\u79cd\u62a5\u6587\uff0c\u5206\u522b\u662f\u7ec4\u6210\u5458\u67e5\u8be2\u62a5\u6587\uff08\u67e5\u8be2\u7ec4\u662f\u5426\u6709\u6210\u5458\uff09\uff0c\u5176\u5b83\u6210\u5458\u56de\u590d\u591a\u64ad\u8def\u7531\u7684\u62a5\u544a\u62a5\u6587\u3002\u7ec4\u6210\u5458\u67e5\u8be2\u62a5\u6587\u7531\u591a\u64ad\u8def\u7531\u53d1\u51fa\uff0c\u6240\u6709\u7684\u591a\u64ad\u7ec4\u4e2d\u7684\u6240\u6709\u4e3b\u673a\u90fd\u53ef\u4ee5\u6536\u5230\u3002\u7ec4\u6210\u5458\u67e5\u8be2\u62a5\u6587\u7684IP\u534f\u8bae\u5934\u7684\u76ee\u7684\u5730\u5740\u662f224.0.0.1\uff08IGMP_ALL_HOSTS\uff09\uff0c\u4ee3\u8868\u6240\u6709\u7684\u7ec4\u64ad\u4e3b\u673a\u90fd\u53ef\u4ee5\u5904\u7406\u8be5\u62a5\u6587\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e24\u79cd\u62a5\u6587\u7684\u5177\u4f53\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 static void igmp_heard_query ( struct device * dev ) { struct ip_mc_list * im ; for ( im = dev -> ip_mc_list ; im != NULL ; im = im -> next ) // IGMP_ALL_HOSTS\u8868\u793a\u6240\u6709\u7ec4\u64ad\u4e3b\u673a if ( ! im -> tm_running && im -> multiaddr != IGMP_ALL_HOSTS ) igmp_start_timer ( im ); } \u8be5\u51fd\u6570\u7528\u4e8e\u5904\u7406\u7ec4\u64ad\u8def\u7531\u7684\u67e5\u8be2\u62a5\u6587\uff0cdev->ip_mc_list\u662f\u8be5\u8bbe\u5907\u5bf9\u5e94\u7684\u6240\u6709\u591a\u64ad\u7ec4\u4fe1\u606f\uff0c\u8fd9\u91cc\u9488\u5bf9\u8be5\u8bbe\u5907\u4e2d\u7684\u6bcf\u4e00\u4e2a\u591a\u64ad\u7ec4\uff0c\u5f00\u542f\u5bf9\u5e94\u7684\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u540e\u4f1a\u53d1\u9001\u56de\u590d\u62a5\u6587\u7ed9\u591a\u64ad\u8def\u7531\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5f00\u542f\u5b9a\u65f6\u5668\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 // \u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668 static void igmp_start_timer ( struct ip_mc_list * im ) { int tv ; if ( im -> tm_running ) return ; tv = random () % ( 10 * HZ ); /* Pick a number any number 8) */ im -> timer . expires = tv ; im -> tm_running = 1 ; add_timer ( & im -> timer ); } \u968f\u673a\u9009\u62e9\u4e00\u4e2a\u8d85\u65f6\u65f6\u95f4\uff0c\u7136\u540e\u63d2\u5165\u7cfb\u7edf\u7ef4\u62a4\u7684\u5b9a\u65f6\u5668\u961f\u5217\u3002\u4e3a\u4ec0\u4e48\u4f7f\u7528\u5b9a\u65f6\u5668\uff0c\u800c\u4e0d\u662f\u7acb\u5373\u56de\u590d\u5462\uff1f\u56e0\u4e3a\u591a\u64ad\u8def\u7531\u53ea\u9700\u8981\u77e5\u9053\u67d0\u4e2a\u591a\u64ad\u7ec4\u662f\u5426\u81f3\u5c11\u8fd8\u6709\u4e00\u4e2a\u6210\u5458\uff0c\u5982\u679c\u6709\u7684\u8bdd\u5c31\u4fdd\u5b58\u8be5\u591a\u64ad\u7ec4\u4fe1\u606f\uff0c\u5426\u5219\u5c31\u5220\u9664\u8def\u7531\u9879\u3002\u5982\u679c\u67d0\u591a\u64ad\u7ec4\u5728\u5c40\u57df\u7f51\u4e2d\u6709\u591a\u4e2a\u6210\u5458\uff0c\u90a3\u4e48\u591a\u4e2a\u6210\u5458\u90fd\u4f1a\u5904\u7406\u8be5\u62a5\u6587\uff0c\u5982\u679c\u90fd\u7acb\u5373\u54cd\u5e94\uff0c\u5219\u4f1a\u5f15\u8d77\u8fc7\u591a\u6ca1\u6709\u5fc5\u8981\u7684\u6d41\u91cf\uff0c\u56e0\u4e3a\u7ec4\u64ad\u8def\u7531\u53ea\u9700\u8981\u6536\u5230\u4e00\u4e2a\u54cd\u5e94\u5c31\u884c\u3002\u6211\u4eec\u770b\u770b\u8d85\u65f6\u65f6\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 static void igmp_init_timer ( struct ip_mc_list * im ) { im -> tm_running = 0 ; init_timer ( & im -> timer ); im -> timer . data = ( unsigned long ) im ; im -> timer . function =& igmp_timer_expire ; } static void igmp_timer_expire ( unsigned long data ) { struct ip_mc_list * im = ( struct ip_mc_list * ) data ; igmp_stop_timer ( im ); igmp_send_report ( im -> interface , im -> multiaddr , IGMP_HOST_MEMBERSHIP_REPORT ); } \u6211\u4eec\u770b\u5230\uff0c\u8d85\u65f6\u540e\u4f1a\u6267\u884cigmp_send_report\u53d1\u9001\u4e00\u4e2a\u7c7b\u578b\u662fIGMP_HOST_MEMBERSHIP_REPORT\u7684IGMP\u3001\u76ee\u7684IP\u662f\u591a\u64ad\u7ec4IP\u7684\u62a5\u6587\uff0c\u8bf4\u660e\u8be5\u591a\u64ad\u7ec4\u8fd8\u6709\u6210\u5458\u3002\u8be5\u62a5\u6587\u4e0d\u4ec5\u4f1a\u53d1\u9001\u7ed9\u591a\u64ad\u8def\u7531\uff0c\u8fd8\u4f1a\u53d1\u7ed9\u540c\u591a\u64ad\u7ec4\u7684\u6240\u6709\u4e3b\u673a\u3002\u5176\u5b83\u4e3b\u673a\u4e5f\u662f\u7c7b\u4f3c\u7684\u903b\u8f91\uff0c\u5373\u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\u3002\u6240\u4ee5\u6700\u5feb\u5230\u671f\u7684\u4e3b\u673a\u4f1a\u5148\u53d1\u9001\u56de\u590d\u62a5\u6587\u7ed9\u591a\u64ad\u8def\u7531\u548c\u540c\u591a\u64ad\u7ec4\u7684\u6210\u5458\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5176\u5b83\u540c\u591a\u64ad\u7ec4\u7684\u4e3b\u673a\u6536\u5230\u8be5\u7c7b\u62a5\u6587\u65f6\u7684\u5904\u7406\u903b\u8f91\u3002 1 2 3 // \u6210\u5458\u62a5\u544a\u62a5\u6587\u5e76\u4e14\u591a\u64ad\u7ec4\u662f\u5f53\u524d\u8bbe\u7f6e\u5173\u8054\u7684\u591a\u64ad\u7ec4 if ( igh -> type == IGMP_HOST_MEMBERSHIP_REPORT && daddr == igh -> group ) igmp_heard_report ( dev , igh -> group ); \u5f53\u4e00\u4e2a\u591a\u64ad\u7ec4\u7684\u5176\u5b83\u6210\u5458\u9488\u5bf9\u591a\u64ad\u8def\u7531\u7684\u67e5\u8be2\u62a5\u6587\u4f5c\u4e86\u54cd\u5e94\uff0c\u56e0\u4e3a\u8be5\u54cd\u5e94\u62a5\u6587\u7684\u76ee\u7684IP\u662f\u591a\u64ad\u7ec4IP\uff0c\u6240\u4ee5\u8be5\u591a\u64ad\u7ec4\u7684\u5176\u5b83\u6210\u5458\u4e5f\u80fd\u6536\u5230\u8be5\u62a5\u6587\u3002\u5f53\u67d0\u4e2a\u4e3b\u673a\u6536\u5230\u8be5\u7c7b\u578b\u7684\u62a5\u6587\u7684\u65f6\u5019\uff0c\u5c31\u77e5\u9053\u540c\u591a\u64ad\u7ec4\u7684\u5176\u5b83\u6210\u5458\u5df2\u7ecf\u56de\u590d\u4e86\u591a\u64ad\u8def\u7531\u4e86\uff0c\u6211\u4eec\u5c31\u4e0d\u9700\u8981\u56de\u590d\u4e86\u3002 1 2 3 4 5 6 7 8 9 10 11 /* \u6536\u5230\u5176\u5b83\u7ec4\u6210\u5458\uff0c\u5bf9\u4e8e\u591a\u64ad\u8def\u7531\u67e5\u8be2\u62a5\u6587\u7684\u56de\u590d\uff0c\u5219\u81ea\u5df1\u5c31\u4e0d\u7528\u56de\u590d\u4e86\uff0c \u56e0\u4e3a\u591a\u64ad\u8def\u7531\u77e5\u9053\u8be5\u7ec4\u8fd8\u6709\u6210\u5458\uff0c\u4e0d\u4f1a\u5220\u9664\u8def\u7531\u4fe1\u606f\uff0c\u51cf\u5c11\u7f51\u7edc\u6d41\u91cf */ static void igmp_heard_report ( struct device * dev , unsigned long address ) { struct ip_mc_list * im ; for ( im = dev -> ip_mc_list ; im != NULL ; im = im -> next ) if ( im -> multiaddr == address ) igmp_stop_timer ( im ); } \u6211\u4eec\u770b\u5230\uff0c\u8fd9\u91cc\u4f1a\u5220\u9664\u5b9a\u65f6\u5668\u3002\u5373\u4e0d\u4f1a\u4f5c\u4e3a\u54cd\u5e94\u4e86\u3002 2.3 \u5176\u5b83 socket\u5173\u95ed\uff0c \u9000\u51fa\u5b83\u4e4b\u524d\u52a0\u5165\u8fc7\u7684\u591a\u64ad 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void ip_mc_drop_socket ( struct sock * sk ) { int i ; if ( sk -> ip_mc_list == NULL ) return ; for ( i = 0 ; i < IP_MAX_MEMBERSHIPS ; i ++ ) { if ( sk -> ip_mc_list -> multidev [ i ]) { ip_mc_dec_group ( sk -> ip_mc_list -> multidev [ i ], sk -> ip_mc_list -> multiaddr [ i ]); sk -> ip_mc_list -> multidev [ i ] = NULL ; } } kfree_s ( sk -> ip_mc_list , sizeof ( * sk -> ip_mc_list )); sk -> ip_mc_list = NULL ; } \u8bbe\u5907\u505c\u6b62\u5de5\u4f5c\u4e86\uff0c\u5220\u9664\u5bf9\u5e94\u7684\u591a\u64ad\u4fe1\u606f 1 2 3 4 5 6 7 8 9 10 11 void ip_mc_drop_device ( struct device * dev ) { struct ip_mc_list * i ; struct ip_mc_list * j ; for ( i = dev -> ip_mc_list ; i != NULL ; i = j ) { j = i -> next ; kfree_s ( i , sizeof ( * i )); } dev -> ip_mc_list = NULL ; } \u4ee5\u4e0a\u662fIGMP V1\u7248\u672c\u7684\u5b9e\u73b0\uff0c\u5728\u540e\u7eedV2 V3\u7248\u672c\u4e86\u53c8\u589e\u52a0\u4e86\u5f88\u591a\u529f\u80fd\uff0c\u6bd4\u5982\u79bb\u5f00\u7ec4\u62a5\u6587\uff0c\u9488\u5bf9\u79bb\u5f00\u62a5\u6587\u4e2d\u7684\u591a\u64ad\u7ec4\uff0c\u589e\u52a0\u7279\u5b9a\u7ec4\u67e5\u8be2\u62a5\u6587\uff0c\u7528\u4e8e\u67e5\u8be2\u67d0\u4e2a\u7ec4\u4e2d\u662f\u5426\u8fd8\u6709\u6210\u5458\uff0c\u53e6\u5916\u8fd8\u6709\u8def\u7531\u9009\u4e3e\uff0c\u5f53\u5c40\u57df\u7f51\u4e2d\u6709\u591a\u4e2a\u591a\u64ad\u8def\u7531\uff0c\u591a\u64ad\u8def\u7531\u4e4b\u95f4\u901a\u8fc7\u534f\u8bae\u9009\u4e3e\u51faIP\u6700\u5c0f\u7684\u8def\u7531\u4e3a\u67e5\u8be2\u8def\u7531\uff0c\u5b9a\u65f6\u7ed9\u591a\u64ad\u7ec4\u53d1\u9001\u63a2\u6d4b\u62a5\u6587\u3002\u7136\u540e\u6210\u4e3a\u67e5\u8be2\u5668\u7684\u591a\u64ad\u8def\u7531\uff0c\u4f1a\u5b9a\u671f\u7ed9\u5176\u5b83\u591a\u64ad\u8def\u7531\u540c\u6b65\u5fc3\u8df3\u3002\u5426\u5219\u5176\u5b83\u591a\u64ad\u8def\u7531\u4f1a\u5728\u5b9a\u65f6\u5668\u8d85\u65f6\u65f6\u8ba4\u4e3a\u5f53\u524d\u67e5\u8be2\u8def\u7531\u5df2\u7ecf\u6302\u4e86\uff0c\u91cd\u65b0\u9009\u4e3e\u3002 16.2.5.3 \u5f00\u542f\u591a\u64ad \u00b6 UDP\u7684\u591a\u64ad\u80fd\u529b\u662f\u9700\u8981\u7528\u6237\u4e3b\u52a8\u5f00\u542f\u7684\uff0c\u539f\u56e0\u662f\u9632\u6b62\u7528\u6237\u53d1\u9001UDP\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u8bef\u4f20\u4e86\u4e00\u4e2a\u591a\u64ad\u5730\u5740\uff0c\u4f46\u5176\u5b9e\u7528\u6237\u662f\u60f3\u53d1\u9001\u4e00\u4e2a\u5355\u64ad\u7684\u6570\u636e\u5305\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7setBroadcast\u5f00\u542f\u591a\u64ad\u80fd\u529b\u3002\u6211\u4eec\u770bLibuv\u7684\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 int uv_udp_set_broadcast ( uv_udp_t * handle , int on ) { if ( setsockopt ( handle -> io_watcher . fd , SOL_SOCKET , SO_BROADCAST , & on , sizeof ( on ))) { return UV__ERR ( errno ); } return 0 ; } \u518d\u770b\u770b\u64cd\u4f5c\u7cfb\u7edf\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 int sock_setsockopt ( struct sock * sk , int level , int optname , char * optval , int optlen ){ ... case SO_BROADCAST : sk -> broadcast = val ? 1 : 0 ; } \u6211\u4eec\u770b\u5230\u5b9e\u73b0\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u8bbe\u7f6e\u4e00\u4e2a\u6807\u8bb0\u4f4d\u3002\u5f53\u6211\u4eec\u53d1\u9001\u6d88\u606f\u7684\u65f6\u5019\uff0c\u5982\u679c\u76ee\u7684\u5730\u5740\u662f\u591a\u64ad\u5730\u5740\uff0c\u4f46\u662f\u53c8\u6ca1\u6709\u8bbe\u7f6e\u8fd9\u4e2a\u6807\u8bb0\uff0c\u5219\u4f1a\u62a5\u9519\u3002 1 2 if ( ! sk -> broadcast && ip_chk_addr ( sin . sin_addr . s_addr ) == IS_BROADCAST ) return - EACCES ; \u4e0a\u9762\u4ee3\u7801\u6765\u81ea\u8c03\u7528udp\u7684\u53d1\u9001\u51fd\u6570\uff08\u4f8b\u5982sendto\uff09\u65f6\uff0c\u8fdb\u884c\u7684\u6821\u9a8c\uff0c\u5982\u679c\u53d1\u9001\u7684\u76ee\u7684ip\u662f\u591a\u64ad\u5730\u5740\uff0c\u4f46\u662f\u6ca1\u6709\u8bbe\u7f6e\u591a\u64ad\u6807\u8bb0\uff0c\u5219\u62a5\u9519\u3002 16.2.5.4 \u591a\u64ad\u7684\u95ee\u9898 \u00b6 \u670d\u52a1\u5668 1 2 3 4 5 6 7 8 9 10 11 const dgram = require ( 'dgram' ); const udp = dgram . createSocket ( 'udp4' ); udp . bind ( 1234 , () => { // \u5c40\u57df\u7f51\u591a\u64ad\u5730\u5740\uff08224.0.0.0~224.0.0.255\uff0c\u8be5\u8303\u56f4\u7684\u591a\u64ad\u6570\u636e\u5305\uff0c\u8def\u7531\u5668\u4e0d\u4f1a\u8f6c\u53d1\uff09 udp . addMembership ( '224.0.0.114' ); }); udp . on ( 'message' , ( msg , rinfo ) => { console . log ( `receive msg: ${ msg } from ${ rinfo . address } : ${ rinfo . port } ` ); }); \u670d\u52a1\u5668\u7ed1\u5b9a1234\u7aef\u53e3\u540e\uff0c\u52a0\u5165\u591a\u64ad\u7ec4224.0.0.114\uff0c\u7136\u540e\u7b49\u5f85\u591a\u64ad\u6570\u636e\u7684\u5230\u6765\u3002 \u5ba2\u6237\u7aef 1 2 3 4 5 6 const dgram = require ( 'dgram' ); const udp = dgram . createSocket ( 'udp4' ); udp . bind ( 1234 , () => { udp . addMembership ( '224.0.0.114' ); }); udp . send ( 'test' , 1234 , '224.0.0.114' , ( err ) => {}); \u5ba2\u6237\u7aef\u7ed1\u5b9a1234\u7aef\u53e3\u540e\uff0c\u4e5f\u52a0\u5165\u4e86\u591a\u64ad\u7ec4224.0.0.114\uff0c\u7136\u540e\u53d1\u9001\u6570\u636e\uff0c\u4f46\u662f\u53d1\u73b0\u670d\u52a1\u7aef\u6ca1\u6709\u6536\u5230\u6570\u636e\uff0c\u5ba2\u6237\u7aef\u6253\u5370\u4e86receive msg test from 169.254.167.41:1234\u3002\u8fd9\u600e\u4e48\u591a\u4e86\u4e00\u4e2aIP\u51fa\u6765\uff1f\u539f\u6765\u6211\u4e3b\u673a\u6709\u4e24\u4e2a\u5c40\u57df\u7f51\u5730\u5740\u3002\u5f53\u6211\u4eec\u52a0\u5165\u591a\u64ad\u7ec4\u7684\u65f6\u5019\uff0c\u4e0d\u4ec5\u53ef\u4ee5\u8bbe\u7f6e\u52a0\u5165\u54ea\u4e2a\u591a\u64ad\u7ec4\uff0c\u8fd8\u80fd\u8bbe\u7f6e\u51fa\u53e3\u7684\u8bbe\u5907\u548cIP\u3002\u5f53\u6211\u4eec\u8c03\u7528udp.addMembership('224.0.0.114')\u7684\u65f6\u5019\uff0c\u6211\u4eec\u53ea\u662f\u8bbe\u7f6e\u4e86\u6211\u4eec\u52a0\u5165\u7684\u591a\u64ad\u7ec4\uff0c\u6ca1\u6709\u8bbe\u7f6e\u51fa\u53e3\u3002\u8fd9\u65f6\u5019\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u4e3a\u6211\u4eec\u9009\u62e9\u4e00\u4e2a\u3002\u6839\u636e\u8f93\u51fa\uff0c\u6211\u4eec\u53d1\u73b0\u64cd\u4f5c\u7cfb\u7edf\u9009\u62e9\u7684\u662f169.254.167.41\uff08\u5b50\u7f51\u63a9\u7801\u662f255.255.0.0\uff09\u3002\u56e0\u4e3a\u8fd9\u4e2aIP\u548c192\u5f00\u5934\u7684\u90a3\u4e2a\u4e0d\u662f\u540c\u4e00\u5b50\u7f51\uff0c\u4f46\u662f\u6211\u4eec\u52a0\u5165\u7684\u662f\u5c40\u57df\u7f51\u7684\u591a\u64adIP\uff0c\u6240\u6709\u670d\u52a1\u7aef\u65e0\u6cd5\u6536\u5230\u5ba2\u6237\u7aef\u53d1\u51fa\u7684\u6570\u636e\u5305\u3002\u4e0b\u9762\u662fNode.js\u6587\u6863\u7684\u89e3\u91ca\u3002 Tells the kernel to join a multicast group at the given multicastAddress and multicastInterface using the IP_ADD_MEMBERSHIP socket option. If the multicastInterface argument is not specified, the operating system will choose one interface and will add membership to it. To add membership to every available interface, call addMembership multiple times, once per interface. \u6211\u4eec\u770b\u4e00\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u7684\u76f8\u5173\u903b\u8f91\u3002 1 2 if ( MULTICAST ( daddr ) && * dev == NULL && skb -> sk && * skb -> sk -> ip_mc_name ) * dev = dev_get ( skb -> sk -> ip_mc_name ); \u4e0a\u9762\u7684\u4ee3\u7801\u6765\u81ea\u64cd\u4f5c\u7cfb\u7edf\u53d1\u9001IP\u6570\u636e\u5305\u65f6\u7684\u903b\u8f91\uff0c\u5982\u679c\u76ee\u7684IP\u4f3c\u4e4e\u591a\u64ad\u5730\u5740\u5e76\u4e14ip_mc_name\u975e\u7a7a\uff08\u5373\u6211\u4eec\u901a\u8fc7addMembership\u7b2c\u4e8c\u4e2a\u53c2\u6570\u8bbe\u7f6e\u7684\u503c\uff09\uff0c\u5219\u51fa\u53e3\u8bbe\u5907\u5c31\u662f\u6211\u4eec\u8bbe\u7f6e\u7684\u503c\u3002\u5426\u5219\u64cd\u4f5c\u7cfb\u7edf\u81ea\u5df1\u9009\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u663e\u793a\u6307\u5b9a\u8fd9\u4e2a\u51fa\u53e3\uff0c\u628a\u4ee3\u7801\u6539\u6210udp.addMembership('224.0.0.114', '192.168.8.164');\u91cd\u65b0\u6267\u884c\u53d1\u73b0\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u90fd\u663e\u793a\u4e86receive msg test from 192.168.8.164:1234\u3002\u4e3a\u4ec0\u4e48\u5ba2\u6237\u7aef\u81ea\u5df1\u4e5f\u4f1a\u6536\u5230\u5462\uff1f\u539f\u6765\u64cd\u4f5c\u7cfb\u7edf\u53d1\u9001\u591a\u64ad\u6570\u636e\u7684\u65f6\u5019\uff0c\u4e5f\u4f1a\u7ed9\u81ea\u5df1\u53d1\u9001\u4e00\u4efd\u3002\u6211\u4eec\u770b\u770b\u76f8\u5173\u903b\u8f91 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // \u76ee\u7684\u5730\u662f\u591a\u64ad\u5730\u5740\uff0c\u5e76\u4e14\u4e0d\u662f\u56de\u73af\u8bbe\u5907 if ( MULTICAST ( iph -> daddr ) && ! ( dev -> flags & IFF_LOOPBACK )) { // \u662f\u5426\u9700\u8981\u7ed9\u81ea\u5df1\u4e00\u4efd\uff0c\u9ed8\u8ba4\u4e3atrue if ( sk == NULL || sk -> ip_mc_loop ) { // \u7ed9\u6240\u6709\u591a\u64ad\u7ec4\u7684\u6240\u6709\u4e3b\u673a\u7684\u6570\u636e\u5305\uff0c\u5219\u76f4\u63a5\u7ed9\u81ea\u5df1\u4e00\u4efd if ( iph -> daddr == IGMP_ALL_HOSTS ) ip_loopback ( dev , skb ); else { // \u5224\u65ad\u76ee\u7684ip\u662f\u5426\u5728\u5f53\u524d\u8bbe\u5907\u7684\u591a\u64adip\u5217\u8868\u4e2d\uff0c\u662f\u7684\u56de\u4f20\u4e00\u4efd struct ip_mc_list * imc = dev -> ip_mc_list ; while ( imc != NULL ) { if ( imc -> multiaddr == iph -> daddr ) { ip_loopback ( dev , skb ); break ; } imc = imc -> next ; } } } } \u4ee5\u4e0a\u4ee3\u7801\u6765\u81eaIP\u5c42\u53d1\u9001\u6570\u636e\u5305\u65f6\u7684\u903b\u8f91\u3002\u5982\u679c\u6211\u4eec\u8bbe\u7f6e\u4e86sk->ip_mc_loop\u5b57\u6bb5\u4e3a1\uff0c\u5e76\u4e14\u6570\u636e\u5305\u7684\u76ee\u7684IP\u5728\u51fa\u53e3\u8bbe\u5907\u7684\u591a\u64ad\u5217\u8868\u4e2d\uff0c\u5219\u9700\u8981\u7ed9\u81ea\u5df1\u56de\u4f20\u4e00\u4efd\u3002\u90a3\u4e48\u6211\u4eec\u5982\u4f55\u5173\u95ed\u8fd9\u4e2a\u7279\u6027\u5462\uff1f\u8c03\u7528udp.setMulticastLoopback(false)\u5c31\u53ef\u4ee5\u4e86\u3002 16.2.5.5 \u5176\u5b83\u529f\u80fd \u00b6 UDP\u6a21\u5757\u8fd8\u63d0\u4f9b\u4e86\u5176\u5b83\u4e00\u4e9b\u529f\u80fd 1 \u83b7\u53d6\u672c\u7aef\u5730\u5740address \u5982\u679c\u7528\u6237\u6ca1\u6709\u663e\u793a\u8c03\u7528bind\u7ed1\u5b9a\u81ea\u5df1\u8bbe\u7f6e\u7684IP\u548c\u7aef\u53e3\uff0c\u90a3\u4e48\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u968f\u673a\u9009\u62e9\u3002\u901a\u8fc7address\u51fd\u6570\u5c31\u53ef\u4ee5\u83b7\u53d6\u64cd\u4f5c\u7cfb\u7edf\u9009\u62e9\u7684\u6e90IP\u548c\u7aef\u53e3\u3002 2 \u83b7\u53d6\u5bf9\u7aef\u7684\u5730\u5740 \u901a\u8fc7remoteAddress\u51fd\u6570\u53ef\u4ee5\u83b7\u53d6\u5bf9\u7aef\u5730\u5740\u3002\u8be5\u5730\u5740\u7531\u7528\u6237\u8c03\u7528connect\u6216sendto\u51fd\u6570\u65f6\u8bbe\u7f6e\u3002 3 \u83b7\u53d6/\u8bbe\u7f6e\u7f13\u51b2\u533a\u5927\u5c0fget/setRecvBufferSize\uff0cget/setSendBufferSize 4 setMulticastLoopback \u53d1\u9001\u591a\u64ad\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u5982\u679c\u591a\u64adIP\u5728\u51fa\u53e3\u8bbe\u5907\u7684\u591a\u64ad\u5217\u8868\u4e2d\uff0c\u5219\u7ed9\u56de\u73af\u8bbe\u5907\u4e5f\u53d1\u4e00\u4efd\u3002 5 setMulticastInterface \u8bbe\u7f6e\u591a\u64ad\u6570\u636e\u7684\u51fa\u53e3\u8bbe\u5907 6 \u52a0\u5165\u6216\u9000\u51fa\u591a\u64ad\u7ec4addMembership/dropMembership 7 addSourceSpecificMembership/dropSourceSpecificMembership \u8fd9\u4e24\u4e2a\u51fd\u6570\u662f\u8bbe\u7f6e\u672c\u7aef\u53ea\u63a5\u6536\u7279\u6027\u6e90\uff08\u4e3b\u673a\uff09\u7684\u591a\u64ad\u6570\u636e\u5305\u3002 8 setTTL \u5355\u64adttl\uff08\u5355\u64ad\u7684\u65f6\u5019\uff0cIP\u534f\u8bae\u5934\u4e2d\u7684ttl\u5b57\u6bb5\uff09\u3002 9 setMulticastTTL \u591a\u64adttl\uff08\u591a\u64ad\u7684\u65f6\u5019\uff0cIP\u534f\u8bae\u7684ttl\u5b57\u6bb5\uff09\u3002 10 ref/unref \u8fd9\u4e24\u4e2a\u51fd\u6570\u8bbe\u7f6e\u5982\u679cNode.js\u4e3b\u8fdb\u7a0b\u4e2d\u53ea\u6709UDP\u5bf9\u5e94\u7684handle\u65f6\uff0c\u662f\u5426\u5141\u8bb8Node.js\u9000\u51fa\u3002Node.js\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u7684\u6761\u4ef6\u4e4b\u4e00\u662f\u662f\u5426\u8fd8\u6709ref\u72b6\u6001\u7684handle\u3002 \u8fd9\u4e9b\u90fd\u662f\u5bf9\u64cd\u4f5c\u7cfb\u7edfAPI\u7684\u5c01\u88c5\uff0c\u5c31\u4e0d\u4e00\u4e00\u5206\u6790\u3002 16.2.6 \u7aef\u53e3\u590d\u7528 \u00b6 \u6211\u4eec\u5728\u7f51\u7edc\u7f16\u7a0b\u4e2d\u7ecf\u5e38\u4f1a\u9047\u5230\u7aef\u53e3\u91cd\u590d\u7ed1\u5b9a\u7684\u9519\u8bef\uff0c\u6839\u636e\u5230\u5e95\u662f\u6211\u4eec\u4e0d\u80fd\u7ed1\u5b9a\u5230\u540c\u4e00\u4e2a\u7aef\u53e3\u548cIP\u4e24\u6b21\u3002\u4f46\u662f\u5728UDP\u4e2d\uff0c\u8fd9\u662f\u5141\u8bb8\u7684\uff0c\u8fd9\u5c31\u662f\u7aef\u53e3\u590d\u7528\u7684\u529f\u80fd\uff0c\u5728TCP\u4e2d\uff0c\u6211\u4eec\u901a\u8fc7\u7aef\u53e3\u590d\u7528\u6765\u89e3\u51b3\u670d\u52a1\u5668\u91cd\u542f\u65f6\u91cd\u65b0\u7ed1\u5b9a\u5230\u540c\u4e00\u4e2a\u7aef\u53e3\u7684\u95ee\u9898\uff0c\u56e0\u4e3a\u6211\u4eec\u77e5\u9053\u7aef\u53e3\u6709\u4e00\u4e2a2msl\u7684\u7b49\u5f85\u65f6\u95f4\uff0c\u91cd\u542f\u670d\u52a1\u5668\u91cd\u65b0\u7ed1\u5b9a\u5230\u8fd9\u4e2a\u7aef\u53e3\u65f6\uff0c\u9ed8\u8ba4\u4f1a\u62a5\u9519\uff0c\u4f46\u662f\u5982\u679c\u6211\u4eec\u8bbe\u7f6e\u4e86\u7aef\u53e3\u590d\u7528\uff08Node.js\u81ea\u52a8\u5e2e\u6211\u4eec\u8bbe\u7f6e\u4e86\uff09\uff0c\u5219\u53ef\u4ee5\u7ed5\u8fc7\u8fd9\u4e2a\u9650\u5236\u3002UDP\u4e2d\u4e5f\u652f\u6301\u7aef\u53e3\u590d\u7528\u7684\u529f\u80fd\uff0c\u4f46\u662f\u529f\u80fd\u3001\u7528\u9014\u548cTCP\u7684\u4e0d\u592a\u4e00\u6837\u3002\u56e0\u4e3a\u591a\u4e2a\u8fdb\u7a0b\u53ef\u4ee5\u7ed1\u5b9a\u540c\u4e00\u4e2aIP\u548c\u7aef\u53e3\u3002\u4f46\u662f\u4e00\u822c\u53ea\u7528\u4e8e\u591a\u64ad\u7684\u60c5\u51b5\u4e0b\u3002\u4e0b\u9762\u6211\u4eec\u6765\u5206\u6790\u4e00\u4e0budp\u7aef\u53e3\u590d\u7528\u7684\u903b\u8f91\u3002\u5728Node.js\u4e2d\uff0c\u4f7f\u7528UDP\u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u901a\u8fc7reuseAddr\u9009\u9879\u4f7f\u5f97\u8fdb\u7a0b\u53ef\u4ee5\u590d\u7528\u7aef\u53e3\uff0c\u5e76\u4e14\u6bcf\u4e00\u4e2a\u60f3\u590d\u7528\u7aef\u53e3\u7684socket\u90fd\u9700\u8981\u8bbe\u7f6ereuseAddr\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2d\u5173\u4e8ereuseAddr\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Socket . prototype . bind = function ( port_ , address_ /* , callback */ ) { let flags = 0 ; if ( state . reuseAddr ) flags |= UV_UDP_REUSEADDR ; state . handle . bind ( ip , port || 0 , flags ); }; // \u6211\u4eec\u770b\u5230Node.js\u5728bind\u7684\u65f6\u5019\u4f1a\u5904\u7406reuseAddr\u5b57\u6bb5\u3002\u6211\u4eec\u76f4\u63a5\u770bLibuv\u7684\u903b\u8f91\u3002 int uv__udp_bind ( uv_udp_t * handle , const struct sockaddr * addr , unsigned int addrlen , unsigned int flags ) { if ( flags & UV_UDP_REUSEADDR ) { err = uv__set_reuse ( fd ); } bind ( fd , addr , addrlen )) return 0 ; } static int uv__set_reuse ( int fd ) { int yes ; yes = 1 ; if ( setsockopt ( fd , SOL_SOCKET , SO_REUSEADDR , & yes , sizeof ( yes ))) return UV__ERR ( errno ); return 0 ; } \u6211\u4eec\u770b\u5230Libuv\u901a\u8fc7\u6700\u7ec8\u901a\u8fc7setsockopt\u8bbe\u7f6e\u4e86\u7aef\u53e3\u590d\u7528\uff0c\u5e76\u4e14\u662f\u5728bind\u4e4b\u524d\u3002\u6211\u4eec\u4e0d\u59a8\u518d\u6df1\u5165\u4e00\u70b9\uff0c\u770b\u4e00\u4e0bLinux\u5185\u6838\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 asmlinkage long sys_setsockopt ( int fd , int level , int optname , char __user * optval , int optlen ) { int err ; struct socket * sock ; if ( optlen < 0 ) return - EINVAL ; if (( sock = sockfd_lookup ( fd , & err )) != NULL ) { if ( level == SOL_SOCKET ) err = sock_setsockopt ( sock , level , optname , optval , optlen ); else err = sock -> ops -> setsockopt ( sock , level , optname , optval , optlen ); sockfd_put ( sock ); } return err ; } sys_setsockopt\u662fsetsockopt\u5bf9\u5e94\u7684\u7cfb\u7edf\u8c03\u7528\uff0c\u6211\u4eec\u770b\u5230sys_setsockopt\u4e5f\u53ea\u662f\u4e2a\u5165\u53e3\u51fd\u6570\uff0c\u5177\u4f53\u51fd\u6570\u662fsock_setsockopt\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int sock_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , int optlen ) { struct sock * sk = sock -> sk ; int val ; int valbool ; int ret = 0 ; if ( get_user ( val , ( int __user * ) optval )) return - EFAULT ; valbool = val ? 1 : 0 ; lock_sock ( sk ); switch ( optname ) { case SO_REUSEADDR : sk -> sk_reuse = valbool ; break ; // ... release_sock ( sk ); return ret ; } \u64cd\u4f5c\u7cfb\u7edf\u7684\u5904\u7406\u5f88\u7b80\u5355\uff0c\u53ea\u662f\u505a\u4e86\u4e00\u4e2a\u6807\u8bb0\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0bbind\u7684\u65f6\u5019\u662f\u600e\u4e48\u5904\u7406\u7684\uff0c\u56e0\u4e3a\u7aef\u53e3\u662f\u5426\u91cd\u590d\u548c\u80fd\u5426\u590d\u7528\u662f\u5728bind\u7684\u65f6\u5019\u5224\u65ad\u7684\u3002\u8fd9\u4e5f\u662f\u4e3a\u4ec0\u4e48\u5728TCP\u4e2d\uff0c\u5373\u4f7f\u4e24\u4e2a\u8fdb\u7a0b\u4e0d\u80fd\u7ed1\u5b9a\u5230\u540c\u4e00\u4e2aIP\u548c\u7aef\u53e3\uff0c\u4f46\u662f\u5982\u679c\u6211\u4eec\u5728\u4e3b\u8fdb\u7a0b\u91cc\u6267\u884c\u4e86bind\u4e4b\u540e\uff0c\u518dfork\u51fd\u6570\u65f6\uff0c\u662f\u53ef\u4ee5\u5b9e\u73b0\u7ed1\u5b9a\u540c\u4e00\u4e2aIP\u7aef\u53e3\u7684\u3002\u8a00\u5f52\u6b63\u4f20\u6211\u4eec\u770b\u4e00\u4e0bUDP\u4e2d\u6267\u884cbind\u65f6\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 int inet_bind ( struct socket * sock , struct sockaddr * uaddr , int addr_len ) { if ( sk -> sk_prot -> get_port ( sk , snum )) { inet -> saddr = inet -> rcv_saddr = 0 ; err = - EADDRINUSE ; goto out_release_sock ; } } \u6bcf\u4e2a\u534f\u8bae\u90fd\u53ef\u4ee5\u5b9e\u73b0\u81ea\u5df1\u7684get_port\u94a9\u5b50\u51fd\u6570\u3002\u7528\u6765\u5224\u65ad\u5f53\u524d\u7684\u7aef\u53e3\u662f\u5426\u5141\u8bb8\u88ab\u7ed1\u5b9a\u3002\u5982\u679c\u4e0d\u5141\u8bb8\u5219\u8fd4\u56deEADDRINUSE\uff0c\u6211\u4eec\u770b\u770bUDP\u534f\u8bae\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 static int udp_v4_get_port ( struct sock * sk , unsigned short snum ) { struct hlist_node * node ; struct sock * sk2 ; struct inet_sock * inet = inet_sk ( sk ); // \u901a\u8fc7\u7aef\u53e3\u627e\u5230\u5bf9\u5e94\u7684\u94fe\u8868\uff0c\u7136\u540e\u904d\u5386\u94fe\u8868 sk_for_each ( sk2 , node , & udp_hash [ snum & ( UDP_HTABLE_SIZE - 1 )]) { struct inet_sock * inet2 = inet_sk ( sk2 ); // \u7aef\u53e3\u5df2\u4f7f\u7528\uff0c\u5219\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u590d\u7528 if ( inet2 -> num == snum && sk2 != sk && ( ! inet2 -> rcv_saddr || ! inet -> rcv_saddr || inet2 -> rcv_saddr == inet -> rcv_saddr ) && // \u6bcf\u4e2asocket\u90fd\u9700\u8981\u8bbe\u7f6e\u7aef\u53e3\u590d\u7528\u6807\u8bb0 ( ! sk2 -> sk_reuse || ! sk -> sk_reuse )) // \u4e0d\u53ef\u4ee5\u590d\u7528\uff0c\u62a5\u9519 goto fail ; } // \u53ef\u4ee5\u590d\u7528 inet -> num = snum ; if ( sk_unhashed ( sk )) { // \u627e\u5230\u7aef\u53e3\u5bf9\u5e94\u7684\u4f4d\u7f6e struct hlist_head * h = & udp_hash [ snum & ( UDP_HTABLE_SIZE - 1 )]; // \u63d2\u5165\u94fe\u8868 sk_add_node ( sk , h ); sock_prot_inc_use ( sk -> sk_prot ); } return 0 ; fail : write_unlock_bh ( & udp_hash_lock ); return 1 ; } \u5206\u6790\u4e4b\u524d\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u7684\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\uff0cUDP\u534f\u8bae\u7684\u5b9e\u73b0\u4e2d\uff0c\u4f1a\u4f7f\u7528\u5982\u4e0b\u7684\u6570\u636e\u7ed3\u6784\u8bb0\u5f55\u6bcf\u4e00\u4e2aUDP socket\uff0c\u5982\u56fe16-6\u6240\u793a\u3002 \u56fe16-6 \u6211\u4eec\u770b\u5230\u64cd\u4f5c\u7cfb\u7edf\u4f7f\u7528\u4e00\u4e2a\u6570\u7ec4\u4f5c\u4e3a\u54c8\u5e0c\u8868\uff0c\u6bcf\u6b21\u64cd\u4f5c\u4e00\u4e2asocket\u7684\u65f6\u5019\uff0c\u9996\u5148\u4f1a\u6839\u636esocket\u7684\u6e90\u7aef\u53e3\u548c\u54c8\u5e0c\u7b97\u6cd5\u8ba1\u7b97\u5f97\u5230\u4e00\u4e2a\u6570\u7ec4\u7d22\u5f15\uff0c\u7136\u540e\u628asocket\u63d2\u5165\u7d22\u5f15\u9501\u5bf9\u5e94\u7684\u94fe\u8868\u4e2d\uff0c\u5373\u54c8\u5e0c\u51b2\u7a81\u7684\u89e3\u51b3\u65b9\u6cd5\u662f\u94fe\u5730\u5740\u6cd5\u3002\u56de\u5230\u4ee3\u7801\u7684\u903b\u8f91\uff0c\u5f53\u7528\u6237\u60f3\u7ed1\u5b9a\u4e00\u4e2a\u7aef\u53e3\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6839\u636e\u7aef\u53e3\u62ff\u5230\u5bf9\u5e94\u7684socket\u94fe\u8868\uff0c\u7136\u540e\u9010\u4e2a\u5224\u65ad\u662f\u5426\u6709\u76f8\u7b49\u7684\u7aef\u53e3\uff0c\u5982\u679c\u6709\u5219\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u590d\u7528\u3002\u4f8b\u5982\u4e24\u4e2asocket\u90fd\u8bbe\u7f6e\u4e86\u590d\u7528\u6807\u8bb0\u5219\u53ef\u4ee5\u590d\u7528\u3002\u6700\u540e\u628asocket\u63d2\u5165\u5230\u94fe\u8868\u4e2d\u3002 1 2 3 4 5 6 7 8 9 10 static inline void hlist_add_head ( struct hlist_node * n , struct hlist_head * h ) { // \u5934\u7ed3\u70b9 struct hlist_node * first = h -> first ; n -> next = first ; if ( first ) first -> pprev = & n -> next ; h -> first = n ; n -> pprev = & h -> first ; } \u6211\u4eec\u770b\u5230\u64cd\u4f5c\u7cfb\u7edf\u662f\u4ee5\u5934\u63d2\u6cd5\u7684\u65b9\u5f0f\u63d2\u5165\u65b0\u8282\u70b9\u7684\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u662f\u5982\u4f55\u4f7f\u7528\u8fd9\u4e9b\u6570\u636e\u7ed3\u6784\u7684\u3002 16.2.6.1 \u591a\u64ad \u00b6 \u6211\u4eec\u5148\u770b\u4e00\u4e2a\u4f8b\u5b50\uff0c\u6211\u4eec\u5728\u540c\u4e3b\u673a\u4e0a\u65b0\u5efa\u4e24\u4e2aJS\u6587\u4ef6\uff08\u5ba2\u6237\u7aef\uff09\uff0c\u4ee3\u7801\u5982\u4e0b 1 2 3 4 5 6 7 8 const dgram = require ( 'dgram' ); const udp = dgram . createSocket ({ type : 'udp4' , reuseAddr : true }); udp . bind ( 1234 , \u2018 192.168.8.164 \u2018 , () => { udp . addMembership ( '224.0.0.114' , '192.168.8.164' ); }); udp . on ( 'message' , ( msg ) => { console . log ( msg ) }); \u4e0a\u9762\u4ee3\u7801\u4f7f\u5f97\u4e24\u4e2a\u8fdb\u7a0b\u90fd\u76d1\u542c\u4e86\u540c\u6837\u7684IP\u548c\u7aef\u53e3\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u5199\u4e00\u4e2aUDP\u670d\u52a1\u5668\u3002 1 2 3 4 5 6 const dgram = require ( 'dgram' ); const udp = dgram . createSocket ({ type : 'udp4' }); const socket = udp . bind ( 5678 ); socket . send ( 'hi' , 1234 , '224.0.0.114' , ( err ) => { console . log ( err ) }); \u4e0a\u9762\u7684\u4ee3\u7801\u7ed9\u4e00\u4e2a\u591a\u64ad\u7ec4\u53d1\u9001\u4e86\u4e00\u4e2a\u6570\u636e\uff0c\u6267\u884c\u4e0a\u9762\u7684\u4ee3\u7801\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4e24\u4e2a\u5ba2\u6237\u7aef\u8fdb\u7a0b\u90fd\u6536\u5230\u4e86\u6570\u636e\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u6536\u5230\u6570\u636e\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u662f\u5982\u4f55\u628a\u6570\u636e\u5206\u53d1\u7ed9\u6bcf\u4e2a\u76d1\u542c\u4e86\u540c\u6837IP\u548c\u7aef\u53e3\u7684\u8fdb\u7a0b\u7684\u3002\u4e0b\u9762\u662f\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230\u4e00\u4e2aUDP\u6570\u636e\u5305\u65f6\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int udp_rcv ( struct sk_buff * skb ) { struct sock * sk ; struct udphdr * uh ; unsigned short ulen ; struct rtable * rt = ( struct rtable * ) skb -> dst ; // ip\u5934\u4e2d\u8bb0\u5f55\u7684\u6e90ip\u548c\u76ee\u7684ip u32 saddr = skb -> nh . iph -> saddr ; u32 daddr = skb -> nh . iph -> daddr ; int len = skb -> len ; // udp\u534f\u8bae\u5934\u7ed3\u6784\u4f53 uh = skb -> h . uh ; ulen = ntohs ( uh -> len ); // \u5e7f\u64ad\u6216\u591a\u64ad\u5305 if ( rt -> rt_flags & ( RTCF_BROADCAST | RTCF_MULTICAST )) return udp_v4_mcast_deliver ( skb , uh , saddr , daddr ); // \u5355\u64ad sk = udp_v4_lookup ( saddr , uh -> source , daddr , uh -> dest , skb -> dev -> ifindex ); // \u627e\u5230\u5bf9\u5e94\u7684socket if ( sk != NULL ) { // \u628a\u6570\u636e\u63d2\u5230socket\u7684\u6d88\u606f\u961f\u5217 int ret = udp_queue_rcv_skb ( sk , skb ); sock_put ( sk ); if ( ret > 0 ) return - ret ; return 0 ; } return ( 0 ); } \u6211\u4eec\u770b\u5230\u5355\u64ad\u548c\u975e\u5355\u64ad\u65f6\u5904\u7406\u903b\u8f91\u662f\u4e0d\u4e00\u6837\u7684\uff0c\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u975e\u5355\u64ad\u7684\u60c5\u51b5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 static int udp_v4_mcast_deliver ( struct sk_buff * skb , struct udphdr * uh , u32 saddr , u32 daddr ) { struct sock * sk ; int dif ; read_lock ( & udp_hash_lock ); // \u901a\u8fc7\u7aef\u53e3\u627e\u5230\u5bf9\u5e94\u7684\u94fe\u8868 sk = sk_head ( & udp_hash [ ntohs ( uh -> dest ) & ( UDP_HTABLE_SIZE - 1 )]); dif = skb -> dev -> ifindex ; sk = udp_v4_mcast_next ( sk , uh -> dest , daddr , uh -> source , saddr , dif ); if ( sk ) { struct sock * sknext = NULL ; // \u904d\u5386\u6bcf\u4e00\u4e2a\u9700\u8981\u5904\u7406\u8be5\u6570\u636e\u5305\u7684socket do { struct sk_buff * skb1 = skb ; sknext = udp_v4_mcast_next ( sk_next ( sk ), uh -> dest , daddr , uh -> source , saddr , dif ); if ( sknext ) // \u590d\u5236\u4e00\u4efd skb1 = skb_clone ( skb , GFP_ATOMIC ); // \u63d2\u5165\u6bcf\u4e00\u4e2asocket\u7684\u6570\u636e\u5305\u961f\u5217 if ( skb1 ) { int ret = udp_queue_rcv_skb ( sk , skb1 ); if ( ret > 0 ) kfree_skb ( skb1 ); } sk = sknext ; } while ( sknext ); } else kfree_skb ( skb ); read_unlock ( & udp_hash_lock ); return 0 ; } \u5728\u975e\u5355\u64ad\u7684\u60c5\u51b5\u4e0b\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u904d\u5386\u94fe\u8868\u627e\u5230\u6bcf\u4e00\u4e2a\u53ef\u4ee5\u63a5\u6536\u8be5\u6570\u636e\u5305\u7684socket\uff0c\u7136\u540e\u628a\u6570\u636e\u5305\u590d\u5236\u4e00\u4efd\uff0c\u6302\u8f7d\u5230socket\u7684\u63a5\u6536\u961f\u5217\u3002\u8fd9\u5c31\u89e3\u91ca\u4e86\u672c\u8282\u5f00\u5934\u7684\u4f8b\u5b50\uff0c\u5373\u4e24\u4e2a\u5ba2\u6237\u7aef\u8fdb\u7a0b\u90fd\u4f1a\u6536\u5230UDP\u6570\u636e\u5305\u3002 16.2.6.2 \u5355\u64ad \u00b6 \u63a5\u7740\u6211\u4eec\u518d\u6765\u770b\u4e00\u4e0b\u5355\u64ad\u7684\u60c5\u51b5\u3002\u9996\u5148\u6211\u4eec\u770b\u4e00\u4e2a\u4f8b\u5b50\u3002\u6211\u4eec\u540c\u6837\u65b0\u5efa\u4e24\u4e2aJS\u6587\u4ef6\u7528\u4f5c\u5ba2\u6237\u7aef\u3002 1 2 3 4 5 6 const dgram = require ( 'dgram' ); const udp = dgram . createSocket ({ type : 'udp4' , reuseAddr : true }); const socket = udp . bind ( 5678 ); socket . on ( 'message' , ( msg ) => { console . log ( msg ) }) \u7136\u540e\u518d\u65b0\u5efa\u4e00\u4e2aJS\u6587\u4ef6\u7528\u4f5c\u670d\u52a1\u5668\u3002 1 2 3 4 const dgram = require ( 'dgram' ); const udp = dgram . createSocket ({ type : 'udp4' }); const socket = udp . bind ( 1234 ); udp . send ( 'hi' , 5678 ) \u6267\u884c\u4ee5\u4e0a\u4ee3\u7801\uff0c\u9996\u5148\u6267\u884c\u5ba2\u6237\u7aef\uff0c\u518d\u6267\u884c\u670d\u52a1\u5668\uff0c\u6211\u4eec\u4f1a\u53d1\u73b0\u53ea\u6709\u4e00\u4e2a\u8fdb\u7a0b\u4f1a\u6536\u5230\u6570\u636e\u3002\u4e0b\u9762\u6211\u4eec\u5206\u6790\u5177\u4f53\u7684\u539f\u56e0\uff0c\u5355\u64ad\u65f6\u6536\u5230\u4f1a\u8c03\u7528udp_v4_lookup\u51fd\u6570\u627e\u5230\u63a5\u6536\u8be5UDP\u6570\u636e\u5305\u7684socket\uff0c\u7136\u540e\u628a\u6570\u636e\u5305\u6302\u8f7d\u5230socket\u7684\u63a5\u6536\u961f\u5217\u4e2d\u3002\u6211\u4eec\u770b\u770budp_v4_lookup\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 static __inline__ struct sock * udp_v4_lookup ( u32 saddr , u16 sport , u32 daddr , u16 dport , int dif ) { struct sock * sk ; sk = udp_v4_lookup_longway ( saddr , sport , daddr , dport , dif ); return sk ; } static struct sock * udp_v4_lookup_longway ( u32 saddr , u16 sport , u32 daddr , u16 dport , int dif ) { struct sock * sk , * result = NULL ; struct hlist_node * node ; unsigned short hnum = ntohs ( dport ); int badness = -1 ; // \u904d\u5386\u7aef\u53e3\u5bf9\u5e94\u7684\u94fe\u8868 sk_for_each ( sk , node , & udp_hash [ hnum & ( UDP_HTABLE_SIZE - 1 )]) { struct inet_sock * inet = inet_sk ( sk ); if ( inet -> num == hnum && ! ipv6_only_sock ( sk )) { int score = ( sk -> sk_family == PF_INET ? 1 : 0 ); if ( inet -> rcv_saddr ) { if ( inet -> rcv_saddr != daddr ) continue ; score += 2 ; } if ( inet -> daddr ) { if ( inet -> daddr != saddr ) continue ; score += 2 ; } if ( inet -> dport ) { if ( inet -> dport != sport ) continue ; score += 2 ; } if ( sk -> sk_bound_dev_if ) { if ( sk -> sk_bound_dev_if != dif ) continue ; score += 2 ; } // \u5168\u5339\u914d\uff0c\u76f4\u63a5\u8fd4\u56de\uff0c\u5426\u5219\u8bb0\u5f55\u5f53\u524d\u6700\u597d\u7684\u5339\u914d\u7ed3\u679c if ( score == 9 ) { result = sk ; break ; } else if ( score > badness ) { result = sk ; badness = score ; } } } return result ; } \u6211\u4eec\u770b\u5230\u4ee3\u7801\u5f88\u591a\uff0c\u4f46\u662f\u903b\u8f91\u5e76\u4e0d\u590d\u6742\uff0c\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230\u6839\u636e\u7aef\u53e3\u4ece\u54c8\u5e0c\u8868\u4e2d\u62ff\u5230\u5bf9\u5e94\u7684\u94fe\u8868\uff0c\u7136\u540e\u904d\u5386\u8be5\u94fe\u8868\u627e\u51fa\u6700\u5339\u914d\u7684socket\u3002\u7136\u540e\u628a\u6570\u636e\u6302\u8f7d\u5230socket\u4e0a\u3002\u4f46\u662f\u6709\u4e00\u4e2a\u7ec6\u8282\u9700\u8981\u6ce8\u610f\uff0c\u5982\u679c\u6709\u4e24\u4e2a\u8fdb\u7a0b\u90fd\u76d1\u542c\u4e86\u540c\u4e00\u4e2aIP\u548c\u7aef\u53e3\uff0c\u90a3\u4e48\u54ea\u4e00\u4e2a\u8fdb\u7a0b\u4f1a\u6536\u5230\u6570\u636e\u5462\uff1f\u8fd9\u4e2a\u53d6\u51b3\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u7684\u5b9e\u73b0\uff0c\u4eceLinux\u6e90\u7801\u6211\u4eec\u770b\u5230\uff0c\u63d2\u5165socket\u7684\u65f6\u5019\u662f\u4f7f\u7528\u5934\u63d2\u6cd5\uff0c\u67e5\u627e\u7684\u65f6\u5019\u662f\u4ece\u5934\u5f00\u59cb\u627e\u6700\u5339\u914d\u7684socket\u3002\u5373\u540e\u9762\u63d2\u5165\u7684socket\u4f1a\u5148\u88ab\u641c\u7d22\u5230\u3002\u4f46\u662fWindows\u4e0b\u7ed3\u6784\u5374\u76f8\u53cd\uff0c\u5148\u76d1\u542c\u4e86\u8be5IP\u7aef\u53e3\u7684\u8fdb\u7a0b\u4f1a\u6536\u5230\u6570\u636e\u3002 \u7b2c","title":"16-UDP"},{"location":"chapter16-UDP/#161-cudp","text":"\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5728C\u8bed\u8a00\u4e2d\u5982\u4f55\u4f7f\u7528UDP\u529f\u80fd\uff0c\u8fd9\u662fNode.js\u7684\u5e95\u5c42\u57fa\u7840\u3002","title":"16.1 \u5728C\u8bed\u8a00\u4e2d\u4f7f\u7528UDP"},{"location":"chapter16-UDP/#1611","text":"1 2 3 4 5 6 // \u7533\u8bf7\u4e00\u4e2asocket int fd = socket (...); // \u7ed1\u5b9a\u4e00\u4e2a\u4f17\u6240\u5468\u77e5\u7684\u5730\u5740\uff0c\u50cfTCP\u4e00\u6837 bind ( fd , ip \uff0c port ); // \u76f4\u63a5\u963b\u585e\u7b49\u5f85\u6d88\u606f\u7684\u5230\u6765\uff0cUDP\u4e0d\u9700\u8981listen recvmsg () \uff1b","title":"16.1.1 \u670d\u52a1\u5668\u6d41\u7a0b\uff08\u4f2a\u4ee3\u7801\uff09"},{"location":"chapter16-UDP/#1612","text":"\u5ba2\u6237\u7aef\u7684\u6d41\u7a0b\u6709\u591a\u79cd\u65b9\u5f0f\uff0c\u539f\u56e0\u5728\u4e8e\u6e90IP\u3001\u7aef\u53e3\u548c\u76ee\u7684IP\u3001\u7aef\u53e3\u53ef\u4ee5\u6709\u591a\u79cd\u8bbe\u7f6e\u65b9\u5f0f\u3002\u4e0d\u50cf\u670d\u52a1\u5668\u4e00\u6837\uff0c\u670d\u52a1\u5668\u7aef\u53e3\u662f\u9700\u8981\u5bf9\u5916\u516c\u5e03\u7684\uff0c\u5426\u5219\u5ba2\u6237\u7aef\u5c31\u65e0\u6cd5\u627e\u5230\u76ee\u7684\u5730\u8fdb\u884c\u901a\u4fe1\u3002\u8fd9\u5c31\u610f\u5473\u7740\u670d\u52a1\u5668\u7684\u7aef\u53e3\u662f\u9700\u8981\u7528\u6237\u663e\u5f0f\u6307\u5b9a\u7684\uff0c\u800c\u5ba2\u6237\u7aef\u5219\u4e0d\u7136\uff0c\u5ba2\u6237\u7aef\u7684IP\u548c\u7aef\u53e3\uff0c\u7528\u6237\u53ef\u4ee5\u81ea\u5df1\u6307\u5b9a\uff0c\u4e5f\u53ef\u4ee5\u7531\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a\uff0c\u4e0b\u9762\u6211\u4eec\u770b\u770b\u5404\u79cd\u4f7f\u7528\u65b9\u5f0f\u3002","title":"16.1.2 \u5ba2\u6237\u7aef\u6d41\u7a0b"},{"location":"chapter16-UDP/#16121-ip","text":"1 2 3 4 5 6 // \u7533\u8bf7\u4e00\u4e2asocket int fd = socket (...); // \u7ed1\u5b9a\u4e00\u4e2a\u5ba2\u6237\u7aef\u7684\u5730\u5740 bind ( fd , ip \uff0c port ); // \u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e sendto ( fd , \u670d\u52a1\u5668 ip , \u670d\u52a1\u5668\u7aef\u53e3 , data ); \u56e0\u4e3aUDP\u4e0d\u662f\u9762\u5411\u8fde\u63a5\u7684\uff0c\u6240\u4ee5\u4f7f\u7528UDP\u65f6\uff0c\u4e0d\u9700\u8981\u8c03\u7528connect\u5efa\u7acb\u8fde\u63a5\uff0c\u53ea\u8981\u6211\u4eec\u77e5\u9053\u670d\u52a1\u5668\u7684\u5730\u5740\uff0c\u76f4\u63a5\u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e\u5373\u53ef\u3002\u800c\u9762\u5411\u8fde\u63a5\u7684TCP\uff0c\u9996\u5148\u9700\u8981\u901a\u8fc7connect\u53d1\u8d77\u4e09\u6b21\u63e1\u624b\u5efa\u7acb\u8fde\u63a5\uff0c\u5efa\u7acb\u8fde\u63a5\u7684\u672c\u8d28\u662f\u5728\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u8bb0\u5f55\u5bf9\u7aef\u7684\u4fe1\u606f\uff0c\u8fd9\u662f\u540e\u9762\u901a\u4fe1\u7684\u901a\u884c\u8bc1\u3002","title":"16.1.2.1 \u663e\u5f0f\u6307\u5b9a\u6e90IP\u548c\u7aef\u53e3"},{"location":"chapter16-UDP/#16122-ip","text":"1 2 3 4 // \u7533\u8bf7\u4e00\u4e2asocket int fd = socket (...); // \u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e sendto ( fd , \u670d\u52a1\u5668 ip , \u670d\u52a1\u5668\u7aef\u53e3 , data ) \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u6ca1\u6709\u7ed1\u5b9a\u5ba2\u6237\u7aef\u7684\u6e90ip\u548c\u7aef\u53e3\uff0c\u800c\u662f\u76f4\u63a5\u5c31\u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e\u3002\u5982\u679c\u7528\u6237\u4e0d\u6307\u5b9aip\u548c\u7aef\u53e3\uff0c\u5219\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u63d0\u4f9b\u9ed8\u8ba4\u7684\u6e90ip\u548c\u7aef\u53e3\u3002\u5bf9\u4e8eip\uff0c\u5982\u679c\u662f\u591a\u5bbf\u4e3b\u4e3b\u673a\uff0c\u6bcf\u6b21\u8c03\u7528sendto\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u52a8\u6001\u9009\u62e9\u6e90ip\u3002\u5bf9\u4e8e\u7aef\u53e3\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u5728\u7b2c\u4e00\u6b21\u8c03\u7528sendto\u7684\u65f6\u5019\u968f\u673a\u9009\u62e9\u4e00\u4e2a\u7aef\u53e3\uff0c\u5e76\u4e14\u4e0d\u80fd\u4fee\u6539\u3002\u53e6\u5916\u8fd8\u6709\u4e00\u79cd\u4f7f\u7528\u65b9\u5f0f\u3002 1 2 3 4 5 6 7 8 // \u7533\u8bf7\u4e00\u4e2asocket int fd = socket (...); connect ( fd , \u670d\u52a1\u5668 ip \uff0c\u670d\u52a1\u5668\u7aef\u53e3 ); /* \u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e,\u6216\u8005sendto(fd, null,null, data)\uff0c \u8c03\u7528sendto\u5219\u4e0d\u9700\u8981\u518d\u6307\u5b9a\u670d\u52a1\u5668ip\u548c\u7aef\u53e3 */ write ( fd , data ); \u6211\u4eec\u53ef\u4ee5\u5148\u8c03\u7528connect\u7ed1\u5b9a\u670d\u52a1\u5668ip\u548c\u7aef\u53e3\u5230fd\uff0c\u7136\u540e\u76f4\u63a5\u8c03\u7528write\u53d1\u9001\u6570\u636e\u3002 \u867d\u7136\u4f7f\u7528\u65b9\u5f0f\u5f88\u591a\uff0c\u4f46\u662f\u5f52\u6839\u5230\u5e95\u8fd8\u662f\u5bf9\u56db\u5143\u7ec4\u8bbe\u7f6e\u7684\u7ba1\u7406\u3002bind\u662f\u7ed1\u5b9a\u6e90ip\u7aef\u53e3\u5230fd\uff0cconnect\u662f\u7ed1\u5b9a\u670d\u52a1\u5668ip\u7aef\u53e3\u5230fd\u3002\u5bf9\u4e8e\u6e90ip\u548c\u7aef\u53e3\uff0c\u6211\u4eec\u53ef\u4ee5\u4e3b\u52a8\u8bbe\u7f6e\uff0c\u4e5f\u53ef\u4ee5\u8ba9\u64cd\u4f5c\u7cfb\u7edf\u968f\u673a\u9009\u62e9\u3002\u5bf9\u4e8e\u76ee\u7684ip\u548c\u7aef\u53e3\uff0c\u6211\u4eec\u53ef\u4ee5\u5728\u53d1\u9001\u6570\u636e\u524d\u8bbe\u7f6e\uff0c\u4e5f\u53ef\u4ee5\u5728\u53d1\u9001\u6570\u636e\u65f6\u8bbe\u7f6e\u3002\u8fd9\u5c31\u5f62\u6210\u4e86\u591a\u79cd\u4f7f\u7528\u65b9\u5f0f\u3002","title":"16.1.2.2 \u7531\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a\u6e90ip\u548c\u7aef\u53e3"},{"location":"chapter16-UDP/#1613","text":"\u6211\u4eec\u521a\u624d\u770b\u5230\u4f7f\u7528UDP\u4e4b\u524d\u90fd\u9700\u8981\u8c03\u7528socket\u51fd\u6570\u7533\u8bf7\u4e00\u4e2asocket\uff0c\u867d\u7136\u8c03\u7528socket\u51fd\u6570\u8fd4\u56de\u7684\u662f\u4e00\u4e2afd\uff0c\u4f46\u662f\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e2d\uff0c\u7684\u786e\u662f\u65b0\u5efa\u4e86\u4e00\u4e2asocket\u7ed3\u6784\u4f53\uff0cfd\u53ea\u662f\u4e00\u4e2a\u7d22\u5f15\uff0c\u64cd\u4f5c\u8fd9\u4e2afd\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6839\u636e\u8fd9\u4e2afd\u627e\u5230\u5bf9\u5e94\u7684socket\u3002socket\u662f\u4e00\u4e2a\u975e\u5e38\u590d\u6742\u7684\u7ed3\u6784\u4f53\uff0c\u6211\u4eec\u53ef\u4ee5\u7406\u89e3\u4e3a\u4e00\u4e2a\u5bf9\u8c61\u3002\u8fd9\u4e2a\u5bf9\u8c61\u4e2d\u6709\u4e24\u4e2a\u5c5e\u6027\uff0c\u4e00\u4e2a\u662f\u8bfb\u7f13\u51b2\u533a\u5927\u5c0f\uff0c\u4e00\u4e2a\u662f\u5199\u7f13\u51b2\u533a\u5927\u5c0f\u3002\u5f53\u6211\u4eec\u53d1\u9001\u6570\u636e\u7684\u65f6\u5019\uff0c\u867d\u7136\u7406\u8bba\u4e0a\u53ef\u4ee5\u53d1\u9001\u4efb\u610f\u5927\u5c0f\u7684\u6570\u636e\uff0c\u4f46\u662f\u56e0\u4e3a\u53d7\u9650\u4e8e\u53d1\u9001\u7f13\u51b2\u533a\u7684\u5927\u5c0f\uff0c\u5982\u679c\u9700\u8981\u53d1\u9001\u7684\u6570\u636e\u6bd4\u5f53\u524d\u7f13\u51b2\u533a\u5927\u5c0f\u5927\u5219\u4f1a\u5bfc\u81f4\u4e00\u4e9b\u95ee\u9898\uff0c\u6211\u4eec\u5206\u60c5\u51b5\u5206\u6790\u4e00\u4e0b\u3002 1 \u53d1\u9001\u7684\u6570\u636e\u5927\u5c0f\u6bd4\u5f53\u524d\u7f13\u51b2\u533a\u5927\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86\u975e\u963b\u585e\u6a21\u5f0f\uff0c\u5219\u8fd4\u56deEAGAIN\uff0c\u5982\u679c\u662f\u963b\u585e\u6a21\u5f0f\uff0c\u5219\u4f1a\u5f15\u8d77\u8fdb\u7a0b\u7684\u963b\u585e\u3002 2 \u5982\u679c\u53d1\u9001\u7684\u6570\u636e\u5927\u5c0f\u6bd4\u7f13\u51b2\u533a\u7684\u6700\u5927\u503c\u8fd8\u5927\uff0c\u5219\u4f1a\u5bfc\u81f4\u62a5\u9519EMSGSIZE\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u9700\u8981\u5206\u5305\u53d1\u9001\u3002\u6211\u4eec\u53ef\u80fd\u4f1a\u60f3\u5230\u4fee\u6539\u7f13\u51b2\u533a\u6700\u5927\u503c\u7684\u5927\u5c0f\uff0c\u4f46\u662f\u8fd9\u4e2a\u5927\u5c0f\u4e5f\u662f\u6709\u9650\u5236\u7684\u3002 \u8bb2\u5b8c\u4e00\u4e9b\u8fb9\u754c\u60c5\u51b5\uff0c\u6211\u4eec\u518d\u6765\u770b\u770b\u6b63\u5e38\u7684\u6d41\u7a0b\uff0c\u6211\u4eec\u770b\u770b\u53d1\u9001\u4e00\u4e2a\u6570\u636e\u5305\u7684\u6d41\u7a0b 1 \u9996\u5148\u5728socket\u7684\u5199\u7f13\u51b2\u533a\u7533\u8bf7\u4e00\u5757\u5185\u5b58\u7528\u4e8e\u6570\u636e\u53d1\u9001\u3002 2 \u8c03\u7528IP\u5c42\u53d1\u9001\u63a5\u53e3\uff0c\u5982\u679c\u6570\u636e\u5305\u5927\u5c0f\u8d85\u8fc7\u4e86IP\u5c42\u7684\u9650\u5236\uff0c\u5219\u9700\u8981\u5206\u5305\u3002 3 \u7ee7\u7eed\u8c03\u7528\u5e95\u5c42\u7684\u63a5\u53e3\u628a\u6570\u636e\u53d1\u5230\u7f51\u7edc\u4e0a\u3002 \u56e0\u4e3aUDP\u4e0d\u662f\u53ef\u9760\u7684\uff0c\u6240\u4ee5\u4e0d\u9700\u8981\u7f13\u5b58\u8fd9\u4e2a\u6570\u636e\u5305\uff08TCP\u534f\u8bae\u5219\u9700\u8981\u7f13\u5b58\u8fd9\u4e2a\u6570\u636e\u5305\uff0c\u7528\u4e8e\u8d85\u65f6\u91cd\u4f20\uff09\u3002 \u8fd9\u5c31\u662fUDP\u53d1\u9001\u6570\u636e\u7684\u6d41\u7a0b\u3002","title":"16.1.3 \u53d1\u9001\u6570\u636e"},{"location":"chapter16-UDP/#1614","text":"\u5f53\u6536\u5230\u4e00\u4e2aUDP\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u9996\u5148\u4f1a\u628a\u8fd9\u4e2a\u6570\u636e\u5305\u7f13\u5b58\u5230socket\u7684\u7f13\u51b2\u533a\uff0c\u5982\u679c\u6536\u5230\u7684\u6570\u636e\u5305\u6bd4\u5f53\u524d\u7f13\u51b2\u533a\u5927\u5c0f\u5927\uff0c\u5219\u4e22\u5f03\u6570\u636e\u5305\uff0c\u5426\u5219\u628a\u6570\u636e\u5305\u6302\u8f7d\u5230\u63a5\u6536\u961f\u5217\uff0c\u7b49\u7528\u6237\u6765\u8bfb\u53d6\u7684\u65f6\u5019\uff0c\u5c31\u9010\u4e2a\u6458\u4e0b\u63a5\u6536\u961f\u5217\u7684\u8282\u70b9\u3002UDP\u548cTCP\u4e0d\u4e00\u6837\uff0c\u867d\u7136\u5b83\u4eec\u90fd\u6709\u4e00\u4e2a\u7f13\u5b58\u4e86\u6d88\u606f\u7684\u961f\u5217\uff0c\u4f46\u662f\u5f53\u7528\u6237\u8bfb\u53d6\u6570\u636e\u65f6\uff0cUDP\u6bcf\u6b21\u53ea\u4f1a\u8fd4\u56de\u4e00\u4e2aUDP\u6570\u636e\u5305\uff0c\u800cTCP\u662f\u4f1a\u6839\u636e\u7528\u6237\u8bbe\u7f6e\u7684\u5927\u5c0f\u8fd4\u56de\u4e00\u4e2a\u6216\u591a\u4e2a\u5305\u91cc\u7684\u6570\u636e\u3002\u56e0\u4e3aTCP\u662f\u9762\u5411\u5b57\u8282\u6d41\u7684\uff0c\u800cUDP\u662f\u9762\u5411\u6570\u636e\u5305\u7684\u3002","title":"16.1.4 \u63a5\u6536\u6570\u636e"},{"location":"chapter16-UDP/#162-udpnodejs","text":"\u4e86\u89e3\u4e86UDP\u7684\u4e00\u4e9b\u57fa\u7840\u548c\u4f7f\u7528\u540e\uff0c\u6211\u4eec\u5f00\u59cb\u5206\u6790\u5728Node.js\u4e2d\u662f\u5982\u4f55\u4f7f\u7528UDP\u7684\uff0cNode.js\u53c8\u662f\u5982\u4f55\u5b9e\u73b0UDP\u6a21\u5757\u7684\u3002","title":"16.2 UDP\u6a21\u5757\u5728Node.js\u4e2d\u7684\u5b9e\u73b0"},{"location":"chapter16-UDP/#1621","text":"\u6211\u4eec\u4ece\u4e00\u4e2a\u4f7f\u7528\u4f8b\u5b50\u5f00\u59cb\u770b\u770bUDP\u6a21\u5757\u7684\u4f7f\u7528\u3002 1 2 3 4 5 6 7 8 9 const dgram = require ( 'dgram' ); // \u521b\u5efa\u4e00\u4e2aUDP\u670d\u52a1\u5668 const server = dgram . createSocket ( 'udp4' ); // \u76d1\u542cUDP\u6570\u636e\u7684\u5230\u6765 server . on ( 'message' , ( msg , rinfo ) => { // \u5904\u7406\u6570\u636e }); // \u7ed1\u5b9a\u7aef\u53e3 server . bind ( 41234 ); \u6211\u4eec\u770b\u5230\u521b\u5efa\u4e00\u4e2aUDP\u670d\u52a1\u5668\u5f88\u7b80\u5355\uff0c\u9996\u5148\u7533\u8bf7\u4e00\u4e2asocket\u5bf9\u8c61\uff0c\u5728Node.js\u4e2d\u548c\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u4e00\u6837\uff0csocket\u662f\u5bf9\u7f51\u7edc\u901a\u4fe1\u7684\u4e00\u4e2a\u62bd\u8c61\uff0c\u6211\u4eec\u53ef\u4ee5\u628a\u5b83\u7406\u89e3\u6210\u5bf9\u4f20\u8f93\u5c42\u7684\u62bd\u8c61\uff0c\u5b83\u53ef\u4ee5\u4ee3\u8868TCP\u4e5f\u53ef\u4ee5\u4ee3\u8868UDP\u3002\u6211\u4eec\u770b\u4e00\u4e0bcreateSocket\u505a\u4e86\u4ec0\u4e48\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 function createSocket ( type , listener ) { return new Socket ( type , listener ); } function Socket ( type , listener ) { EventEmitter . call ( this ); let lookup ; let recvBufferSize ; let sendBufferSize ; let options ; if ( type !== null && typeof type === 'object' ) { options = type ; type = options . type ; lookup = options . lookup ; recvBufferSize = options . recvBufferSize ; sendBufferSize = options . sendBufferSize ; } const handle = newHandle ( type , lookup ); this . type = type ; if ( typeof listener === 'function' ) this . on ( 'message' , listener ); // \u4fdd\u5b58\u4e0a\u4e0b\u6587 this [ kStateSymbol ] = { handle , receiving : false , // \u8fd8\u6ca1\u6709\u6267\u884cbind bindState : BIND_STATE_UNBOUND , connectState : CONNECT_STATE_DISCONNECTED , queue : undefined , // \u7aef\u53e3\u590d\u7528\uff0c\u53ea\u4f7f\u4e8e\u591a\u64ad reuseAddr : options && options . reuseAddr , ipv6Only : options && options . ipv6Only , // \u53d1\u9001\u7f13\u51b2\u533a\u548c\u63a5\u6536\u7f13\u51b2\u533a\u5927\u5c0f recvBufferSize , sendBufferSize }; } \u6211\u4eec\u770b\u5230\u4e00\u4e2asocket\u5bf9\u8c61\u662f\u5bf9handle\u7684\u4e00\u4e2a\u5c01\u88c5\u3002\u6211\u4eec\u770b\u770bhandle\u662f\u4ec0\u4e48\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function newHandle ( type , lookup ) { // \u7528\u4e8edns\u89e3\u6790\u7684\u51fd\u6570\uff0c\u6bd4\u5982\u6211\u4eec\u8c03send\u7684\u65f6\u5019\uff0c\u4f20\u7684\u662f\u4e00\u4e2a\u57df\u540d if ( lookup === undefined ) { if ( dns === undefined ) { dns = require ( 'dns' ); } lookup = dns . lookup ; } if ( type === 'udp4' ) { const handle = new UDP (); handle . lookup = lookup4 . bind ( handle , lookup ); return handle ; } // \u5ffd\u7565ipv6\u7684\u5904\u7406 } handle\u53c8\u662f\u5bf9UDP\u6a21\u5757\u7684\u5c01\u88c5\uff0cUDP\u662fC++\u6a21\u5757\uff0c\u5728\u4e4b\u524d\u7ae0\u8282\u4e2d\u6211\u4eec\u8bb2\u8fc7\u76f8\u5173\u7684\u77e5\u8bc6\uff0c\u8fd9\u91cc\u5c31\u4e0d\u8be6\u7ec6\u8bb2\u8ff0\u4e86\uff0c\u5f53\u6211\u4eec\u5728JS\u5c42new UDP\u7684\u65f6\u5019\uff0c\u4f1a\u65b0\u5efa\u4e00\u4e2aC++\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 UDPWrap :: UDPWrap ( Environment * env , Local < Object > object ) : HandleWrap ( env , object , reinterpret_cast < uv_handle_t *> ( & handle_ ), AsyncWrap :: PROVIDER_UDPWRAP ) { int r = uv_udp_init ( env -> event_loop (), & handle_ ); } \u6267\u884c\u4e86uv_udp_init\u521d\u59cb\u5316udp\u5bf9\u5e94\u7684handle\uff08uv_udp_t\uff09\u3002\u6211\u4eec\u770b\u4e00\u4e0bLibuv\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int uv_udp_init_ex ( uv_loop_t * loop , uv_udp_t * handle , unsigned int flags ) { int domain ; int err ; int fd ; /* Use the lower 8 bits for the domain */ domain = flags & 0xFF ; // \u7533\u8bf7\u4e00\u4e2asocket\uff0c\u8fd4\u56de\u4e00\u4e2afd fd = uv__socket ( domain , SOCK_DGRAM , 0 ); uv__handle_init ( loop , ( uv_handle_t * ) handle , UV_UDP ); handle -> alloc_cb = NULL ; handle -> recv_cb = NULL ; handle -> send_queue_size = 0 ; handle -> send_queue_count = 0 ; /* \u521d\u59cb\u5316IO\u89c2\u5bdf\u8005\uff08\u8fd8\u6ca1\u6709\u6ce8\u518c\u5230\u4e8b\u4ef6\u5faa\u73af\u7684Poll IO\u9636\u6bb5\uff09\uff0c \u76d1\u542c\u7684\u6587\u4ef6\u63cf\u8ff0\u7b26\u662ffd\uff0c\u56de\u8c03\u662fuv__udp_io */ uv__io_init ( & handle -> io_watcher , uv__udp_io , fd ); // \u521d\u59cb\u5316\u5199\u961f\u5217 QUEUE_INIT ( & handle -> write_queue ); QUEUE_INIT ( & handle -> write_completed_queue ); return 0 ; } \u5c31\u662f\u6211\u4eec\u5728JS\u5c42\u6267\u884cdgram.createSocket('udp4')\u7684\u65f6\u5019\uff0c\u5728Node.js\u4e2d\u4e3b\u8981\u7684\u6267\u884c\u8fc7\u7a0b\u3002\u56de\u5230\u6700\u5f00\u59cb\u7684\u4f8b\u5b50\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u6267\u884cbind\u7684\u65f6\u5019\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Socket . prototype . bind = function ( port_ , address_ /* , callback */ ) { let port = port_ ; // socket\u7684\u4e0a\u4e0b\u6587 const state = this [ kStateSymbol ]; // \u5df2\u7ecf\u7ed1\u5b9a\u8fc7\u4e86\u5219\u62a5\u9519 if ( state . bindState !== BIND_STATE_UNBOUND ) throw new ERR_SOCKET_ALREADY_BOUND (); // \u5426\u5219\u6807\u8bb0\u5df2\u7ecf\u7ed1\u5b9a\u4e86 state . bindState = BIND_STATE_BINDING ; // \u6ca1\u4f20\u5730\u5740\u5219\u9ed8\u8ba4\u7ed1\u5b9a\u6240\u6709\u5730\u5740 if ( ! address ) { if ( this . type === 'udp4' ) address = '0.0.0.0' ; else address = '::' ; } // dns\u89e3\u6790\u540e\u5728\u7ed1\u5b9a\uff0c\u5982\u679c\u9700\u8981\u7684\u8bdd state . handle . lookup ( address , ( err , ip ) => { if ( err ) { state . bindState = BIND_STATE_UNBOUND ; this . emit ( 'error' , err ); return ; } const err = state . handle . bind ( ip , port || 0 , flags ); if ( err ) { const ex = exceptionWithHostPort ( err , 'bind' , ip , port ); state . bindState = BIND_STATE_UNBOUND ; this . emit ( 'error' , ex ); // Todo: close? return ; } startListening ( this ); return this ; } bind\u51fd\u6570\u4e3b\u8981\u7684\u903b\u8f91\u662fhandle.bind\u548cstartListening\u3002\u6211\u4eec\u4e00\u4e2a\u4e2a\u770b\u3002\u6211\u4eec\u770b\u4e00\u4e0bC++\u5c42\u7684bind\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void UDPWrap::DoBind ( const FunctionCallbackInfo < Value >& args , int family ) { UDPWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder (), args . GetReturnValue (). Set ( UV_EBADF )); // bind(ip, port, flags) CHECK_EQ ( args . Length (), 3 ); node :: Utf8Value address ( args . GetIsolate (), args [ 0 ]); Local < Context > ctx = args . GetIsolate () -> GetCurrentContext (); uint32_t port , flags ; struct sockaddr_storage addr_storage ; int err = sockaddr_for_family ( family , address . out (), port , & addr_storage ); if ( err == 0 ) { err = uv_udp_bind ( & wrap -> handle_ , reinterpret_cast < const sockaddr *> ( & addr_storage ), flags ); } args . GetReturnValue (). Set ( err ); } \u4e5f\u6ca1\u6709\u592a\u591a\u903b\u8f91\uff0c\u5904\u7406\u53c2\u6570\u7136\u540e\u6267\u884cuv_udp_bind\u8bbe\u7f6e\u4e00\u4e9b\u6807\u8bb0\u3001\u5c5e\u6027\u548c\u7aef\u53e3\u590d\u7528\uff08\u7aef\u53e3\u590d\u7528\u540e\u7eed\u4f1a\u5355\u72ec\u5206\u6790\uff09\uff0c\u7136\u540e\u6267\u884c\u64cd\u4f5c\u7cfb\u7edfbind\u7684\u51fd\u6570\u628a\u672c\u7aef\u7684ip\u548c\u7aef\u53e3\u4fdd\u5b58\u5230socket\u4e2d\u3002\u6211\u4eec\u7ee7\u7eed\u770bstartListening\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function startListening ( socket ) { const state = socket [ kStateSymbol ]; // \u6709\u6570\u636e\u65f6\u7684\u56de\u8c03\uff0c\u89e6\u53d1message\u4e8b\u4ef6 state . handle . onmessage = onMessage ; // \u91cd\u70b9\uff0c\u5f00\u59cb\u76d1\u542c\u6570\u636e state . handle . recvStart (); state . receiving = true ; state . bindState = BIND_STATE_BOUND ; // \u8bbe\u7f6e\u64cd\u4f5c\u7cfb\u7edf\u7684\u63a5\u6536\u548c\u53d1\u9001\u7f13\u51b2\u533a\u5927\u5c0f if ( state . recvBufferSize ) bufferSize ( socket , state . recvBufferSize , RECV_BUFFER ); if ( state . sendBufferSize ) bufferSize ( socket , state . sendBufferSize , SEND_BUFFER ); socket . emit ( 'listening' ); } \u91cd\u70b9\u662frecvStart\u51fd\u6570\uff0c\u6211\u4eec\u770bC++\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 void UDPWrap::RecvStart ( const FunctionCallbackInfo < Value >& args ) { UDPWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder (), args . GetReturnValue (). Set ( UV_EBADF )); int err = uv_udp_recv_start ( & wrap -> handle_ , OnAlloc , OnRecv ); // UV_EALREADY means that the socket is already bound but that's okay if ( err == UV_EALREADY ) err = 0 ; args . GetReturnValue (). Set ( err ); } OnAlloc, OnRecv\u5206\u522b\u662f\u5206\u914d\u5185\u5b58\u63a5\u6536\u6570\u636e\u7684\u51fd\u6570\u548c\u6570\u636e\u5230\u6765\u65f6\u6267\u884c\u7684\u56de\u8c03\u3002\u7ee7\u7eed\u770bLibuv 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 int uv__udp_recv_start ( uv_udp_t * handle , uv_alloc_cb alloc_cb , uv_udp_recv_cb recv_cb ) { int err ; err = uv__udp_maybe_deferred_bind ( handle , AF_INET , 0 ); if ( err ) return err ; // \u4fdd\u5b58\u4e00\u4e9b\u4e0a\u4e0b\u6587 handle -> alloc_cb = alloc_cb ; handle -> recv_cb = recv_cb ; // \u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230loop\uff0c\u5982\u679c\u4e8b\u4ef6\u5230\u6765\uff0c\u7b49\u5230Poll IO\u9636\u6bb5\u5904\u7406 uv__io_start ( handle -> loop , & handle -> io_watcher , POLLIN ); uv__handle_start ( handle ); return 0 ; } uv__udp_recv_start\u4e3b\u8981\u662f\u6ce8\u518cIO\u89c2\u5bdf\u8005\u5230loop\uff0c\u7b49\u5f85\u4e8b\u4ef6\u5230\u6765\u7684\u65f6\u5019\uff0c\u5230\u8fd9\uff0c\u670d\u52a1\u5668\u5c31\u542f\u52a8\u4e86\u3002","title":"16.2.1 \u670d\u52a1\u5668"},{"location":"chapter16-UDP/#1622","text":"\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u5ba2\u6237\u7aef\u7684\u4f7f\u7528\u65b9\u5f0f\u548c\u6d41\u7a0b 1 2 3 4 5 6 7 8 const dgram = require ( 'dgram' ); const message = Buffer . from ( 'Some bytes' ); const client = dgram . createSocket ( 'udp4' ); client . connect ( 41234 , 'localhost' , ( err ) => { client . send ( message , ( err ) => { client . close (); }); }); \u6211\u4eec\u770b\u5230Node.js\u9996\u5148\u8c03\u7528connect\u7ed1\u5b9a\u670d\u52a1\u5668\u7684\u5730\u5740\uff0c\u7136\u540e\u8c03\u7528send\u53d1\u9001\u4fe1\u606f\uff0c\u6700\u540e\u8c03\u7528close\u3002\u6211\u4eec\u4e00\u4e2a\u4e2a\u5206\u6790\u3002\u9996\u5148\u770bconnect\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Socket . prototype . connect = function ( port , address , callback ) { port = validatePort ( port ); // \u53c2\u6570\u5904\u7406 if ( typeof address === 'function' ) { callback = address ; address = '' ; } else if ( address === undefined ) { address = '' ; } const state = this [ kStateSymbol ]; // \u4e0d\u662f\u521d\u59cb\u5316\u72b6\u6001 if ( state . connectState !== CONNECT_STATE_DISCONNECTED ) throw new ERR_SOCKET_DGRAM_IS_CONNECTED (); // \u8bbe\u7f6esocket\u72b6\u6001 state . connectState = CONNECT_STATE_CONNECTING ; // \u8fd8\u6ca1\u6709\u7ed1\u5b9a\u5ba2\u6237\u7aef\u5730\u5740\u4fe1\u606f\uff0c\u5219\u5148\u7ed1\u5b9a\u968f\u673a\u5730\u5740\uff08\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a\uff09 if ( state . bindState === BIND_STATE_UNBOUND ) this . bind ({ port : 0 , exclusive : true }, null ); // \u6267\u884cbind\u7684\u65f6\u5019\uff0cstate.bindState\u4e0d\u662f\u540c\u6b65\u8bbe\u7f6e\u7684 if ( state . bindState !== BIND_STATE_BOUND ) { enqueue ( this , _connect . bind ( this , port , address , callback )); return ; } _connect . call ( this , port , address , callback ); }; \u8fd9\u91cc\u5206\u4e3a\u4e24\u79cd\u60c5\u51b5\uff0c\u4e00\u79cd\u662f\u5728connect\u4e4b\u524d\u5df2\u7ecf\u8c03\u7528\u4e86bind\uff0c\u7b2c\u4e8c\u79cd\u662f\u6ca1\u6709\u8c03\u7528bind\uff0c\u5982\u679c\u6ca1\u6709\u8c03\u7528bind\uff0c\u5219\u5728connect\u4e4b\u524d\u5148\u8981\u8c03\u7528bind\uff08\u56e0\u4e3abind\u4e2d\u4e0d\u4ec5\u4ec5\u7ed1\u5b9a\u4e86ip\u7aef\u53e3\uff0c\u8fd8\u6709\u7aef\u53e3\u590d\u7528\u7684\u5904\u7406\uff09\u3002\u8fd9\u91cc\u53ea\u5206\u6790\u6ca1\u6709\u8c03\u7528bind\u7684\u60c5\u51b5\uff0c\u56e0\u4e3a\u8fd9\u662f\u6700\u957f\u7684\u8def\u5f84\u3002bind\u521a\u624d\u6211\u4eec\u5206\u6790\u8fc7\u4e86\uff0c\u6211\u4eec\u4ece\u4ee5\u4e0b\u4ee3\u7801\u7ee7\u7eed\u5206\u6790 1 2 3 4 if ( state . bindState !== BIND_STATE_BOUND ) { enqueue ( this , _connect . bind ( this , port , address , callback )); return ; } enqueue\u628a\u4efb\u52a1\u52a0\u5165\u4efb\u52a1\u961f\u5217\uff0c\u5e76\u4e14\u76d1\u542c\u4e86listening\u4e8b\u4ef6\uff08\u8be5\u4e8b\u4ef6\u5728bind\u6210\u529f\u540e\u89e6\u53d1\uff09\u3002 1 2 3 4 5 6 7 8 9 function enqueue ( self , toEnqueue ) { const state = self [ kStateSymbol ]; if ( state . queue === undefined ) { state . queue = []; self . once ( 'error' , onListenError ); self . once ( 'listening' , onListenSuccess ); } state . queue . push ( toEnqueue ); } \u8fd9\u65f6\u5019connect\u51fd\u6570\u5c31\u6267\u884c\u5b8c\u4e86\uff0c\u7b49\u5f85bind\u6210\u529f\u540e\uff08nextTick\uff09\u4f1a\u6267\u884c startListening\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function startListening ( socket ) { const state = socket [ kStateSymbol ]; state . handle . onmessage = onMessage ; // \u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 state . handle . recvStart (); state . receiving = true ; // \u6807\u8bb0\u5df2bind\u6210\u529f state . bindState = BIND_STATE_BOUND ; // \u8bbe\u7f6e\u8bfb\u5199\u7f13\u51b2\u533a\u5927\u5c0f if ( state . recvBufferSize ) bufferSize ( socket , state . recvBufferSize , RECV_BUFFER ); if ( state . sendBufferSize ) bufferSize ( socket , state . sendBufferSize , SEND_BUFFER ); // \u89e6\u53d1listening\u4e8b\u4ef6 socket . emit ( 'listening' ); } \u6211\u4eec\u770b\u5230startListening\u89e6\u53d1\u4e86listening\u4e8b\u4ef6\uff0c\u4ece\u800c\u6267\u884c\u6211\u4eec\u521a\u624d\u5165\u961f\u7684\u56de\u8c03onListenSuccess\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 function onListenSuccess () { this . removeListener ( 'error' , onListenError ); clearQueue . call ( this ); } function clearQueue () { const state = this [ kStateSymbol ]; const queue = state . queue ; state . queue = undefined ; for ( const queueEntry of queue ) queueEntry (); } \u56de\u8c03\u5c31\u662f\u628a\u961f\u5217\u4e2d\u7684\u56de\u8c03\u6267\u884c\u4e00\u904d\uff0cconnect\u51fd\u6570\u8bbe\u7f6e\u7684\u56de\u8c03\u662f_connect\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function _connect ( port , address , callback ) { const state = this [ kStateSymbol ]; if ( callback ) this . once ( 'connect' , callback ); const afterDns = ( ex , ip ) => { defaultTriggerAsyncIdScope ( this [ async_id_symbol ], doConnect , ex , this , ip , address , port , callback ); }; state . handle . lookup ( address , afterDns ); } \u8fd9\u91cc\u7684address\u662f\u670d\u52a1\u5668\u5730\u5740\uff0c_connect\u51fd\u6570\u4e3b\u8981\u903b\u8f91\u662f 1 \u76d1\u542cconnect\u4e8b\u4ef6 2 \u5bf9\u670d\u52a1\u5668\u5730\u5740\u8fdb\u884cdns\u89e3\u6790\uff08\u53ea\u80fd\u662f\u672c\u5730\u7684\u914d\u7684\u57df\u540d\uff09\u3002\u89e3\u6790\u6210\u529f\u540e\u6267\u884cafterDns\uff0c\u6700\u540e\u6267\u884cdoConnect\uff0c\u5e76\u4f20\u5165\u89e3\u6790\u51fa\u6765\u7684ip\u3002\u6211\u4eec\u770b\u770bdoConnect 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function doConnect ( ex , self , ip , address , port , callback ) { const state = self [ kStateSymbol ]; // dns\u89e3\u6790\u6210\u529f\uff0c\u6267\u884c\u5e95\u5c42\u7684connect if ( ! ex ) { const err = state . handle . connect ( ip , port ); if ( err ) { ex = exceptionWithHostPort ( err , 'connect' , address , port ); } } // connect\u6210\u529f\uff0c\u89e6\u53d1connect\u4e8b\u4ef6 state . connectState = CONNECT_STATE_CONNECTED ; process . nextTick (() => self . emit ( 'connect' )); } connect\u51fd\u6570\u901a\u8fc7C++\u5c42\uff0c\u7136\u540e\u8c03\u7528Libuv\uff0c\u5230\u64cd\u4f5c\u7cfb\u7edf\u7684connect\u3002\u4f5c\u7528\u662f\u628a\u670d\u52a1\u5668\u5730\u5740\u4fdd\u5b58\u5230socket\u4e2d\u3002connect\u7684\u6d41\u7a0b\u5c31\u8d70\u5b8c\u4e86\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u5c31\u53ef\u4ee5\u8c03\u7528send\u548crecv\u53d1\u9001\u548c\u63a5\u6536\u6570\u636e\u3002","title":"16.2.2 \u5ba2\u6237\u7aef"},{"location":"chapter16-UDP/#1623","text":"\u53d1\u9001\u6570\u636e\u63a5\u53e3\u662fsendto\uff0c\u5b83\u662f\u5bf9send\u7684\u5c01\u88c5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 Socket . prototype . send = function ( buffer , offset , length , port , address , callback ) { let list ; const state = this [ kStateSymbol ]; const connected = state . connectState === CONNECT_STATE_CONNECTED ; // \u6ca1\u6709\u8c03\u7528connect\u7ed1\u5b9a\u8fc7\u670d\u52a1\u7aef\u5730\u5740\uff0c\u5219\u9700\u8981\u4f20\u670d\u52a1\u7aef\u5730\u5740\u4fe1\u606f if ( ! connected ) { if ( address || ( port && typeof port !== 'function' )) { buffer = sliceBuffer ( buffer , offset , length ); } else { callback = port ; port = offset ; address = length ; } } else { if ( typeof length === 'number' ) { buffer = sliceBuffer ( buffer , offset , length ); if ( typeof port === 'function' ) { callback = port ; port = null ; } } else { callback = offset ; } // \u5df2\u7ecf\u7ed1\u5b9a\u4e86\u670d\u52a1\u7aef\u5730\u5740\uff0c\u5219\u4e0d\u80fd\u518d\u4f20\u4e86 if ( port || address ) throw new ERR_SOCKET_DGRAM_IS_CONNECTED (); } // \u5982\u679c\u6ca1\u6709\u7ed1\u5b9a\u670d\u52a1\u5668\u7aef\u53e3\uff0c\u5219\u8fd9\u91cc\u9700\u8981\u4f20\uff0c\u5e76\u4e14\u6821\u9a8c if ( ! connected ) port = validatePort ( port ); // \u5ffd\u7565\u4e00\u4e9b\u53c2\u6570\u5904\u7406\u903b\u8f91 // \u6ca1\u6709\u7ed1\u5b9a\u5ba2\u6237\u7aef\u5730\u5740\u4fe1\u606f\uff0c\u5219\u9700\u8981\u5148\u7ed1\u5b9a\uff0c\u503c\u7531\u64cd\u4f5c\u7cfb\u7edf\u51b3\u5b9a if ( state . bindState === BIND_STATE_UNBOUND ) this . bind ({ port : 0 , exclusive : true }, null ); // bind\u8fd8\u6ca1\u6709\u5b8c\u6210\uff0c\u5219\u5148\u5165\u961f\uff0c\u7b49\u5f85bind\u5b8c\u6210\u518d\u6267\u884c if ( state . bindState !== BIND_STATE_BOUND ) { enqueue ( this , this . send . bind ( this , list , port , address , callback )); return ; } // \u5df2\u7ecf\u7ed1\u5b9a\u4e86\uff0c\u8bbe\u7f6e\u670d\u52a1\u7aef\u5730\u5740\u540e\u53d1\u9001\u6570\u636e const afterDns = ( ex , ip ) => { defaultTriggerAsyncIdScope ( this [ async_id_symbol ], doSend , ex , this , ip , list , address , port , callback ); }; // \u4f20\u4e86\u5730\u5740\u5219\u53ef\u80fd\u9700\u8981dns\u89e3\u6790 if ( ! connected ) { state . handle . lookup ( address , afterDns ); } else { afterDns ( null , null ); } } \u6211\u4eec\u7ee7\u7eed\u770bdoSend\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 function doSend ( ex , self , ip , list , address , port , callback ) { const state = self [ kStateSymbol ]; // dns\u89e3\u6790\u51fa\u9519 if ( ex ) { if ( typeof callback === 'function' ) { process . nextTick ( callback , ex ); return ; } process . nextTick (() => self . emit ( 'error' , ex )); return ; } // \u5b9a\u4e49\u4e00\u4e2a\u8bf7\u6c42\u5bf9\u8c61 const req = new SendWrap (); req . list = list ; // Keep reference alive. req . address = address ; req . port = port ; /* \u8bbe\u7f6eNode.js\u548c\u7528\u6237\u7684\u56de\u8c03\uff0concomplete\u7531C++\u5c42\u8c03\u7528\uff0c callback\u7531oncomplete\u8c03\u7528 */ if ( callback ) { req . callback = callback ; req . oncomplete = afterSend ; } let err ; // \u6839\u636e\u662f\u5426\u9700\u8981\u8bbe\u7f6e\u670d\u52a1\u7aef\u5730\u5740\uff0c\u8c03C++\u5c42\u51fd\u6570 if ( port ) err = state . handle . send ( req , list , list . length , port , ip , !! callback ); else err = state . handle . send ( req , list , list . length , !! callback ); /* err\u5927\u4e8e\u7b49\u4e8e1\u8bf4\u660e\u540c\u6b65\u53d1\u9001\u6210\u529f\u4e86\uff0c\u76f4\u63a5\u6267\u884c\u56de\u8c03\uff0c \u5426\u5219\u7b49\u5f85\u5f02\u6b65\u56de\u8c03 */ if ( err >= 1 ) { if ( callback ) process . nextTick ( callback , null , err - 1 ); return ; } // \u53d1\u9001\u5931\u8d25 if ( err && callback ) { const ex = exceptionWithHostPort ( err , 'send' , address , port ); process . nextTick ( callback , ex ); } } \u6211\u4eec\u7a7f\u8fc7C++\u5c42\uff0c\u76f4\u63a5\u770bLibuv\u7684\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 int uv__udp_send ( uv_udp_send_t * req , uv_udp_t * handle , const uv_buf_t bufs [], unsigned int nbufs , const struct sockaddr * addr , unsigned int addrlen , uv_udp_send_cb send_cb ) { int err ; int empty_queue ; assert ( nbufs > 0 ); // \u8fd8\u6ca1\u6709\u7ed1\u5b9a\u670d\u52a1\u7aef\u5730\u5740\uff0c\u5219\u7ed1\u5b9a if ( addr ) { err = uv__udp_maybe_deferred_bind ( handle , addr -> sa_family , 0 ); if ( err ) return err ; } // \u5f53\u524d\u5199\u961f\u5217\u662f\u5426\u4e3a\u7a7a empty_queue = ( handle -> send_queue_count == 0 ); // \u521d\u59cb\u5316\u4e00\u4e2a\u5199\u8bf7\u6c42 uv__req_init ( handle -> loop , req , UV_UDP_SEND ); if ( addr == NULL ) req -> addr . ss_family = AF_UNSPEC ; else memcpy ( & req -> addr , addr , addrlen ); // \u4fdd\u5b58\u4e0a\u4e0b\u6587 req -> send_cb = send_cb ; req -> handle = handle ; req -> nbufs = nbufs ; // \u521d\u59cb\u5316\u6570\u636e\uff0c\u9884\u5206\u914d\u7684\u5185\u5b58\u4e0d\u591f\uff0c\u5219\u5206\u914d\u65b0\u7684\u5806\u5185\u5b58 req -> bufs = req -> bufsml ; if ( nbufs > ARRAY_SIZE ( req -> bufsml )) req -> bufs = uv__malloc ( nbufs * sizeof ( bufs [ 0 ])); // \u590d\u5236\u8fc7\u53bb\u5806\u4e2d memcpy ( req -> bufs , bufs , nbufs * sizeof ( bufs [ 0 ])); // \u66f4\u65b0\u5199\u961f\u5217\u6570\u636e handle -> send_queue_size += uv__count_bufs ( req -> bufs , req -> nbufs ); handle -> send_queue_count ++ ; // \u63d2\u5165\u5199\u961f\u5217\uff0c\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\u7684\u53d1\u751f QUEUE_INSERT_TAIL ( & handle -> write_queue , & req -> queue ); uv__handle_start ( handle ); // \u5f53\u524d\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u76f4\u63a5\u5f00\u59cb\u5199\uff0c\u5426\u5219\u8bbe\u7f6e\u7b49\u5f85\u53ef\u5199\u961f\u5217 if ( empty_queue && ! ( handle -> flags & UV_HANDLE_UDP_PROCESSING )) { // \u53d1\u9001\u6570\u636e uv__udp_sendmsg ( handle ); // \u5199\u961f\u5217\u662f\u5426\u975e\u7a7a\uff0c\u5219\u8bbe\u7f6e\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\uff0c\u53ef\u5199\u7684\u65f6\u5019\u63a5\u7740\u5199 if ( ! QUEUE_EMPTY ( & handle -> write_queue )) uv__io_start ( handle -> loop , & handle -> io_watcher , POLLOUT ); } else { uv__io_start ( handle -> loop , & handle -> io_watcher , POLLOUT ); } return 0 ; } \u8be5\u51fd\u6570\u9996\u5148\u8bb0\u5f55\u5199\u8bf7\u6c42\u7684\u4e0a\u4e0b\u6587\uff0c\u7136\u540e\u628a\u5199\u8bf7\u6c42\u63d2\u5165\u5199\u961f\u5217\u4e2d\uff0c\u5f53\u5f85\u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u76f4\u63a5\u6267\u884cuv__udp_sendmsg\u8fdb\u884c\u5199\u64cd\u4f5c\uff0c\u5426\u5219\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6\u7684\u5230\u6765\uff0c\u5f53\u53ef\u5199\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u6267\u884c\u7684\u51fd\u6570\u662fuv__udp_io\u3002 1 2 3 4 5 6 7 static void uv__udp_io ( uv_loop_t * loop , uv__io_t * w , unsigned int revents ) { uv_udp_t * handle ; if ( revents & POLLOUT ) { uv__udp_sendmsg ( handle ); uv__udp_run_completed ( handle ); } } \u6211\u4eec\u5148\u770buv__udp_sendmsg 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 static void uv__udp_sendmsg ( uv_udp_t * handle ) { uv_udp_send_t * req ; QUEUE * q ; struct msghdr h ; ssize_t size ; // \u9010\u4e2a\u8282\u70b9\u53d1\u9001 while ( ! QUEUE_EMPTY ( & handle -> write_queue )) { q = QUEUE_HEAD ( & handle -> write_queue ); req = QUEUE_DATA ( q , uv_udp_send_t , queue ); memset ( & h , 0 , sizeof h ); // \u5ffd\u7565\u53c2\u6570\u5904\u7406 h . msg_iov = ( struct iovec * ) req -> bufs ; h . msg_iovlen = req -> nbufs ; do { size = sendmsg ( handle -> io_watcher . fd , & h , 0 ); } while ( size == -1 && errno == EINTR ); if ( size == -1 ) { // \u7e41\u5fd9\u5219\u5148\u4e0d\u53d1\u4e86\uff0c\u7b49\u5230\u53ef\u5199\u4e8b\u4ef6 if ( errno == EAGAIN || errno == EWOULDBLOCK || errno == ENOBUFS ) break ; } // \u8bb0\u5f55\u53d1\u9001\u7ed3\u679c req -> status = ( size == -1 ? UV__ERR ( errno ) : size ); // \u53d1\u9001\u201c\u5b8c\u201d\u79fb\u51fa\u5199\u961f\u5217 QUEUE_REMOVE ( & req -> queue ); // \u52a0\u5165\u5199\u5b8c\u6210\u961f\u5217 QUEUE_INSERT_TAIL ( & handle -> write_completed_queue , & req -> queue ); /* \u6709\u8282\u70b9\u6570\u636e\u5199\u5b8c\u4e86\uff0c\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\uff0c pending\u9636\u6bb5\u6267\u884c\u56de\u8c03uv__udp_io */ uv__io_feed ( handle -> loop , & handle -> io_watcher ); } } \u8be5\u51fd\u6570\u904d\u5386\u5199\u961f\u5217\uff0c\u7136\u540e\u9010\u4e2a\u53d1\u9001\u8282\u70b9\u4e2d\u7684\u6570\u636e\uff0c\u5e76\u8bb0\u5f55\u53d1\u9001\u7ed3\u679c\u3002 1 \u5982\u679c\u5199\u7e41\u5fd9\u5219\u7ed3\u675f\u5199\u903b\u8f91\uff0c\u7b49\u5f85\u4e0b\u4e00\u6b21\u5199\u4e8b\u4ef6\u89e6\u53d1\u3002 2 \u5982\u679c\u5199\u6210\u529f\u5219\u628a\u8282\u70b9\u63d2\u5165\u5199\u5b8c\u6210\u961f\u5217\u4e2d\uff0c\u5e76\u4e14\u628aIO\u89c2\u5bdf\u8005\u63d2\u5165pending\u961f\u5217\u3002 \u7b49\u5f85pending\u9636\u6bb5\u6267\u884c\u56de\u8c03\u65f6\uff0c\u6267\u884c\u7684\u51fd\u6570\u662fuv__udp_io\u3002 \u6211\u4eec\u518d\u6b21\u56de\u5230uv__udp_io\u4e2d 1 2 3 4 if ( revents & POLLOUT ) { uv__udp_sendmsg ( handle ); uv__udp_run_completed ( handle ); } \u6211\u4eec\u770b\u5230\u8fd9\u65f6\u5019\u4f1a\u7ee7\u7eed\u6267\u884c\u6570\u636e\u53d1\u9001\u7684\u903b\u8f91\uff0c\u7136\u540e\u5904\u7406\u5199\u5b8c\u6210\u961f\u5217\u3002\u6211\u4eec\u770buv__udp_run_completed\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 static void uv__udp_run_completed ( uv_udp_t * handle ) { uv_udp_send_t * req ; QUEUE * q ; handle -> flags |= UV_HANDLE_UDP_PROCESSING ; // \u9010\u4e2a\u8282\u70b9\u5904\u7406 while ( ! QUEUE_EMPTY ( & handle -> write_completed_queue )) { q = QUEUE_HEAD ( & handle -> write_completed_queue ); QUEUE_REMOVE ( q ); req = QUEUE_DATA ( q , uv_udp_send_t , queue ); uv__req_unregister ( handle -> loop , req ); // \u66f4\u65b0\u5f85\u5199\u6570\u636e\u5927\u5c0f handle -> send_queue_size -= uv__count_bufs ( req -> bufs , req -> nbufs ); handle -> send_queue_count -- ; // \u5982\u679c\u91cd\u65b0\u7533\u8bf7\u4e86\u5806\u5185\u5b58\uff0c\u5219\u9700\u8981\u91ca\u653e if ( req -> bufs != req -> bufsml ) uv__free ( req -> bufs ); req -> bufs = NULL ; if ( req -> send_cb == NULL ) continue ; // \u6267\u884c\u56de\u8c03 if ( req -> status >= 0 ) req -> send_cb ( req , 0 ); else req -> send_cb ( req , req -> status ); } // \u5199\u961f\u5217\u4e3a\u7a7a\uff0c\u5219\u6ce8\u9500\u7b49\u5f85\u53ef\u5199\u4e8b\u4ef6 if ( QUEUE_EMPTY ( & handle -> write_queue )) { uv__io_stop ( handle -> loop , & handle -> io_watcher , POLLOUT ); if ( ! uv__io_active ( & handle -> io_watcher , POLLIN )) uv__handle_stop ( handle ); } handle -> flags &= ~ UV_HANDLE_UDP_PROCESSING ; } \u8fd9\u5c31\u662f\u53d1\u9001\u7684\u903b\u8f91\uff0c\u53d1\u9001\u5b8c\u540eLibuv\u4f1a\u8c03\u7528C++\u56de\u8c03\uff0c\u6700\u540e\u56de\u8c03JS\u5c42\u56de\u8c03\u3002\u5177\u4f53\u5230\u64cd\u4f5c\u7cfb\u7edf\u4e5f\u662f\u7c7b\u4f3c\u7684\u5b9e\u73b0\uff0c\u64cd\u4f5c\u7cfb\u7edf\u9996\u5148\u5224\u65ad\u6570\u636e\u7684\u5927\u5c0f\u662f\u5426\u5c0f\u4e8e\u5199\u7f13\u51b2\u533a\uff0c\u662f\u7684\u8bdd\u7533\u8bf7\u4e00\u5757\u5185\u5b58\uff0c\u7136\u540e\u6784\u9020UDP\u534f\u8bae\u6570\u636e\u5305\uff0c\u518d\u9010\u5c42\u5f80\u4e0b\u8c03\uff0c\u6700\u540e\u53d1\u9001\u51fa\u6765\uff0c\u4f46\u662f\u5982\u679c\u6570\u636e\u8d85\u8fc7\u4e86\u5e95\u5c42\u7684\u62a5\u6587\u5927\u5c0f\u9650\u5236\uff0c\u5219\u4f1a\u88ab\u5206\u7247\u3002","title":"16.2.3 \u53d1\u9001\u6570\u636e"},{"location":"chapter16-UDP/#1624","text":"UDP\u670d\u52a1\u5668\u542f\u52a8\u7684\u65f6\u5019\uff0c\u5c31\u6ce8\u518c\u4e86\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\u7684\u53d1\u9001\uff0c\u5982\u679c\u6536\u5230\u4e86\u6570\u636e\uff0c\u5219\u5728Poll IO\u9636\u6bb5\u5c31\u4f1a\u88ab\u5904\u7406\u3002\u524d\u9762\u6211\u4eec\u8bb2\u8fc7\uff0c\u56de\u8c03\u51fd\u6570\u662fuv__udp_io\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u8be5\u51fd\u6570\u600e\u4e48\u5904\u7406\u7684\u3002 1 2 3 4 5 6 7 8 static void uv__udp_io ( uv_loop_t * loop , uv__io_t * w , unsigned int revents ) { uv_udp_t * handle ; handle = container_of ( w , uv_udp_t , io_watcher ); // \u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1 if ( revents & POLLIN ) uv__udp_recvmsg ( handle ); } \u6211\u4eec\u770buv__udp_recvmsg\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 static void uv__udp_recvmsg ( uv_udp_t * handle ) { struct sockaddr_storage peer ; struct msghdr h ; ssize_t nread ; uv_buf_t buf ; int flags ; int count ; count = 32 ; do { // \u5206\u914d\u5185\u5b58\u63a5\u6536\u6570\u636e\uff0cC++\u5c42\u8bbe\u7f6e\u7684 buf = uv_buf_init ( NULL , 0 ); handle -> alloc_cb (( uv_handle_t * ) handle , 64 * 1024 , & buf ); memset ( & h , 0 , sizeof ( h )); memset ( & peer , 0 , sizeof ( peer )); h . msg_name = & peer ; h . msg_namelen = sizeof ( peer ); h . msg_iov = ( void * ) & buf ; h . msg_iovlen = 1 ; // \u8c03\u64cd\u4f5c\u7cfb\u7edf\u7684\u51fd\u6570\u8bfb\u53d6\u6570\u636e do { nread = recvmsg ( handle -> io_watcher . fd , & h , 0 ); } while ( nread == -1 && errno == EINTR ); // \u8c03\u7528C++\u5c42\u56de\u8c03 handle -> recv_cb ( handle , nread , & buf , ( const struct sockaddr * ) & peer , flags ); } } \u6700\u7ec8\u901a\u8fc7\u64cd\u4f5c\u7cfb\u7edf\u8c03\u7528recvmsg\u8bfb\u53d6\u6570\u636e\uff0c\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230\u4e00\u4e2audp\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u4f1a\u6302\u8f7d\u5230socket\u7684\u63a5\u6536\u961f\u5217\uff0c\u5982\u679c\u63a5\u6536\u961f\u5217\u6ee1\u4e86\u5219\u4f1a\u4e22\u5f03\uff0c\u5f53\u7528\u6237\u8c03\u7528recvmsg\u51fd\u6570\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u628a\u63a5\u6536\u961f\u5217\u4e2d\u8282\u70b9\u9010\u4e2a\u8fd4\u56de\u7ed9\u7528\u6237\u3002\u8bfb\u53d6\u5b8c\u540e\uff0cLibuv\u4f1a\u56de\u8c03C++\u5c42\uff0c\u7136\u540eC++\u5c42\u56de\u8c03\u5230JS\u5c42\uff0c\u6700\u540e\u89e6\u53d1message\u4e8b\u4ef6\uff0c\u8fd9\u5c31\u662f\u5bf9\u5e94\u5f00\u59cb\u90a3\u6bb5\u4ee3\u7801\u7684message\u4e8b\u4ef6\u3002","title":"16.2.4 \u63a5\u6536\u6570\u636e"},{"location":"chapter16-UDP/#1625","text":"\u6211\u4eec\u77e5\u9053\uff0cTCP\u662f\u57fa\u4e8e\u8fde\u63a5\u548c\u53ef\u9760\u7684\uff0c\u591a\u64ad\u5219\u4f1a\u5e26\u6765\u8fc7\u591a\u7684\u8fde\u63a5\u548c\u6d41\u91cf\uff0c\u6240\u4ee5TCP\u662f\u4e0d\u652f\u6301\u591a\u64ad\u7684\uff0c\u800cUDP\u5219\u652f\u6301\u591a\u64ad\u3002\u591a\u64ad\u5206\u4e3a\u5c40\u57df\u7f51\u591a\u64ad\u548c\u5e7f\u57df\u7f51\u591a\u64ad\uff0c\u6211\u4eec\u77e5\u9053\u5728\u5c40\u57df\u7f51\u5185\u53d1\u751f\u4e00\u4e2a\u6570\u636e\uff0c\u662f\u4f1a\u4ee5\u5e7f\u64ad\u7684\u5f62\u5f0f\u53d1\u9001\u5230\u5404\u4e2a\u4e3b\u673a\u7684\uff0c\u4e3b\u673a\u6839\u636e\u76ee\u7684\u5730\u5740\u5224\u65ad\u662f\u5426\u9700\u8981\u5904\u7406\u8be5\u6570\u636e\u5305\u3002\u5982\u679cUDP\u662f\u5355\u64ad\u7684\u6a21\u5f0f\uff0c\u5219\u53ea\u4f1a\u6709\u4e00\u4e2a\u4e3b\u673a\u4f1a\u5904\u7406\u8be5\u6570\u636e\u5305\u3002\u5982\u679cUDP\u662f\u591a\u64ad\u7684\u6a21\u5f0f\uff0c\u5219\u6709\u591a\u4e2a\u4e3b\u673a\u5904\u7406\u8be5\u6570\u636e\u5305\u3002\u591a\u64ad\u7684\u65f6\u5019\uff0c\u5b58\u5728\u4e00\u4e2a\u591a\u64ad\u7ec4\u7684\u6982\u5ff5\uff0c\u8fd9\u5c31\u662fIGMP\u505a\u7684\u4e8b\u60c5\u3002\u5b83\u5b9a\u4e49\u4e86\u7ec4\u7684\u6982\u5ff5\u3002\u53ea\u6709\u52a0\u5165\u8fd9\u4e2a\u7ec4\u7684\u4e3b\u673a\u624d\u80fd\u5904\u7406\u8be5\u7ec4\u7684\u6570\u636e\u5305\u3002\u5047\u8bbe\u6709\u4ee5\u4e0b\u5c40\u57df\u7f51\uff0c\u5982\u56fe16-1\u6240\u793a\u3002 \u56fe16-1 \u5f53\u4e3b\u673a1\u7ed9\u591a\u64ad\u7ec41\u53d1\u9001\u6570\u636e\u7684\u65f6\u5019\uff0c\u4e3b\u673a4\u53ef\u4ee5\u6536\u5230\uff0c\u4e3b\u673a2\uff0c3\u5219\u65e0\u6cd5\u6536\u5230\u3002 \u6211\u4eec\u518d\u6765\u770b\u770b\u5e7f\u57df\u7f51\u7684\u591a\u64ad\u3002\u5e7f\u57df\u7f51\u7684\u591a\u64ad\u9700\u8981\u8def\u7531\u5668\u7684\u652f\u6301\uff0c\u591a\u4e2a\u8def\u7531\u5668\u4e4b\u95f4\u4f1a\u4f7f\u7528\u591a\u64ad\u8def\u7531\u534f\u8bae\u4ea4\u6362\u591a\u64ad\u7ec4\u7684\u4fe1\u606f\u3002\u5047\u8bbe\u6709\u4ee5\u4e0b\u5e7f\u57df\u7f51\uff0c\u5982\u56fe16-2\u6240\u793a\u3002 \u56fe16-2 \u5f53\u4e3b\u673a1\u7ed9\u591a\u64ad\u7ec41\u53d1\u9001\u6570\u636e\u7684\u65f6\u5019\uff0c\u8def\u7531\u56681\u4f1a\u7ed9\u8def\u7531\u56682\u53d1\u9001\u4e00\u4efd\u6570\u636e\uff08\u901a\u8fc7\u591a\u64ad\u8def\u7531\u534f\u8bae\u4ea4\u6362\u4e86\u4fe1\u606f\uff0c\u8def\u75311\u77e5\u9053\u8def\u7531\u56682\u7684\u4e3b\u673a7\u5728\u591a\u64ad\u7ec41\u4e2d\uff09\uff0c\u4f46\u662f\u8def\u7531\u56682\u4e0d\u4f1a\u7ed9\u8def\u7531\u56683\u53d1\u9001\u6570\u636e\uff0c\u56e0\u4e3a\u5b83\u77e5\u9053\u8def\u7531\u56683\u5bf9\u5e94\u7684\u7f51\u7edc\u4e2d\u6ca1\u6709\u4e3b\u673a\u5728\u591a\u64ad\u7ec41\u3002 \u4ee5\u4e0a\u662f\u591a\u64ad\u7684\u4e00\u4e9b\u6982\u5ff5\u3002Node.js\u4e2d\u5173\u4e8e\u591a\u64ad\u7684\u5b9e\u73b0\uff0c\u57fa\u672c\u662f\u5bf9\u64cd\u4f5c\u7cfb\u7edfAPI\u7684\u5c01\u88c5\uff0c\u6240\u4ee5\u5c31\u4e0d\u6253\u7b97\u8bb2\u89e3\uff0c\u6211\u4eec\u76f4\u63a5\u770b\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u5bf9\u4e8e\u591a\u64ad\u7684\u5b9e\u73b0\u3002","title":"16.2.5 \u591a\u64ad"},{"location":"chapter16-UDP/#16251","text":"\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u63a5\u53e3\u52a0\u5165\u4e00\u4e2a\u591a\u64ad\u7ec4\u3002 1 2 3 4 5 setsockopt ( fd , IPPROTO_IP , IP_ADD_MEMBERSHIP , & mreq , // \u8bb0\u5f55\u51fa\u53e3ip\u548c\u52a0\u5165\u591a\u64ad\u7ec4\u7684ip sizeof ( mreq )); mreq\u7684\u7ed3\u6784\u4f53\u5b9a\u4e49\u5982\u4e0b 1 2 3 4 5 6 7 struct ip_mreq { // \u52a0\u5165\u7684\u591a\u64ad\u7ec4ip struct in_addr imr_multiaddr ; // \u51fa\u53e3ip struct in_addr imr_interface ; }; \u6211\u4eec\u770b\u4e00\u4e0bsetsockopt\u7684\u5b9e\u73b0\uff08\u53ea\u5217\u51fa\u76f8\u5173\u90e8\u5206\u4ee3\u7801\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 case IP_ADD_MEMBERSHIP : { struct ip_mreq mreq ; static struct options optmem ; unsigned long route_src ; struct rtable * rt ; struct device * dev = NULL ; err = verify_area ( VERIFY_READ , optval , sizeof ( mreq )); memcpy_fromfs ( & mreq , optval , sizeof ( mreq )); // \u6ca1\u6709\u8bbe\u7f6edevice\u5219\u6839\u636e\u591a\u64ad\u7ec4ip\u9009\u62e9\u4e00\u4e2adevice if ( mreq . imr_interface . s_addr == INADDR_ANY ) { if (( rt = ip_rt_route ( mreq . imr_multiaddr . s_addr , & optmem , & route_src )) != NULL ) { dev = rt -> rt_dev ; rt -> rt_use -- ; } } else { // \u6839\u636e\u8bbe\u7f6e\u7684ip\u627e\u5230\u5bf9\u5e94\u7684device for ( dev = dev_base ; dev ; dev = dev -> next ) { // \u5728\u5de5\u4f5c\u72b6\u6001\u3001\u652f\u6301\u591a\u64ad\uff0cip\u4e00\u6837 if (( dev -> flags & IFF_UP ) && ( dev -> flags & IFF_MULTICAST ) && ( dev -> pa_addr == mreq . imr_interface . s_addr )) break ; } } // \u52a0\u5165\u591a\u64ad\u7ec4 return ip_mc_join_group ( sk , dev , mreq . imr_multiaddr . s_addr ); } \u9996\u5148\u62ff\u5230\u52a0\u5165\u7684\u591a\u64ad\u7ec4IP\u548c\u51fa\u53e3IP\u5bf9\u5e94\u7684device\u540e\uff0c\u8c03\u7528ip_mc_join_group\uff0c\u5728socket\u7ed3\u6784\u4f53\u4e2d\uff0c\u6709\u4e00\u4e2a\u5b57\u6bb5\u7ef4\u62a4\u4e86\u8be5socket\u52a0\u5165\u7684\u591a\u64ad\u7ec4\u4fe1\u606f\uff0c\u5982\u56fe16-3\u6240\u793a\u3002 \u56fe16-3 \u6211\u4eec\u63a5\u7740\u770b\u4e00\u4e0bip_mc_join_group 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 int ip_mc_join_group ( struct sock * sk , struct device * dev , unsigned long addr ) { int unused = -1 ; int i ; // \u8fd8\u6ca1\u6709\u52a0\u5165\u8fc7\u591a\u64ad\u7ec4\u5219\u5206\u914d\u4e00\u4e2aip_mc_socklist\u7ed3\u6784\u4f53 if ( sk -> ip_mc_list == NULL ) { if (( sk -> ip_mc_list = ( struct ip_mc_socklist * ) kmalloc ( sizeof ( * sk -> ip_mc_list ), GFP_KERNEL )) == NULL ) return - ENOMEM ; memset ( sk -> ip_mc_list , '\\0' , sizeof ( * sk -> ip_mc_list )); } // \u904d\u5386\u52a0\u5165\u7684\u591a\u64ad\u7ec4\u961f\u5217\uff0c\u5224\u65ad\u662f\u5426\u5df2\u7ecf\u52a0\u5165\u8fc7 for ( i = 0 ; i < IP_MAX_MEMBERSHIPS ; i ++ ) { if ( sk -> ip_mc_list -> multiaddr [ i ] == addr && sk -> ip_mc_list -> multidev [ i ] == dev ) return - EADDRINUSE ; if ( sk -> ip_mc_list -> multidev [ i ] == NULL ) // \u8bb0\u5f55\u53ef\u7528\u4f4d\u7f6e\u7684\u7d22\u5f15 unused = i ; } // \u5230\u8fd9\u8bf4\u660e\u6ca1\u6709\u52a0\u5165\u8fc7\u5f53\u524d\u8bbe\u7f6e\u7684\u591a\u64ad\u7ec4\uff0c\u5219\u8bb0\u5f55\u5e76\u4e14\u52a0\u5165 if ( unused == -1 ) return - ENOBUFS ; sk -> ip_mc_list -> multiaddr [ unused ] = addr ; sk -> ip_mc_list -> multidev [ unused ] = dev ; // addr\u4e3a\u591a\u64ad\u7ec4ip ip_mc_inc_group ( dev , addr ); return 0 ; } ip_mc_join_group\u51fd\u6570\u7684\u4e3b\u8981\u903b\u8f91\u662f\u628asocket\u60f3\u52a0\u5165\u7684\u591a\u64ad\u7ec4\u4fe1\u606f\u8bb0\u5f55\u5230socket\u7684ip_mc_list\u5b57\u6bb5\u4e2d\uff08\u5982\u679c\u8fd8\u6ca1\u6709\u52a0\u5165\u8fc7\u8be5\u591a\u64ad\u7ec4\u7684\u8bdd\uff09\u3002\u63a5\u7740\u8c03ip_mc_inc_group\u5f80\u4e0b\u8d70\u3002device\u7684ip_mc_list\u5b57\u6bb5\u7ef4\u62a4\u4e86\u4e3b\u673a\u4e2d\u4f7f\u7528\u4e86\u8be5device\u7684\u591a\u64ad\u7ec4\u4fe1\u606f\uff0c\u5982\u56fe16-4\u6240\u793a\u3002 \u56fe16-4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 static void ip_mc_inc_group ( struct device * dev , unsigned long addr ) { struct ip_mc_list * i ; /* \u904d\u5386\u8be5\u8bbe\u5907\u7ef4\u62a4\u7684\u591a\u64ad\u7ec4\u961f\u5217\uff0c \u5224\u65ad\u662f\u5426\u5df2\u7ecf\u6709socket\u52a0\u5165\u8fc7\u8be5\u591a\u64ad\u7ec4\uff0c\u662f\u5219\u5f15\u7528\u6570\u52a0\u4e00 */ for ( i = dev -> ip_mc_list ; i != NULL ; i = i -> next ) { if ( i -> multiaddr == addr ) { i -> users ++ ; return ; } } // \u5230\u8fd9\u8bf4\u660e\uff0c\u8fd8\u6ca1\u6709socket\u52a0\u5165\u8fc7\u5f53\u524d\u591a\u64ad\u7ec4\uff0c\u5219\u8bb0\u5f55\u5e76\u52a0\u5165 i = ( struct ip_mc_list * ) kmalloc ( sizeof ( * i ), GFP_KERNEL ); if ( ! i ) return ; i -> users = 1 ; i -> interface = dev ; i -> multiaddr = addr ; i -> next = dev -> ip_mc_list ; // \u901a\u8fc7igmp\u901a\u77e5\u5176\u5b83\u65b9 igmp_group_added ( i ); dev -> ip_mc_list = i ; } ip_mc_inc_group\u51fd\u6570\u7684\u4e3b\u8981\u903b\u8f91\u662f\u5224\u65adsocket\u60f3\u8981\u52a0\u5165\u7684\u591a\u64ad\u7ec4\u662f\u4e0d\u662f\u5df2\u7ecf\u5b58\u5728\u4e8e\u5f53\u524ddevice\u4e2d\uff0c\u5982\u679c\u4e0d\u662f\u5219\u65b0\u589e\u4e00\u4e2a\u8282\u70b9\u3002\u7ee7\u7eed\u8c03\u7528igmp_group_added 1 2 3 4 5 6 7 8 9 10 11 12 13 14 static void igmp_group_added ( struct ip_mc_list * im ) { // \u521d\u59cb\u5316\u5b9a\u65f6\u5668 igmp_init_timer ( im ); /* \u53d1\u9001\u4e00\u4e2aigmp\u6570\u636e\u5305\uff0c\u540c\u6b65\u591a\u64ad\u7ec4\u4fe1\u606f\uff08socket\u52a0\u5165 \u4e86\u4e00\u4e2a\u65b0\u7684\u591a\u64ad\u7ec4\uff09 */ igmp_send_report ( im -> interface , im -> multiaddr , IGMP_HOST_MEMBERSHIP_REPORT ); // \u8f6c\u6362\u591a\u64ad\u7ec4ip\u5230\u591a\u64admac\u5730\u5740\uff0c\u5e76\u8bb0\u5f55\u5230device\u4e2d ip_mc_filter_add ( im -> interface , im -> multiaddr ); } \u6211\u4eec\u770b\u770bigmp_send_report\u548cip_mc_filter_add\u7684\u5177\u4f53\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 static void igmp_send_report ( struct device * dev , unsigned long address , int type ) { // \u7533\u8bf7\u4e00\u4e2askb\u8868\u793a\u4e00\u4e2a\u6570\u636e\u5305 struct sk_buff * skb = alloc_skb ( MAX_IGMP_SIZE , GFP_ATOMIC ); int tmp ; struct igmphdr * igh ; /* \u6784\u5efaip\u5934\uff0cip\u534f\u8bae\u5934\u7684\u6e90ip\u662fINADDR_ANY\uff0c \u5373\u968f\u673a\u9009\u62e9\u4e00\u4e2a\u672c\u673a\u7684\uff0c\u76ee\u7684ip\u4e3a\u591a\u64ad\u7ec4ip\uff08address\uff09 */ tmp = ip_build_header ( skb , INADDR_ANY , address , & dev , IPPROTO_IGMP , NULL , skb -> mem_len , 0 , 1 ); /* data\u8868\u793a\u6240\u6709\u7684\u6570\u636e\u90e8\u5206\uff0ctmp\u8868\u793aip\u5934\u5927\u5c0f\uff0c\u6240\u4ee5igh \u5c31\u662fip\u534f\u8bae\u7684\u6570\u636e\u90e8\u5206\uff0c\u5373igmp\u62a5\u6587\u7684\u5185\u5bb9 */ igh = ( struct igmphdr * )( skb -> data + tmp ); skb -> len = tmp + sizeof ( * igh ); igh -> csum = 0 ; igh -> unused = 0 ; igh -> type = type ; igh -> group = address ; igh -> csum = ip_compute_csum (( void * ) igh , sizeof ( * igh )); // \u8c03\u7528ip\u5c42\u53d1\u9001\u51fa\u53bb ip_queue_xmit ( NULL , dev , skb , 1 ); } igmp_send_report\u5176\u5b9e\u5c31\u662f\u6784\u9020\u4e00\u4e2aIGMP\u534f\u8bae\u6570\u636e\u5305\uff0c\u7136\u540e\u53d1\u9001\u51fa\u53bb\uff0c\u544a\u8bc9\u8def\u7531\u5668\u67d0\u4e2a\u4e3b\u673a\u52a0\u5165\u4e86\u591a\u64ad\u7ec4\uff0cIGMP\u7684\u534f\u8bae\u683c\u5f0f\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 struct igmphdr { // \u7c7b\u578b unsigned char type ; unsigned char unused ; // \u6821\u9a8c\u548c unsigned short csum ; // igmp\u7684\u6570\u636e\u90e8\u5206\uff0c\u6bd4\u5982\u52a0\u5165\u591a\u64ad\u7ec4\u7684\u65f6\u5019\uff0cgroup\u8868\u793a\u591a\u64ad\u7ec4ip unsigned long group ; }; \u63a5\u7740\u6211\u4eec\u770bip_mc_filter_add 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void ip_mc_filter_add ( struct device * dev , unsigned long addr ) { char buf [ 6 ]; // \u628a\u591a\u64ad\u7ec4ip\u8f6c\u6210mac\u591a\u64ad\u5730\u5740 addr = ntohl ( addr ); buf [ 0 ] = 0x01 ; buf [ 1 ] = 0x00 ; buf [ 2 ] = 0x5e ; buf [ 5 ] = addr & 0xFF ; addr >>= 8 ; buf [ 4 ] = addr & 0xFF ; addr >>= 8 ; buf [ 3 ] = addr & 0x7F ; dev_mc_add ( dev , buf , ETH_ALEN , 0 ); } \u6211\u4eec\u77e5\u9053IP\u5730\u5740\u662f32\u4f4d\uff0cmac\u5730\u5740\u662f48\u4f4d\uff0c\u4f46\u662fIANA\u89c4\u5b9a\uff0cIP V4\u7ec4\u64adMAC\u5730\u5740\u7684\u9ad824\u4f4d\u662f0x01005E\uff0c\u7b2c25\u4f4d\u662f0\uff0c\u4f4e23\u4f4d\u662fipv4\u7ec4\u64ad\u5730\u5740\u7684\u4f4e23\u4f4d\u3002\u800c\u591a\u64ad\u7684IP\u5730\u5740\u9ad8\u56db\u4f4d\u56fa\u5b9a\u662f1110\u3002\u53e6\u5916\u4f4e23\u4f4d\u88ab\u6620\u5c04\u5230MAC\u591a\u64ad\u5730\u5740\u768423\u4f4d\uff0c\u6240\u4ee5\u591a\u64adIP\u5730\u5740\u4e2d\uff0c\u67095\u4f4d\u662f\u53ef\u4ee5\u968f\u673a\u7ec4\u5408\u7684\u3002\u8fd9\u5c31\u610f\u5473\u7740\uff0c\u6bcf32\u4e2a\u591a\u64adIP\u5730\u5740\uff0c\u6620\u5c04\u5230\u4e00\u4e2aMAC\u5730\u5740\u3002\u8fd9\u4f1a\u5e26\u6765\u4e00\u4e9b\u95ee\u9898\uff0c\u5047\u8bbe\u4e3b\u673ax\u52a0\u5165\u4e86\u591a\u64ad\u7ec4a\uff0c\u4e3b\u673ay\u52a0\u5165\u4e86\u591a\u64ad\u7ec4b\uff0c\u800ca\u548cb\u5bf9\u5e94\u7684mac\u591a\u64ad\u5730\u5740\u662f\u4e00\u6837\u7684\u3002\u5f53\u4e3b\u673az\u7ed9\u591a\u64ad\u7ec4a\u53d1\u9001\u4e00\u4e2a\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u8fd9\u65f6\u5019\u4e3b\u673ax\u548cy\u7684\u7f51\u5361\u90fd\u4f1a\u5904\u7406\u8be5\u6570\u636e\u5305\uff0c\u5e76\u4e0a\u62a5\u5230\u4e0a\u5c42\uff0c\u4f46\u662f\u591a\u64ad\u7ec4a\u5bf9\u5e94\u7684MAC\u591a\u64ad\u5730\u5740\u548c\u591a\u64ad\u7ec4b\u662f\u4e00\u6837\u7684\u3002\u6211\u4eec\u62ff\u5230\u4e00\u4e2a\u591a\u64ad\u7ec4ip\u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u8ba1\u7b97\u51fa\u5b83\u7684\u591a\u64adMAC\u5730\u5740\uff0c\u4f46\u662f\u53cd\u8fc7\u6765\u5c31\u4e0d\u884c\uff0c\u56e0\u4e3a\u4e00\u4e2a\u591a\u64admac\u5730\u5740\u5bf9\u5e94\u4e8632\u4e2a\u591a\u64adip\u5730\u5740\u3002\u90a3\u4e3b\u673ax\u548cy\u600e\u4e48\u5224\u65ad\u662f\u4e0d\u662f\u53d1\u7ed9\u81ea\u5df1\u7684\u6570\u636e\u5305\uff1f\u56e0\u4e3adevice\u7ef4\u62a4\u4e86\u4e00\u4e2a\u672cdevice\u4e0a\u7684\u591a\u64adIP\u5217\u8868\uff0c\u64cd\u4f5c\u7cfb\u7edf\u6839\u636e\u6536\u5230\u7684\u6570\u636e\u5305\u4e2d\u7684IP\u76ee\u7684\u5730\u5740\u548cdevice\u7684\u591a\u64adIP\u5217\u8868\u5bf9\u6bd4\u3002\u5982\u679c\u5728\u5217\u8868\u4e2d\uff0c\u5219\u8bf4\u660e\u662f\u53d1\u7ed9\u81ea\u5df1\u7684\u3002\u6700\u540e\u6211\u4eec\u770b\u770bdev_mc_add\u3002device\u4e2d\u7ef4\u62a4\u4e86\u5f53\u524d\u7684mac\u591a\u64ad\u5730\u5740\u5217\u8868\uff0c\u5b83\u4f1a\u628a\u8fd9\u4e2a\u5217\u8868\u4fe1\u606f\u540c\u6b65\u5230\u7f51\u5361\u4e2d\uff0c\u4f7f\u5f97\u7f51\u5361\u53ef\u4ee5\u5904\u7406\u8be5\u5217\u8868\u4e2d\u591a\u64admac\u5730\u5740\u7684\u6570\u636e\u5305\uff0c\u5982\u56fe16-5\u6240\u793a\u3002 \u56fe16-5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void dev_mc_add ( struct device * dev , void * addr , int alen , int newonly ) { struct dev_mc_list * dmi ; // device\u7ef4\u62a4\u7684\u591a\u64admac\u5730\u5740\u5217\u8868 for ( dmi = dev -> mc_list ; dmi != NULL ; dmi = dmi -> next ) { // \u5df2\u5b58\u5728\uff0c\u5219\u5f15\u7528\u8ba1\u6570\u52a0\u4e00 if ( memcmp ( dmi -> dmi_addr , addr , dmi -> dmi_addrlen ) == 0 && dmi -> dmi_addrlen == alen ) { if ( ! newonly ) dmi -> dmi_users ++ ; return ; } } // \u4e0d\u5b58\u5728\u5219\u65b0\u589e\u4e00\u4e2a\u9879\u5230device\u5217\u8868\u4e2d dmi = ( struct dev_mc_list * ) kmalloc ( sizeof ( * dmi ), GFP_KERNEL ); memcpy ( dmi -> dmi_addr , addr , alen ); dmi -> dmi_addrlen = alen ; dmi -> next = dev -> mc_list ; dmi -> dmi_users = 1 ; dev -> mc_list = dmi ; dev -> mc_count ++ ; // \u901a\u77e5\u7f51\u5361\u9700\u8981\u5904\u7406\u8be5\u591a\u64admac\u5730\u5740 dev_mc_upload ( dev ); } \u7f51\u5361\u7684\u5de5\u4f5c\u6a21\u5f0f\u6709\u51e0\u79cd\uff0c\u5206\u522b\u662f\u6b63\u5e38\u6a21\u5f0f\uff08\u53ea\u63a5\u6536\u53d1\u7ed9\u81ea\u5df1\u7684\u6570\u636e\u5305\uff09\u3001\u6df7\u6742\u6a21\u5f0f\uff08\u63a5\u6536\u6240\u6709\u6570\u636e\u5305\uff09\u3001\u591a\u64ad\u6a21\u5f0f\uff08\u63a5\u6536\u4e00\u822c\u6570\u636e\u5305\u548c\u591a\u64ad\u6570\u636e\u5305\uff09\u3002\u7f51\u5361\u9ed8\u8ba4\u662f\u53ea\u5904\u7406\u53d1\u7ed9\u81ea\u5df1\u7684\u6570\u636e\u5305\uff0c\u6240\u4ee5\u5f53\u6211\u4eec\u52a0\u5165\u4e00\u4e2a\u591a\u64ad\u7ec4\u7684\u65f6\u5019\uff0c\u6211\u4eec\u9700\u8981\u544a\u8bc9\u7f51\u5361\uff0c\u5f53\u6536\u5230\u8be5\u591a\u64ad\u7ec4\u7684\u6570\u636e\u5305\u65f6\uff0c\u9700\u8981\u5904\u7406\uff0c\u800c\u4e0d\u662f\u5ffd\u7565\u3002dev_mc_upload\u51fd\u6570\u5c31\u662f\u901a\u77e5\u7f51\u5361\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 void dev_mc_upload ( struct device * dev ) { struct dev_mc_list * dmi ; char * data , * tmp ; // \u4e0d\u5de5\u4f5c\u4e86 if ( ! ( dev -> flags & IFF_UP )) return ; /* \u5f53\u524d\u662f\u6df7\u6742\u6a21\u5f0f\uff0c\u5219\u4e0d\u9700\u8981\u8bbe\u7f6e\u591a\u64ad\u4e86\uff0c\u56e0\u4e3a\u7f51\u5361\u4f1a\u5904\u7406\u6240\u6709 \u6536\u5230\u7684\u6570\u636e\uff0c\u4e0d\u7ba1\u662f\u4e0d\u662f\u53d1\u7ed9\u81ea\u5df1\u7684 */ if ( dev -> flags & IFF_PROMISC ) { dev -> set_multicast_list ( dev , -1 , NULL ); return ; } /* \u591a\u64ad\u5730\u5740\u4e2a\u6570\uff0c\u4e3a0\uff0c\u5219\u8bbe\u7f6e\u7f51\u5361\u5de5\u4f5c\u6a21\u5f0f\u4e3a\u6b63\u5e38\u6a21\u5f0f\uff0c \u56e0\u4e3a\u4e0d\u9700\u8981\u5904\u7406\u591a\u64ad\u4e86 */ if ( dev -> mc_count == 0 ) { dev -> set_multicast_list ( dev , 0 , NULL ); return ; } data = kmalloc ( dev -> mc_count * dev -> addr_len , GFP_KERNEL ); // \u590d\u5236\u6240\u6709\u7684\u591a\u64admac\u5730\u5740\u4fe1\u606f for ( tmp = data , dmi = dev -> mc_list ; dmi != NULL ; dmi = dmi -> next ) { memcpy ( tmp , dmi -> dmi_addr , dmi -> dmi_addrlen ); tmp += dev -> addr_len ; } // \u544a\u8bc9\u7f51\u5361 dev -> set_multicast_list ( dev , dev -> mc_count , data ); kfree ( data ); } \u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0bset_multicast_list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 static void set_multicast_list ( struct device * dev , int num_addrs , void * addrs ) { int ioaddr = dev -> base_addr ; // \u591a\u64ad\u6a21\u5f0f if ( num_addrs > 0 ) { outb ( RX_MULT , RX_CMD ); inb ( RX_STATUS ); /* Clear status. */ } else if ( num_addrs < 0 ) { // \u6df7\u6742\u6a21\u5f0f outb ( RX_PROM , RX_CMD ); inb ( RX_STATUS ); } else { // \u6b63\u5e38\u6a21\u5f0f outb ( RX_NORM , RX_CMD ); inb ( RX_STATUS ); } } set_multicast_list\u5c31\u662f\u8bbe\u7f6e\u7f51\u5361\u5de5\u4f5c\u6a21\u5f0f\u7684\u51fd\u6570\u3002\u81f3\u6b64\uff0c\u6211\u4eec\u5c31\u6210\u529f\u52a0\u5165\u4e86\u4e00\u4e2a\u591a\u64ad\u7ec4\u3002\u79bb\u5f00\u4e00\u4e2a\u591a\u64ad\u7ec4\u4e5f\u662f\u7c7b\u4f3c\u7684\u8fc7\u7a0b\u3002","title":"16.2.5.1 \u52a0\u5165\u4e00\u4e2a\u591a\u64ad\u7ec4"},{"location":"chapter16-UDP/#16252","text":"\u52a0\u5165\u591a\u64ad\u7ec4\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u4e3b\u52a8\u9000\u51fa\u591a\u64ad\u7ec4\uff0c\u4f46\u662f\u5982\u679c\u4e3b\u673a\u6302\u4e86\uff0c\u5c31\u65e0\u6cd5\u4e3b\u52a8\u9000\u51fa\u4e86\uff0c\u6240\u4ee5\u591a\u64ad\u8def\u7531\u4e5f\u4f1a\u5b9a\u671f\u5411\u6240\u6709\u591a\u64ad\u7ec4\u7684\u6240\u6709\u4e3b\u673a\u53d1\u9001\u63a2\u6d4b\u62a5\u6587\uff0c\u6240\u4ee5\u4e3b\u673a\u9700\u8981\u76d1\u542c\u6765\u81ea\u591a\u64ad\u8def\u7531\u7684\u63a2\u6d4b\u62a5\u6587\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void ip_mc_allhost ( struct device * dev ) { struct ip_mc_list * i ; for ( i = dev -> ip_mc_list ; i != NULL ; i = i -> next ) if ( i -> multiaddr == IGMP_ALL_HOSTS ) return ; i = ( struct ip_mc_list * ) kmalloc ( sizeof ( * i ), GFP_KERNEL ); if ( ! i ) return ; I -> users = 1 ; i -> interface = dev ; i -> multiaddr = IGMP_ALL_HOSTS ; i -> next = dev -> ip_mc_list ; dev -> ip_mc_list = i ; ip_mc_filter_add ( i -> interface , i -> multiaddr ); } \u8bbe\u5907\u542f\u52a8\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u8bbe\u7f6e\u7f51\u5361\u76d1\u542c\u76ee\u7684IP\u662f224.0.0.1\u7684\u62a5\u6587\uff0c\u4f7f\u5f97\u53ef\u4ee5\u5904\u7406\u76ee\u7684IP\u662f224.0.0.1\u7684\u591a\u64ad\u6d88\u606f\u3002\u8be5\u7c7b\u578b\u7684\u62a5\u6587\u662f\u591a\u64ad\u8def\u7531\u7528\u4e8e\u67e5\u8be2\u5c40\u57df\u7f51\u5f53\u524d\u591a\u64ad\u7ec4\u60c5\u51b5\u7684\uff0c\u6bd4\u5982\u67e5\u8be2\u54ea\u4e9b\u591a\u64ad\u7ec4\u5df2\u7ecf\u6ca1\u6709\u6210\u5458\u4e86\uff0c\u5982\u679c\u6ca1\u6709\u6210\u5458\u5219\u5220\u9664\u8def\u7531\u4fe1\u606f\u3002\u6211\u4eec\u770b\u770b\u5982\u4f55\u5904\u7406\u67d0\u8bbe\u5907\u7684IGMP\u62a5\u6587\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int igmp_rcv ( struct sk_buff * skb , struct device * dev , struct options * opt , unsigned long daddr , unsigned short len , unsigned long saddr , int redo , struct inet_protocol * protocol ) { // IGMP\u62a5\u5934 struct igmphdr * igh = ( struct igmphdr * ) skb -> h . raw ; // \u8be5\u6570\u636e\u5305\u662f\u53d1\u7ed9\u6240\u6709\u591a\u64ad\u4e3b\u673a\u7684\uff0c\u7528\u4e8e\u67e5\u8be2\u672c\u591a\u64ad\u7ec4\u4e2d\u662f\u5426\u8fd8\u6709\u6210\u5458 if ( igh -> type == IGMP_HOST_MEMBERSHIP_QUERY && daddr == IGMP_ALL_HOSTS ) igmp_heard_query ( dev ); // \u8be5\u6570\u636e\u5305\u662f\u5176\u5b83\u6210\u5458\u5bf9\u591a\u64ad\u8def\u7531\u67e5\u8be2\u62a5\u6587\u7684\u56de\u590d\uff0c\u540c\u591a\u64ad\u7ec4\u7684\u4e3b\u673a\u4e5f\u4f1a\u6536\u5230 if ( igh -> type == IGMP_HOST_MEMBERSHIP_REPORT && daddr == igh -> group ) igmp_heard_report ( dev , igh -> group ); kfree_skb ( skb , FREE_READ ); return 0 ; } IGMP V1\u53ea\u5904\u7406\u4e24\u79cd\u62a5\u6587\uff0c\u5206\u522b\u662f\u7ec4\u6210\u5458\u67e5\u8be2\u62a5\u6587\uff08\u67e5\u8be2\u7ec4\u662f\u5426\u6709\u6210\u5458\uff09\uff0c\u5176\u5b83\u6210\u5458\u56de\u590d\u591a\u64ad\u8def\u7531\u7684\u62a5\u544a\u62a5\u6587\u3002\u7ec4\u6210\u5458\u67e5\u8be2\u62a5\u6587\u7531\u591a\u64ad\u8def\u7531\u53d1\u51fa\uff0c\u6240\u6709\u7684\u591a\u64ad\u7ec4\u4e2d\u7684\u6240\u6709\u4e3b\u673a\u90fd\u53ef\u4ee5\u6536\u5230\u3002\u7ec4\u6210\u5458\u67e5\u8be2\u62a5\u6587\u7684IP\u534f\u8bae\u5934\u7684\u76ee\u7684\u5730\u5740\u662f224.0.0.1\uff08IGMP_ALL_HOSTS\uff09\uff0c\u4ee3\u8868\u6240\u6709\u7684\u7ec4\u64ad\u4e3b\u673a\u90fd\u53ef\u4ee5\u5904\u7406\u8be5\u62a5\u6587\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e24\u79cd\u62a5\u6587\u7684\u5177\u4f53\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 static void igmp_heard_query ( struct device * dev ) { struct ip_mc_list * im ; for ( im = dev -> ip_mc_list ; im != NULL ; im = im -> next ) // IGMP_ALL_HOSTS\u8868\u793a\u6240\u6709\u7ec4\u64ad\u4e3b\u673a if ( ! im -> tm_running && im -> multiaddr != IGMP_ALL_HOSTS ) igmp_start_timer ( im ); } \u8be5\u51fd\u6570\u7528\u4e8e\u5904\u7406\u7ec4\u64ad\u8def\u7531\u7684\u67e5\u8be2\u62a5\u6587\uff0cdev->ip_mc_list\u662f\u8be5\u8bbe\u5907\u5bf9\u5e94\u7684\u6240\u6709\u591a\u64ad\u7ec4\u4fe1\u606f\uff0c\u8fd9\u91cc\u9488\u5bf9\u8be5\u8bbe\u5907\u4e2d\u7684\u6bcf\u4e00\u4e2a\u591a\u64ad\u7ec4\uff0c\u5f00\u542f\u5bf9\u5e94\u7684\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u540e\u4f1a\u53d1\u9001\u56de\u590d\u62a5\u6587\u7ed9\u591a\u64ad\u8def\u7531\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5f00\u542f\u5b9a\u65f6\u5668\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 // \u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668 static void igmp_start_timer ( struct ip_mc_list * im ) { int tv ; if ( im -> tm_running ) return ; tv = random () % ( 10 * HZ ); /* Pick a number any number 8) */ im -> timer . expires = tv ; im -> tm_running = 1 ; add_timer ( & im -> timer ); } \u968f\u673a\u9009\u62e9\u4e00\u4e2a\u8d85\u65f6\u65f6\u95f4\uff0c\u7136\u540e\u63d2\u5165\u7cfb\u7edf\u7ef4\u62a4\u7684\u5b9a\u65f6\u5668\u961f\u5217\u3002\u4e3a\u4ec0\u4e48\u4f7f\u7528\u5b9a\u65f6\u5668\uff0c\u800c\u4e0d\u662f\u7acb\u5373\u56de\u590d\u5462\uff1f\u56e0\u4e3a\u591a\u64ad\u8def\u7531\u53ea\u9700\u8981\u77e5\u9053\u67d0\u4e2a\u591a\u64ad\u7ec4\u662f\u5426\u81f3\u5c11\u8fd8\u6709\u4e00\u4e2a\u6210\u5458\uff0c\u5982\u679c\u6709\u7684\u8bdd\u5c31\u4fdd\u5b58\u8be5\u591a\u64ad\u7ec4\u4fe1\u606f\uff0c\u5426\u5219\u5c31\u5220\u9664\u8def\u7531\u9879\u3002\u5982\u679c\u67d0\u591a\u64ad\u7ec4\u5728\u5c40\u57df\u7f51\u4e2d\u6709\u591a\u4e2a\u6210\u5458\uff0c\u90a3\u4e48\u591a\u4e2a\u6210\u5458\u90fd\u4f1a\u5904\u7406\u8be5\u62a5\u6587\uff0c\u5982\u679c\u90fd\u7acb\u5373\u54cd\u5e94\uff0c\u5219\u4f1a\u5f15\u8d77\u8fc7\u591a\u6ca1\u6709\u5fc5\u8981\u7684\u6d41\u91cf\uff0c\u56e0\u4e3a\u7ec4\u64ad\u8def\u7531\u53ea\u9700\u8981\u6536\u5230\u4e00\u4e2a\u54cd\u5e94\u5c31\u884c\u3002\u6211\u4eec\u770b\u770b\u8d85\u65f6\u65f6\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 static void igmp_init_timer ( struct ip_mc_list * im ) { im -> tm_running = 0 ; init_timer ( & im -> timer ); im -> timer . data = ( unsigned long ) im ; im -> timer . function =& igmp_timer_expire ; } static void igmp_timer_expire ( unsigned long data ) { struct ip_mc_list * im = ( struct ip_mc_list * ) data ; igmp_stop_timer ( im ); igmp_send_report ( im -> interface , im -> multiaddr , IGMP_HOST_MEMBERSHIP_REPORT ); } \u6211\u4eec\u770b\u5230\uff0c\u8d85\u65f6\u540e\u4f1a\u6267\u884cigmp_send_report\u53d1\u9001\u4e00\u4e2a\u7c7b\u578b\u662fIGMP_HOST_MEMBERSHIP_REPORT\u7684IGMP\u3001\u76ee\u7684IP\u662f\u591a\u64ad\u7ec4IP\u7684\u62a5\u6587\uff0c\u8bf4\u660e\u8be5\u591a\u64ad\u7ec4\u8fd8\u6709\u6210\u5458\u3002\u8be5\u62a5\u6587\u4e0d\u4ec5\u4f1a\u53d1\u9001\u7ed9\u591a\u64ad\u8def\u7531\uff0c\u8fd8\u4f1a\u53d1\u7ed9\u540c\u591a\u64ad\u7ec4\u7684\u6240\u6709\u4e3b\u673a\u3002\u5176\u5b83\u4e3b\u673a\u4e5f\u662f\u7c7b\u4f3c\u7684\u903b\u8f91\uff0c\u5373\u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\u3002\u6240\u4ee5\u6700\u5feb\u5230\u671f\u7684\u4e3b\u673a\u4f1a\u5148\u53d1\u9001\u56de\u590d\u62a5\u6587\u7ed9\u591a\u64ad\u8def\u7531\u548c\u540c\u591a\u64ad\u7ec4\u7684\u6210\u5458\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5176\u5b83\u540c\u591a\u64ad\u7ec4\u7684\u4e3b\u673a\u6536\u5230\u8be5\u7c7b\u62a5\u6587\u65f6\u7684\u5904\u7406\u903b\u8f91\u3002 1 2 3 // \u6210\u5458\u62a5\u544a\u62a5\u6587\u5e76\u4e14\u591a\u64ad\u7ec4\u662f\u5f53\u524d\u8bbe\u7f6e\u5173\u8054\u7684\u591a\u64ad\u7ec4 if ( igh -> type == IGMP_HOST_MEMBERSHIP_REPORT && daddr == igh -> group ) igmp_heard_report ( dev , igh -> group ); \u5f53\u4e00\u4e2a\u591a\u64ad\u7ec4\u7684\u5176\u5b83\u6210\u5458\u9488\u5bf9\u591a\u64ad\u8def\u7531\u7684\u67e5\u8be2\u62a5\u6587\u4f5c\u4e86\u54cd\u5e94\uff0c\u56e0\u4e3a\u8be5\u54cd\u5e94\u62a5\u6587\u7684\u76ee\u7684IP\u662f\u591a\u64ad\u7ec4IP\uff0c\u6240\u4ee5\u8be5\u591a\u64ad\u7ec4\u7684\u5176\u5b83\u6210\u5458\u4e5f\u80fd\u6536\u5230\u8be5\u62a5\u6587\u3002\u5f53\u67d0\u4e2a\u4e3b\u673a\u6536\u5230\u8be5\u7c7b\u578b\u7684\u62a5\u6587\u7684\u65f6\u5019\uff0c\u5c31\u77e5\u9053\u540c\u591a\u64ad\u7ec4\u7684\u5176\u5b83\u6210\u5458\u5df2\u7ecf\u56de\u590d\u4e86\u591a\u64ad\u8def\u7531\u4e86\uff0c\u6211\u4eec\u5c31\u4e0d\u9700\u8981\u56de\u590d\u4e86\u3002 1 2 3 4 5 6 7 8 9 10 11 /* \u6536\u5230\u5176\u5b83\u7ec4\u6210\u5458\uff0c\u5bf9\u4e8e\u591a\u64ad\u8def\u7531\u67e5\u8be2\u62a5\u6587\u7684\u56de\u590d\uff0c\u5219\u81ea\u5df1\u5c31\u4e0d\u7528\u56de\u590d\u4e86\uff0c \u56e0\u4e3a\u591a\u64ad\u8def\u7531\u77e5\u9053\u8be5\u7ec4\u8fd8\u6709\u6210\u5458\uff0c\u4e0d\u4f1a\u5220\u9664\u8def\u7531\u4fe1\u606f\uff0c\u51cf\u5c11\u7f51\u7edc\u6d41\u91cf */ static void igmp_heard_report ( struct device * dev , unsigned long address ) { struct ip_mc_list * im ; for ( im = dev -> ip_mc_list ; im != NULL ; im = im -> next ) if ( im -> multiaddr == address ) igmp_stop_timer ( im ); } \u6211\u4eec\u770b\u5230\uff0c\u8fd9\u91cc\u4f1a\u5220\u9664\u5b9a\u65f6\u5668\u3002\u5373\u4e0d\u4f1a\u4f5c\u4e3a\u54cd\u5e94\u4e86\u3002 2.3 \u5176\u5b83 socket\u5173\u95ed\uff0c \u9000\u51fa\u5b83\u4e4b\u524d\u52a0\u5165\u8fc7\u7684\u591a\u64ad 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void ip_mc_drop_socket ( struct sock * sk ) { int i ; if ( sk -> ip_mc_list == NULL ) return ; for ( i = 0 ; i < IP_MAX_MEMBERSHIPS ; i ++ ) { if ( sk -> ip_mc_list -> multidev [ i ]) { ip_mc_dec_group ( sk -> ip_mc_list -> multidev [ i ], sk -> ip_mc_list -> multiaddr [ i ]); sk -> ip_mc_list -> multidev [ i ] = NULL ; } } kfree_s ( sk -> ip_mc_list , sizeof ( * sk -> ip_mc_list )); sk -> ip_mc_list = NULL ; } \u8bbe\u5907\u505c\u6b62\u5de5\u4f5c\u4e86\uff0c\u5220\u9664\u5bf9\u5e94\u7684\u591a\u64ad\u4fe1\u606f 1 2 3 4 5 6 7 8 9 10 11 void ip_mc_drop_device ( struct device * dev ) { struct ip_mc_list * i ; struct ip_mc_list * j ; for ( i = dev -> ip_mc_list ; i != NULL ; i = j ) { j = i -> next ; kfree_s ( i , sizeof ( * i )); } dev -> ip_mc_list = NULL ; } \u4ee5\u4e0a\u662fIGMP V1\u7248\u672c\u7684\u5b9e\u73b0\uff0c\u5728\u540e\u7eedV2 V3\u7248\u672c\u4e86\u53c8\u589e\u52a0\u4e86\u5f88\u591a\u529f\u80fd\uff0c\u6bd4\u5982\u79bb\u5f00\u7ec4\u62a5\u6587\uff0c\u9488\u5bf9\u79bb\u5f00\u62a5\u6587\u4e2d\u7684\u591a\u64ad\u7ec4\uff0c\u589e\u52a0\u7279\u5b9a\u7ec4\u67e5\u8be2\u62a5\u6587\uff0c\u7528\u4e8e\u67e5\u8be2\u67d0\u4e2a\u7ec4\u4e2d\u662f\u5426\u8fd8\u6709\u6210\u5458\uff0c\u53e6\u5916\u8fd8\u6709\u8def\u7531\u9009\u4e3e\uff0c\u5f53\u5c40\u57df\u7f51\u4e2d\u6709\u591a\u4e2a\u591a\u64ad\u8def\u7531\uff0c\u591a\u64ad\u8def\u7531\u4e4b\u95f4\u901a\u8fc7\u534f\u8bae\u9009\u4e3e\u51faIP\u6700\u5c0f\u7684\u8def\u7531\u4e3a\u67e5\u8be2\u8def\u7531\uff0c\u5b9a\u65f6\u7ed9\u591a\u64ad\u7ec4\u53d1\u9001\u63a2\u6d4b\u62a5\u6587\u3002\u7136\u540e\u6210\u4e3a\u67e5\u8be2\u5668\u7684\u591a\u64ad\u8def\u7531\uff0c\u4f1a\u5b9a\u671f\u7ed9\u5176\u5b83\u591a\u64ad\u8def\u7531\u540c\u6b65\u5fc3\u8df3\u3002\u5426\u5219\u5176\u5b83\u591a\u64ad\u8def\u7531\u4f1a\u5728\u5b9a\u65f6\u5668\u8d85\u65f6\u65f6\u8ba4\u4e3a\u5f53\u524d\u67e5\u8be2\u8def\u7531\u5df2\u7ecf\u6302\u4e86\uff0c\u91cd\u65b0\u9009\u4e3e\u3002","title":"16.2.5.2 \u7ef4\u62a4\u591a\u64ad\u7ec4\u4fe1\u606f"},{"location":"chapter16-UDP/#16253","text":"UDP\u7684\u591a\u64ad\u80fd\u529b\u662f\u9700\u8981\u7528\u6237\u4e3b\u52a8\u5f00\u542f\u7684\uff0c\u539f\u56e0\u662f\u9632\u6b62\u7528\u6237\u53d1\u9001UDP\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u8bef\u4f20\u4e86\u4e00\u4e2a\u591a\u64ad\u5730\u5740\uff0c\u4f46\u5176\u5b9e\u7528\u6237\u662f\u60f3\u53d1\u9001\u4e00\u4e2a\u5355\u64ad\u7684\u6570\u636e\u5305\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7setBroadcast\u5f00\u542f\u591a\u64ad\u80fd\u529b\u3002\u6211\u4eec\u770bLibuv\u7684\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 int uv_udp_set_broadcast ( uv_udp_t * handle , int on ) { if ( setsockopt ( handle -> io_watcher . fd , SOL_SOCKET , SO_BROADCAST , & on , sizeof ( on ))) { return UV__ERR ( errno ); } return 0 ; } \u518d\u770b\u770b\u64cd\u4f5c\u7cfb\u7edf\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 int sock_setsockopt ( struct sock * sk , int level , int optname , char * optval , int optlen ){ ... case SO_BROADCAST : sk -> broadcast = val ? 1 : 0 ; } \u6211\u4eec\u770b\u5230\u5b9e\u73b0\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u8bbe\u7f6e\u4e00\u4e2a\u6807\u8bb0\u4f4d\u3002\u5f53\u6211\u4eec\u53d1\u9001\u6d88\u606f\u7684\u65f6\u5019\uff0c\u5982\u679c\u76ee\u7684\u5730\u5740\u662f\u591a\u64ad\u5730\u5740\uff0c\u4f46\u662f\u53c8\u6ca1\u6709\u8bbe\u7f6e\u8fd9\u4e2a\u6807\u8bb0\uff0c\u5219\u4f1a\u62a5\u9519\u3002 1 2 if ( ! sk -> broadcast && ip_chk_addr ( sin . sin_addr . s_addr ) == IS_BROADCAST ) return - EACCES ; \u4e0a\u9762\u4ee3\u7801\u6765\u81ea\u8c03\u7528udp\u7684\u53d1\u9001\u51fd\u6570\uff08\u4f8b\u5982sendto\uff09\u65f6\uff0c\u8fdb\u884c\u7684\u6821\u9a8c\uff0c\u5982\u679c\u53d1\u9001\u7684\u76ee\u7684ip\u662f\u591a\u64ad\u5730\u5740\uff0c\u4f46\u662f\u6ca1\u6709\u8bbe\u7f6e\u591a\u64ad\u6807\u8bb0\uff0c\u5219\u62a5\u9519\u3002","title":"16.2.5.3 \u5f00\u542f\u591a\u64ad"},{"location":"chapter16-UDP/#16254","text":"\u670d\u52a1\u5668 1 2 3 4 5 6 7 8 9 10 11 const dgram = require ( 'dgram' ); const udp = dgram . createSocket ( 'udp4' ); udp . bind ( 1234 , () => { // \u5c40\u57df\u7f51\u591a\u64ad\u5730\u5740\uff08224.0.0.0~224.0.0.255\uff0c\u8be5\u8303\u56f4\u7684\u591a\u64ad\u6570\u636e\u5305\uff0c\u8def\u7531\u5668\u4e0d\u4f1a\u8f6c\u53d1\uff09 udp . addMembership ( '224.0.0.114' ); }); udp . on ( 'message' , ( msg , rinfo ) => { console . log ( `receive msg: ${ msg } from ${ rinfo . address } : ${ rinfo . port } ` ); }); \u670d\u52a1\u5668\u7ed1\u5b9a1234\u7aef\u53e3\u540e\uff0c\u52a0\u5165\u591a\u64ad\u7ec4224.0.0.114\uff0c\u7136\u540e\u7b49\u5f85\u591a\u64ad\u6570\u636e\u7684\u5230\u6765\u3002 \u5ba2\u6237\u7aef 1 2 3 4 5 6 const dgram = require ( 'dgram' ); const udp = dgram . createSocket ( 'udp4' ); udp . bind ( 1234 , () => { udp . addMembership ( '224.0.0.114' ); }); udp . send ( 'test' , 1234 , '224.0.0.114' , ( err ) => {}); \u5ba2\u6237\u7aef\u7ed1\u5b9a1234\u7aef\u53e3\u540e\uff0c\u4e5f\u52a0\u5165\u4e86\u591a\u64ad\u7ec4224.0.0.114\uff0c\u7136\u540e\u53d1\u9001\u6570\u636e\uff0c\u4f46\u662f\u53d1\u73b0\u670d\u52a1\u7aef\u6ca1\u6709\u6536\u5230\u6570\u636e\uff0c\u5ba2\u6237\u7aef\u6253\u5370\u4e86receive msg test from 169.254.167.41:1234\u3002\u8fd9\u600e\u4e48\u591a\u4e86\u4e00\u4e2aIP\u51fa\u6765\uff1f\u539f\u6765\u6211\u4e3b\u673a\u6709\u4e24\u4e2a\u5c40\u57df\u7f51\u5730\u5740\u3002\u5f53\u6211\u4eec\u52a0\u5165\u591a\u64ad\u7ec4\u7684\u65f6\u5019\uff0c\u4e0d\u4ec5\u53ef\u4ee5\u8bbe\u7f6e\u52a0\u5165\u54ea\u4e2a\u591a\u64ad\u7ec4\uff0c\u8fd8\u80fd\u8bbe\u7f6e\u51fa\u53e3\u7684\u8bbe\u5907\u548cIP\u3002\u5f53\u6211\u4eec\u8c03\u7528udp.addMembership('224.0.0.114')\u7684\u65f6\u5019\uff0c\u6211\u4eec\u53ea\u662f\u8bbe\u7f6e\u4e86\u6211\u4eec\u52a0\u5165\u7684\u591a\u64ad\u7ec4\uff0c\u6ca1\u6709\u8bbe\u7f6e\u51fa\u53e3\u3002\u8fd9\u65f6\u5019\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u4e3a\u6211\u4eec\u9009\u62e9\u4e00\u4e2a\u3002\u6839\u636e\u8f93\u51fa\uff0c\u6211\u4eec\u53d1\u73b0\u64cd\u4f5c\u7cfb\u7edf\u9009\u62e9\u7684\u662f169.254.167.41\uff08\u5b50\u7f51\u63a9\u7801\u662f255.255.0.0\uff09\u3002\u56e0\u4e3a\u8fd9\u4e2aIP\u548c192\u5f00\u5934\u7684\u90a3\u4e2a\u4e0d\u662f\u540c\u4e00\u5b50\u7f51\uff0c\u4f46\u662f\u6211\u4eec\u52a0\u5165\u7684\u662f\u5c40\u57df\u7f51\u7684\u591a\u64adIP\uff0c\u6240\u6709\u670d\u52a1\u7aef\u65e0\u6cd5\u6536\u5230\u5ba2\u6237\u7aef\u53d1\u51fa\u7684\u6570\u636e\u5305\u3002\u4e0b\u9762\u662fNode.js\u6587\u6863\u7684\u89e3\u91ca\u3002 Tells the kernel to join a multicast group at the given multicastAddress and multicastInterface using the IP_ADD_MEMBERSHIP socket option. If the multicastInterface argument is not specified, the operating system will choose one interface and will add membership to it. To add membership to every available interface, call addMembership multiple times, once per interface. \u6211\u4eec\u770b\u4e00\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u7684\u76f8\u5173\u903b\u8f91\u3002 1 2 if ( MULTICAST ( daddr ) && * dev == NULL && skb -> sk && * skb -> sk -> ip_mc_name ) * dev = dev_get ( skb -> sk -> ip_mc_name ); \u4e0a\u9762\u7684\u4ee3\u7801\u6765\u81ea\u64cd\u4f5c\u7cfb\u7edf\u53d1\u9001IP\u6570\u636e\u5305\u65f6\u7684\u903b\u8f91\uff0c\u5982\u679c\u76ee\u7684IP\u4f3c\u4e4e\u591a\u64ad\u5730\u5740\u5e76\u4e14ip_mc_name\u975e\u7a7a\uff08\u5373\u6211\u4eec\u901a\u8fc7addMembership\u7b2c\u4e8c\u4e2a\u53c2\u6570\u8bbe\u7f6e\u7684\u503c\uff09\uff0c\u5219\u51fa\u53e3\u8bbe\u5907\u5c31\u662f\u6211\u4eec\u8bbe\u7f6e\u7684\u503c\u3002\u5426\u5219\u64cd\u4f5c\u7cfb\u7edf\u81ea\u5df1\u9009\u3002\u6240\u4ee5\u6211\u4eec\u9700\u8981\u663e\u793a\u6307\u5b9a\u8fd9\u4e2a\u51fa\u53e3\uff0c\u628a\u4ee3\u7801\u6539\u6210udp.addMembership('224.0.0.114', '192.168.8.164');\u91cd\u65b0\u6267\u884c\u53d1\u73b0\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u90fd\u663e\u793a\u4e86receive msg test from 192.168.8.164:1234\u3002\u4e3a\u4ec0\u4e48\u5ba2\u6237\u7aef\u81ea\u5df1\u4e5f\u4f1a\u6536\u5230\u5462\uff1f\u539f\u6765\u64cd\u4f5c\u7cfb\u7edf\u53d1\u9001\u591a\u64ad\u6570\u636e\u7684\u65f6\u5019\uff0c\u4e5f\u4f1a\u7ed9\u81ea\u5df1\u53d1\u9001\u4e00\u4efd\u3002\u6211\u4eec\u770b\u770b\u76f8\u5173\u903b\u8f91 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // \u76ee\u7684\u5730\u662f\u591a\u64ad\u5730\u5740\uff0c\u5e76\u4e14\u4e0d\u662f\u56de\u73af\u8bbe\u5907 if ( MULTICAST ( iph -> daddr ) && ! ( dev -> flags & IFF_LOOPBACK )) { // \u662f\u5426\u9700\u8981\u7ed9\u81ea\u5df1\u4e00\u4efd\uff0c\u9ed8\u8ba4\u4e3atrue if ( sk == NULL || sk -> ip_mc_loop ) { // \u7ed9\u6240\u6709\u591a\u64ad\u7ec4\u7684\u6240\u6709\u4e3b\u673a\u7684\u6570\u636e\u5305\uff0c\u5219\u76f4\u63a5\u7ed9\u81ea\u5df1\u4e00\u4efd if ( iph -> daddr == IGMP_ALL_HOSTS ) ip_loopback ( dev , skb ); else { // \u5224\u65ad\u76ee\u7684ip\u662f\u5426\u5728\u5f53\u524d\u8bbe\u5907\u7684\u591a\u64adip\u5217\u8868\u4e2d\uff0c\u662f\u7684\u56de\u4f20\u4e00\u4efd struct ip_mc_list * imc = dev -> ip_mc_list ; while ( imc != NULL ) { if ( imc -> multiaddr == iph -> daddr ) { ip_loopback ( dev , skb ); break ; } imc = imc -> next ; } } } } \u4ee5\u4e0a\u4ee3\u7801\u6765\u81eaIP\u5c42\u53d1\u9001\u6570\u636e\u5305\u65f6\u7684\u903b\u8f91\u3002\u5982\u679c\u6211\u4eec\u8bbe\u7f6e\u4e86sk->ip_mc_loop\u5b57\u6bb5\u4e3a1\uff0c\u5e76\u4e14\u6570\u636e\u5305\u7684\u76ee\u7684IP\u5728\u51fa\u53e3\u8bbe\u5907\u7684\u591a\u64ad\u5217\u8868\u4e2d\uff0c\u5219\u9700\u8981\u7ed9\u81ea\u5df1\u56de\u4f20\u4e00\u4efd\u3002\u90a3\u4e48\u6211\u4eec\u5982\u4f55\u5173\u95ed\u8fd9\u4e2a\u7279\u6027\u5462\uff1f\u8c03\u7528udp.setMulticastLoopback(false)\u5c31\u53ef\u4ee5\u4e86\u3002","title":"16.2.5.4 \u591a\u64ad\u7684\u95ee\u9898"},{"location":"chapter16-UDP/#16255","text":"UDP\u6a21\u5757\u8fd8\u63d0\u4f9b\u4e86\u5176\u5b83\u4e00\u4e9b\u529f\u80fd 1 \u83b7\u53d6\u672c\u7aef\u5730\u5740address \u5982\u679c\u7528\u6237\u6ca1\u6709\u663e\u793a\u8c03\u7528bind\u7ed1\u5b9a\u81ea\u5df1\u8bbe\u7f6e\u7684IP\u548c\u7aef\u53e3\uff0c\u90a3\u4e48\u64cd\u4f5c\u7cfb\u7edf\u5c31\u4f1a\u968f\u673a\u9009\u62e9\u3002\u901a\u8fc7address\u51fd\u6570\u5c31\u53ef\u4ee5\u83b7\u53d6\u64cd\u4f5c\u7cfb\u7edf\u9009\u62e9\u7684\u6e90IP\u548c\u7aef\u53e3\u3002 2 \u83b7\u53d6\u5bf9\u7aef\u7684\u5730\u5740 \u901a\u8fc7remoteAddress\u51fd\u6570\u53ef\u4ee5\u83b7\u53d6\u5bf9\u7aef\u5730\u5740\u3002\u8be5\u5730\u5740\u7531\u7528\u6237\u8c03\u7528connect\u6216sendto\u51fd\u6570\u65f6\u8bbe\u7f6e\u3002 3 \u83b7\u53d6/\u8bbe\u7f6e\u7f13\u51b2\u533a\u5927\u5c0fget/setRecvBufferSize\uff0cget/setSendBufferSize 4 setMulticastLoopback \u53d1\u9001\u591a\u64ad\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u5982\u679c\u591a\u64adIP\u5728\u51fa\u53e3\u8bbe\u5907\u7684\u591a\u64ad\u5217\u8868\u4e2d\uff0c\u5219\u7ed9\u56de\u73af\u8bbe\u5907\u4e5f\u53d1\u4e00\u4efd\u3002 5 setMulticastInterface \u8bbe\u7f6e\u591a\u64ad\u6570\u636e\u7684\u51fa\u53e3\u8bbe\u5907 6 \u52a0\u5165\u6216\u9000\u51fa\u591a\u64ad\u7ec4addMembership/dropMembership 7 addSourceSpecificMembership/dropSourceSpecificMembership \u8fd9\u4e24\u4e2a\u51fd\u6570\u662f\u8bbe\u7f6e\u672c\u7aef\u53ea\u63a5\u6536\u7279\u6027\u6e90\uff08\u4e3b\u673a\uff09\u7684\u591a\u64ad\u6570\u636e\u5305\u3002 8 setTTL \u5355\u64adttl\uff08\u5355\u64ad\u7684\u65f6\u5019\uff0cIP\u534f\u8bae\u5934\u4e2d\u7684ttl\u5b57\u6bb5\uff09\u3002 9 setMulticastTTL \u591a\u64adttl\uff08\u591a\u64ad\u7684\u65f6\u5019\uff0cIP\u534f\u8bae\u7684ttl\u5b57\u6bb5\uff09\u3002 10 ref/unref \u8fd9\u4e24\u4e2a\u51fd\u6570\u8bbe\u7f6e\u5982\u679cNode.js\u4e3b\u8fdb\u7a0b\u4e2d\u53ea\u6709UDP\u5bf9\u5e94\u7684handle\u65f6\uff0c\u662f\u5426\u5141\u8bb8Node.js\u9000\u51fa\u3002Node.js\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u7684\u6761\u4ef6\u4e4b\u4e00\u662f\u662f\u5426\u8fd8\u6709ref\u72b6\u6001\u7684handle\u3002 \u8fd9\u4e9b\u90fd\u662f\u5bf9\u64cd\u4f5c\u7cfb\u7edfAPI\u7684\u5c01\u88c5\uff0c\u5c31\u4e0d\u4e00\u4e00\u5206\u6790\u3002","title":"16.2.5.5 \u5176\u5b83\u529f\u80fd"},{"location":"chapter16-UDP/#1626","text":"\u6211\u4eec\u5728\u7f51\u7edc\u7f16\u7a0b\u4e2d\u7ecf\u5e38\u4f1a\u9047\u5230\u7aef\u53e3\u91cd\u590d\u7ed1\u5b9a\u7684\u9519\u8bef\uff0c\u6839\u636e\u5230\u5e95\u662f\u6211\u4eec\u4e0d\u80fd\u7ed1\u5b9a\u5230\u540c\u4e00\u4e2a\u7aef\u53e3\u548cIP\u4e24\u6b21\u3002\u4f46\u662f\u5728UDP\u4e2d\uff0c\u8fd9\u662f\u5141\u8bb8\u7684\uff0c\u8fd9\u5c31\u662f\u7aef\u53e3\u590d\u7528\u7684\u529f\u80fd\uff0c\u5728TCP\u4e2d\uff0c\u6211\u4eec\u901a\u8fc7\u7aef\u53e3\u590d\u7528\u6765\u89e3\u51b3\u670d\u52a1\u5668\u91cd\u542f\u65f6\u91cd\u65b0\u7ed1\u5b9a\u5230\u540c\u4e00\u4e2a\u7aef\u53e3\u7684\u95ee\u9898\uff0c\u56e0\u4e3a\u6211\u4eec\u77e5\u9053\u7aef\u53e3\u6709\u4e00\u4e2a2msl\u7684\u7b49\u5f85\u65f6\u95f4\uff0c\u91cd\u542f\u670d\u52a1\u5668\u91cd\u65b0\u7ed1\u5b9a\u5230\u8fd9\u4e2a\u7aef\u53e3\u65f6\uff0c\u9ed8\u8ba4\u4f1a\u62a5\u9519\uff0c\u4f46\u662f\u5982\u679c\u6211\u4eec\u8bbe\u7f6e\u4e86\u7aef\u53e3\u590d\u7528\uff08Node.js\u81ea\u52a8\u5e2e\u6211\u4eec\u8bbe\u7f6e\u4e86\uff09\uff0c\u5219\u53ef\u4ee5\u7ed5\u8fc7\u8fd9\u4e2a\u9650\u5236\u3002UDP\u4e2d\u4e5f\u652f\u6301\u7aef\u53e3\u590d\u7528\u7684\u529f\u80fd\uff0c\u4f46\u662f\u529f\u80fd\u3001\u7528\u9014\u548cTCP\u7684\u4e0d\u592a\u4e00\u6837\u3002\u56e0\u4e3a\u591a\u4e2a\u8fdb\u7a0b\u53ef\u4ee5\u7ed1\u5b9a\u540c\u4e00\u4e2aIP\u548c\u7aef\u53e3\u3002\u4f46\u662f\u4e00\u822c\u53ea\u7528\u4e8e\u591a\u64ad\u7684\u60c5\u51b5\u4e0b\u3002\u4e0b\u9762\u6211\u4eec\u6765\u5206\u6790\u4e00\u4e0budp\u7aef\u53e3\u590d\u7528\u7684\u903b\u8f91\u3002\u5728Node.js\u4e2d\uff0c\u4f7f\u7528UDP\u7684\u65f6\u5019\uff0c\u53ef\u4ee5\u901a\u8fc7reuseAddr\u9009\u9879\u4f7f\u5f97\u8fdb\u7a0b\u53ef\u4ee5\u590d\u7528\u7aef\u53e3\uff0c\u5e76\u4e14\u6bcf\u4e00\u4e2a\u60f3\u590d\u7528\u7aef\u53e3\u7684socket\u90fd\u9700\u8981\u8bbe\u7f6ereuseAddr\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2d\u5173\u4e8ereuseAddr\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Socket . prototype . bind = function ( port_ , address_ /* , callback */ ) { let flags = 0 ; if ( state . reuseAddr ) flags |= UV_UDP_REUSEADDR ; state . handle . bind ( ip , port || 0 , flags ); }; // \u6211\u4eec\u770b\u5230Node.js\u5728bind\u7684\u65f6\u5019\u4f1a\u5904\u7406reuseAddr\u5b57\u6bb5\u3002\u6211\u4eec\u76f4\u63a5\u770bLibuv\u7684\u903b\u8f91\u3002 int uv__udp_bind ( uv_udp_t * handle , const struct sockaddr * addr , unsigned int addrlen , unsigned int flags ) { if ( flags & UV_UDP_REUSEADDR ) { err = uv__set_reuse ( fd ); } bind ( fd , addr , addrlen )) return 0 ; } static int uv__set_reuse ( int fd ) { int yes ; yes = 1 ; if ( setsockopt ( fd , SOL_SOCKET , SO_REUSEADDR , & yes , sizeof ( yes ))) return UV__ERR ( errno ); return 0 ; } \u6211\u4eec\u770b\u5230Libuv\u901a\u8fc7\u6700\u7ec8\u901a\u8fc7setsockopt\u8bbe\u7f6e\u4e86\u7aef\u53e3\u590d\u7528\uff0c\u5e76\u4e14\u662f\u5728bind\u4e4b\u524d\u3002\u6211\u4eec\u4e0d\u59a8\u518d\u6df1\u5165\u4e00\u70b9\uff0c\u770b\u4e00\u4e0bLinux\u5185\u6838\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 asmlinkage long sys_setsockopt ( int fd , int level , int optname , char __user * optval , int optlen ) { int err ; struct socket * sock ; if ( optlen < 0 ) return - EINVAL ; if (( sock = sockfd_lookup ( fd , & err )) != NULL ) { if ( level == SOL_SOCKET ) err = sock_setsockopt ( sock , level , optname , optval , optlen ); else err = sock -> ops -> setsockopt ( sock , level , optname , optval , optlen ); sockfd_put ( sock ); } return err ; } sys_setsockopt\u662fsetsockopt\u5bf9\u5e94\u7684\u7cfb\u7edf\u8c03\u7528\uff0c\u6211\u4eec\u770b\u5230sys_setsockopt\u4e5f\u53ea\u662f\u4e2a\u5165\u53e3\u51fd\u6570\uff0c\u5177\u4f53\u51fd\u6570\u662fsock_setsockopt\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int sock_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , int optlen ) { struct sock * sk = sock -> sk ; int val ; int valbool ; int ret = 0 ; if ( get_user ( val , ( int __user * ) optval )) return - EFAULT ; valbool = val ? 1 : 0 ; lock_sock ( sk ); switch ( optname ) { case SO_REUSEADDR : sk -> sk_reuse = valbool ; break ; // ... release_sock ( sk ); return ret ; } \u64cd\u4f5c\u7cfb\u7edf\u7684\u5904\u7406\u5f88\u7b80\u5355\uff0c\u53ea\u662f\u505a\u4e86\u4e00\u4e2a\u6807\u8bb0\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0bbind\u7684\u65f6\u5019\u662f\u600e\u4e48\u5904\u7406\u7684\uff0c\u56e0\u4e3a\u7aef\u53e3\u662f\u5426\u91cd\u590d\u548c\u80fd\u5426\u590d\u7528\u662f\u5728bind\u7684\u65f6\u5019\u5224\u65ad\u7684\u3002\u8fd9\u4e5f\u662f\u4e3a\u4ec0\u4e48\u5728TCP\u4e2d\uff0c\u5373\u4f7f\u4e24\u4e2a\u8fdb\u7a0b\u4e0d\u80fd\u7ed1\u5b9a\u5230\u540c\u4e00\u4e2aIP\u548c\u7aef\u53e3\uff0c\u4f46\u662f\u5982\u679c\u6211\u4eec\u5728\u4e3b\u8fdb\u7a0b\u91cc\u6267\u884c\u4e86bind\u4e4b\u540e\uff0c\u518dfork\u51fd\u6570\u65f6\uff0c\u662f\u53ef\u4ee5\u5b9e\u73b0\u7ed1\u5b9a\u540c\u4e00\u4e2aIP\u7aef\u53e3\u7684\u3002\u8a00\u5f52\u6b63\u4f20\u6211\u4eec\u770b\u4e00\u4e0bUDP\u4e2d\u6267\u884cbind\u65f6\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 int inet_bind ( struct socket * sock , struct sockaddr * uaddr , int addr_len ) { if ( sk -> sk_prot -> get_port ( sk , snum )) { inet -> saddr = inet -> rcv_saddr = 0 ; err = - EADDRINUSE ; goto out_release_sock ; } } \u6bcf\u4e2a\u534f\u8bae\u90fd\u53ef\u4ee5\u5b9e\u73b0\u81ea\u5df1\u7684get_port\u94a9\u5b50\u51fd\u6570\u3002\u7528\u6765\u5224\u65ad\u5f53\u524d\u7684\u7aef\u53e3\u662f\u5426\u5141\u8bb8\u88ab\u7ed1\u5b9a\u3002\u5982\u679c\u4e0d\u5141\u8bb8\u5219\u8fd4\u56deEADDRINUSE\uff0c\u6211\u4eec\u770b\u770bUDP\u534f\u8bae\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 static int udp_v4_get_port ( struct sock * sk , unsigned short snum ) { struct hlist_node * node ; struct sock * sk2 ; struct inet_sock * inet = inet_sk ( sk ); // \u901a\u8fc7\u7aef\u53e3\u627e\u5230\u5bf9\u5e94\u7684\u94fe\u8868\uff0c\u7136\u540e\u904d\u5386\u94fe\u8868 sk_for_each ( sk2 , node , & udp_hash [ snum & ( UDP_HTABLE_SIZE - 1 )]) { struct inet_sock * inet2 = inet_sk ( sk2 ); // \u7aef\u53e3\u5df2\u4f7f\u7528\uff0c\u5219\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u590d\u7528 if ( inet2 -> num == snum && sk2 != sk && ( ! inet2 -> rcv_saddr || ! inet -> rcv_saddr || inet2 -> rcv_saddr == inet -> rcv_saddr ) && // \u6bcf\u4e2asocket\u90fd\u9700\u8981\u8bbe\u7f6e\u7aef\u53e3\u590d\u7528\u6807\u8bb0 ( ! sk2 -> sk_reuse || ! sk -> sk_reuse )) // \u4e0d\u53ef\u4ee5\u590d\u7528\uff0c\u62a5\u9519 goto fail ; } // \u53ef\u4ee5\u590d\u7528 inet -> num = snum ; if ( sk_unhashed ( sk )) { // \u627e\u5230\u7aef\u53e3\u5bf9\u5e94\u7684\u4f4d\u7f6e struct hlist_head * h = & udp_hash [ snum & ( UDP_HTABLE_SIZE - 1 )]; // \u63d2\u5165\u94fe\u8868 sk_add_node ( sk , h ); sock_prot_inc_use ( sk -> sk_prot ); } return 0 ; fail : write_unlock_bh ( & udp_hash_lock ); return 1 ; } \u5206\u6790\u4e4b\u524d\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u7684\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\uff0cUDP\u534f\u8bae\u7684\u5b9e\u73b0\u4e2d\uff0c\u4f1a\u4f7f\u7528\u5982\u4e0b\u7684\u6570\u636e\u7ed3\u6784\u8bb0\u5f55\u6bcf\u4e00\u4e2aUDP socket\uff0c\u5982\u56fe16-6\u6240\u793a\u3002 \u56fe16-6 \u6211\u4eec\u770b\u5230\u64cd\u4f5c\u7cfb\u7edf\u4f7f\u7528\u4e00\u4e2a\u6570\u7ec4\u4f5c\u4e3a\u54c8\u5e0c\u8868\uff0c\u6bcf\u6b21\u64cd\u4f5c\u4e00\u4e2asocket\u7684\u65f6\u5019\uff0c\u9996\u5148\u4f1a\u6839\u636esocket\u7684\u6e90\u7aef\u53e3\u548c\u54c8\u5e0c\u7b97\u6cd5\u8ba1\u7b97\u5f97\u5230\u4e00\u4e2a\u6570\u7ec4\u7d22\u5f15\uff0c\u7136\u540e\u628asocket\u63d2\u5165\u7d22\u5f15\u9501\u5bf9\u5e94\u7684\u94fe\u8868\u4e2d\uff0c\u5373\u54c8\u5e0c\u51b2\u7a81\u7684\u89e3\u51b3\u65b9\u6cd5\u662f\u94fe\u5730\u5740\u6cd5\u3002\u56de\u5230\u4ee3\u7801\u7684\u903b\u8f91\uff0c\u5f53\u7528\u6237\u60f3\u7ed1\u5b9a\u4e00\u4e2a\u7aef\u53e3\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u6839\u636e\u7aef\u53e3\u62ff\u5230\u5bf9\u5e94\u7684socket\u94fe\u8868\uff0c\u7136\u540e\u9010\u4e2a\u5224\u65ad\u662f\u5426\u6709\u76f8\u7b49\u7684\u7aef\u53e3\uff0c\u5982\u679c\u6709\u5219\u5224\u65ad\u662f\u5426\u53ef\u4ee5\u590d\u7528\u3002\u4f8b\u5982\u4e24\u4e2asocket\u90fd\u8bbe\u7f6e\u4e86\u590d\u7528\u6807\u8bb0\u5219\u53ef\u4ee5\u590d\u7528\u3002\u6700\u540e\u628asocket\u63d2\u5165\u5230\u94fe\u8868\u4e2d\u3002 1 2 3 4 5 6 7 8 9 10 static inline void hlist_add_head ( struct hlist_node * n , struct hlist_head * h ) { // \u5934\u7ed3\u70b9 struct hlist_node * first = h -> first ; n -> next = first ; if ( first ) first -> pprev = & n -> next ; h -> first = n ; n -> pprev = & h -> first ; } \u6211\u4eec\u770b\u5230\u64cd\u4f5c\u7cfb\u7edf\u662f\u4ee5\u5934\u63d2\u6cd5\u7684\u65b9\u5f0f\u63d2\u5165\u65b0\u8282\u70b9\u7684\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u662f\u5982\u4f55\u4f7f\u7528\u8fd9\u4e9b\u6570\u636e\u7ed3\u6784\u7684\u3002","title":"16.2.6 \u7aef\u53e3\u590d\u7528"},{"location":"chapter16-UDP/#16261","text":"\u6211\u4eec\u5148\u770b\u4e00\u4e2a\u4f8b\u5b50\uff0c\u6211\u4eec\u5728\u540c\u4e3b\u673a\u4e0a\u65b0\u5efa\u4e24\u4e2aJS\u6587\u4ef6\uff08\u5ba2\u6237\u7aef\uff09\uff0c\u4ee3\u7801\u5982\u4e0b 1 2 3 4 5 6 7 8 const dgram = require ( 'dgram' ); const udp = dgram . createSocket ({ type : 'udp4' , reuseAddr : true }); udp . bind ( 1234 , \u2018 192.168.8.164 \u2018 , () => { udp . addMembership ( '224.0.0.114' , '192.168.8.164' ); }); udp . on ( 'message' , ( msg ) => { console . log ( msg ) }); \u4e0a\u9762\u4ee3\u7801\u4f7f\u5f97\u4e24\u4e2a\u8fdb\u7a0b\u90fd\u76d1\u542c\u4e86\u540c\u6837\u7684IP\u548c\u7aef\u53e3\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u5199\u4e00\u4e2aUDP\u670d\u52a1\u5668\u3002 1 2 3 4 5 6 const dgram = require ( 'dgram' ); const udp = dgram . createSocket ({ type : 'udp4' }); const socket = udp . bind ( 5678 ); socket . send ( 'hi' , 1234 , '224.0.0.114' , ( err ) => { console . log ( err ) }); \u4e0a\u9762\u7684\u4ee3\u7801\u7ed9\u4e00\u4e2a\u591a\u64ad\u7ec4\u53d1\u9001\u4e86\u4e00\u4e2a\u6570\u636e\uff0c\u6267\u884c\u4e0a\u9762\u7684\u4ee3\u7801\uff0c\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4e24\u4e2a\u5ba2\u6237\u7aef\u8fdb\u7a0b\u90fd\u6536\u5230\u4e86\u6570\u636e\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u6536\u5230\u6570\u636e\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u662f\u5982\u4f55\u628a\u6570\u636e\u5206\u53d1\u7ed9\u6bcf\u4e2a\u76d1\u542c\u4e86\u540c\u6837IP\u548c\u7aef\u53e3\u7684\u8fdb\u7a0b\u7684\u3002\u4e0b\u9762\u662f\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230\u4e00\u4e2aUDP\u6570\u636e\u5305\u65f6\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int udp_rcv ( struct sk_buff * skb ) { struct sock * sk ; struct udphdr * uh ; unsigned short ulen ; struct rtable * rt = ( struct rtable * ) skb -> dst ; // ip\u5934\u4e2d\u8bb0\u5f55\u7684\u6e90ip\u548c\u76ee\u7684ip u32 saddr = skb -> nh . iph -> saddr ; u32 daddr = skb -> nh . iph -> daddr ; int len = skb -> len ; // udp\u534f\u8bae\u5934\u7ed3\u6784\u4f53 uh = skb -> h . uh ; ulen = ntohs ( uh -> len ); // \u5e7f\u64ad\u6216\u591a\u64ad\u5305 if ( rt -> rt_flags & ( RTCF_BROADCAST | RTCF_MULTICAST )) return udp_v4_mcast_deliver ( skb , uh , saddr , daddr ); // \u5355\u64ad sk = udp_v4_lookup ( saddr , uh -> source , daddr , uh -> dest , skb -> dev -> ifindex ); // \u627e\u5230\u5bf9\u5e94\u7684socket if ( sk != NULL ) { // \u628a\u6570\u636e\u63d2\u5230socket\u7684\u6d88\u606f\u961f\u5217 int ret = udp_queue_rcv_skb ( sk , skb ); sock_put ( sk ); if ( ret > 0 ) return - ret ; return 0 ; } return ( 0 ); } \u6211\u4eec\u770b\u5230\u5355\u64ad\u548c\u975e\u5355\u64ad\u65f6\u5904\u7406\u903b\u8f91\u662f\u4e0d\u4e00\u6837\u7684\uff0c\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u975e\u5355\u64ad\u7684\u60c5\u51b5 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 static int udp_v4_mcast_deliver ( struct sk_buff * skb , struct udphdr * uh , u32 saddr , u32 daddr ) { struct sock * sk ; int dif ; read_lock ( & udp_hash_lock ); // \u901a\u8fc7\u7aef\u53e3\u627e\u5230\u5bf9\u5e94\u7684\u94fe\u8868 sk = sk_head ( & udp_hash [ ntohs ( uh -> dest ) & ( UDP_HTABLE_SIZE - 1 )]); dif = skb -> dev -> ifindex ; sk = udp_v4_mcast_next ( sk , uh -> dest , daddr , uh -> source , saddr , dif ); if ( sk ) { struct sock * sknext = NULL ; // \u904d\u5386\u6bcf\u4e00\u4e2a\u9700\u8981\u5904\u7406\u8be5\u6570\u636e\u5305\u7684socket do { struct sk_buff * skb1 = skb ; sknext = udp_v4_mcast_next ( sk_next ( sk ), uh -> dest , daddr , uh -> source , saddr , dif ); if ( sknext ) // \u590d\u5236\u4e00\u4efd skb1 = skb_clone ( skb , GFP_ATOMIC ); // \u63d2\u5165\u6bcf\u4e00\u4e2asocket\u7684\u6570\u636e\u5305\u961f\u5217 if ( skb1 ) { int ret = udp_queue_rcv_skb ( sk , skb1 ); if ( ret > 0 ) kfree_skb ( skb1 ); } sk = sknext ; } while ( sknext ); } else kfree_skb ( skb ); read_unlock ( & udp_hash_lock ); return 0 ; } \u5728\u975e\u5355\u64ad\u7684\u60c5\u51b5\u4e0b\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u904d\u5386\u94fe\u8868\u627e\u5230\u6bcf\u4e00\u4e2a\u53ef\u4ee5\u63a5\u6536\u8be5\u6570\u636e\u5305\u7684socket\uff0c\u7136\u540e\u628a\u6570\u636e\u5305\u590d\u5236\u4e00\u4efd\uff0c\u6302\u8f7d\u5230socket\u7684\u63a5\u6536\u961f\u5217\u3002\u8fd9\u5c31\u89e3\u91ca\u4e86\u672c\u8282\u5f00\u5934\u7684\u4f8b\u5b50\uff0c\u5373\u4e24\u4e2a\u5ba2\u6237\u7aef\u8fdb\u7a0b\u90fd\u4f1a\u6536\u5230UDP\u6570\u636e\u5305\u3002","title":"16.2.6.1 \u591a\u64ad"},{"location":"chapter16-UDP/#16262","text":"\u63a5\u7740\u6211\u4eec\u518d\u6765\u770b\u4e00\u4e0b\u5355\u64ad\u7684\u60c5\u51b5\u3002\u9996\u5148\u6211\u4eec\u770b\u4e00\u4e2a\u4f8b\u5b50\u3002\u6211\u4eec\u540c\u6837\u65b0\u5efa\u4e24\u4e2aJS\u6587\u4ef6\u7528\u4f5c\u5ba2\u6237\u7aef\u3002 1 2 3 4 5 6 const dgram = require ( 'dgram' ); const udp = dgram . createSocket ({ type : 'udp4' , reuseAddr : true }); const socket = udp . bind ( 5678 ); socket . on ( 'message' , ( msg ) => { console . log ( msg ) }) \u7136\u540e\u518d\u65b0\u5efa\u4e00\u4e2aJS\u6587\u4ef6\u7528\u4f5c\u670d\u52a1\u5668\u3002 1 2 3 4 const dgram = require ( 'dgram' ); const udp = dgram . createSocket ({ type : 'udp4' }); const socket = udp . bind ( 1234 ); udp . send ( 'hi' , 5678 ) \u6267\u884c\u4ee5\u4e0a\u4ee3\u7801\uff0c\u9996\u5148\u6267\u884c\u5ba2\u6237\u7aef\uff0c\u518d\u6267\u884c\u670d\u52a1\u5668\uff0c\u6211\u4eec\u4f1a\u53d1\u73b0\u53ea\u6709\u4e00\u4e2a\u8fdb\u7a0b\u4f1a\u6536\u5230\u6570\u636e\u3002\u4e0b\u9762\u6211\u4eec\u5206\u6790\u5177\u4f53\u7684\u539f\u56e0\uff0c\u5355\u64ad\u65f6\u6536\u5230\u4f1a\u8c03\u7528udp_v4_lookup\u51fd\u6570\u627e\u5230\u63a5\u6536\u8be5UDP\u6570\u636e\u5305\u7684socket\uff0c\u7136\u540e\u628a\u6570\u636e\u5305\u6302\u8f7d\u5230socket\u7684\u63a5\u6536\u961f\u5217\u4e2d\u3002\u6211\u4eec\u770b\u770budp_v4_lookup\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 static __inline__ struct sock * udp_v4_lookup ( u32 saddr , u16 sport , u32 daddr , u16 dport , int dif ) { struct sock * sk ; sk = udp_v4_lookup_longway ( saddr , sport , daddr , dport , dif ); return sk ; } static struct sock * udp_v4_lookup_longway ( u32 saddr , u16 sport , u32 daddr , u16 dport , int dif ) { struct sock * sk , * result = NULL ; struct hlist_node * node ; unsigned short hnum = ntohs ( dport ); int badness = -1 ; // \u904d\u5386\u7aef\u53e3\u5bf9\u5e94\u7684\u94fe\u8868 sk_for_each ( sk , node , & udp_hash [ hnum & ( UDP_HTABLE_SIZE - 1 )]) { struct inet_sock * inet = inet_sk ( sk ); if ( inet -> num == hnum && ! ipv6_only_sock ( sk )) { int score = ( sk -> sk_family == PF_INET ? 1 : 0 ); if ( inet -> rcv_saddr ) { if ( inet -> rcv_saddr != daddr ) continue ; score += 2 ; } if ( inet -> daddr ) { if ( inet -> daddr != saddr ) continue ; score += 2 ; } if ( inet -> dport ) { if ( inet -> dport != sport ) continue ; score += 2 ; } if ( sk -> sk_bound_dev_if ) { if ( sk -> sk_bound_dev_if != dif ) continue ; score += 2 ; } // \u5168\u5339\u914d\uff0c\u76f4\u63a5\u8fd4\u56de\uff0c\u5426\u5219\u8bb0\u5f55\u5f53\u524d\u6700\u597d\u7684\u5339\u914d\u7ed3\u679c if ( score == 9 ) { result = sk ; break ; } else if ( score > badness ) { result = sk ; badness = score ; } } } return result ; } \u6211\u4eec\u770b\u5230\u4ee3\u7801\u5f88\u591a\uff0c\u4f46\u662f\u903b\u8f91\u5e76\u4e0d\u590d\u6742\uff0c\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230\u6839\u636e\u7aef\u53e3\u4ece\u54c8\u5e0c\u8868\u4e2d\u62ff\u5230\u5bf9\u5e94\u7684\u94fe\u8868\uff0c\u7136\u540e\u904d\u5386\u8be5\u94fe\u8868\u627e\u51fa\u6700\u5339\u914d\u7684socket\u3002\u7136\u540e\u628a\u6570\u636e\u6302\u8f7d\u5230socket\u4e0a\u3002\u4f46\u662f\u6709\u4e00\u4e2a\u7ec6\u8282\u9700\u8981\u6ce8\u610f\uff0c\u5982\u679c\u6709\u4e24\u4e2a\u8fdb\u7a0b\u90fd\u76d1\u542c\u4e86\u540c\u4e00\u4e2aIP\u548c\u7aef\u53e3\uff0c\u90a3\u4e48\u54ea\u4e00\u4e2a\u8fdb\u7a0b\u4f1a\u6536\u5230\u6570\u636e\u5462\uff1f\u8fd9\u4e2a\u53d6\u51b3\u4e8e\u64cd\u4f5c\u7cfb\u7edf\u7684\u5b9e\u73b0\uff0c\u4eceLinux\u6e90\u7801\u6211\u4eec\u770b\u5230\uff0c\u63d2\u5165socket\u7684\u65f6\u5019\u662f\u4f7f\u7528\u5934\u63d2\u6cd5\uff0c\u67e5\u627e\u7684\u65f6\u5019\u662f\u4ece\u5934\u5f00\u59cb\u627e\u6700\u5339\u914d\u7684socket\u3002\u5373\u540e\u9762\u63d2\u5165\u7684socket\u4f1a\u5148\u88ab\u641c\u7d22\u5230\u3002\u4f46\u662fWindows\u4e0b\u7ed3\u6784\u5374\u76f8\u53cd\uff0c\u5148\u76d1\u542c\u4e86\u8be5IP\u7aef\u53e3\u7684\u8fdb\u7a0b\u4f1a\u6536\u5230\u6570\u636e\u3002 \u7b2c","title":"16.2.6.2 \u5355\u64ad"},{"location":"chapter17-TCP/","text":"\u672c\u7ae0\u6211\u4eec\u4e3b\u8981\u770b\u4e00\u4e0bNode.js\u4e2d\u5bf9TCP\u7684\u5c01\u88c5\uff0c\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u5728\u7f51\u7edc\u7f16\u7a0b\u4e2d\uff0c\u662f\u5982\u4f55\u7f16\u5199\u4e00\u4e2a\u670d\u52a1\u5668\u548c\u5ba2\u6237\u7aef\u7684\uff08\u4f2a\u4ee3\u7801\uff09\u3002 \u670d\u52a1\u5668 1 2 3 4 5 const fd = socket (); bind ( fd , ip , port ); listen ( fd ); const acceptedFd = accept ( fd ); handle ( acceptedFd ); \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u51e0\u4e2a\u51fd\u6570\u7684\u4f5c\u7528 1 socket\uff1asocket\u51fd\u6570\u7528\u4e8e\u4ece\u64cd\u4f5c\u7cfb\u7edf\u7533\u8bf7\u4e00\u4e2asocket\u7ed3\u6784\u4f53\uff0cLinux\u4e2d\u4e07\u7269\u7686\u6587\u4ef6\uff0c\u6240\u4ee5\u6700\u540e\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u8fd4\u56de\u4e00\u4e2afd\uff0cfd\u5728\u64cd\u4f5c\u7cfb\u7edf\u4e2d\u7c7b\u4f3c\u6570\u636e\u5e93\u7684id\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5e95\u5c42\u7ef4\u62a4\u4e86fd\u5bf9\u5e94\u7684\u8d44\u6e90\uff0c\u6bd4\u5982\u7f51\u7edc\u3001\u6587\u4ef6\u3001\u7ba1\u9053\u7b49\uff0c\u540e\u7eed\u5c31\u53ef\u4ee5\u901a\u8fc7\u8be5fd\u53bb\u64cd\u4f5c\u5bf9\u5e94\u7684\u8d44\u6e90\u3002 2 bind\uff1abind\u51fd\u6570\u7528\u4e8e\u7ed9fd\u5bf9\u5e94\u7684socket\u8bbe\u7f6e\u5730\u5740\uff08IP\u548c\u7aef\u53e3\uff09\uff0c\u540e\u7eed\u9700\u8981\u7528\u5230\u3002 3 listen\uff1alisten\u51fd\u6570\u7528\u4e8e\u4fee\u6539fd\u5bf9\u5e94\u7684socket\u7684\u72b6\u6001\u548c\u76d1\u542c\u72b6\u6001\u3002\u53ea\u6709\u76d1\u542c\u72b6\u6001\u7684socket\u53ef\u4ee5\u63a5\u53d7\u5ba2\u6237\u7aef\u7684\u8fde\u63a5\u3002socket\u6211\u4eec\u53ef\u4ee5\u7406\u89e3\u6709\u4e24\u79cd\uff0c\u4e00\u79cd\u662f\u76d1\u542c\u578b\u7684\uff0c\u4e00\u79cd\u662f\u901a\u4fe1\u578b\u7684\uff0c\u76d1\u542c\u578b\u7684socket\u53ea\u8d1f\u8d23\u5904\u7406\u4e09\u6b21\u63e1\u624b\uff0c\u5efa\u7acb\u8fde\u63a5\uff0c\u901a\u4fe1\u578b\u7684\u8d1f\u8d23\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u3002 4 accept\uff1aaccept\u51fd\u6570\u9ed8\u8ba4\u4f1a\u963b\u585e\u8fdb\u7a0b\uff0c\u76f4\u5230\u6709\u6709\u8fde\u63a5\u5230\u6765\u5e76\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u3002 \u6267\u884c\u5b8c\u4ee5\u4e0a\u4ee3\u7801\uff0c\u5c31\u5b8c\u6210\u4e86\u4e00\u4e2a\u670d\u52a1\u5668\u7684\u542f\u52a8\u3002\u8fd9\u65f6\u5019\u5173\u7cfb\u56fe\u5982\u56fe17-1\u6240\u793a\u3002 \u56fe17-1 \u5ba2\u6237\u7aef 1 2 3 const fd = socket (); const connectRet = connect ( fd , ip , port ); write ( fd , 'hello' ); \u5ba2\u6237\u7aef\u6bd4\u670d\u52a1\u5668\u7a0d\u5fae\u7b80\u5355\u4e00\u70b9\uff0c\u6211\u4eec\u770b\u770b\u8fd9\u51e0\u4e2a\u51fd\u6570\u7684\u4f5c\u7528\u3002 1 socket\uff1a\u548c\u670d\u52a1\u5668\u4e00\u6837\uff0c\u5ba2\u6237\u7aef\u4e5f\u9700\u8981\u7533\u8bf7\u4e00\u4e2asocket\u7528\u4e8e\u548c\u670d\u52a1\u5668\u901a\u4fe1\u3002 2 connect\uff1aconnect\u4f1a\u5f00\u59cb\u4e09\u6b21\u63e1\u624b\u8fc7\u7a0b\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u4f1a\u963b\u585e\u8fdb\u7a0b\uff0c\u76f4\u5230\u8fde\u63a5\u6709\u7ed3\u679c\uff0c\u8fde\u63a5\u7ed3\u679c\u901a\u8fc7\u8fd4\u56de\u503c\u544a\u8bc9\u8c03\u7528\u65b9\uff0c\u5982\u679c\u4e09\u6b21\u63e1\u624b\u5b8c\u6210\uff0c\u90a3\u4e48\u6211\u4eec\u5c31\u53ef\u4ee5\u5f00\u59cb\u53d1\u9001\u6570\u636e\u4e86\u3002 3 write\uff1awrite\u7528\u4e8e\u7ed9\u670d\u52a1\u5668\u53d1\u9001\u6570\u636e\uff0c\u4e0d\u8fc7\u5e76\u4e0d\u662f\u76f4\u63a5\u53d1\u9001\uff0c\u8fd9\u4e9b\u6570\u636e\u53ea\u662f\u4fdd\u5b58\u5230socket\u7684\u53d1\u9001\u7f13\u51b2\u533a\uff0c\u5e95\u5c42\u4f1a\u6839\u636eTCP\u534f\u8bae\u51b3\u5b9a\u4ec0\u4e48\u65f6\u5019\u53d1\u9001\u6570\u636e\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u5f53\u5ba2\u6237\u7aef\u53d1\u9001\u7b2c\u4e00\u4e2a\u63e1\u624b\u7684syn\u5305\u65f6\uff0csocket\u5904\u4e8esyn\u53d1\u9001\u72b6\u6001\uff0c\u6211\u4eec\u770b\u770b\u8fd9\u65f6\u5019\u7684\u670d\u52a1\u5668\u662f\u600e\u6837\u7684\uff0c\u5982\u56fe17-2\u6240\u793a\u3002 \u56fe17-2 \u6211\u4eec\u770b\u5230\u8fd9\u65f6\u5019\uff0c\u670d\u52a1\u5668\u5bf9\u5e94\u7684socket\u4e2d\uff0c\u4f1a\u65b0\u5efa\u4e00\u4e2asocket\u7528\u4e8e\u540e\u7eed\u901a\u4fe1\uff08socket\u7ed3\u6784\u4f53\u6709\u4e00\u4e2a\u5b57\u6bb5\u6307\u5411\u8be5\u961f\u5217\uff09\u3002\u5e76\u4e14\u6807\u8bb0\u8be5socket\u7684\u72b6\u6001\u4e3a\u6536\u5230syn\uff0c\u7136\u540e\u53d1\u9001ack\uff0c\u5373\u7b2c\u4e8c\u6b21\u63e1\u624b\uff0c\u7b49\u5230\u5ba2\u6237\u7aef\u56de\u590d\u7b2c\u4e09\u6b21\u63e1\u624b\u7684\u6570\u636e\u5305\u65f6\uff0c\u5c31\u5b8c\u6210\u4e86\u8fde\u63a5\u7684\u5efa\u7acb\u3002\u4e0d\u540c\u7684\u64cd\u4f5c\u7cfb\u7edf\u7248\u672c\u5b9e\u73b0\u4e0d\u4e00\u6837\uff0c\u6709\u7684\u7248\u672c\u5b9e\u73b0\u4e2d\uff0c\u5df2\u5b8c\u6210\u8fde\u63a5\u548c\u6b63\u5728\u5efa\u7acb\u8fde\u63a5\u7684socket\u662f\u5728\u4e00\u4e2a\u961f\u5217\u4e2d\u7684\uff0c\u6709\u7684\u7248\u672c\u5b9e\u73b0\u4e2d\uff0c\u5df2\u5b8c\u6210\u8fde\u63a5\u548c\u6b63\u5728\u5efa\u7acb\u8fde\u63a5\u7684socket\u662f\u5206\u4e3a\u4e24\u4e2a\u961f\u5217\u7ef4\u62a4\u7684\u3002 \u5f53\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u5b8c\u6210\u4e86TCP\u8fde\u63a5\u540e\uff0c\u5c31\u53ef\u4ee5\u8fdb\u884c\u6570\u636e\u901a\u4fe1\u4e86\uff0c\u8fd9\u65f6\u5019\u670d\u52a1\u5668\u7684accept\u5c31\u4f1a\u4ece\u963b\u585e\u4e2d\u88ab\u5524\u9192\uff0c\u5e76\u4ece\u8fde\u63a5\u961f\u5217\u4e2d\u6458\u4e0b\u4e00\u4e2a\u5df2\u5b8c\u6210\u8fde\u63a5\u7684socket\u7ed3\u70b9\uff0c\u7136\u540e\u751f\u6210\u4e00\u4e2a\u65b0\u7684fd\u3002\u540e\u7eed\u5c31\u53ef\u4ee5\u5728\u8be5fd\u4e0a\u548c\u5bf9\u7aef\u901a\u4fe1\u3002\u90a3\u4e48\u5f53\u5ba2\u6237\u7aef\u53d1\u9001\u4e00\u4e2aTCP\u6570\u636e\u5305\u8fc7\u6765\u7684\u65f6\u5019\uff0c\u64cd\u4f5c\u7cfb\u7edf\u662f\u5982\u4f55\u5904\u7406\u7684\u5462\uff1f 1 \u64cd\u4f5c\u7cfb\u7edf\u9996\u5148\u6839\u636eTCP\u62a5\u6587\u7684\u6e90IP\u3001\u6e90\u7aef\u53e3\u3001\u76ee\u7684IP\u3001\u76ee\u7684\u7aef\u53e3\u7b49\u4fe1\u606f\u4ecesocket\u6c60\u4e2d\u627e\u5230\u5bf9\u5e94\u7684socket\u3002 2 \u64cd\u4f5c\u7cfb\u7edf\u5224\u65ad\u8bfb\u7f13\u51b2\u533a\u662f\u5426\u8fd8\u6709\u8db3\u591f\u7684\u7a7a\u95f4\uff0c\u5982\u679c\u7a7a\u95f4\u4e0d\u591f\uff0c\u5219\u4e22\u5f03TCP\u62a5\u6587\uff0c\u5426\u5219\u628a\u62a5\u6587\u5bf9\u5e94\u7684\u6570\u636e\u7ed3\u6784\u6302\u8f7d\u5230socket\u7684\u6570\u636e\u961f\u5217\uff0c\u7b49\u5f85\u8bfb\u53d6\u3002 \u4e86\u89e3\u4e86TCP\u901a\u4fe1\u7684\u5927\u81f4\u8fc7\u7a0b\u540e\uff0c\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2d\u662f\u5982\u4f55\u5c01\u88c5\u5e95\u5c42\u7684\u80fd\u529b\u7684\u3002 17.1 TCP\u5ba2\u6237\u7aef \u00b6 17.1.1 \u5efa\u7acb\u8fde\u63a5 \u00b6 net.connect\u662fNode.js\u4e2d\u53d1\u8d77TCP\u8fde\u63a5\u7684API\u3002\u672c\u8d28\u4e0a\u662f\u5bf9\u5e95\u5c42TCP connect\u51fd\u6570\u7684\u5c01\u88c5\u3002connect\u8fd4\u56de\u4e00\u4e2a\u8868\u793a\u5ba2\u6237\u7aef\u7684Socket\u5bf9\u8c61\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2d\u7684\u5177\u4f53\u5b9e\u73b0\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bconnect\u51fd\u6570\u7684\u5165\u53e3\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 function connect (... args ) { // \u5904\u7406\u53c2\u6570 var normalized = normalizeArgs ( args ); var options = normalized [ 0 ]; // \u7533\u8bf7\u4e00\u4e2asocket\u8868\u793a\u4e00\u4e2a\u5ba2\u6237\u7aef var socket = new Socket ( options ); // \u8bbe\u7f6e\u8d85\u65f6\uff0c\u8d85\u65f6\u540e\u4f1a\u89e6\u53d1timeout\uff0c\u7528\u6237\u53ef\u4ee5\u81ea\u5b9a\u4e49\u5904\u7406\u8d85\u65f6\u903b\u8f91 if ( options . timeout ) { socket . setTimeout ( options . timeout ); } // \u8c03\u7528socket\u7684connect return Socket . prototype . connect . call ( socket , normalized ); } \u4ece\u4ee3\u7801\u4e2d\u53ef\u4ee5\u770b\u5230\uff0cconnect\u51fd\u6570\u662f\u5bf9Socket\u5bf9\u8c61\u7684\u5c01\u88c5\u3002Socket\u8868\u793a\u4e00\u4e2aTCP\u5ba2\u6237\u7aef\u3002\u6211\u4eec\u5206\u6210\u4e09\u90e8\u5206\u5206\u6790\u3002 1 2 3 1 new Socket 2 setTimeout 3 Socket\u7684connect 1 new Socket \u6211\u4eec\u770b\u770b\u65b0\u5efa\u4e00\u4e2aSocket\u5bf9\u8c61\uff0c\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function Socket ( options ) { // \u662f\u5426\u6b63\u5728\u5efa\u7acb\u8fde\u63a5\uff0c\u5373\u4e09\u6b21\u63e1\u624b\u4e2d this . connecting = false ; // \u89e6\u53d1close\u4e8b\u4ef6\u65f6\uff0c\u8be5\u5b57\u6bb5\u6807\u8bb0\u662f\u5426\u7531\u4e8e\u9519\u8bef\u5bfc\u81f4\u4e86close this . _hadError = false ; // \u5bf9\u5e94\u7684\u5e95\u5c42handle\uff0c\u6bd4\u5982tcp_wrap this . _handle = null ; // \u5b9a\u65f6\u5668id this [ kTimeout ] = null ; options = options || {}; // socket\u662f\u53cc\u5411\u6d41 stream . Duplex . call ( this , options ); // \u8fd8\u4e0d\u80fd\u8bfb\u5199\uff0c\u5148\u8bbe\u7f6e\u6210false\uff0c\u8fde\u63a5\u6210\u529f\u540e\u518d\u91cd\u65b0\u8bbe\u7f6e this . readable = this . writable = false ; // \u6ce8\u518c\u5199\u7aef\u5173\u95ed\u7684\u56de\u8c03 this . on ( 'finish' , onSocketFinish ); // \u6ce8\u518c\u8bfb\u7aef\u5173\u95ed\u7684\u56de\u8c03 this . on ( '_socketEnd' , onSocketEnd ); // \u662f\u5426\u5141\u8bb8\u534a\u5f00\u5173\uff0c\u9ed8\u8ba4\u4e0d\u5141\u8bb8 this . allowHalfOpen = options && options . allowHalfOpen || false ; } Socket\u662f\u5bf9C++\u6a21\u5757tcp_wrap\u7684\u5c01\u88c5\u3002\u4e3b\u8981\u662f\u521d\u59cb\u5316\u4e86\u4e00\u4e9b\u5c5e\u6027\u548c\u76d1\u542c\u4e00\u4e9b\u4e8b\u4ef6\u3002 2 setTimeout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Socket . prototype . setTimeout = function ( msecs , callback ) { // \u6e05\u9664\u4e4b\u524d\u7684\uff0c\u5982\u679c\u6709\u7684\u8bdd clearTimeout ( this [ kTimeout ]); // 0\u4ee3\u8868\u6e05\u9664 if ( msecs === 0 ) { if ( callback ) { this . removeListener ( 'timeout' , callback ); } } else { // \u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u65f6\u95f4\u662fmsecs\uff0c\u8d85\u65f6\u56de\u8c03\u662f_onTimeout this [ kTimeout ] = setUnrefTimeout ( this . _onTimeout . bind ( this ), msecs ); /* \u76d1\u542ctimeout\u4e8b\u4ef6\uff0c\u5b9a\u65f6\u5668\u8d85\u65f6\u65f6\uff0c\u5e95\u5c42\u4f1a\u8c03\u7528Node.js\u7684\u56de\u8c03\uff0c Node.js\u4f1a\u8c03\u7528\u7528\u6237\u7684\u56de\u8c03callback */ if ( callback ) { this . once ( 'timeout' , callback ); } } return this ; }; setTimeout\u505a\u7684\u4e8b\u60c5\u5c31\u662f\u8bbe\u7f6e\u4e00\u4e2a\u8d85\u65f6\u65f6\u95f4\uff0c\u8fd9\u4e2a\u65f6\u95f4\u7528\u4e8e\u68c0\u6d4bsocket\u7684\u6d3b\u8dc3\u60c5\u51b5\uff08\u6bd4\u5982\u6709\u6570\u636e\u901a\u4fe1\uff09\uff0c\u5f53socket\u6d3b\u8dc3\u65f6\uff0cNode.js\u4f1a\u91cd\u7f6e\u8be5\u5b9a\u65f6\u5668\uff0c\u5982\u679csocket\u4e00\u76f4\u4e0d\u6d3b\u8dc3\u5219\u8d85\u65f6\u4f1a\u89e6\u53d1timeout\u4e8b\u4ef6\uff0c\u4ece\u800c\u6267\u884cNode.js\u7684_onTimeout\u56de\u8c03\uff0c\u5728\u56de\u8c03\u91cc\u518d\u89e6\u53d1\u7528\u6237\u4f20\u5165\u7684\u56de\u8c03\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8d85\u65f6\u5904\u7406\u51fd\u6570_onTimeout\u3002 1 2 3 Socket . prototype . _onTimeout = function () { this . emit ( 'timeout' ); }; \u76f4\u63a5\u89e6\u53d1timeout\u51fd\u6570\uff0c\u56de\u8c03\u7528\u6237\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u5230setTimeout\u53ea\u662f\u8bbe\u7f6e\u4e86\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u7136\u540e\u89e6\u53d1timeout\u4e8b\u4ef6\uff0cNode.js\u5e76\u6ca1\u6709\u5e2e\u6211\u4eec\u505a\u989d\u5916\u7684\u64cd\u4f5c\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u81ea\u5df1\u5904\u7406\uff0c\u6bd4\u5982\u5173\u95edsocket\u3002 1 2 3 4 socket . setTimeout ( 10000 ); socket . on ( 'timeout' , () => { socket . close (); }); \u53e6\u5916\u6211\u4eec\u770b\u5230\u8fd9\u91cc\u662f\u4f7f\u7528setUnrefTimeout\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\uff0c\u56e0\u4e3a\u8fd9\u4e00\u7c7b\u5b9a\u65f6\u5668\u4e0d\u5e94\u8be5\u963b\u6b62\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002 3 connect\u51fd\u6570 \u5728\u7b2c\u4e00\u6b65\u6211\u4eec\u5df2\u7ecf\u521b\u5efa\u4e86\u4e00\u4e2asocket\uff0c\u63a5\u7740\u6211\u4eec\u8c03\u7528\u8be5socket\u7684connect\u51fd\u6570\u5f00\u59cb\u53d1\u8d77\u8fde\u63a5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // \u5efa\u7acb\u8fde\u63a5\uff0c\u5373\u4e09\u6b21\u63e1\u624b Socket . prototype . connect = function (... args ) { let normalized ; /* \u5ffd\u7565\u53c2\u6570\u5904\u7406 */ var options = normalized [ 0 ]; var cb = normalized [ 1 ]; // TCP\u5728tcp_wrap.cc\u4e2d\u5b9a\u4e49 this . _handle = new TCP ( TCPConstants . SOCKET ); // \u6709\u6570\u636e\u53ef\u8bfb\u65f6\u7684\u56de\u8c03 this . _handle . onread = onread ; // \u8fde\u63a5\u6210\u529f\u65f6\u6267\u884c\u7684\u56de\u8c03 if ( cb !== null ) { this . once ( 'connect' , cb ); } // \u6b63\u5728\u8fde\u63a5 this . connecting = true ; this . writable = true ; // \u91cd\u7f6e\u5b9a\u65f6\u5668 this . _unrefTimer (); // \u53ef\u80fd\u9700\u8981DNS\u89e3\u6790\uff0c\u89e3\u6790\u6210\u529f\u518d\u53d1\u8d77\u8fde\u63a5 lookupAndConnect ( this , options ); return this ; }; connect \u51fd\u6570\u4e3b\u8981\u662f\u4e09\u4e2a\u903b\u8f91 1 \u9996\u5148\u901a\u8fc7new TCP()\u521b\u5efa\u4e00\u4e2a\u5e95\u5c42\u7684handle\uff0c\u6bd4\u5982\u6211\u4eec\u8fd9\u91cc\u662fTCP\uff08\u5bf9\u5e94tcp_wrap.cc\u7684\u5b9e\u73b0\uff09\u3002 2 \u8bbe\u7f6e\u4e00\u4e9b\u56de\u8c03 3 \u505aDNS\u89e3\u6790\uff08\u5982\u679c\u9700\u8981\u7684\u8bdd\uff09\uff0c\u7136\u540e\u53d1\u8d77\u4e09\u6b21\u63e1\u624b\u3002 \u6211\u4eec\u770b\u4e00\u4e0bnew TCP\u610f\u5473\u7740\u4ec0\u4e48\uff0c\u6211\u4eec\u770btcp_wrap.cc\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void TCPWrap::New ( const FunctionCallbackInfo < Value >& args ) { // \u8981\u4ee5new TCP\u7684\u5f62\u5f0f\u8c03\u7528 CHECK ( args . IsConstructCall ()); // \u7b2c\u4e00\u4e2a\u5165\u53c2\u662f\u6570\u5b57 CHECK ( args [ 0 ] -> IsInt32 ()); Environment * env = Environment :: GetCurrent ( args ); // \u4f5c\u4e3a\u5ba2\u6237\u7aef\u8fd8\u662f\u670d\u52a1\u5668 int type_value = args [ 0 ]. As < Int32 > () -> Value (); TCPWrap :: SocketType type = static_cast < TCPWrap :: SocketType > ( type_value ); ProviderType provider ; switch ( type ) { // \u4f5c\u4e3a\u5ba2\u6237\u7aef\uff0c\u5373\u53d1\u8d77\u8fde\u63a5\u65b9 case SOCKET : provider = PROVIDER_TCPWRAP ; break ; // \u4f5c\u4e3a\u670d\u52a1\u5668 case SERVER : provider = PROVIDER_TCPSERVERWRAP ; break ; default : UNREACHABLE (); } new TCPWrap ( env , args . This (), provider ); } new TCP\u5bf9\u5e94\u5230C++\u5c42\uff0c\u5c31\u662f\u521b\u5efa\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u3002\u5e76\u521d\u59cb\u5316\u5bf9\u8c61\u4e2d\u7684handle_\u5b57\u6bb5 1 2 3 4 5 6 TCPWrap :: TCPWrap ( Environment * env , Local < Object > object , ProviderType provider ) : ConnectionWrap ( env , object , provider ) { int r = uv_tcp_init ( env -> event_loop (), & handle_ ); } \u521d\u59cb\u5316\u5b8c\u5e95\u5c42\u7684\u6570\u636e\u7ed3\u6784\u540e\uff0c\u6211\u4eec\u7ee7\u7eed\u770blookupAndConnect\uff0clookupAndConnect\u4e3b\u8981\u662f\u5bf9\u53c2\u6570\u8fdb\u884c\u6821\u9a8c\uff0c\u7136\u540e\u8fdb\u884cDNS\u89e3\u6790\uff08\u5982\u679c\u4f20\u7684\u662f\u57df\u540d\u7684\u8bdd\uff09\uff0cDNS\u89e3\u6790\u6210\u529f\u540e\u6267\u884cinternalConnect 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 function internalConnect ( self , // \u9700\u8981\u8fde\u63a5\u7684\u8fdc\u7aefIP\u3001\u7aef\u53e3 address , port , addressType , /* \u7528\u4e8e\u548c\u5bf9\u7aef\u8fde\u63a5\u7684\u672c\u5730IP\u3001\u7aef\u53e3\uff08\u5982\u679c\u4e0d\u8bbe\u7f6e\uff0c \u5219\u64cd\u4f5c\u7cfb\u7edf\u81ea\u5df1\u51b3\u5b9a\uff09 */ localAddress , localPort ) { var err ; /* \u5982\u679c\u4f20\u4e86\u672c\u5730\u7684\u5730\u5740\u6216\u7aef\u53e3\uff0c\u5219TCP\u8fde\u63a5\u4e2d\u7684\u6e90IP \u548c\u7aef\u53e3\u5c31\u662f\u4f20\u7684\uff0c\u5426\u5219\u7531\u64cd\u4f5c\u7cfb\u7edf\u81ea\u5df1\u9009 */ if ( localAddress || localPort ) { // IP v4 if ( addressType === 4 ) { localAddress = localAddress || '0.0.0.0' ; // \u7ed1\u5b9a\u5730\u5740\u548c\u7aef\u53e3\u5230handle err = self . _handle . bind ( localAddress , localPort ); } else if ( addressType === 6 ) { localAddress = localAddress || '::' ; err = self . _handle . bind6 ( localAddress , localPort ); } // \u7ed1\u5b9a\u662f\u5426\u6210\u529f err = checkBindError ( err , localPort , self . _handle ); if ( err ) { const ex = exceptionWithHostPort ( err , 'bind' , localAddress , localPort ); self . destroy ( ex ); return ; } } // \u5bf9\u7aef\u7684\u5730\u5740\u4fe1\u606f if ( addressType === 6 || addressType === 4 ) { // \u65b0\u5efa\u4e00\u4e2a\u8bf7\u6c42\u5bf9\u8c61\uff0cC++\u5c42\u5b9a\u4e49 const req = new TCPConnectWrap (); // \u8bbe\u7f6e\u4e00\u4e9b\u5217\u5c5e\u6027 req . oncomplete = afterConnect ; req . address = address ; req . port = port ; req . localAddress = localAddress ; req . localPort = localPort ; // \u8c03\u7528\u5e95\u5c42\u5bf9\u5e94\u7684\u51fd\u6570 if ( addressType === 4 ) err = self . _handle . connect ( req , address , port ); else err = self . _handle . connect6 ( req , address , port ); } /* \u975e\u963b\u585e\u8c03\u7528\uff0c\u53ef\u80fd\u5728\u8fd8\u6ca1\u53d1\u8d77\u4e09\u6b21\u63e1\u624b\u4e4b\u524d\u5c31\u62a5\u9519\u4e86\uff0c \u800c\u4e0d\u662f\u4e09\u6b21\u63e1\u624b\u51fa\u9519\uff0c\u8fd9\u91cc\u8fdb\u884c\u51fa\u9519\u5904\u7406 */ if ( err ) { // \u83b7\u53d6socket\u5bf9\u5e94\u7684\u5e95\u5c42IP\u7aef\u53e3\u4fe1\u606f var sockname = self . _getsockname (); var details ; if ( sockname ) { details = sockname . address + ':' + sockname . port ; } // \u6784\u9020\u9519\u8bef\u4fe1\u606f\uff0c\u9500\u9b42socket\u5e76\u89e6\u53d1error\u4e8b\u4ef6 const ex = exceptionWithHostPort ( err , 'connect' , address , port , details ); self . destroy ( ex ); } } \u8fd9\u91cc\u7684\u4ee3\u7801\u6bd4\u8f83\u591a\uff0c\u9664\u4e86\u9519\u8bef\u5904\u7406\u5916\uff0c\u4e3b\u8981\u7684\u903b\u8f91\u662fbind\u548cconnect\u3002bind\u51fd\u6570\u7684\u903b\u8f91\u5f88\u7b80\u5355\uff08\u5373\u4f7f\u662f\u5e95\u5c42\u7684bind\uff09\uff0c\u5b83\u5c31\u662f\u5728\u5e95\u5c42\u7684\u4e00\u4e2a\u7ed3\u6784\u4f53\u4e0a\u8bbe\u7f6e\u4e86\u4e24\u4e2a\u5b57\u6bb5\u7684\u503c\u3002\u6240\u4ee5\u6211\u4eec\u4e3b\u8981\u6765\u5206\u6790connect\u3002\u6211\u4eec\u628a\u5173\u4e8econnect\u7684\u8fd9\u6bb5\u903b\u8f91\u62ce\u51fa\u6765\u3002 1 2 3 4 5 6 7 8 9 const req = new TCPConnectWrap (); // \u8bbe\u7f6e\u4e00\u4e9b\u5217\u5c5e\u6027 req . oncomplete = afterConnect ; req . address = address ; req . port = port ; req . localAddress = localAddress ; req . localPort = localPort ; // \u8c03\u7528\u5e95\u5c42\u5bf9\u5e94\u7684\u51fd\u6570 self . _handle . connect ( req , address , port ); TCPConnectWrap\u662fC++\u5c42\u63d0\u4f9b\u7684\u7c7b\uff0cconnect\u5bf9\u5e94C++\u5c42\u7684Conenct\uff0c \u524d\u9762\u7684\u7ae0\u8282\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4e0d\u518d\u5177\u4f53\u5206\u6790\u3002\u8fde\u63a5\u5b8c\u6210\u540e\uff0c\u56de\u8c03\u51fd\u6570\u662fuv__stream_io\u3002\u5728uv__stream_io\u91cc\u4f1a\u8c03\u7528connect_req\u4e2d\u7684\u56de\u8c03\u3002\u5047\u8bbe\u8fde\u63a5\u5efa\u7acb\uff0c\u8fd9\u65f6\u5019\u5c31\u4f1a\u6267\u884cC++\u5c42\u7684AfterConnect\u3002AfterConnect\u4f1a\u6267\u884cJS\u5c42\u7684afterConnect\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // \u8fde\u63a5\u540e\u6267\u884c\u7684\u56de\u8c03\uff0c\u6210\u529f\u6216\u5931\u8d25 function afterConnect ( status , handle , req , readable , writable ) { // handle\u5173\u8054\u7684socket var self = handle . owner ; // \u8fde\u63a5\u8fc7\u7a0b\u4e2d\u6267\u884c\u4e86socket\u88ab\u9500\u6bc1\u4e86\uff0c\u5219\u4e0d\u9700\u8981\u7ee7\u7eed\u5904\u7406 if ( self . destroyed ) { return ; } handle = self . _handle ; self . connecting = false ; self . _sockname = null ; // \u8fde\u63a5\u6210\u529f if ( status === 0 ) { // \u8bbe\u7f6e\u8bfb\u5199\u5c5e\u6027 self . readable = readable ; self . writable = writable ; // socket\u5f53\u524d\u6d3b\u8dc3\uff0c\u91cd\u7f6e\u5b9a\u65f6\u5668 self . _unrefTimer (); // \u89e6\u53d1\u8fde\u63a5\u6210\u529f\u4e8b\u4ef6 self . emit ( 'connect' ); // socket\u53ef\u8bfb\u5e76\u4e14\u6ca1\u6709\u8bbe\u7f6e\u6682\u505c\u6a21\u5f0f\uff0c\u5219\u5f00\u542f\u8bfb if ( readable && ! self . isPaused ()) self . read ( 0 ); } else { // \u8fde\u63a5\u5931\u8d25\uff0c\u62a5\u9519\u5e76\u9500\u6bc1socket self . connecting = false ; var details ; // \u63d0\u793a\u51fa\u9519\u4fe1\u606f if ( req . localAddress && req . localPort ) { details = req . localAddress + ':' + req . localPort ; } var ex = exceptionWithHostPort ( status , 'connect' , req . address , req . port , details ); if ( details ) { ex . localAddress = req . localAddress ; ex . localPort = req . localPort ; } // \u9500\u6bc1socket self . destroy ( ex ); } } \u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u8fde\u63a5\u6210\u529f\u540e\uff0cJS\u5c42\u8c03\u7528self.read(0)\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\u3002 17.1.2 \u8bfb\u64cd\u4f5c \u00b6 \u6211\u4eec\u770b\u4e00\u4e0bsocket\u7684\u8bfb\u64cd\u4f5c\u903b\u8f91\uff0c\u5728\u8fde\u63a5\u6210\u529f\u540e\uff0csocket\u4f1a\u901a\u8fc7read\u51fd\u6570\u5728\u5e95\u5c42\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u7b49\u5f85\u5e95\u5c42\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u901a\u77e5\u6709\u6570\u636e\u53ef\u8bfb\u3002 1 2 3 4 5 6 7 8 Socket . prototype . read = function ( n ) { if ( n === 0 ) return stream . Readable . prototype . read . call ( this , n ); this . read = stream . Readable . prototype . read ; this . _consuming = true ; return this . read ( n ); }; \u8fd9\u91cc\u4f1a\u6267\u884cReadable\u6a21\u5757\u7684read\u51fd\u6570\uff0c\u4ece\u800c\u6267\u884c_read\u51fd\u6570\uff0c_read\u51fd\u6570\u662f\u7531\u5b50\u7c7b\u5b9e\u73b0\u3002\u6240\u4ee5\u6211\u4eec\u770bSocket\u7684_read 1 2 3 4 5 6 7 8 9 10 11 12 Socket . prototype . _read = function ( n ) { // \u8fd8\u6ca1\u5efa\u7acb\u8fde\u63a5\uff0c\u5219\u5efa\u7acb\u540e\u518d\u6267\u884c if ( this . connecting || ! this . _handle ) { this . once ( 'connect' , () => this . _read ( n )); } else if ( ! this . _handle . reading ) { this . _handle . reading = true ; // \u6267\u884c\u5e95\u5c42\u7684readStart\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 var err = this . _handle . readStart (); if ( err ) this . destroy ( errnoException ( err , 'read' )); } }; \u4f46\u662f\u6211\u4eec\u53d1\u73b0tcp_wrap.cc\u6ca1\u6709readStart\u51fd\u6570\u3002\u4e00\u8def\u5f80\u7236\u7c7b\u627e\uff0c\u6700\u7ec8\u5728stream_wrap.cc\u627e\u5230\u4e86\u8be5\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // \u6ce8\u518c\u8bfb\u4e8b\u4ef6 int LibuvStreamWrap::ReadStart () { return uv_read_start ( stream (), []( uv_handle_t * handle , size_t suggested_size , uv_buf_t * buf ) { // \u5206\u914d\u5b58\u50a8\u6570\u636e\u7684\u5185\u5b58 static_cast < LibuvStreamWrap *> ( handle -> data ) -> OnUvAlloc ( suggested_size , buf ); }, []( uv_stream_t * stream , ssize_t nread , const uv_buf_t * buf ) { // \u8bfb\u53d6\u6570\u636e\u6210\u529f\u7684\u56de\u8c03 static_cast < LibuvStreamWrap *> ( stream -> data ) -> OnUvRead ( nread , buf ); }); } uv_read_start\u51fd\u6570\u5728\u6d41\u7ae0\u8282\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4f5c\u7528\u5c31\u662f\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u8fd9\u91cc\u5c31\u4e0d\u518d\u6df1\u5165\u3002OnUvAlloc\u662f\u5206\u914d\u5b58\u50a8\u6570\u636e\u7684\u51fd\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u4e0d\u5173\u6ce8\uff0c\u6211\u4eec\u770b\u4e00\u4e0bOnUvRead\uff0c\u5f53\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\u4f1a\u6267\u884cOnUvRead 1 2 3 4 5 6 void LibuvStreamWrap::OnUvRead ( ssize_t nread , const uv_buf_t * buf ) { HandleScope scope ( env () -> isolate ()); Context :: Scope context_scope ( env () -> context ()); // \u89e6\u53d1onread\u4e8b\u4ef6 EmitRead ( nread , * buf ); } OnUvRead\u51fd\u6570\u89e6\u53d1onread\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 function onread ( nread , buffer ) { var handle = this ; // handle\u5173\u8054\u7684socket var self = handle . owner ; // socket\u6709\u6570\u636e\u5230\u6765\uff0c\u5904\u4e8e\u6d3b\u8dc3\u72b6\u6001\uff0c\u91cd\u7f6e\u5b9a\u65f6\u5668 self . _unrefTimer (); // \u6210\u529f\u8bfb\u53d6\u6570\u636e if ( nread > 0 ) { // push\u5230\u6d41\u4e2d var ret = self . push ( buffer ); /* push\u8fd4\u56defalse\uff0c\u8bf4\u660e\u7f13\u5b58\u7684\u6570\u636e\u5df2\u7ecf\u8fbe\u5230\u9608\u503c\uff0c \u4e0d\u80fd\u518d\u89e6\u53d1\u8bfb\uff0c\u9700\u8981\u6ce8\u9500\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 */ if ( handle . reading && ! ret ) { handle . reading = false ; var err = handle . readStop (); if ( err ) self . destroy ( errnoException ( err , 'read' )); } return ; } // \u6ca1\u6709\u6570\u636e\uff0c\u5ffd\u7565 if ( nread === 0 ) { debug ( 'not any data, keep waiting' ); return ; } // \u4e0d\u7b49\u4e8e\u7ed3\u675f\uff0c\u5219\u8bfb\u51fa\u9519\uff0c\u9500\u6bc1\u6d41 if ( nread !== UV_EOF ) { return self . destroy ( errnoException ( nread , 'read' )); } // \u6d41\u7ed3\u675f\u4e86\uff0c\u6ca1\u6709\u6570\u636e\u8bfb\u4e86 self . push ( null ); /* \u4e5f\u6ca1\u6709\u7f13\u5b58\u7684\u6570\u636e\u4e86\uff0c\u53ef\u80fd\u9700\u8981\u9500\u6bc1\u6d41\uff0c\u6bd4\u5982\u662f\u53ea\u8bfb\u6d41\uff0c \u6216\u8005\u53ef\u8bfb\u5199\u6d41\uff0c\u5199\u7aef\u4e5f\u6ca1\u6709\u6570\u636e\u4e86\uff0c\u53c2\u8003maybeDestroy */ if ( self . readableLength === 0 ) { self . readable = false ; maybeDestroy ( self ); } // \u89e6\u53d1\u4e8b\u4ef6 self . emit ( '_socketEnd' ); } socket\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\u5927\u6982\u6709\u4e0b\u9762\u51e0\u79cd\u60c5\u51b5 1 \u6709\u6709\u6548\u6570\u636e\u53ef\u8bfb\uff0cpush\u5230\u6d41\u4e2d\uff0c\u89e6\u53d1ondata\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u3002 2 \u6ca1\u6709\u6709\u6548\u6570\u636e\u53ef\u8bfb\uff0c\u5ffd\u7565\u3002 3 \u8bfb\u51fa\u9519\uff0c\u9500\u6bc1\u6d41 4 \u8bfb\u7ed3\u675f\u3002 \u6211\u4eec\u5206\u6790\u4e00\u4e0b4\u3002\u5728\u65b0\u5efa\u4e00\u4e2asocket\u7684\u65f6\u5019\u6ce8\u518c\u4e86\u6d41\u7ed3\u675f\u7684\u5904\u7406\u51fd\u6570onSocketEnd\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // \u8bfb\u7ed3\u675f\u540e\u6267\u884c\u7684\u51fd\u6570 function onSocketEnd () { // \u8bfb\u7ed3\u675f\u6807\u8bb0 this . _readableState . ended = true ; /* \u5df2\u7ecf\u89e6\u53d1\u8fc7end\u4e8b\u4ef6\uff0c\u5219\u5224\u65ad\u662f\u5426\u9700\u8981\u9500\u6bc1\uff0c\u53ef\u80fd\u8fd8\u6709\u5199\u7aef */ if ( this . _readableState . endEmitted ) { this . readable = false ; maybeDestroy ( this ); } else { // \u8fd8\u6ca1\u6709\u89e6\u53d1end\u5219\u7b49\u5f85\u89e6\u53d1end\u4e8b\u4ef6\u518d\u6267\u884c\u4e0b\u4e00\u6b65\u64cd\u4f5c this . once ( 'end' , function end () { this . readable = false ; maybeDestroy ( this ); }); /* \u6267\u884cread\uff0c\u5982\u679c\u6d41\u4e2d\u6ca1\u6709\u7f13\u5b58\u7684\u6570\u636e\u5219\u4f1a\u89e6\u53d1end\u4e8b\u4ef6\uff0c \u5426\u5219\u7b49\u5f85\u6d88\u8d39\u5b8c\u540e\u518d\u89e6\u53d1 */ this . read ( 0 ); } /* 1 \u8bfb\u7ed3\u675f\u540e\uff0c\u5982\u679c\u4e0d\u5141\u8bb8\u534a\u5f00\u5173\uff0c\u5219\u5173\u95ed\u5199\u7aef\uff0c\u5982\u679c\u8fd8\u6709\u6570\u636e\u8fd8\u6ca1\u6709\u53d1\u9001 \u5b8c\u6bd5\uff0c\u5219\u5148\u53d1\u9001\u5b8c\u518d\u5173\u95ed 2 \u91cd\u7f6e\u5199\u51fd\u6570\uff0c\u540e\u7eed\u6267\u884c\u5199\u7684\u65f6\u5019\u62a5\u9519 */ if ( ! this . allowHalfOpen ) { this . write = writeAfterFIN ; this . destroySoon (); } } \u5f53socket\u7684\u8bfb\u7aef\u7ed3\u675f\u65f6\uff0csocket\u7684\u72b6\u6001\u53d8\u66f4\u5206\u4e3a\u51e0\u79cd\u60c5\u51b5 1 \u5982\u679c\u53ef\u8bfb\u6d41\u4e2d\u8fd8\u6709\u7f13\u5b58\u7684\u6570\u636e\uff0c\u5219\u7b49\u5f85\u8bfb\u53d6\u3002 2 \u5982\u679c\u5199\u7aef\u4e5f\u7ed3\u675f\u4e86\uff0c\u5219\u9500\u6bc1\u6d41\u3002 3 \u5982\u679c\u5199\u7aef\u6ca1\u6709\u7ed3\u675f\uff0c\u5219\u5224\u65adallowHalfOpen\u662f\u5426\u5141\u8bb8\u534a\u5f00\u5173\uff0c\u4e0d\u5141\u8bb8\u5e76\u4e14\u5199\u7aef\u6570\u636e\u5df2\u7ecf\u53d1\u9001\u5b8c\u6bd5\u5219\u5173\u95ed\u5199\u7aef\u3002 17.1.3 \u5199\u64cd\u4f5c \u00b6 \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u5728\u4e00\u4e2a\u6d41\u4e0a\u5199\u7684\u65f6\u5019\uff0c\u903b\u8f91\u662f\u600e\u6837\u7684\u3002Socket\u5b9e\u73b0\u4e86\u5355\u4e2a\u5199\u548c\u6279\u91cf\u5199\u63a5\u53e3\u3002 1 2 3 4 5 6 7 8 9 // \u6279\u91cf\u5199 Socket . prototype . _writev = function ( chunks , cb ) { this . _writeGeneric ( true , chunks , '' , cb ); }; // \u5355\u4e2a\u5199 Socket . prototype . _write = function ( data , encoding , cb ) { this . _writeGeneric ( false , data , encoding , cb ); }; _writeGeneric 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 Socket . prototype . _writeGeneric = function ( writev , data , encoding , cb ) { /* \u6b63\u5728\u8fde\u63a5\uff0c\u5219\u5148\u4fdd\u5b58\u5f85\u5199\u7684\u6570\u636e\uff0c\u56e0\u4e3astream\u6a21\u5757\u662f\u4e32\u884c\u5199\u7684\uff0c \u6240\u4ee5\u7b2c\u4e00\u6b21\u5199\u6ca1\u5b8c\u6210\uff0c\u4e0d\u4f1a\u6267\u884c\u7b2c\u4e8c\u6b21\u5199\u64cd\u4f5c\uff08_write\uff09\uff0c \u6240\u4ee5\u8fd9\u91cc\u7528\u4e00\u4e2a\u5b57\u6bb5\u800c\u4e0d\u662f\u4e00\u4e2a\u6570\u7ec4\u6216\u961f\u5217\u4fdd\u5b58\u6570\u636e\u548c\u7f16\u7801\uff0c \u56e0\u4e3a\u6709pendingData\u65f6_writeGeneric \u4e0d\u4f1a\u88ab\u6267\u884c\u7b2c\u4e8c\u6b21\uff0c\u8fd9\u91cc\u7f13\u5b58 pendingData\u4e0d\u662f\u4e3a\u4e86\u540e\u7eed\u5199\u5165\uff0c\u800c\u662f\u4e3a\u4e86\u7edf\u8ba1\u5199\u5165\u7684\u6570\u636e\u603b\u6570 */ if ( this . connecting ) { this . _pendingData = data ; this . _pendingEncoding = encoding ; this . once ( 'connect' , function connect () { this . _writeGeneric ( writev , data , encoding , cb ); }); return ; } // \u5f00\u59cb\u5199\uff0c\u5219\u6e05\u7a7a\u4e4b\u524d\u7f13\u5b58\u7684\u6570\u636e this . _pendingData = null ; this . _pendingEncoding = '' ; // \u5199\u64cd\u4f5c\uff0c\u6709\u6570\u636e\u901a\u4fe1\uff0c\u5237\u65b0\u5b9a\u65f6\u5668 this . _unrefTimer (); // \u5df2\u7ecf\u5173\u95ed\uff0c\u5219\u9500\u6bc1socket if ( ! this . _handle ) { this . destroy ( new errors . Error ( 'ERR_SOCKET_CLOSED' ), cb ); return false ; } // \u65b0\u5efa\u4e00\u4e2a\u5199\u8bf7\u6c42 var req = new WriteWrap (); req . handle = this . _handle ; req . oncomplete = afterWrite ; // \u662f\u5426\u540c\u6b65\u6267\u884c\u5199\u5b8c\u6210\u56de\u8c03\uff0c\u53d6\u51b3\u4e8e\u5e95\u5c42\u662f\u540c\u6b65\u5199\u5165\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03\u8fd8\u662f\u5f02\u6b65\u5199\u5165 req . async = false ; var err ; // \u662f\u5426\u6279\u91cf\u5199 if ( writev ) { // \u6240\u6709\u6570\u636e\u90fd\u662fbuffer\u7c7b\u578b\uff0c\u5219\u76f4\u63a5\u5806\u8d77\u6765\uff0c\u5426\u5219\u9700\u8981\u4fdd\u5b58\u7f16\u7801\u7c7b\u578b var allBuffers = data . allBuffers ; var chunks ; var i ; if ( allBuffers ) { chunks = data ; for ( i = 0 ; i < data . length ; i ++ ) data [ i ] = data [ i ]. chunk ; } else { // \u7533\u8bf7double\u4e2a\u5927\u5c0f\u7684\u6570\u7ec4 chunks = new Array ( data . length << 1 ); for ( i = 0 ; i < data . length ; i ++ ) { var entry = data [ i ]; chunks [ i * 2 ] = entry . chunk ; chunks [ i * 2 + 1 ] = entry . encoding ; } } err = this . _handle . writev ( req , chunks , allBuffers ); // Retain chunks if ( err === 0 ) req . _chunks = chunks ; } else { var enc ; if ( data instanceof Buffer ) { enc = 'buffer' ; } else { enc = encoding ; } err = createWriteReq ( req , this . _handle , data , enc ); } if ( err ) return this . destroy ( errnoException ( err , 'write' , req . error ), cb ); // \u8bf7\u6c42\u5199\u5165\u5e95\u5c42\u7684\u6570\u636e\u5b57\u8282\u957f\u5ea6 this . _bytesDispatched += req . bytes ; // \u5728stream_base.cc\u4e2dreq_wrap_obj->Set(env->async(), True(env->isolate()));\u8bbe\u7f6e if ( ! req . async ) { cb (); return ; } req . cb = cb ; // \u6700\u540e\u4e00\u6b21\u8bf7\u6c42\u5199\u6570\u636e\u7684\u5b57\u8282\u957f\u5ea6 this [ kLastWriteQueueSize ] = req . bytes ; }; \u4e0a\u9762\u7684\u4ee3\u7801\u5f88\u591a\uff0c\u4f46\u662f\u903b\u8f91\u5e76\u4e0d\u590d\u6742\uff0c\u5177\u4f53\u5b9e\u73b0\u5728stream_base.cc\u548cstream_wrap.cc\uff0c\u8fd9\u91cc\u4e0d\u518d\u5c55\u5f00\u5206\u6790\uff0c\u4e3b\u8981\u662f\u6267\u884cwritev\u548ccreateWriteReq\u51fd\u6570\u8fdb\u884c\u5199\u64cd\u4f5c\u3002\u5b83\u4eec\u5e95\u5c42\u8c03\u7528\u7684\u90fd\u662fuv_write2\uff08\u9700\u8981\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\uff09\u6216uv_write\uff08\u4e0d\u9700\u8981\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\uff09\u6216\u8005uv_try_write\u51fd\u6570\u8fdb\u884c\u5199\u64cd\u4f5c\u3002\u8fd9\u91cc\u53ea\u5206\u6790\u4e00\u4e0basync\u7684\u610f\u4e49\uff0casync\u9ed8\u8ba4\u662ffalse\uff0c\u5b83\u8868\u793a\u7684\u610f\u4e49\u662f\u6267\u884c\u5e95\u5c42\u5199\u5165\u65f6\uff0c\u5e95\u5c42\u662f\u5426\u540c\u6b65\u6267\u884c\u56de\u8c03\uff0casync\u4e3afalse\u8bf4\u660e\u5199\u5165\u5b8c\u6210\u56de\u8c03\u662f\u540c\u6b65\u6267\u884c\u7684\u3002\u5728stream_base.cc\u7684\u5199\u51fd\u6570\u4e2d\u6709\u76f8\u5173\u7684\u903b\u8f91\u3002 1 2 err = DoWrite ( req_wrap , buf_list , count , nullptr ); req_wrap_obj -> Set ( env -> async (), True ( env -> isolate ())); \u5f53\u6267\u884cDoWrite\u7684\u65f6\u5019\uff0creq_wrap\u4e2d\u4fdd\u5b58\u7684\u56de\u8c03\u53ef\u80fd\u4f1a\u88abLibuv\u540c\u6b65\u6267\u884c\uff0c\u4ece\u800c\u6267\u884cJS\u4ee3\u7801\uff0c\u8fd9\u65f6\u5019async\u662ffalse\uff08\u9ed8\u8ba4\u503c\uff09\uff0c\u8bf4\u660e\u56de\u8c03\u662f\u88ab\u540c\u6b65\u6267\u884c\u7684\uff0c\u5982\u679cDoWrite\u6ca1\u6709\u540c\u6b65\u6267\u884c\u56de\u8c03\u3002\u5219\u8bf4\u660e\u662f\u5f02\u6b65\u6267\u884c\u56de\u8c03\u3002\u8bbe\u7f6easync\u4e3atrue\uff0c\u518d\u6267\u884cJS\u4ee3\u7801\u3002 17.1.4 \u5173\u95ed\u5199\u64cd\u4f5c \u00b6 \u5f53\u6211\u4eec\u53d1\u9001\u5b8c\u6570\u636e\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528socket\u5bf9\u8c61\u7684end\u51fd\u6570\u5173\u95ed\u6d41\u7684\u5199\u7aef\u3002\u6211\u4eec\u770b\u4e00\u4e0bend\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 Socket . prototype . end = function ( data , encoding , callback ) { stream . Duplex . prototype . end . call ( this , data , encoding , callback ); return this ; }; Socket\u7684end\u662f\u8c03\u7528\u7684Duplex\u7684end\uff0c\u800cDuplex\u7684end\u662f\u7ee7\u627f\u4e8eWritable\u7684end\u3002Writable\u7684end\u6700\u7ec8\u4f1a\u89e6\u53d1finish\u4e8b\u4ef6\uff0csocket\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u76d1\u542c\u4e86\u8be5\u4e8b\u4ef6\u3002 1 this . on ( 'finish' , onSocketFinish ); \u6211\u4eec\u770b\u770bonSocketFinish\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // \u6267\u884c\u4e86end\uff0c\u5e76\u4e14\u6570\u636e\u53d1\u9001\u5b8c\u6bd5\uff0c\u5219\u5173\u95ed\u5199\u7aef function onSocketFinish () { // \u8fd8\u6ca1\u8fde\u63a5\u6210\u529f\u5c31\u6267\u884c\u4e86end if ( this . connecting ) { return this . once ( 'connect' , onSocketFinish ); } // \u5199\u7ed3\u675f\u4e86\uff0c\u5982\u679c\u4e5f\u4e0d\u80fd\u8bfb\u6216\u8005\u8bfb\u7ed3\u675f\u4e86\uff0c\u5219\u9500\u6bc1socket if ( ! this . readable || this . _readableState . ended ) { return this . destroy (); } // \u4e0d\u652f\u6301shutdown\u5219\u76f4\u63a5\u9500\u6bc1 if ( ! this . _handle || ! this . _handle . shutdown ) return this . destroy (); // \u652f\u6301shutdown\u5219\u6267\u884c\u5173\u95ed\uff0c\u5e76\u8bbe\u7f6e\u56de\u8c03 var err = defaultTriggerAsyncIdScope ( this [ async_id_symbol ], shutdownSocket , this , afterShutdown ); // \u6267\u884cshutdown\u5931\u8d25\u5219\u76f4\u63a5\u9500\u6bc1 if ( err ) return this . destroy ( errnoException ( err , 'shutdown' )); } // \u53d1\u9001\u5173\u95ed\u5199\u7aef\u7684\u8bf7\u6c42 function shutdownSocket ( self , callback ) { var req = new ShutdownWrap (); req . oncomplete = callback ; req . handle = self . _handle ; return self . _handle . shutdown ( req ); } Shutdown\u51fd\u6570\u5728stream_base.cc\u4e2d\u5b9a\u4e49\uff0c\u6700\u7ec8\u8c03\u7528uv_shutdown\u5173\u95ed\u6d41\u7684\u5199\u7aef\uff0c\u5728Libuv\u6d41\u7ae0\u8282\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u5173\u95ed\u5199\u7aef\u540e\uff0c\u56de\u8c03\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // \u5173\u95ed\u5199\u7aef\u6210\u529f\u540e\u7684\u56de\u8c03 function afterShutdown ( status , handle , req ) { // handle\u5173\u8054\u7684socket var self = handle . owner ; // \u5df2\u7ecf\u9500\u6bc1\u4e86\uff0c\u5219\u4e0d\u9700\u8981\u5f80\u4e0b\u8d70\u4e86\uff0c\u5426\u5219\u6267\u884c\u9500\u6bc1\u64cd\u4f5c if ( self . destroyed ) return ; // \u5199\u5173\u95ed\u6210\u529f\uff0c\u5e76\u4e14\u8bfb\u4e5f\u7ed3\u675f\u4e86\uff0c\u5219\u9500\u6bc1socket\uff0c\u5426\u5219\u7b49\u5f85\u8bfb\u7ed3\u675f\u518d\u6267\u884c\u9500\u6bc1 if ( self . _readableState . ended ) { self . destroy (); } else { self . once ( '_socketEnd' , self . destroy ); } } 17.1.5 \u9500\u6bc1 \u00b6 \u5f53\u4e00\u4e2asocket\u4e0d\u53ef\u8bfb\u4e5f\u4e0d\u53ef\u5199\u7684\u65f6\u5019\u3001\u88ab\u5173\u95ed\u3001\u53d1\u751f\u9519\u8bef\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u88ab\u9500\u6bc1\u3002\u9500\u6bc1\u4e00\u4e2a\u6d41\u5c31\u662f\u9500\u6bc1\u6d41\u7684\u8bfb\u7aef\u3001\u5199\u7aef\u3002\u7136\u540e\u6267\u884c\u6d41\u5b50\u7c7b\u7684_destory\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0bsocket\u7684_destroy\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // \u9500\u6bc1\u65f6\u6267\u884c\u7684\u94a9\u5b50\u51fd\u6570\uff0cexception\u4ee3\u8868\u662f\u5426\u56e0\u4e3a\u9519\u8bef\u5bfc\u81f4\u7684\u9500\u6bc1 Socket . prototype . _destroy = function ( exception , cb ) { this . connecting = false ; this . readable = this . writable = false ; // \u6e05\u9664\u5b9a\u65f6\u5668 for ( var s = this ; s !== null ; s = s . _parent ) { clearTimeout ( s [ kTimeout ]); } if ( this . _handle ) { // \u662f\u5426\u56e0\u4e3a\u51fa\u9519\u5bfc\u81f4\u9500\u6bc1\u6d41 var isException = exception ? true : false ; // \u5173\u95ed\u5e95\u5c42handle this . _handle . close (() => { // close\u4e8b\u4ef6\u7684\u5165\u53c2\uff0c\u8868\u793a\u662f\u5426\u56e0\u4e3a\u9519\u8bef\u5bfc\u81f4\u7684\u5173\u95ed this . emit ( 'close' , isException ); }); this . _handle . onread = noop ; this . _handle = null ; this . _sockname = null ; } // \u6267\u884c\u56de\u8c03 cb ( exception ); // socket\u6240\u5c5e\u7684server\uff0c\u4f5c\u4e3a\u5ba2\u6237\u7aef\u65f6\u662fnull if ( this . _server ) { // server\u4e0b\u7684\u8fde\u63a5\u6570\u51cf\u4e00 this . _server . _connections -- ; /* \u662f\u5426\u9700\u8981\u89e6\u53d1server\u7684close\u4e8b\u4ef6\uff0c \u5f53\u6240\u6709\u7684\u8fde\u63a5\uff08socket\uff09\u90fd\u5173\u95ed\u65f6\u624d\u89e6\u53d1server\u7684\u662fclose\u4e8b\u4ef6 */ if ( this . _server . _emitCloseIfDrained ) { this . _server . _emitCloseIfDrained (); } } }; _stream_writable.js\u4e2d\u7684destroy\u51fd\u6570\u53ea\u662f\u4fee\u6539\u8bfb\u5199\u6d41\u7684\u72b6\u6001\u548c\u6807\u8bb0\uff0c\u5b50\u7c7b\u9700\u8981\u5b9a\u4e49_destroy\u51fd\u6570\u9500\u6bc1\u76f8\u5173\u7684\u8d44\u6e90\uff0csocket\u901a\u8fc7\u8c03\u7528close\u5173\u95ed\u5e95\u5c42\u5173\u8054\u7684\u8d44\u6e90\uff0c\u5173\u95ed\u540e\u89e6\u53d1socket\u7684close\u4e8b\u4ef6\uff08\u56de\u8c03\u51fd\u6570\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u662fboolean\u7c7b\u578b\uff0c\u8bf4\u660e\u662f\u5426\u56e0\u4e3a\u9519\u8bef\u5bfc\u81f4socket\u5173\u95ed\uff09\u3002\u6700\u540e\u5224\u65ad\u8be5socket\u662f\u5426\u6765\u81ea\u670d\u52a1\u5668\u521b\u5efa\u7684\uff0c\u662f\u7684\u8bdd\u8be5\u670d\u52a1\u5668\u7684\u8fde\u63a5\u6570\u51cf\u4e00\uff0c\u5982\u679c\u670d\u52a1\u5668\u6267\u884c\u4e86close\u5e76\u4e14\u5f53\u524d\u8fde\u63a5\u6570\u4e3a0\uff0c\u5219\u5173\u95ed\u670d\u52a1\u5668\u3002 17.2 TCP \u670d\u52a1\u5668 \u00b6 net\u6a21\u5757\u63d0\u4f9b\u4e86createServer\u51fd\u6570\u521b\u5efa\u4e00\u4e2aTCP\u670d\u52a1\u5668\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 function createServer ( options , connectionListener ) { return new Server ( options , connectionListener ); } function Server ( options , connectionListener ) { EventEmitter . call ( this ); // \u6ce8\u518c\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c\u7684\u56de\u8c03 if ( typeof options === 'function' ) { connectionListener = options ; options = {}; this . on ( 'connection' , connectionListener ); } else if ( options == null || typeof options === 'object' ) { options = options || {}; if ( typeof connectionListener === 'function' ) { this . on ( 'connection' , connectionListener ); } } else { throw new errors . TypeError ( 'ERR_INVALID_ARG_TYPE' , 'options' , 'Object' , options ); } // \u670d\u52a1\u5668\u5efa\u7acb\u7684\u8fde\u63a5\u6570 this . _connections = 0 ; this . _handle = null ; this . _unref = false ; // \u670d\u52a1\u5668\u4e0b\u7684\u6240\u6709\u8fde\u63a5\u662f\u5426\u5141\u8bb8\u534a\u8fde\u63a5 this . allowHalfOpen = options . allowHalfOpen || false ; // \u6709\u8fde\u63a5\u65f6\u662f\u5426\u6ce8\u518c\u8bfb\u4e8b\u4ef6 this . pauseOnConnect = !! options . pauseOnConnect ; } createServer\u8fd4\u56de\u7684\u5c31\u662f\u4e00\u4e2a\u4e00\u822c\u7684JS\u5bf9\u8c61\uff0c\u63a5\u7740\u8c03\u7528listen\u51fd\u6570\u76d1\u542c\u7aef\u53e3\u3002\u770b\u4e00\u4e0blisten\u51fd\u6570\u7684\u903b\u8f91 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 Server . prototype . listen = function (... args ) { /* \u5904\u7406\u5165\u53c2\uff0c\u6839\u636e\u6587\u6863\u6211\u4eec\u77e5\u9053listen\u53ef\u4ee5\u63a5\u6536\u597d\u51e0\u4e2a\u53c2\u6570\uff0c \u5047\u8bbe\u6211\u4eec\u8fd9\u91cc\u662f\u53ea\u4f20\u4e86\u7aef\u53e3\u53f79297 */ var normalized = normalizeArgs ( args ); // normalized = [{port: 9297}, null]; var options = normalized [ 0 ]; var cb = normalized [ 1 ]; // \u7b2c\u4e00\u6b21listen\u7684\u65f6\u5019\u4f1a\u521b\u5efa\uff0c\u5982\u679c\u975e\u7a7a\u8bf4\u660e\u5df2\u7ecflisten\u8fc7 if ( this . _handle ) { throw new errors . Error ( 'ERR_SERVER_ALREADY_LISTEN' ); } // listen\u6210\u529f\u540e\u6267\u884c\u7684\u56de\u8c03 var hasCallback = ( cb !== null ); if ( hasCallback ) { // listen\u6210\u529f\u7684\u56de\u8c03 this . once ( 'listening' , cb ); } options = options . _handle || options . handle || options ; // \u7b2c\u4e00\u79cd\u60c5\u51b5\uff0c\u4f20\u8fdb\u6765\u7684\u662f\u4e00\u4e2aTCP\u670d\u52a1\u5668\uff0c\u800c\u4e0d\u662f\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u670d\u52a1\u5668 if ( options instanceof TCP ) { this . _handle = options ; this [ async_id_symbol ] = this . _handle . getAsyncId (); listenIncluster ( this , null , - 1 , - 1 , backlogFromArgs ); return this ; } // \u7b2c\u4e8c\u79cd\uff0c\u4f20\u8fdb\u6765\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5e76\u4e14\u5e26\u4e86fd if ( typeof options . fd === 'number' && options . fd >= 0 ) { listenIncluster ( this , null , null , null , backlogFromArgs , options . fd ); return this ; } // \u521b\u5efa\u4e00\u4e2atcp\u670d\u52a1\u5668 var backlog ; if ( typeof options . port === 'number' || typeof options . port === 'string' ) { backlog = options . backlog || backlogFromArgs ; // \u7b2c\u4e09\u79cd \u542f\u52a8\u4e00\u4e2aTCP\u670d\u52a1\u5668\uff0c\u4f20\u4e86host\u5219\u5148\u8fdb\u884cDNS\u89e3\u6790 if ( options . host ) { lookupAndListen ( this , options . port | 0 , options . host , backlog , options . exclusive ); } else { listenIncluster ( this , null , options . port | 0 , 4 , backlog , undefined , options . exclusive ); } return this ; } }; \u6211\u4eec\u770b\u5230\u6709\u4e09\u79cd\u60c5\u51b5\uff0c\u5206\u522b\u662f\u4f20\u4e86\u4e00\u4e2a\u670d\u52a1\u5668\u3001\u4f20\u4e86\u4e00\u4e2afd\u3001\u4f20\u4e86\u7aef\u53e3\uff08\u6216\u8005host\uff09\uff0c\u4f46\u662f\u6211\u4eec\u53d1\u73b0\uff0c\u8fd9\u51e0\u79cd\u60c5\u51b5\u6700\u540e\u90fd\u662f\u8c03\u7528\u4e86listenIncluster\uff08lookupAndListen\u662f\u5148DNS\u89e3\u6790\u540e\u518d\u6267\u884clistenIncluster\uff09\uff0c\u53ea\u662f\u5165\u53c2\u4e0d\u4e00\u6837\uff0c\u6240\u4ee5\u6211\u4eec\u76f4\u63a5\u770blistenIncluster\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function listenIncluster ( server , address , port , addressType , backlog , fd , exclusive ) { exclusive = !! exclusive ; if ( cluster === null ) cluster = require ( 'cluster' ); if ( cluster . isMaster || exclusive ) { server . _listen2 ( address , port , addressType , backlog , fd ); return ; } } \u56e0\u4e3a\u6211\u4eec\u662f\u5728\u4e3b\u8fdb\u7a0b\uff0c\u6240\u4ee5\u76f4\u63a5\u6267\u884c_listen2\uff0c\u5b50\u8fdb\u7a0b\u7684\u5728cluster\u6a21\u5757\u5206\u6790\u3002_listen\u5bf9\u5e94\u7684\u51fd\u6570\u662fsetupListenHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 function setupListenHandle ( address , port , addressType , backlog , fd ) { // \u6709handle\u5219\u4e0d\u9700\u8981\u521b\u5efa\u4e86\uff0c\u5426\u5219\u521b\u5efa\u4e00\u4e2a\u5e95\u5c42\u7684handle if ( this . _handle ) { } else { var rval = null ; // \u6ca1\u6709\u4f20fd\uff0c\u5219\u8bf4\u660e\u662f\u76d1\u542c\u7aef\u53e3\u548cIP if ( ! address && typeof fd !== 'number' ) { rval = createServerHandle ( '::' , port , 6 , fd ); /* \u8fd4\u56denumber\u8bf4\u660ebind IPv6\u7248\u672c\u7684handle\u5931\u8d25\uff0c \u56de\u9000\u5230v4\uff0c\u5426\u5219\u8bf4\u660e\u652f\u6301IPv6 */ if ( typeof rval === 'number' ) { // \u8d4b\u503c\u4e3anull\uff0c\u624d\u80fd\u8d70\u4e0b\u9762\u7684createServerHandle rval = null ; address = '0.0.0.0' ; addressType = 4 ; } else { address = '::' ; addressType = 6 ; } } // \u521b\u5efa\u5931\u8d25\u5219\u7ee7\u7eed\u521b\u5efa if ( rval === null ) rval = createServerHandle ( address , port , addressType , fd ); // \u8fd8\u62a5\u9519\u5219\u8bf4\u660e\u521b\u5efa\u670d\u52a1\u5668\u5931\u8d25\uff0c\u62a5\u9519 if ( typeof rval === 'number' ) { var error = exceptionWithHostPort ( rval , 'listen' , address , port ); process . nextTick ( emitErrorNT , this , error ); return ; } this . _handle = rval ; } // \u6709\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u7684\u8fde\u63a5\u65f6\u6267\u884c\u7684\u56de\u8c03 this . _handle . onconnection = onconnection ; this . _handle . owner = this ; // \u6267\u884cC++\u5c42listen var err = this . _handle . listen ( backlog || 511 ); // \u51fa\u9519\u5219\u62a5\u9519 if ( err ) { var ex = exceptionWithHostPort ( err , 'listen' , address , port ); this . _handle . close (); this . _handle = null ; nextTick ( this [ async_id_symbol ], emitErrorNT , this , ex ); return ; } // \u89e6\u53d1listen\u56de\u8c03 nextTick ( this [ async_id_symbol ], emitListeningNT , this ); } \u4e3b\u8981\u662f\u8c03\u7528createServerHandle\u521b\u5efa\u4e00\u4e2ahandle\uff0c\u7136\u540e\u8c03\u7528listen\u51fd\u6570\u76d1\u542c\u3002\u6211\u4eec\u5148\u770bcreateServerHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 function createServerHandle ( address , port , addressType , fd ) { var err = 0 ; var handle ; var isTCP = false ; // \u4f20\u4e86fd\u5219\u6839\u636efd\u521b\u5efa\u4e00\u4e2ahandle if ( typeof fd === 'number' && fd >= 0 ) { try { handle = createHandle ( fd , true ); } catch ( e ) { return UV_EINVAL ; } // \u628afd\u5b58\u5230handle\u4e2d handle . open ( fd ); handle . readable = true ; handle . writable = true ; assert ( ! address && ! port ); // \u7ba1\u9053 } else if ( port === - 1 && addressType === - 1 ) { // \u521b\u5efa\u4e00\u4e2aUnix\u57df\u670d\u52a1\u5668 handle = new Pipe ( PipeConstants . SERVER ); } else { // \u521b\u5efa\u4e00\u4e2aTCP\u670d\u52a1\u5668 handle = new TCP ( TCPConstants . SERVER ); isTCP = true ; } /* \u6709\u5730\u5740\u6216\u8005IP\u8bf4\u660e\u662f\u901a\u8fc7IP\u7aef\u53e3\u521b\u5efa\u7684TCP\u670d\u52a1\u5668\uff0c \u9700\u8981\u8c03bind\u7ed1\u5b9a\u5730\u5740 */ if ( address || port || isTCP ) { // \u6ca1\u6709\u5730\u5740\uff0c\u5219\u4f18\u5148\u7ed1\u5b9aIPv6\u7248\u672c\u7684\u672c\u5730\u5730\u5740 if ( ! address ) { // Try binding to IPv6 first err = handle . bind6 ( '::' , port ); // \u5931\u8d25\u5219\u7ed1\u5b9av4\u7684 if ( err ) { handle . close (); // Fallback to IPv4 return createServerHandle ( '0.0.0.0' , port ); } } else if ( addressType === 6 ) { // IPv6\u6216v4 err = handle . bind6 ( address , port ); } else { err = handle . bind ( address , port ); } } if ( err ) { handle . close (); return err ; } return handle ; } createServerHandle\u4e3b\u8981\u662f\u8c03\u7528createHandle\u521b\u5efa\u4e00\u4e2ahandle\u7136\u540e\u6267\u884cbind\u51fd\u6570\u3002\u521b\u5efahandle\u7684\u65b9\u5f0f\u6709\u51e0\u79cd\uff0c\u76f4\u63a5\u8c03\u7528C++\u5c42\u7684\u51fd\u6570\u6216\u8005\u901a\u8fc7fd\u521b\u5efa\u3002\u8c03\u7528createHandle\u53ef\u4ee5\u901a\u8fc7fd\u521b\u5efa\u4e00\u4e2ahandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // \u901a\u8fc7fd\u521b\u5efa\u4e00\u4e2ahandle\uff0c\u4f5c\u4e3a\u5ba2\u6237\u7aef\u6216\u8005\u670d\u52a1\u5668 function createHandle ( fd , is_server ) { // \u5224\u65adfd\u5bf9\u5e94\u7684\u7c7b\u578b const type = TTYWrap . guessHandleType ( fd ); // Unix\u57df if ( type === 'PIPE' ) { return new Pipe ( is_server ? PipeConstants . SERVER : PipeConstants . SOCKET ); } // tcp if ( type === 'TCP' ) { return new TCP ( is_server ? TCPConstants . SERVER : TCPConstants . SOCKET ); } throw new errors . TypeError ( 'ERR_INVALID_FD_TYPE' , type ); } \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bbind\u51fd\u6570\u7684\u903b\u8f91\uff0c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int uv__tcp_bind ( uv_tcp_t * tcp , const struct sockaddr * addr , unsigned int addrlen , unsigned int flags ) { int err ; int on ; // \u5982\u679c\u6ca1\u6709socket\u5219\u521b\u5efa\u4e00\u4e2a\uff0c\u6709\u5224\u65ad\u662f\u5426\u8bbe\u7f6e\u4e86UV_HANDLE_BOUND\uff0c\u662f\u5219\u6267\u884cbind\uff0c\u5426\u5219\u4e0d\u6267\u884cbind err = maybe_new_socket ( tcp , addr -> sa_family , 0 ); if ( err ) return err ; on = 1 ; // \u8bbe\u7f6e\u5728\u65ad\u5f00\u8fde\u63a5\u76842 msl\u5185\u53ef\u4ee5\u91cd\u7528\u7aef\u53e3\uff0c\u6240\u4ee5Node.js\u670d\u52a1\u5668\u53ef\u4ee5\u5feb\u901f\u91cd\u542f if ( setsockopt ( tcp -> io_watcher . fd , SOL_SOCKET , SO_REUSEADDR , & on , sizeof ( on ))) return UV__ERR ( errno ); errno = 0 ; // \u6267\u884cbind if ( bind ( tcp -> io_watcher . fd , addr , addrlen ) && errno != EADDRINUSE ) { if ( errno == EAFNOSUPPORT ) return UV_EINVAL ; return UV__ERR ( errno ); } // bind\u662f\u5426\u51fa\u9519 tcp -> delayed_error = UV__ERR ( errno ); // \u6253\u4e0a\u5df2\u7ecf\u6267\u884c\u4e86bind\u7684\u6807\u8bb0 tcp -> flags |= UV_HANDLE_BOUND ; if ( addr -> sa_family == AF_INET6 ) tcp -> flags |= UV_HANDLE_IPV6 ; return 0 ; } \u6267\u884c\u5b8cbind\u540e\uff0c\u4f1a\u7ee7\u7eed\u6267\u884clisten\uff0c\u6211\u4eec\u63a5\u7740\u770blisten\u51fd\u6570\u505a\u4e86\u4ec0\u4e48\u3002\u6211\u4eec\u76f4\u63a5\u770btcp_wrap.cc\u7684Listen\u3002 1 2 3 4 5 6 7 8 9 10 11 void TCPWrap::Listen ( const FunctionCallbackInfo < Value >& args ) { TCPWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder (), args . GetReturnValue (). Set ( UV_EBADF )); int backlog = args [ 0 ] -> Int32Value (); int err = uv_listen ( reinterpret_cast < uv_stream_t *> ( & wrap -> handle_ ), backlog , OnConnection ); args . GetReturnValue (). Set ( err ); } C++\u5c42\u51e0\u4e4e\u662f\u900f\u4f20\u5230Libuv\uff0cLibuv\u7684\u5185\u5bb9\u6211\u4eec\u4e0d\u518d\u5177\u4f53\u5c55\u5f00\uff0c\u5f53\u6709\u4e09\u6b21\u63e1\u624b\u7684\u8fde\u63a5\u5b8c\u6210\u65f6\uff0c\u4f1a\u6267\u884cOnConnection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 template < typename WrapType , typename UVType > void ConnectionWrap < WrapType , UVType >:: OnConnection ( uv_stream_t * handle , int status ) { // TCPWrap WrapType * wrap_data = static_cast < WrapType *> ( handle -> data ); Environment * env = wrap_data -> env (); HandleScope handle_scope ( env -> isolate ()); Context :: Scope context_scope ( env -> context ()); Local < Value > argv [] = { Integer :: New ( env -> isolate (), status ), Undefined ( env -> isolate ()) }; if ( status == 0 ) { // \u65b0\u5efa\u4e00\u4e2a\u8868\u793a\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5bf9\u8c61,\u5fc5\u586bTCPWrap\u5bf9\u8c61 Local < Object > client_obj = WrapType :: Instantiate ( env , wrap_data , WrapType :: SOCKET ); WrapType * wrap ; // \u89e3\u5305\u51fa\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u5b58\u5230wrap ASSIGN_OR_RETURN_UNWRAP ( & wrap , client_obj ); uv_stream_t * client_handle = reinterpret_cast < uv_stream_t *> ( & wrap -> handle_ ); // \u628a\u901a\u4fe1fd\u5b58\u50a8\u5230client_handle\u4e2d if ( uv_accept ( handle , client_handle )) return ; argv [ 1 ] = client_obj ; } // \u56de\u8c03\u4e0a\u5c42\u7684onconnection\u51fd\u6570 wrap_data -> MakeCallback ( env -> onconnection_string (), arraysize ( argv ), argv ); } \u5f53\u5efa\u7acb\u4e86\u65b0\u8fde\u63a5\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u65b0\u5efa\u4e00\u4e2asocket\u8868\u793a\uff0c\u540c\u6837\uff0c\u5728Node.js\u5c42\uff0c\u4e5f\u4f1a\u65b0\u5efa\u4e00\u4e2a\u5bf9\u5e94\u7684\u5bf9\u8c61\u8868\u793a\u548c\u5ba2\u6237\u7aef\u7684\u901a\u4fe1\uff0c\u63a5\u7740\u6211\u4eec\u770bJS\u5c42\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // clientHandle\u4ee3\u8868\u4e00\u4e2a\u548c\u5ba2\u6237\u7aef\u5efa\u7acbTCP\u8fde\u63a5\u7684\u5b9e\u4f53 function onconnection ( err , clientHandle ) { var handle = this ; var self = handle . owner ; // \u9519\u8bef\u5219\u89e6\u53d1\u9519\u8bef\u4e8b\u4ef6 if ( err ) { self . emit ( 'error' , errnoException ( err , 'accept' )); return ; } // \u5efa\u7acb\u8fc7\u591a\uff0c\u5173\u6389 if ( self . maxConnections && self . _connections >= self . maxConnections ) { clientHandle . close (); return ; } //\u65b0\u5efa\u4e00\u4e2asocket\u7528\u4e8e\u901a\u4fe1 var socket = new Socket ({ handle : clientHandle , allowHalfOpen : self . allowHalfOpen , pauseOnCreate : self . pauseOnConnect }); socket . readable = socket . writable = true ; // \u670d\u52a1\u5668\u7684\u8fde\u63a5\u6570\u52a0\u4e00 self . _connections ++ ; socket . server = self ; socket . _server = self ; // \u89e6\u53d1\u7528\u6237\u5c42\u8fde\u63a5\u4e8b\u4ef6 self . emit ( 'connection' , socket ); } \u5728JS\u5c42\u4e5f\u4f1a\u5c01\u88c5\u4e00\u4e2aSocket\u5bf9\u8c61\u7528\u4e8e\u7ba1\u7406\u548c\u5ba2\u6237\u7aef\u7684\u901a\u4fe1\uff0c\u63a5\u7740\u89e6\u53d1connection\u4e8b\u4ef6\u3002\u5269\u4e0b\u7684\u4e8b\u60c5\u5c31\u662f\u5e94\u7528\u5c42\u5904\u7406\u4e86\u3002 17.3 keepalive \u00b6 \u672c\u8282\u5206\u6790\u57fa\u4e8eTCP\u5c42\u7684\u957f\u8fde\u63a5\u95ee\u9898\uff0c\u76f8\u6bd4\u5e94\u7528\u5c42HTTP\u534f\u8bae\u7684\u957f\u8fde\u63a5\uff0cTCP\u5c42\u63d0\u4f9b\u7684\u529f\u80fd\u66f4\u591a\u3002TCP\u5c42\u5b9a\u4e49\u4e86\u4e09\u4e2a\u914d\u7f6e\u3002 1 \u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\uff0c\u5219\u5f00\u59cb\u53d1\u9001\u63a2\u6d4b\u5305\u3002 2 \u6bcf\u9694\u591a\u4e45\uff0c\u518d\u6b21\u53d1\u9001\u63a2\u6d4b\u5305\u3002 3 \u53d1\u9001\u591a\u5c11\u4e2a\u63a2\u6d4b\u5305\u540e\uff0c\u5c31\u65ad\u5f00\u8fde\u63a5\u3002 \u6211\u4eec\u770bLinux\u5185\u6838\u4ee3\u7801\u91cc\u63d0\u4f9b\u7684\u914d\u7f6e\u3002 1 2 3 4 5 6 // \u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5c31\u53d1\u8d77\u63a2\u6d4b\u5305 #define TCP_KEEPALIVE_TIME (120*60*HZ) /* two hours */ // \u63a2\u6d4b\u6b21\u6570 #define TCP_KEEPALIVE_PROBES 9 /* Max of 9 keepalive probes*/ // \u6bcf\u9694\u591a\u4e45\u63a2\u6d4b\u4e00\u6b21 #define TCP_KEEPALIVE_INTVL (75*HZ) \u8fd9\u662fLinux\u63d0\u4f9b\u7684\u9ed8\u8ba4\u503c\u3002\u4e0b\u9762\u518d\u770b\u770b\u9608\u503c 1 2 3 #define MAX_TCP_KEEPIDLE 32767 #define MAX_TCP_KEEPINTVL 32767 #define MAX_TCP_KEEPCNT 127 \u8fd9\u4e09\u4e2a\u914d\u7f6e\u548c\u4e0a\u9762\u4e09\u4e2a\u4e00\u4e00\u5bf9\u5e94\u3002\u662f\u4e0a\u9762\u4e09\u4e2a\u914d\u7f6e\u7684\u9608\u503c\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2dkeep-alive\u7684\u4f7f\u7528\u3002 socket.setKeepAlive([enable][, initialDelay]) enable\uff1a\u662f\u5426\u5f00\u542fkeep-alive\uff0cLinux\u4e0b\u9ed8\u8ba4\u662f\u4e0d\u5f00\u542f\u7684\u3002 initialDelay\uff1a\u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u5c31\u5f00\u59cb\u53d1\u9001\u63a2\u6d4b\u5305\u3002 \u63a5\u7740\u6211\u4eec\u770b\u770b\u8fd9\u4e2aAPI\u5728Libuv\u4e2d\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int uv__tcp_keepalive ( int fd , int on , unsigned int delay ) { if ( setsockopt ( fd , SOL_SOCKET , SO_KEEPALIVE , & on , sizeof ( on ))) return UV__ERR ( errno ); // Linux\u5b9a\u4e49\u4e86\u8fd9\u4e2a\u5b8f #ifdef TCP_KEEPIDLE /* on\u662f1\u624d\u4f1a\u8bbe\u7f6e\uff0c\u6240\u4ee5\u5982\u679c\u6211\u4eec\u5148\u5f00\u542fkeep-alive\uff0c\u5e76\u4e14\u8bbe\u7f6edelay\uff0c \u7136\u540e\u5173\u95edkeep-alive\u7684\u65f6\u5019\uff0c\u662f\u4e0d\u4f1a\u4fee\u6539\u4e4b\u524d\u4fee\u6539\u8fc7\u7684\u914d\u7f6e\u7684\u3002 \u56e0\u4e3a\u8fd9\u4e2a\u914d\u7f6e\u5728keep-alive\u5173\u95ed\u7684\u65f6\u5019\u662f\u6ca1\u7528\u7684 */ if ( on && setsockopt ( fd , IPPROTO_TCP , TCP_KEEPIDLE , & delay , sizeof ( delay ))) return UV__ERR ( errno ); #endif return 0 ; } \u6211\u4eec\u770b\u5230Libuv\u8c03\u7528\u4e86\u540c\u4e00\u4e2a\u7cfb\u7edf\u51fd\u6570\u4e24\u6b21\u3002\u6211\u4eec\u5206\u522b\u770b\u4e00\u4e0b\u8fd9\u4e2a\u51fd\u6570\u7684\u610f\u4e49\u3002\u53c2\u8003Linux2.6.13.1\u7684\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // net\\socket.c asmlinkage long sys_setsockopt ( int fd , int level , int optname , char __user * optval , int optlen ) { int err ; struct socket * sock ; if (( sock = sockfd_lookup ( fd , & err )) != NULL ) { ... if ( level == SOL_SOCKET ) err = sock_setsockopt ( sock , level , optname , optval , optlen ); else err = sock -> ops -> setsockopt ( sock , level , optname , optval , optlen ); sockfd_put ( sock ); } return err ; } \u5f53level\u662fSOL_SOCKET\u4ee3\u8868\u4fee\u6539\u7684socket\u5c42\u9762\u7684\u914d\u7f6e\u3002IPPROTO_TCP\u662f\u4fee\u6539TCP\u5c42\u7684\u914d\u7f6e\uff08\u8be5\u7248\u672c\u4ee3\u7801\u91cc\u662fSOL_TCP\uff09\u3002\u6211\u4eec\u5148\u770bSOL_SOCKET\u5c42\u9762\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 // net\\socket.c -> net\\core\\sock.c -> net\\ipv4\\tcp_timer.c int sock_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , int optlen ) { ... case SO_KEEPALIVE : if ( sk -> sk_protocol == IPPROTO_TCP ) tcp_set_keepalive ( sk , valbool ); // \u8bbe\u7f6eSOCK_KEEPOPEN\u6807\u8bb0\u4f4d1 sock_valbool_flag ( sk , SOCK_KEEPOPEN , valbool ); break ; ... } sock_setcsockopt\u9996\u5148\u8c03\u7528\u4e86tcp_set_keepalive\u51fd\u6570\uff0c\u7136\u540e\u7ed9\u5bf9\u5e94socket\u7684SOCK_KEEPOPEN\u5b57\u6bb5\u6253\u4e0a\u6807\u8bb0\uff080\u6216\u80051\u8868\u793a\u5f00\u542f\u8fd8\u662f\u5173\u95ed\uff09\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770btcp_set_keepalive 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void tcp_set_keepalive ( struct sock * sk , int val ) { if (( 1 << sk -> sk_state ) & ( TCPF_CLOSE | TCPF_LISTEN )) return ; /* \u5982\u679cval\u662f1\u5e76\u4e14\u4e4b\u524d\u662f0\uff08\u6ca1\u5f00\u542f\uff09\u90a3\u4e48\u5c31\u5f00\u542f\u8ba1\u65f6\uff0c\u8d85\u65f6\u540e\u53d1\u9001\u63a2\u6d4b\u5305\uff0c \u5982\u679c\u4e4b\u524d\u662f1\uff0cval\u53c8\u662f1\uff0c\u5219\u5ffd\u7565\uff0c\u6240\u4ee5\u91cd\u590d\u8bbe\u7f6e\u662f\u65e0\u5bb3\u7684 */ if ( val && ! sock_flag ( sk , SOCK_KEEPOPEN )) tcp_reset_keepalive_timer ( sk , keepalive_time_when ( tcp_sk ( sk ))); else if ( ! val ) // val\u662f0\u8868\u793a\u5173\u95ed\uff0c\u5219\u6e05\u9664\u5b9a\u65f6\u5668\uff0c\u5c31\u4e0d\u53d1\u9001\u63a2\u6d4b\u5305\u4e86 tcp_delete_keepalive_timer ( sk ); } \u6211\u4eec\u770b\u770b\u8d85\u65f6\u540e\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // \u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u5219\u53d1\u9001\u7b2c\u4e00\u4e2a\u63a2\u6d4b\u5305 static inline int keepalive_time_when ( const struct tcp_sock * tp ) { // \u7528\u6237\u8bbe\u7f6e\u7684\uff08TCP_KEEPIDLE\uff09\u548c\u7cfb\u7edf\u9ed8\u8ba4\u7684 return tp -> keepalive_time ? : sysctl_tcp_keepalive_time ; } // \u9694\u591a\u4e45\u53d1\u9001\u4e00\u4e2a\u63a2\u6d4b\u5305 static inline int keepalive_intvl_when ( const struct tcp_sock * tp ) { return tp -> keepalive_intvl ? : sysctl_tcp_keepalive_intvl ; } static void tcp_keepalive_timer ( unsigned long data ) { ... // \u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u4e86 elapsed = tcp_time_stamp - tp -> rcv_tstamp ; // \u662f\u5426\u8d85\u8fc7\u4e86\u9608\u503c if ( elapsed >= keepalive_time_when ( tp )) { // \u53d1\u9001\u7684\u63a2\u6d4b\u5305\u4e2a\u6570\u8fbe\u5230\u9608\u503c\uff0c\u53d1\u9001\u91cd\u7f6e\u5305 if (( ! tp -> keepalive_probes && tp -> probes_out >= sysctl_tcp_keepalive_probes ) || ( tp -> keepalive_probes && tp -> probes_out >= tp -> keepalive_probes )) { tcp_send_active_reset ( sk , GFP_ATOMIC ); tcp_write_err ( sk ); goto out ; } // \u53d1\u9001\u63a2\u6d4b\u5305\uff0c\u5e76\u8ba1\u7b97\u4e0b\u4e00\u4e2a\u63a2\u6d4b\u5305\u7684\u53d1\u9001\u65f6\u95f4\uff08\u8d85\u65f6\u65f6\u95f4\uff09 tcp_write_wakeup ( sk ) tp -> probes_out ++ ; elapsed = keepalive_intvl_when ( tp ); } else { /* \u8fd8\u6ca1\u5230\u671f\u5219\u91cd\u65b0\u8ba1\u7b97\u5230\u671f\u65f6\u95f4\uff0c\u6536\u5230\u6570\u636e\u5305\u7684\u65f6\u5019\u5e94\u8be5\u4f1a\u91cd\u7f6e\u5b9a\u65f6\u5668\uff0c \u6240\u4ee5\u6267\u884c\u8be5\u51fd\u6570\u8bf4\u660e\u7684\u786e\u662f\u8d85\u65f6\u4e86\uff0c\u6309\u7406\u8bf4\u4e0d\u4f1a\u8fdb\u5165\u8fd9\u91cc\u3002 */ elapsed = keepalive_time_when ( tp ) - elapsed ; } TCP_CHECK_TIMER ( sk ); sk_stream_mem_reclaim ( sk ); resched : // \u91cd\u65b0\u8bbe\u7f6e\u5b9a\u65f6\u5668 tcp_reset_keepalive_timer ( sk , elapsed ); ... \u6240\u4ee5\u5728SOL_SOCKET\u5c42\u9762\u662f\u8bbe\u7f6e\u662f\u5426\u5f00\u542fkeep-alive\u673a\u5236\u3002\u5982\u679c\u5f00\u542f\u4e86\uff0c\u5c31\u4f1a\u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u7684\u65f6\u5019\u5c31\u4f1a\u53d1\u9001\u63a2\u6d4b\u5305\u3002\u4f46\u662f\u6211\u4eec\u53d1\u73b0\uff0cSOL_SOCKET\u53ea\u662f\u8bbe\u7f6e\u4e86\u662f\u5426\u5f00\u542f\u63a2\u6d4b\u673a\u5236\uff0c\u5e76\u6ca1\u6709\u5b9a\u4e49\u4e0a\u9762\u4e09\u4e2a\u914d\u7f6e\u7684\u503c\uff0c\u6240\u4ee5\u7cfb\u7edf\u4f1a\u4f7f\u7528\u9ed8\u8ba4\u503c\u8fdb\u884c\u5fc3\u8df3\u673a\u5236\uff08\u5982\u679c\u6211\u4eec\u8bbe\u7f6e\u4e86\u5f00\u542fkeep-alive\u7684\u8bdd\uff09\u3002\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48Libuv\u8c03\u4e86\u4e24\u6b21setsockopt\u51fd\u6570\u3002\u7b2c\u4e8c\u6b21\u7684\u8c03\u7528\u8bbe\u7f6e\u4e86\u5c31\u662f\u4e0a\u9762\u4e09\u4e2a\u914d\u7f6e\u4e2d\u7684\u7b2c\u4e00\u4e2a\uff08\u540e\u9762\u4e24\u4e2a\u4e5f\u53ef\u4ee5\u8bbe\u7f6e\uff0c\u4e0d\u8fc7Libuv\u6ca1\u6709\u63d0\u4f9b\u63a5\u53e3\uff0c\u53ef\u4ee5\u81ea\u5df1\u8c03\u7528setsockopt\u8bbe\u7f6e\uff09\u3002\u90a3\u4e48\u6211\u4eec\u6765\u770b\u4e00\u4e0bLibuv\u7684\u7b2c\u4e8c\u6b21\u8c03\u7528setsockopt\u662f\u505a\u4e86\u4ec0\u4e48\u3002\u6211\u4eec\u76f4\u63a5\u770bTCP\u5c42\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // net\\ipv4\\tcp.c int tcp_setsockopt ( struct sock * sk , int level , int optname , char __user * optval , int optlen ) { ... case TCP_KEEPIDLE : // \u4fee\u6539\u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u5219\u53d1\u9001\u63a2\u6d4b\u5305\u7684\u914d\u7f6e tp -> keepalive_time = val * HZ ; // \u662f\u5426\u5f00\u542f\u4e86keep-alive\u673a\u5236 if ( sock_flag ( sk , SOCK_KEEPOPEN ) && ! (( 1 << sk -> sk_state ) & ( TCPF_CLOSE | TCPF_LISTEN ))) { // \u5f53\u524d\u65f6\u95f4\u51cf\u53bb\u4e0a\u6b21\u6536\u5230\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u5373\u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u4e86 __u32 elapsed = tcp_time_stamp - tp -> rcv_tstamp ; // \u7b97\u51fa\u8fd8\u8981\u591a\u4e45\u53ef\u4ee5\u53d1\u9001\u63a2\u6d4b\u5305\uff0c\u8fd8\u662f\u53ef\u4ee5\u76f4\u63a5\u53d1\uff08\u5df2\u7ecf\u89e6\u53d1\u4e86\uff09 if ( tp -> keepalive_time > elapsed ) elapsed = tp -> keepalive_time - elapsed ; else elapsed = 0 ; // \u8bbe\u7f6e\u5b9a\u65f6\u5668 tcp_reset_keepalive_timer ( sk , elapsed ); } ... } \u8be5\u51fd\u6570\u9996\u5148\u4fee\u6539\u914d\u7f6e\uff0c\u7136\u540e\u5224\u65ad\u662f\u5426\u5f00\u542f\u4e86keep-alive\u7684\u673a\u5236\uff0c\u5982\u679c\u5f00\u542f\u4e86\uff0c\u5219\u91cd\u65b0\u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u7684\u65f6\u5019\u5c31\u4f1a\u53d1\u9001\u63a2\u6d4b\u5305\u3002\u4f46\u662f\u6709\u4e00\u4e2a\u95ee\u9898\u662f\uff0c\u5fc3\u8df3\u673a\u5236\u5e76\u4e0d\u662f\u4ec0\u4e48\u65f6\u5019\u90fd\u597d\u4f7f\uff0c\u5982\u679c\u4e24\u7aef\u90fd\u6ca1\u6709\u6570\u636e\u6765\u5f80\u65f6\uff0c\u5fc3\u8df3\u673a\u5236\u80fd\u5f88\u597d\u5730\u5de5\u4f5c\uff0c\u4f46\u662f\u4e00\u65e6\u672c\u7aef\u6709\u6570\u636e\u53d1\u9001\u7684\u65f6\u5019\uff0c\u5b83\u5c31\u4f1a\u6291\u5236\u5fc3\u8df3\u673a\u5236\u3002\u6211\u4eec\u770b\u4e00\u4e0bLinux\u5185\u68385.7.7\u7684\u4e00\u6bb5\u76f8\u5173\u4ee3\u7801\uff0c\u5982\u56fe17-3\u6240\u793a\u3002 \u56fe17-3 \u4e0a\u9762\u8fd9\u4e00\u6bb5\u662f\u5fc3\u8df3\u673a\u5236\u4e2d\uff0c\u5b9a\u65f6\u5668\u8d85\u65f6\u65f6\uff0c\u6267\u884c\u7684\u4e00\u6bb5\u903b\u8f91\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5173\u6ce8\u7ea2\u8272\u6846\u91cc\u7684\u4ee3\u7801\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u5fc3\u8df3\u5b9a\u65f6\u5668\u8d85\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u53d1\u9001\u4e00\u4e2a\u65b0\u7684\u5fc3\u8df3\u5305\uff0c\u4f46\u662f\u5982\u679c\u53d1\u9001\u961f\u5217\u91cc\u8fd8\u6709\u6570\u636e\u6ca1\u6709\u53d1\u9001\uff0c\u90a3\u4e48\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u4f18\u5148\u53d1\u9001\u3002\u6216\u8005\u53d1\u9001\u51fa\u53bb\u7684\u6ca1\u6709ack\uff0c\u4e5f\u4f1a\u4f18\u5148\u89e6\u53d1\u91cd\u4f20\u3002\u8fd9\u65f6\u5019\u5fc3\u8df3\u673a\u5236\u5c31\u5931\u6548\u4e86\u3002\u5bf9\u4e8e\u8fd9\u4e2a\u95ee\u9898\uff0cLinux\u63d0\u4f9b\u4e86\u53e6\u4e00\u4e2a\u5c5e\u6027TCP_USER_TIMEOUT\u3002\u8fd9\u4e2a\u5c5e\u6027\u7684\u529f\u80fd\u662f\uff0c\u53d1\u9001\u4e86\u6570\u636e\uff0c\u591a\u4e45\u6ca1\u6709\u6536\u5230ack\u540e\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u8ba4\u4e3a\u8fd9\u4e2a\u8fde\u63a5\u65ad\u5f00\u4e86\u3002\u770b\u4e00\u4e0b\u76f8\u5173\u4ee3\u7801\uff0c\u5982\u56fe17-4\u6240\u793a\u3002 \u56fe17-4 \u4e0b\u9762\u662f\u8bbe\u7f6e\u9608\u503c\u7684\u4ee3\u7801\uff0c\u5982\u56fe17-5\u6240\u793a\u3002 \u56fe17-5 \u8fd9\u662f\u8d85\u65f6\u65f6\u5224\u65ad\u662f\u5426\u65ad\u5f00\u8fde\u63a5\u7684\u4ee3\u7801\u3002\u6211\u4eec\u770b\u5230\u6709\u4e24\u4e2a\u60c5\u51b5\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u8ba4\u4e3a\u8fde\u63a5\u65ad\u5f00\u4e86\u3002 1 \u8bbe\u7f6e\u4e86TCP_USER_TIMEOUT\u65f6\uff0c\u5982\u679c\u53d1\u9001\u5305\u6570\u91cf\u5927\u4e8e1\u5e76\u4e14\u5f53\u524d\u65f6\u95f4\u8ddd\u79bb\u4e0a\u6b21\u6536\u5230\u5305\u7684\u65f6\u95f4\u95f4\u9694\u5df2\u7ecf\u8fbe\u5230\u9608\u503c\u3002 2 \u6ca1\u6709\u8bbe\u7f6eTCP_USER_TIMEOUT\uff0c\u4f46\u662f\u5fc3\u8df3\u5305\u53d1\u9001\u6570\u91cf\u8fbe\u5230\u9608\u503c\u3002 \u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u540c\u65f6\u8bbe\u7f6e\u8fd9\u4e24\u4e2a\u5c5e\u6027\u3002\u4fdd\u8bc1\u5fc3\u8df3\u673a\u5236\u53ef\u4ee5\u6b63\u5e38\u8fd0\u884c\uff0c Node.js\u7684keep-alive\u6709\u4e24\u4e2a\u5c42\u9762\u7684\u5185\u5bb9\uff0c\u7b2c\u4e00\u4e2a\u662f\u662f\u5426\u5f00\u542f\uff0c\u7b2c\u4e8c\u4e2a\u662f\u5f00\u542f\u540e\uff0c\u4f7f\u7528\u7684\u914d\u7f6e\u3002Node.js\u7684setKeepAlive\u5c31\u662f\u505a\u4e86\u8fd9\u4e24\u4ef6\u4e8b\u60c5\u3002\u53ea\u4e0d\u8fc7\u5b83\u53ea\u652f\u6301\u4fee\u6539\u4e00\u4e2a\u914d\u7f6e\u3002Node.js\u53ea\u652f\u6301TCP_KEEPALIVE_TIME\u3002\u53e6\u5916\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4e00\u4e0b\u4ee3\u7801\u5224\u65ad\u914d\u7f6e\u7684\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 include < stdio . h > #include <netinet/tcp.h> int main ( int argc , const char * argv []) { int sockfd ; int optval ; socklen_t optlen = sizeof ( optval ); sockfd = socket ( AF_INET , SOCK_STREAM , 0 ); getsockopt ( sockfd , SOL_SOCKET , SO_KEEPALIVE , & optval , & optlen ); printf ( \"\u9ed8\u8ba4\u662f\u5426\u5f00\u542fkeep-alive\uff1a%d \\n \" , optval ); getsockopt ( sockfd , SOL_TCP , TCP_KEEPIDLE , & optval , & optlen ); printf ( \"\u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u5219\u53d1\u9001\u63a2\u6d4b\u5305\uff1a%d seconds \\n \" , optval ); getsockopt ( sockfd , SOL_TCP , TCP_KEEPINTVL , & optval , & optlen ); printf ( \"\u591a\u4e45\u53d1\u9001\u4e00\u6b21\u63a2\u6d4b\u5305\uff1a%d seconds \\n \" , optval ); getsockopt ( sockfd , SOL_TCP , TCP_KEEPCNT , & optval , & optlen ); printf ( \"\u6700\u591a\u53d1\u9001\u51e0\u4e2a\u63a2\u6d4b\u5305\u5c31\u65ad\u5f00\u8fde\u63a5\uff1a%d \\n \" , optval ); return 0 ; } \u8f93\u51fa\u5982\u56fe17-6\u6240\u793a\u3002 \u56fe17-6 \u518d\u770b\u4e00\u4e0bwireshark\u4e0b\u7684keepalive\u5305\uff0c\u5982\u56fe17-7\u6240\u793a\u3002 \u56fe17-7 17.4 allowHalfOpen \u00b6 \u6211\u4eec\u77e5\u9053TCP\u8fde\u63a5\u5728\u6b63\u5e38\u65ad\u5f00\u7684\u65f6\u5019\uff0c\u4f1a\u8d70\u56db\u6b21\u6325\u624b\u7684\u6d41\u7a0b\uff0c\u5728Node.js\u4e2d\uff0c\u5f53\u6536\u5230\u5bf9\u7aef\u53d1\u9001\u8fc7\u6765\u7684fin\u5305\u65f6\uff0c\u56de\u590dack\u540e\uff0c\u9ed8\u8ba4\u4f1a\u53d1\u9001fin\u5305\u7ed9\u5bf9\u7aef\uff0c\u4ee5\u5b8c\u6210\u56db\u6b21\u6325\u624b\u3002\u4f46\u662f\u6211\u4eec\u53ef\u80fd\u4f1a\u6709\u8fd9\u6837\u7684\u573a\u666f\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u5b8c\u6570\u636e\u540e\uff0c\u53d1\u9001fin\u5305\u8868\u793a\u81ea\u5df1\u6ca1\u6709\u6570\u636e\u53ef\u5199\u4e86\uff0c\u53ea\u9700\u8981\u7b49\u5f85\u670d\u52a1\u5668\u8fd4\u56de\u3002\u8fd9\u65f6\u5019\u5982\u679c\u670d\u52a1\u5668\u5728\u6536\u5230fin\u5305\u540e\uff0c\u4e5f\u56de\u590dfin\uff0c\u90a3\u5c31\u4f1a\u6709\u95ee\u9898\u3002\u5728Node.js\u4e2d\u63d0\u4f9b\u4e86allowHalfOpen\u9009\u9879\u652f\u6301\u534a\u5173\u95ed\uff0c\u6211\u4eec\u77e5\u9053TCP\u662f\u5168\u53cc\u5de5\u7684\uff0c\u4e24\u7aef\u53ef\u4ee5\u540c\u65f6\u4e92\u76f8\u53d1\u9001\u6570\u636e\uff0callowHalfOpen\u76f8\u5f53\u4e8e\u628a\u4e00\u7aef\u5173\u95ed\u4e86\uff0c\u5141\u8bb8\u6570\u636e\u5355\u5411\u4f20\u8f93\u3002\u6211\u4eec\u770b\u4e00\u4e0ballowHalfOpen\u7684\u5b9e\u73b0\u3002allowHalfOpen\u662f\u5c5e\u4e8eSocket\u7684\u9009\u9879\u3002\u6211\u4eec\u4eceNode.js\u6536\u5230\u4e00\u4e2afin\u5305\u5f00\u59cb\u5206\u6790\u6574\u4e2a\u6d41\u7a0b\u3002\u9996\u5148\u5728\u65b0\u5efaSocket\u5bf9\u8c61\u7684\u65f6\u5019\uff0c\u6ce8\u518c\u5bf9\u5e94\u4e8b\u4ef6\u3002 socket.on('_socketEnd', onSocketEnd); \u5f53\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230fin\u5305\u7684\u65f6\u5019\uff0c\u4f1a\u89e6\u53d1socket\u7684\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u6267\u884cNode.js\u7684\u8bfb\u56de\u8c03\u3002Node.js\u6267\u884c\u8bfb\u53d6\u7684\u65f6\u5019\u53d1\u73b0\uff0c\u8bfb\u53d6\u5df2\u7ed3\u675f\uff0c\u56e0\u4e3a\u5bf9\u7aef\u53d1\u9001\u4e86fin\u5305\u3002\u8fd9\u65f6\u5019\u4f1a\u89e6\u53d1_socketEnd\u4e8b\u4ef6\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u76f8\u5173\u4ee3\u7801\u3002 1 2 3 4 5 6 7 function onSocketEnd () { // ... if ( ! this . allowHalfOpen ) { this . write = writeAfterFIN ; this . destroySoon (); } } allowHalfOpen\u9ed8\u8ba4\u662ffalse\u3002onSocketEnd\u9996\u5148\u8bbe\u7f6ewrite\u51fd\u6570\u4e3awriteAfterFIN\uff0c\u6211\u4eec\u770b\u770b\u8fd9\u65f6\u5019\u5982\u679c\u6211\u4eec\u5199\u4f1a\u600e\u6837\u3002\u6211\u4eec\u4f1a\u6536\u5230\u4e00\u4e2a\u9519\u8bef\u3002 1 2 3 4 5 6 7 8 function writeAfterFIN ( chunk , encoding , cb ) { var er = new Error ( 'This socket has been ended by the other party' ); er . code = 'EPIPE' ; this . emit ( 'error' , er ); if ( typeof cb === 'function' ) { nextTick ( this [ async_id_symbol ], cb , er ); } } \u8bbe\u7f6e\u5b8cwrite\u540e\uff0c\u63a5\u7740Node.js\u4f1a\u53d1\u9001fin\u5305\u3002 1 2 3 4 5 6 7 8 9 10 Socket . prototype . destroySoon = function () { // \u5173\u95ed\u5199\u6d41 if ( this . writable ) this . end (); // \u5173\u95ed\u6210\u529f\u540e\u9500\u6bc1\u6d41 if ( this . _writableState . finished ) this . destroy (); else this . once ( 'finish' , this . destroy ); }; \u9996\u5148\u5173\u95ed\u5199\u6d41\uff0c\u7136\u540e\u6267\u884cdestroy\u51fd\u6570\u9500\u6bc1\u6d41\u3002\u5728destroy\u4e2d\u4f1a\u6267\u884c_destroy\u3002_destroy\u4f1a\u6267\u884c\u5177\u4f53\u7684\u5173\u95ed\u64cd\u4f5c\uff0c\u5373\u53d1\u9001fin\u5305\u3002 1 2 3 this._handle.close(() => { this.emit('close', isException); }); \u6211\u4eec\u770b\u5230C++\u5c42\u7684close\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void HandleWrap::Close ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); HandleWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder ()); // \u5173\u95edhandle uv_close ( wrap -> handle_ , OnClose ); wrap -> state_ = kClosing ; // \u6267\u884c\u56de\u8c03\uff0c\u89e6\u53d1close\u4e8b\u4ef6 if ( args [ 0 ] -> IsFunction ()) { wrap -> object () -> Set ( env -> onclose_string (), args [ 0 ]); wrap -> state_ = kClosingWithCallback ; } } \u6211\u4eec\u7ee7\u7eed\u5f80Libuv\u770b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 void uv_close ( uv_handle_t * handle , uv_close_cb cb ) { uv_loop_t * loop = handle -> loop ; handle -> close_cb = cb ; switch ( handle -> type ) { case UV_TCP : uv_tcp_close ( loop , ( uv_tcp_t * ) handle ); return ; // ... } } uv_tcp_close\u4f1a\u5bf9close\u7684\u5c01\u88c5\uff0c\u6211\u4eec\u770btcp close\u7684\u5927\u81f4\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 static void tcp_close ( struct sock * sk , int timeout ) { // \u76d1\u542c\u578b\u7684socket\u8981\u5173\u95ed\u5efa\u7acb\u7684\u8fde\u63a5 if ( sk -> state == TCP_LISTEN ) { /* Special case */ tcp_set_state ( sk , TCP_CLOSE ); // \u5173\u95ed\u5df2\u7ecf\u5efa\u7acb\u7684\u8fde\u63a5 tcp_close_pending ( sk ); release_sock ( sk ); return ; } struct sk_buff * skb ; // \u9500\u6bc1\u63a5\u6536\u961f\u5217\u4e2d\u672a\u5904\u7406\u7684\u6570\u636e while (( skb = skb_dequeue ( & sk -> receive_queue )) != NULL ) kfree_skb ( skb , FREE_READ ); // \u53d1\u9001fin\u5305 tcp_send_fin ( sk ); release_sock ( sk ); } \u4ee5\u4e0a\u662fNode.js\u4e2dsocket\u6536\u5230fin\u5305\u65f6\u7684\u9ed8\u8ba4\u5904\u7406\u6d41\u7a0b\uff0c\u5f53\u6211\u4eec\u8bbe\u7f6eallowHalfOpen\u4e3atrue\u7684\u65f6\u5019\uff0c\u5c31\u53ef\u4ee5\u4fee\u6539\u8fd9\u4e2a\u9ed8\u8ba4\u7684\u884c\u4e3a\uff0c\u5141\u8bb8\u534a\u5173\u95ed\u72b6\u6001\u7684\u8fde\u63a5\u3002 17.5 server close \u00b6 \u8c03\u7528close\u53ef\u4ee5\u5173\u95ed\u4e00\u4e2a\u670d\u52a1\u5668\uff0c\u9996\u5148\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u6587\u6863\u5173\u4e8eclose\u51fd\u6570\u7684\u89e3\u91ca Stops the server from accepting new connections and keeps existing connections. This function is asynchronous, the server is finally closed when all connections are ended and the server emits a 'close' event. The optional callback will be called once the 'close' event occurs. Unlike that event, it will be called with an Error as its only argument if the server was not open when it was closed. \u5728Node.js\u4e2d \uff0c\u5f53\u6211\u4eec\u4f7f\u7528close\u5173\u95ed\u4e00\u4e2aserver\u65f6\uff0cserver\u4f1a\u7b49\u6240\u6709\u7684\u8fde\u63a5\u5173\u95ed\u540e\u624d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u3002\u6211\u4eec\u770bclose\u7684\u5b9e\u73b0\uff0c\u4e00\u63a2\u7a76\u7adf\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Server . prototype . close = function ( cb ) { // \u89e6\u53d1\u56de\u8c03 if ( typeof cb === 'function' ) { if ( ! this . _handle ) { this . once ( 'close' , function close () { cb ( new errors . Error ( 'ERR_SERVER_NOT_RUNNING' )); }); } else { this . once ( 'close' , cb ); } } // \u5173\u95ed\u5e95\u5c42\u8d44\u6e90 if ( this . _handle ) { this . _handle . close (); this . _handle = null ; } // \u5224\u65ad\u662f\u5426\u9700\u8981\u7acb\u523b\u89e6\u53d1close\u4e8b\u4ef6 this . _emitCloseIfDrained (); return this ; }; close\u7684\u4ee3\u7801\u6bd4\u8f83\u7b80\u5355\uff0c\u9996\u5148\u76d1\u542cclose\u4e8b\u4ef6\uff0c\u7136\u540e\u5173\u95edserver\u5bf9\u5e94\u7684handle\uff0c\u6240\u4ee5server\u4e0d\u4f1a\u518d\u63a5\u6536\u65b0\u7684\u8bf7\u6c42\u4e86\u3002\u6700\u540e\u8c03\u7528_emitCloseIfDrained\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u51fd\u6570\u662f\u5e72\u561b\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Server . prototype . _emitCloseIfDrained = function () { // \u8fd8\u6709\u8fde\u63a5\u6216\u8005handle\u975e\u7a7a\u8bf4\u660ehandle\u8fd8\u6ca1\u6709\u5173\u95ed\uff0c\u5219\u5148\u4e0d\u89e6\u53d1close\u4e8b\u4ef6 if ( this . _handle || this . _connections ) { return ; } // \u89e6\u53d1close\u4e8b\u4ef6 const asyncId = this . _handle ? this [ async_id_symbol ] : null ; nextTick ( asyncId , emitCloseNT , this ); }; function emitCloseNT ( self ) { self . emit ( 'close' ); } _emitCloseIfDrained\u4e2d\u6709\u4e00\u4e2a\u62e6\u622a\u7684\u5224\u65ad\uff0chandle\u975e\u7a7a\u6216\u8005\u8fde\u63a5\u6570\u975e0\u3002\u7531\u4e4b\u524d\u7684\u4ee3\u7801\u6211\u4eec\u5df2\u7ecf\u77e5\u9053handle\u662fnull\uff0c\u4f46\u662f\u5982\u679c\u8fd9\u65f6\u5019\u8fde\u63a5\u6570\u975e0\uff0c\u4e5f\u4e0d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u3002\u90a3\u4ec0\u4e48\u65f6\u5019\u624d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u5462\uff1f\u5728socket\u7684_destroy\u51fd\u6570\u4e2d\u6211\u4eec\u627e\u5230\u4fee\u6539\u8fde\u63a5\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 Socket . prototype . _destroy = function ( exception , cb ) { ... // socket\u6240\u5c5e\u7684server if ( this . _server ) { // server\u4e0b\u7684\u8fde\u63a5\u6570\u51cf\u4e00 this . _server . _connections -- ; // \u662f\u5426\u9700\u8981\u89e6\u53d1server\u7684close\u4e8b\u4ef6\uff0c\u5f53\u6240\u6709\u7684\u8fde\u63a5\uff08socket\uff09\u90fd\u5173\u95ed\u65f6\u624d\u89e6\u53d1server\u7684\u662fclose\u4e8b\u4ef6 if ( this . _server . _emitCloseIfDrained ) { this . _server . _emitCloseIfDrained (); } } }; \u6211\u4eec\u770b\u5230\u6bcf\u4e00\u4e2a\u8fde\u63a5\u5173\u95ed\u7684\u65f6\u5019\uff0c\u90fd\u4f1a\u5bfc\u81f4\u8fde\u63a5\u6570\u51cf\u4e00\uff0c\u76f4\u5230\u4e3a0\u7684\u65f6\u5019\u624d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u3002\u5047\u8bbe\u6211\u4eec\u542f\u52a8\u4e86\u4e00\u4e2a\u670d\u52a1\u5668\uff0c\u63a5\u6536\u5230\u4e86\u4e00\u4e9b\u5ba2\u6237\u7aef\u7684\u8bf7\u6c42\uff0c\u8fd9\u65f6\u5019\uff0c\u5982\u679c\u6211\u4eec\u60f3\u4fee\u6539\u4e00\u4e2a\u4ee3\u7801\u53d1\u5e03\uff0c\u9700\u8981\u91cd\u542f\u670d\u52a1\u5668\uff0c\u600e\u4e48\u529e\uff1f\u5047\u8bbe\u6211\u4eec\u6709\u4ee5\u4e0b\u4ee3\u7801\u3002 server.js 1 2 const net = require ( 'net' ); const server = net . createServer (). listen ( 80 ); client.js 1 2 const net = require('net'); net.connect({port:80}) \u5982\u679c\u6211\u4eec\u76f4\u63a5\u6740\u6b7b\u8fdb\u7a0b\uff0c\u90a3\u4e48\u5b58\u91cf\u7684\u8bf7\u6c42\u5c31\u4f1a\u65e0\u6cd5\u6b63\u5e38\u88ab\u5904\u7406\u3002\u8fd9\u4f1a\u5f71\u54cd\u6211\u4eec\u7684\u670d\u52a1\u8d28\u91cf\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u5982\u4f55\u5728\u91cd\u542f\u65f6\u4f18\u96c5\u5730\u9000\u51fa\uff0c\u6240\u8c13\u4f18\u96c5\uff0c\u5373\u8ba9Node.js\u8fdb\u7a0b\u5904\u7406\u5b8c\u5b58\u91cf\u8bf7\u6c42\u540e\u518d\u9000\u51fa\u3002Server\u7684close\u7684\u5b9e\u73b0\u7ed9\u4e86\u6211\u4eec\u4e00\u4e9b\u601d\u8def\u3002\u6211\u4eec\u53ef\u4ee5\u76d1\u542cserver\u7684close\u4e8b\u4ef6\uff0c\u7b49\u5230\u89e6\u53d1close\u4e8b\u4ef6\u540e\u624d\u9000\u51fa\u8fdb\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 const net = require ( 'net' ); const server = net . createServer (). listen ( 80 ); server . on ( 'close' , () => { process . exit (); }); // \u9632\u6b62\u8fdb\u7a0b\u63d0\u524d\u6302\u6389 process . on ( 'uncaughtException' , () => { }); process . on ( 'SIGINT' , function () { server . close (); }) \u6211\u4eec\u9996\u5148\u76d1\u542cSIGINT\u4fe1\u53f7\uff0c\u5f53\u6211\u4eec\u4f7f\u7528SIGINT\u4fe1\u53f7\u6740\u6b7b\u8fdb\u7a0b\u65f6\uff0c\u9996\u5148\u8c03\u7528server.close\uff0c\u7b49\u5230\u6240\u6709\u7684\u8fde\u63a5\u65ad\u5f00\uff0c\u89e6\u53d1close\u65f6\u5019\u65f6\uff0c\u518d\u9000\u51fa\u8fdb\u7a0b\u3002\u6211\u4eec\u9996\u5148\u5f00\u542f\u670d\u52a1\u5668\uff0c\u7136\u540e\u5f00\u542f\u4e24\u4e2a\u5ba2\u6237\u7aef\u3002\u63a5\u7740\u6309\u4e0bctrl+c\uff0c\u6211\u4eec\u53d1\u73b0\u8fd9\u65f6\u5019\u670d\u52a1\u5668\u4e0d\u4f1a\u9000\u51fa\uff0c\u7136\u540e\u6211\u4eec\u5173\u95ed\u4e24\u4e2a\u5ba2\u6237\u7aef\uff0c\u8fd9\u65f6\u5019server\u5c31\u4f1a\u4f18\u96c5\u5730\u9000\u51fa\u3002","title":"17-TCP"},{"location":"chapter17-TCP/#171-tcp","text":"","title":"17.1 TCP\u5ba2\u6237\u7aef"},{"location":"chapter17-TCP/#1711","text":"net.connect\u662fNode.js\u4e2d\u53d1\u8d77TCP\u8fde\u63a5\u7684API\u3002\u672c\u8d28\u4e0a\u662f\u5bf9\u5e95\u5c42TCP connect\u51fd\u6570\u7684\u5c01\u88c5\u3002connect\u8fd4\u56de\u4e00\u4e2a\u8868\u793a\u5ba2\u6237\u7aef\u7684Socket\u5bf9\u8c61\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2d\u7684\u5177\u4f53\u5b9e\u73b0\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bconnect\u51fd\u6570\u7684\u5165\u53e3\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 function connect (... args ) { // \u5904\u7406\u53c2\u6570 var normalized = normalizeArgs ( args ); var options = normalized [ 0 ]; // \u7533\u8bf7\u4e00\u4e2asocket\u8868\u793a\u4e00\u4e2a\u5ba2\u6237\u7aef var socket = new Socket ( options ); // \u8bbe\u7f6e\u8d85\u65f6\uff0c\u8d85\u65f6\u540e\u4f1a\u89e6\u53d1timeout\uff0c\u7528\u6237\u53ef\u4ee5\u81ea\u5b9a\u4e49\u5904\u7406\u8d85\u65f6\u903b\u8f91 if ( options . timeout ) { socket . setTimeout ( options . timeout ); } // \u8c03\u7528socket\u7684connect return Socket . prototype . connect . call ( socket , normalized ); } \u4ece\u4ee3\u7801\u4e2d\u53ef\u4ee5\u770b\u5230\uff0cconnect\u51fd\u6570\u662f\u5bf9Socket\u5bf9\u8c61\u7684\u5c01\u88c5\u3002Socket\u8868\u793a\u4e00\u4e2aTCP\u5ba2\u6237\u7aef\u3002\u6211\u4eec\u5206\u6210\u4e09\u90e8\u5206\u5206\u6790\u3002 1 2 3 1 new Socket 2 setTimeout 3 Socket\u7684connect 1 new Socket \u6211\u4eec\u770b\u770b\u65b0\u5efa\u4e00\u4e2aSocket\u5bf9\u8c61\uff0c\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function Socket ( options ) { // \u662f\u5426\u6b63\u5728\u5efa\u7acb\u8fde\u63a5\uff0c\u5373\u4e09\u6b21\u63e1\u624b\u4e2d this . connecting = false ; // \u89e6\u53d1close\u4e8b\u4ef6\u65f6\uff0c\u8be5\u5b57\u6bb5\u6807\u8bb0\u662f\u5426\u7531\u4e8e\u9519\u8bef\u5bfc\u81f4\u4e86close this . _hadError = false ; // \u5bf9\u5e94\u7684\u5e95\u5c42handle\uff0c\u6bd4\u5982tcp_wrap this . _handle = null ; // \u5b9a\u65f6\u5668id this [ kTimeout ] = null ; options = options || {}; // socket\u662f\u53cc\u5411\u6d41 stream . Duplex . call ( this , options ); // \u8fd8\u4e0d\u80fd\u8bfb\u5199\uff0c\u5148\u8bbe\u7f6e\u6210false\uff0c\u8fde\u63a5\u6210\u529f\u540e\u518d\u91cd\u65b0\u8bbe\u7f6e this . readable = this . writable = false ; // \u6ce8\u518c\u5199\u7aef\u5173\u95ed\u7684\u56de\u8c03 this . on ( 'finish' , onSocketFinish ); // \u6ce8\u518c\u8bfb\u7aef\u5173\u95ed\u7684\u56de\u8c03 this . on ( '_socketEnd' , onSocketEnd ); // \u662f\u5426\u5141\u8bb8\u534a\u5f00\u5173\uff0c\u9ed8\u8ba4\u4e0d\u5141\u8bb8 this . allowHalfOpen = options && options . allowHalfOpen || false ; } Socket\u662f\u5bf9C++\u6a21\u5757tcp_wrap\u7684\u5c01\u88c5\u3002\u4e3b\u8981\u662f\u521d\u59cb\u5316\u4e86\u4e00\u4e9b\u5c5e\u6027\u548c\u76d1\u542c\u4e00\u4e9b\u4e8b\u4ef6\u3002 2 setTimeout 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Socket . prototype . setTimeout = function ( msecs , callback ) { // \u6e05\u9664\u4e4b\u524d\u7684\uff0c\u5982\u679c\u6709\u7684\u8bdd clearTimeout ( this [ kTimeout ]); // 0\u4ee3\u8868\u6e05\u9664 if ( msecs === 0 ) { if ( callback ) { this . removeListener ( 'timeout' , callback ); } } else { // \u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u65f6\u95f4\u662fmsecs\uff0c\u8d85\u65f6\u56de\u8c03\u662f_onTimeout this [ kTimeout ] = setUnrefTimeout ( this . _onTimeout . bind ( this ), msecs ); /* \u76d1\u542ctimeout\u4e8b\u4ef6\uff0c\u5b9a\u65f6\u5668\u8d85\u65f6\u65f6\uff0c\u5e95\u5c42\u4f1a\u8c03\u7528Node.js\u7684\u56de\u8c03\uff0c Node.js\u4f1a\u8c03\u7528\u7528\u6237\u7684\u56de\u8c03callback */ if ( callback ) { this . once ( 'timeout' , callback ); } } return this ; }; setTimeout\u505a\u7684\u4e8b\u60c5\u5c31\u662f\u8bbe\u7f6e\u4e00\u4e2a\u8d85\u65f6\u65f6\u95f4\uff0c\u8fd9\u4e2a\u65f6\u95f4\u7528\u4e8e\u68c0\u6d4bsocket\u7684\u6d3b\u8dc3\u60c5\u51b5\uff08\u6bd4\u5982\u6709\u6570\u636e\u901a\u4fe1\uff09\uff0c\u5f53socket\u6d3b\u8dc3\u65f6\uff0cNode.js\u4f1a\u91cd\u7f6e\u8be5\u5b9a\u65f6\u5668\uff0c\u5982\u679csocket\u4e00\u76f4\u4e0d\u6d3b\u8dc3\u5219\u8d85\u65f6\u4f1a\u89e6\u53d1timeout\u4e8b\u4ef6\uff0c\u4ece\u800c\u6267\u884cNode.js\u7684_onTimeout\u56de\u8c03\uff0c\u5728\u56de\u8c03\u91cc\u518d\u89e6\u53d1\u7528\u6237\u4f20\u5165\u7684\u56de\u8c03\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8d85\u65f6\u5904\u7406\u51fd\u6570_onTimeout\u3002 1 2 3 Socket . prototype . _onTimeout = function () { this . emit ( 'timeout' ); }; \u76f4\u63a5\u89e6\u53d1timeout\u51fd\u6570\uff0c\u56de\u8c03\u7528\u6237\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u5230setTimeout\u53ea\u662f\u8bbe\u7f6e\u4e86\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u7136\u540e\u89e6\u53d1timeout\u4e8b\u4ef6\uff0cNode.js\u5e76\u6ca1\u6709\u5e2e\u6211\u4eec\u505a\u989d\u5916\u7684\u64cd\u4f5c\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u81ea\u5df1\u5904\u7406\uff0c\u6bd4\u5982\u5173\u95edsocket\u3002 1 2 3 4 socket . setTimeout ( 10000 ); socket . on ( 'timeout' , () => { socket . close (); }); \u53e6\u5916\u6211\u4eec\u770b\u5230\u8fd9\u91cc\u662f\u4f7f\u7528setUnrefTimeout\u8bbe\u7f6e\u7684\u5b9a\u65f6\u5668\uff0c\u56e0\u4e3a\u8fd9\u4e00\u7c7b\u5b9a\u65f6\u5668\u4e0d\u5e94\u8be5\u963b\u6b62\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002 3 connect\u51fd\u6570 \u5728\u7b2c\u4e00\u6b65\u6211\u4eec\u5df2\u7ecf\u521b\u5efa\u4e86\u4e00\u4e2asocket\uff0c\u63a5\u7740\u6211\u4eec\u8c03\u7528\u8be5socket\u7684connect\u51fd\u6570\u5f00\u59cb\u53d1\u8d77\u8fde\u63a5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // \u5efa\u7acb\u8fde\u63a5\uff0c\u5373\u4e09\u6b21\u63e1\u624b Socket . prototype . connect = function (... args ) { let normalized ; /* \u5ffd\u7565\u53c2\u6570\u5904\u7406 */ var options = normalized [ 0 ]; var cb = normalized [ 1 ]; // TCP\u5728tcp_wrap.cc\u4e2d\u5b9a\u4e49 this . _handle = new TCP ( TCPConstants . SOCKET ); // \u6709\u6570\u636e\u53ef\u8bfb\u65f6\u7684\u56de\u8c03 this . _handle . onread = onread ; // \u8fde\u63a5\u6210\u529f\u65f6\u6267\u884c\u7684\u56de\u8c03 if ( cb !== null ) { this . once ( 'connect' , cb ); } // \u6b63\u5728\u8fde\u63a5 this . connecting = true ; this . writable = true ; // \u91cd\u7f6e\u5b9a\u65f6\u5668 this . _unrefTimer (); // \u53ef\u80fd\u9700\u8981DNS\u89e3\u6790\uff0c\u89e3\u6790\u6210\u529f\u518d\u53d1\u8d77\u8fde\u63a5 lookupAndConnect ( this , options ); return this ; }; connect \u51fd\u6570\u4e3b\u8981\u662f\u4e09\u4e2a\u903b\u8f91 1 \u9996\u5148\u901a\u8fc7new TCP()\u521b\u5efa\u4e00\u4e2a\u5e95\u5c42\u7684handle\uff0c\u6bd4\u5982\u6211\u4eec\u8fd9\u91cc\u662fTCP\uff08\u5bf9\u5e94tcp_wrap.cc\u7684\u5b9e\u73b0\uff09\u3002 2 \u8bbe\u7f6e\u4e00\u4e9b\u56de\u8c03 3 \u505aDNS\u89e3\u6790\uff08\u5982\u679c\u9700\u8981\u7684\u8bdd\uff09\uff0c\u7136\u540e\u53d1\u8d77\u4e09\u6b21\u63e1\u624b\u3002 \u6211\u4eec\u770b\u4e00\u4e0bnew TCP\u610f\u5473\u7740\u4ec0\u4e48\uff0c\u6211\u4eec\u770btcp_wrap.cc\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void TCPWrap::New ( const FunctionCallbackInfo < Value >& args ) { // \u8981\u4ee5new TCP\u7684\u5f62\u5f0f\u8c03\u7528 CHECK ( args . IsConstructCall ()); // \u7b2c\u4e00\u4e2a\u5165\u53c2\u662f\u6570\u5b57 CHECK ( args [ 0 ] -> IsInt32 ()); Environment * env = Environment :: GetCurrent ( args ); // \u4f5c\u4e3a\u5ba2\u6237\u7aef\u8fd8\u662f\u670d\u52a1\u5668 int type_value = args [ 0 ]. As < Int32 > () -> Value (); TCPWrap :: SocketType type = static_cast < TCPWrap :: SocketType > ( type_value ); ProviderType provider ; switch ( type ) { // \u4f5c\u4e3a\u5ba2\u6237\u7aef\uff0c\u5373\u53d1\u8d77\u8fde\u63a5\u65b9 case SOCKET : provider = PROVIDER_TCPWRAP ; break ; // \u4f5c\u4e3a\u670d\u52a1\u5668 case SERVER : provider = PROVIDER_TCPSERVERWRAP ; break ; default : UNREACHABLE (); } new TCPWrap ( env , args . This (), provider ); } new TCP\u5bf9\u5e94\u5230C++\u5c42\uff0c\u5c31\u662f\u521b\u5efa\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u3002\u5e76\u521d\u59cb\u5316\u5bf9\u8c61\u4e2d\u7684handle_\u5b57\u6bb5 1 2 3 4 5 6 TCPWrap :: TCPWrap ( Environment * env , Local < Object > object , ProviderType provider ) : ConnectionWrap ( env , object , provider ) { int r = uv_tcp_init ( env -> event_loop (), & handle_ ); } \u521d\u59cb\u5316\u5b8c\u5e95\u5c42\u7684\u6570\u636e\u7ed3\u6784\u540e\uff0c\u6211\u4eec\u7ee7\u7eed\u770blookupAndConnect\uff0clookupAndConnect\u4e3b\u8981\u662f\u5bf9\u53c2\u6570\u8fdb\u884c\u6821\u9a8c\uff0c\u7136\u540e\u8fdb\u884cDNS\u89e3\u6790\uff08\u5982\u679c\u4f20\u7684\u662f\u57df\u540d\u7684\u8bdd\uff09\uff0cDNS\u89e3\u6790\u6210\u529f\u540e\u6267\u884cinternalConnect 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 function internalConnect ( self , // \u9700\u8981\u8fde\u63a5\u7684\u8fdc\u7aefIP\u3001\u7aef\u53e3 address , port , addressType , /* \u7528\u4e8e\u548c\u5bf9\u7aef\u8fde\u63a5\u7684\u672c\u5730IP\u3001\u7aef\u53e3\uff08\u5982\u679c\u4e0d\u8bbe\u7f6e\uff0c \u5219\u64cd\u4f5c\u7cfb\u7edf\u81ea\u5df1\u51b3\u5b9a\uff09 */ localAddress , localPort ) { var err ; /* \u5982\u679c\u4f20\u4e86\u672c\u5730\u7684\u5730\u5740\u6216\u7aef\u53e3\uff0c\u5219TCP\u8fde\u63a5\u4e2d\u7684\u6e90IP \u548c\u7aef\u53e3\u5c31\u662f\u4f20\u7684\uff0c\u5426\u5219\u7531\u64cd\u4f5c\u7cfb\u7edf\u81ea\u5df1\u9009 */ if ( localAddress || localPort ) { // IP v4 if ( addressType === 4 ) { localAddress = localAddress || '0.0.0.0' ; // \u7ed1\u5b9a\u5730\u5740\u548c\u7aef\u53e3\u5230handle err = self . _handle . bind ( localAddress , localPort ); } else if ( addressType === 6 ) { localAddress = localAddress || '::' ; err = self . _handle . bind6 ( localAddress , localPort ); } // \u7ed1\u5b9a\u662f\u5426\u6210\u529f err = checkBindError ( err , localPort , self . _handle ); if ( err ) { const ex = exceptionWithHostPort ( err , 'bind' , localAddress , localPort ); self . destroy ( ex ); return ; } } // \u5bf9\u7aef\u7684\u5730\u5740\u4fe1\u606f if ( addressType === 6 || addressType === 4 ) { // \u65b0\u5efa\u4e00\u4e2a\u8bf7\u6c42\u5bf9\u8c61\uff0cC++\u5c42\u5b9a\u4e49 const req = new TCPConnectWrap (); // \u8bbe\u7f6e\u4e00\u4e9b\u5217\u5c5e\u6027 req . oncomplete = afterConnect ; req . address = address ; req . port = port ; req . localAddress = localAddress ; req . localPort = localPort ; // \u8c03\u7528\u5e95\u5c42\u5bf9\u5e94\u7684\u51fd\u6570 if ( addressType === 4 ) err = self . _handle . connect ( req , address , port ); else err = self . _handle . connect6 ( req , address , port ); } /* \u975e\u963b\u585e\u8c03\u7528\uff0c\u53ef\u80fd\u5728\u8fd8\u6ca1\u53d1\u8d77\u4e09\u6b21\u63e1\u624b\u4e4b\u524d\u5c31\u62a5\u9519\u4e86\uff0c \u800c\u4e0d\u662f\u4e09\u6b21\u63e1\u624b\u51fa\u9519\uff0c\u8fd9\u91cc\u8fdb\u884c\u51fa\u9519\u5904\u7406 */ if ( err ) { // \u83b7\u53d6socket\u5bf9\u5e94\u7684\u5e95\u5c42IP\u7aef\u53e3\u4fe1\u606f var sockname = self . _getsockname (); var details ; if ( sockname ) { details = sockname . address + ':' + sockname . port ; } // \u6784\u9020\u9519\u8bef\u4fe1\u606f\uff0c\u9500\u9b42socket\u5e76\u89e6\u53d1error\u4e8b\u4ef6 const ex = exceptionWithHostPort ( err , 'connect' , address , port , details ); self . destroy ( ex ); } } \u8fd9\u91cc\u7684\u4ee3\u7801\u6bd4\u8f83\u591a\uff0c\u9664\u4e86\u9519\u8bef\u5904\u7406\u5916\uff0c\u4e3b\u8981\u7684\u903b\u8f91\u662fbind\u548cconnect\u3002bind\u51fd\u6570\u7684\u903b\u8f91\u5f88\u7b80\u5355\uff08\u5373\u4f7f\u662f\u5e95\u5c42\u7684bind\uff09\uff0c\u5b83\u5c31\u662f\u5728\u5e95\u5c42\u7684\u4e00\u4e2a\u7ed3\u6784\u4f53\u4e0a\u8bbe\u7f6e\u4e86\u4e24\u4e2a\u5b57\u6bb5\u7684\u503c\u3002\u6240\u4ee5\u6211\u4eec\u4e3b\u8981\u6765\u5206\u6790connect\u3002\u6211\u4eec\u628a\u5173\u4e8econnect\u7684\u8fd9\u6bb5\u903b\u8f91\u62ce\u51fa\u6765\u3002 1 2 3 4 5 6 7 8 9 const req = new TCPConnectWrap (); // \u8bbe\u7f6e\u4e00\u4e9b\u5217\u5c5e\u6027 req . oncomplete = afterConnect ; req . address = address ; req . port = port ; req . localAddress = localAddress ; req . localPort = localPort ; // \u8c03\u7528\u5e95\u5c42\u5bf9\u5e94\u7684\u51fd\u6570 self . _handle . connect ( req , address , port ); TCPConnectWrap\u662fC++\u5c42\u63d0\u4f9b\u7684\u7c7b\uff0cconnect\u5bf9\u5e94C++\u5c42\u7684Conenct\uff0c \u524d\u9762\u7684\u7ae0\u8282\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4e0d\u518d\u5177\u4f53\u5206\u6790\u3002\u8fde\u63a5\u5b8c\u6210\u540e\uff0c\u56de\u8c03\u51fd\u6570\u662fuv__stream_io\u3002\u5728uv__stream_io\u91cc\u4f1a\u8c03\u7528connect_req\u4e2d\u7684\u56de\u8c03\u3002\u5047\u8bbe\u8fde\u63a5\u5efa\u7acb\uff0c\u8fd9\u65f6\u5019\u5c31\u4f1a\u6267\u884cC++\u5c42\u7684AfterConnect\u3002AfterConnect\u4f1a\u6267\u884cJS\u5c42\u7684afterConnect\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // \u8fde\u63a5\u540e\u6267\u884c\u7684\u56de\u8c03\uff0c\u6210\u529f\u6216\u5931\u8d25 function afterConnect ( status , handle , req , readable , writable ) { // handle\u5173\u8054\u7684socket var self = handle . owner ; // \u8fde\u63a5\u8fc7\u7a0b\u4e2d\u6267\u884c\u4e86socket\u88ab\u9500\u6bc1\u4e86\uff0c\u5219\u4e0d\u9700\u8981\u7ee7\u7eed\u5904\u7406 if ( self . destroyed ) { return ; } handle = self . _handle ; self . connecting = false ; self . _sockname = null ; // \u8fde\u63a5\u6210\u529f if ( status === 0 ) { // \u8bbe\u7f6e\u8bfb\u5199\u5c5e\u6027 self . readable = readable ; self . writable = writable ; // socket\u5f53\u524d\u6d3b\u8dc3\uff0c\u91cd\u7f6e\u5b9a\u65f6\u5668 self . _unrefTimer (); // \u89e6\u53d1\u8fde\u63a5\u6210\u529f\u4e8b\u4ef6 self . emit ( 'connect' ); // socket\u53ef\u8bfb\u5e76\u4e14\u6ca1\u6709\u8bbe\u7f6e\u6682\u505c\u6a21\u5f0f\uff0c\u5219\u5f00\u542f\u8bfb if ( readable && ! self . isPaused ()) self . read ( 0 ); } else { // \u8fde\u63a5\u5931\u8d25\uff0c\u62a5\u9519\u5e76\u9500\u6bc1socket self . connecting = false ; var details ; // \u63d0\u793a\u51fa\u9519\u4fe1\u606f if ( req . localAddress && req . localPort ) { details = req . localAddress + ':' + req . localPort ; } var ex = exceptionWithHostPort ( status , 'connect' , req . address , req . port , details ); if ( details ) { ex . localAddress = req . localAddress ; ex . localPort = req . localPort ; } // \u9500\u6bc1socket self . destroy ( ex ); } } \u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u8fde\u63a5\u6210\u529f\u540e\uff0cJS\u5c42\u8c03\u7528self.read(0)\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\u3002","title":"17.1.1 \u5efa\u7acb\u8fde\u63a5"},{"location":"chapter17-TCP/#1712","text":"\u6211\u4eec\u770b\u4e00\u4e0bsocket\u7684\u8bfb\u64cd\u4f5c\u903b\u8f91\uff0c\u5728\u8fde\u63a5\u6210\u529f\u540e\uff0csocket\u4f1a\u901a\u8fc7read\u51fd\u6570\u5728\u5e95\u5c42\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u7b49\u5f85\u5e95\u5c42\u4e8b\u4ef6\u9a71\u52a8\u6a21\u5757\u901a\u77e5\u6709\u6570\u636e\u53ef\u8bfb\u3002 1 2 3 4 5 6 7 8 Socket . prototype . read = function ( n ) { if ( n === 0 ) return stream . Readable . prototype . read . call ( this , n ); this . read = stream . Readable . prototype . read ; this . _consuming = true ; return this . read ( n ); }; \u8fd9\u91cc\u4f1a\u6267\u884cReadable\u6a21\u5757\u7684read\u51fd\u6570\uff0c\u4ece\u800c\u6267\u884c_read\u51fd\u6570\uff0c_read\u51fd\u6570\u662f\u7531\u5b50\u7c7b\u5b9e\u73b0\u3002\u6240\u4ee5\u6211\u4eec\u770bSocket\u7684_read 1 2 3 4 5 6 7 8 9 10 11 12 Socket . prototype . _read = function ( n ) { // \u8fd8\u6ca1\u5efa\u7acb\u8fde\u63a5\uff0c\u5219\u5efa\u7acb\u540e\u518d\u6267\u884c if ( this . connecting || ! this . _handle ) { this . once ( 'connect' , () => this . _read ( n )); } else if ( ! this . _handle . reading ) { this . _handle . reading = true ; // \u6267\u884c\u5e95\u5c42\u7684readStart\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 var err = this . _handle . readStart (); if ( err ) this . destroy ( errnoException ( err , 'read' )); } }; \u4f46\u662f\u6211\u4eec\u53d1\u73b0tcp_wrap.cc\u6ca1\u6709readStart\u51fd\u6570\u3002\u4e00\u8def\u5f80\u7236\u7c7b\u627e\uff0c\u6700\u7ec8\u5728stream_wrap.cc\u627e\u5230\u4e86\u8be5\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // \u6ce8\u518c\u8bfb\u4e8b\u4ef6 int LibuvStreamWrap::ReadStart () { return uv_read_start ( stream (), []( uv_handle_t * handle , size_t suggested_size , uv_buf_t * buf ) { // \u5206\u914d\u5b58\u50a8\u6570\u636e\u7684\u5185\u5b58 static_cast < LibuvStreamWrap *> ( handle -> data ) -> OnUvAlloc ( suggested_size , buf ); }, []( uv_stream_t * stream , ssize_t nread , const uv_buf_t * buf ) { // \u8bfb\u53d6\u6570\u636e\u6210\u529f\u7684\u56de\u8c03 static_cast < LibuvStreamWrap *> ( stream -> data ) -> OnUvRead ( nread , buf ); }); } uv_read_start\u51fd\u6570\u5728\u6d41\u7ae0\u8282\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4f5c\u7528\u5c31\u662f\u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u8fd9\u91cc\u5c31\u4e0d\u518d\u6df1\u5165\u3002OnUvAlloc\u662f\u5206\u914d\u5b58\u50a8\u6570\u636e\u7684\u51fd\u6570\uff0c\u6211\u4eec\u53ef\u4ee5\u4e0d\u5173\u6ce8\uff0c\u6211\u4eec\u770b\u4e00\u4e0bOnUvRead\uff0c\u5f53\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\u4f1a\u6267\u884cOnUvRead 1 2 3 4 5 6 void LibuvStreamWrap::OnUvRead ( ssize_t nread , const uv_buf_t * buf ) { HandleScope scope ( env () -> isolate ()); Context :: Scope context_scope ( env () -> context ()); // \u89e6\u53d1onread\u4e8b\u4ef6 EmitRead ( nread , * buf ); } OnUvRead\u51fd\u6570\u89e6\u53d1onread\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 function onread ( nread , buffer ) { var handle = this ; // handle\u5173\u8054\u7684socket var self = handle . owner ; // socket\u6709\u6570\u636e\u5230\u6765\uff0c\u5904\u4e8e\u6d3b\u8dc3\u72b6\u6001\uff0c\u91cd\u7f6e\u5b9a\u65f6\u5668 self . _unrefTimer (); // \u6210\u529f\u8bfb\u53d6\u6570\u636e if ( nread > 0 ) { // push\u5230\u6d41\u4e2d var ret = self . push ( buffer ); /* push\u8fd4\u56defalse\uff0c\u8bf4\u660e\u7f13\u5b58\u7684\u6570\u636e\u5df2\u7ecf\u8fbe\u5230\u9608\u503c\uff0c \u4e0d\u80fd\u518d\u89e6\u53d1\u8bfb\uff0c\u9700\u8981\u6ce8\u9500\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6 */ if ( handle . reading && ! ret ) { handle . reading = false ; var err = handle . readStop (); if ( err ) self . destroy ( errnoException ( err , 'read' )); } return ; } // \u6ca1\u6709\u6570\u636e\uff0c\u5ffd\u7565 if ( nread === 0 ) { debug ( 'not any data, keep waiting' ); return ; } // \u4e0d\u7b49\u4e8e\u7ed3\u675f\uff0c\u5219\u8bfb\u51fa\u9519\uff0c\u9500\u6bc1\u6d41 if ( nread !== UV_EOF ) { return self . destroy ( errnoException ( nread , 'read' )); } // \u6d41\u7ed3\u675f\u4e86\uff0c\u6ca1\u6709\u6570\u636e\u8bfb\u4e86 self . push ( null ); /* \u4e5f\u6ca1\u6709\u7f13\u5b58\u7684\u6570\u636e\u4e86\uff0c\u53ef\u80fd\u9700\u8981\u9500\u6bc1\u6d41\uff0c\u6bd4\u5982\u662f\u53ea\u8bfb\u6d41\uff0c \u6216\u8005\u53ef\u8bfb\u5199\u6d41\uff0c\u5199\u7aef\u4e5f\u6ca1\u6709\u6570\u636e\u4e86\uff0c\u53c2\u8003maybeDestroy */ if ( self . readableLength === 0 ) { self . readable = false ; maybeDestroy ( self ); } // \u89e6\u53d1\u4e8b\u4ef6 self . emit ( '_socketEnd' ); } socket\u53ef\u8bfb\u4e8b\u4ef6\u89e6\u53d1\u65f6\u5927\u6982\u6709\u4e0b\u9762\u51e0\u79cd\u60c5\u51b5 1 \u6709\u6709\u6548\u6570\u636e\u53ef\u8bfb\uff0cpush\u5230\u6d41\u4e2d\uff0c\u89e6\u53d1ondata\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u3002 2 \u6ca1\u6709\u6709\u6548\u6570\u636e\u53ef\u8bfb\uff0c\u5ffd\u7565\u3002 3 \u8bfb\u51fa\u9519\uff0c\u9500\u6bc1\u6d41 4 \u8bfb\u7ed3\u675f\u3002 \u6211\u4eec\u5206\u6790\u4e00\u4e0b4\u3002\u5728\u65b0\u5efa\u4e00\u4e2asocket\u7684\u65f6\u5019\u6ce8\u518c\u4e86\u6d41\u7ed3\u675f\u7684\u5904\u7406\u51fd\u6570onSocketEnd\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // \u8bfb\u7ed3\u675f\u540e\u6267\u884c\u7684\u51fd\u6570 function onSocketEnd () { // \u8bfb\u7ed3\u675f\u6807\u8bb0 this . _readableState . ended = true ; /* \u5df2\u7ecf\u89e6\u53d1\u8fc7end\u4e8b\u4ef6\uff0c\u5219\u5224\u65ad\u662f\u5426\u9700\u8981\u9500\u6bc1\uff0c\u53ef\u80fd\u8fd8\u6709\u5199\u7aef */ if ( this . _readableState . endEmitted ) { this . readable = false ; maybeDestroy ( this ); } else { // \u8fd8\u6ca1\u6709\u89e6\u53d1end\u5219\u7b49\u5f85\u89e6\u53d1end\u4e8b\u4ef6\u518d\u6267\u884c\u4e0b\u4e00\u6b65\u64cd\u4f5c this . once ( 'end' , function end () { this . readable = false ; maybeDestroy ( this ); }); /* \u6267\u884cread\uff0c\u5982\u679c\u6d41\u4e2d\u6ca1\u6709\u7f13\u5b58\u7684\u6570\u636e\u5219\u4f1a\u89e6\u53d1end\u4e8b\u4ef6\uff0c \u5426\u5219\u7b49\u5f85\u6d88\u8d39\u5b8c\u540e\u518d\u89e6\u53d1 */ this . read ( 0 ); } /* 1 \u8bfb\u7ed3\u675f\u540e\uff0c\u5982\u679c\u4e0d\u5141\u8bb8\u534a\u5f00\u5173\uff0c\u5219\u5173\u95ed\u5199\u7aef\uff0c\u5982\u679c\u8fd8\u6709\u6570\u636e\u8fd8\u6ca1\u6709\u53d1\u9001 \u5b8c\u6bd5\uff0c\u5219\u5148\u53d1\u9001\u5b8c\u518d\u5173\u95ed 2 \u91cd\u7f6e\u5199\u51fd\u6570\uff0c\u540e\u7eed\u6267\u884c\u5199\u7684\u65f6\u5019\u62a5\u9519 */ if ( ! this . allowHalfOpen ) { this . write = writeAfterFIN ; this . destroySoon (); } } \u5f53socket\u7684\u8bfb\u7aef\u7ed3\u675f\u65f6\uff0csocket\u7684\u72b6\u6001\u53d8\u66f4\u5206\u4e3a\u51e0\u79cd\u60c5\u51b5 1 \u5982\u679c\u53ef\u8bfb\u6d41\u4e2d\u8fd8\u6709\u7f13\u5b58\u7684\u6570\u636e\uff0c\u5219\u7b49\u5f85\u8bfb\u53d6\u3002 2 \u5982\u679c\u5199\u7aef\u4e5f\u7ed3\u675f\u4e86\uff0c\u5219\u9500\u6bc1\u6d41\u3002 3 \u5982\u679c\u5199\u7aef\u6ca1\u6709\u7ed3\u675f\uff0c\u5219\u5224\u65adallowHalfOpen\u662f\u5426\u5141\u8bb8\u534a\u5f00\u5173\uff0c\u4e0d\u5141\u8bb8\u5e76\u4e14\u5199\u7aef\u6570\u636e\u5df2\u7ecf\u53d1\u9001\u5b8c\u6bd5\u5219\u5173\u95ed\u5199\u7aef\u3002","title":"17.1.2 \u8bfb\u64cd\u4f5c"},{"location":"chapter17-TCP/#1713","text":"\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u5728\u4e00\u4e2a\u6d41\u4e0a\u5199\u7684\u65f6\u5019\uff0c\u903b\u8f91\u662f\u600e\u6837\u7684\u3002Socket\u5b9e\u73b0\u4e86\u5355\u4e2a\u5199\u548c\u6279\u91cf\u5199\u63a5\u53e3\u3002 1 2 3 4 5 6 7 8 9 // \u6279\u91cf\u5199 Socket . prototype . _writev = function ( chunks , cb ) { this . _writeGeneric ( true , chunks , '' , cb ); }; // \u5355\u4e2a\u5199 Socket . prototype . _write = function ( data , encoding , cb ) { this . _writeGeneric ( false , data , encoding , cb ); }; _writeGeneric 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 Socket . prototype . _writeGeneric = function ( writev , data , encoding , cb ) { /* \u6b63\u5728\u8fde\u63a5\uff0c\u5219\u5148\u4fdd\u5b58\u5f85\u5199\u7684\u6570\u636e\uff0c\u56e0\u4e3astream\u6a21\u5757\u662f\u4e32\u884c\u5199\u7684\uff0c \u6240\u4ee5\u7b2c\u4e00\u6b21\u5199\u6ca1\u5b8c\u6210\uff0c\u4e0d\u4f1a\u6267\u884c\u7b2c\u4e8c\u6b21\u5199\u64cd\u4f5c\uff08_write\uff09\uff0c \u6240\u4ee5\u8fd9\u91cc\u7528\u4e00\u4e2a\u5b57\u6bb5\u800c\u4e0d\u662f\u4e00\u4e2a\u6570\u7ec4\u6216\u961f\u5217\u4fdd\u5b58\u6570\u636e\u548c\u7f16\u7801\uff0c \u56e0\u4e3a\u6709pendingData\u65f6_writeGeneric \u4e0d\u4f1a\u88ab\u6267\u884c\u7b2c\u4e8c\u6b21\uff0c\u8fd9\u91cc\u7f13\u5b58 pendingData\u4e0d\u662f\u4e3a\u4e86\u540e\u7eed\u5199\u5165\uff0c\u800c\u662f\u4e3a\u4e86\u7edf\u8ba1\u5199\u5165\u7684\u6570\u636e\u603b\u6570 */ if ( this . connecting ) { this . _pendingData = data ; this . _pendingEncoding = encoding ; this . once ( 'connect' , function connect () { this . _writeGeneric ( writev , data , encoding , cb ); }); return ; } // \u5f00\u59cb\u5199\uff0c\u5219\u6e05\u7a7a\u4e4b\u524d\u7f13\u5b58\u7684\u6570\u636e this . _pendingData = null ; this . _pendingEncoding = '' ; // \u5199\u64cd\u4f5c\uff0c\u6709\u6570\u636e\u901a\u4fe1\uff0c\u5237\u65b0\u5b9a\u65f6\u5668 this . _unrefTimer (); // \u5df2\u7ecf\u5173\u95ed\uff0c\u5219\u9500\u6bc1socket if ( ! this . _handle ) { this . destroy ( new errors . Error ( 'ERR_SOCKET_CLOSED' ), cb ); return false ; } // \u65b0\u5efa\u4e00\u4e2a\u5199\u8bf7\u6c42 var req = new WriteWrap (); req . handle = this . _handle ; req . oncomplete = afterWrite ; // \u662f\u5426\u540c\u6b65\u6267\u884c\u5199\u5b8c\u6210\u56de\u8c03\uff0c\u53d6\u51b3\u4e8e\u5e95\u5c42\u662f\u540c\u6b65\u5199\u5165\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03\u8fd8\u662f\u5f02\u6b65\u5199\u5165 req . async = false ; var err ; // \u662f\u5426\u6279\u91cf\u5199 if ( writev ) { // \u6240\u6709\u6570\u636e\u90fd\u662fbuffer\u7c7b\u578b\uff0c\u5219\u76f4\u63a5\u5806\u8d77\u6765\uff0c\u5426\u5219\u9700\u8981\u4fdd\u5b58\u7f16\u7801\u7c7b\u578b var allBuffers = data . allBuffers ; var chunks ; var i ; if ( allBuffers ) { chunks = data ; for ( i = 0 ; i < data . length ; i ++ ) data [ i ] = data [ i ]. chunk ; } else { // \u7533\u8bf7double\u4e2a\u5927\u5c0f\u7684\u6570\u7ec4 chunks = new Array ( data . length << 1 ); for ( i = 0 ; i < data . length ; i ++ ) { var entry = data [ i ]; chunks [ i * 2 ] = entry . chunk ; chunks [ i * 2 + 1 ] = entry . encoding ; } } err = this . _handle . writev ( req , chunks , allBuffers ); // Retain chunks if ( err === 0 ) req . _chunks = chunks ; } else { var enc ; if ( data instanceof Buffer ) { enc = 'buffer' ; } else { enc = encoding ; } err = createWriteReq ( req , this . _handle , data , enc ); } if ( err ) return this . destroy ( errnoException ( err , 'write' , req . error ), cb ); // \u8bf7\u6c42\u5199\u5165\u5e95\u5c42\u7684\u6570\u636e\u5b57\u8282\u957f\u5ea6 this . _bytesDispatched += req . bytes ; // \u5728stream_base.cc\u4e2dreq_wrap_obj->Set(env->async(), True(env->isolate()));\u8bbe\u7f6e if ( ! req . async ) { cb (); return ; } req . cb = cb ; // \u6700\u540e\u4e00\u6b21\u8bf7\u6c42\u5199\u6570\u636e\u7684\u5b57\u8282\u957f\u5ea6 this [ kLastWriteQueueSize ] = req . bytes ; }; \u4e0a\u9762\u7684\u4ee3\u7801\u5f88\u591a\uff0c\u4f46\u662f\u903b\u8f91\u5e76\u4e0d\u590d\u6742\uff0c\u5177\u4f53\u5b9e\u73b0\u5728stream_base.cc\u548cstream_wrap.cc\uff0c\u8fd9\u91cc\u4e0d\u518d\u5c55\u5f00\u5206\u6790\uff0c\u4e3b\u8981\u662f\u6267\u884cwritev\u548ccreateWriteReq\u51fd\u6570\u8fdb\u884c\u5199\u64cd\u4f5c\u3002\u5b83\u4eec\u5e95\u5c42\u8c03\u7528\u7684\u90fd\u662fuv_write2\uff08\u9700\u8981\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\uff09\u6216uv_write\uff08\u4e0d\u9700\u8981\u4f20\u9012\u6587\u4ef6\u63cf\u8ff0\u7b26\uff09\u6216\u8005uv_try_write\u51fd\u6570\u8fdb\u884c\u5199\u64cd\u4f5c\u3002\u8fd9\u91cc\u53ea\u5206\u6790\u4e00\u4e0basync\u7684\u610f\u4e49\uff0casync\u9ed8\u8ba4\u662ffalse\uff0c\u5b83\u8868\u793a\u7684\u610f\u4e49\u662f\u6267\u884c\u5e95\u5c42\u5199\u5165\u65f6\uff0c\u5e95\u5c42\u662f\u5426\u540c\u6b65\u6267\u884c\u56de\u8c03\uff0casync\u4e3afalse\u8bf4\u660e\u5199\u5165\u5b8c\u6210\u56de\u8c03\u662f\u540c\u6b65\u6267\u884c\u7684\u3002\u5728stream_base.cc\u7684\u5199\u51fd\u6570\u4e2d\u6709\u76f8\u5173\u7684\u903b\u8f91\u3002 1 2 err = DoWrite ( req_wrap , buf_list , count , nullptr ); req_wrap_obj -> Set ( env -> async (), True ( env -> isolate ())); \u5f53\u6267\u884cDoWrite\u7684\u65f6\u5019\uff0creq_wrap\u4e2d\u4fdd\u5b58\u7684\u56de\u8c03\u53ef\u80fd\u4f1a\u88abLibuv\u540c\u6b65\u6267\u884c\uff0c\u4ece\u800c\u6267\u884cJS\u4ee3\u7801\uff0c\u8fd9\u65f6\u5019async\u662ffalse\uff08\u9ed8\u8ba4\u503c\uff09\uff0c\u8bf4\u660e\u56de\u8c03\u662f\u88ab\u540c\u6b65\u6267\u884c\u7684\uff0c\u5982\u679cDoWrite\u6ca1\u6709\u540c\u6b65\u6267\u884c\u56de\u8c03\u3002\u5219\u8bf4\u660e\u662f\u5f02\u6b65\u6267\u884c\u56de\u8c03\u3002\u8bbe\u7f6easync\u4e3atrue\uff0c\u518d\u6267\u884cJS\u4ee3\u7801\u3002","title":"17.1.3 \u5199\u64cd\u4f5c"},{"location":"chapter17-TCP/#1714","text":"\u5f53\u6211\u4eec\u53d1\u9001\u5b8c\u6570\u636e\u540e\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528socket\u5bf9\u8c61\u7684end\u51fd\u6570\u5173\u95ed\u6d41\u7684\u5199\u7aef\u3002\u6211\u4eec\u770b\u4e00\u4e0bend\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 Socket . prototype . end = function ( data , encoding , callback ) { stream . Duplex . prototype . end . call ( this , data , encoding , callback ); return this ; }; Socket\u7684end\u662f\u8c03\u7528\u7684Duplex\u7684end\uff0c\u800cDuplex\u7684end\u662f\u7ee7\u627f\u4e8eWritable\u7684end\u3002Writable\u7684end\u6700\u7ec8\u4f1a\u89e6\u53d1finish\u4e8b\u4ef6\uff0csocket\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u76d1\u542c\u4e86\u8be5\u4e8b\u4ef6\u3002 1 this . on ( 'finish' , onSocketFinish ); \u6211\u4eec\u770b\u770bonSocketFinish\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // \u6267\u884c\u4e86end\uff0c\u5e76\u4e14\u6570\u636e\u53d1\u9001\u5b8c\u6bd5\uff0c\u5219\u5173\u95ed\u5199\u7aef function onSocketFinish () { // \u8fd8\u6ca1\u8fde\u63a5\u6210\u529f\u5c31\u6267\u884c\u4e86end if ( this . connecting ) { return this . once ( 'connect' , onSocketFinish ); } // \u5199\u7ed3\u675f\u4e86\uff0c\u5982\u679c\u4e5f\u4e0d\u80fd\u8bfb\u6216\u8005\u8bfb\u7ed3\u675f\u4e86\uff0c\u5219\u9500\u6bc1socket if ( ! this . readable || this . _readableState . ended ) { return this . destroy (); } // \u4e0d\u652f\u6301shutdown\u5219\u76f4\u63a5\u9500\u6bc1 if ( ! this . _handle || ! this . _handle . shutdown ) return this . destroy (); // \u652f\u6301shutdown\u5219\u6267\u884c\u5173\u95ed\uff0c\u5e76\u8bbe\u7f6e\u56de\u8c03 var err = defaultTriggerAsyncIdScope ( this [ async_id_symbol ], shutdownSocket , this , afterShutdown ); // \u6267\u884cshutdown\u5931\u8d25\u5219\u76f4\u63a5\u9500\u6bc1 if ( err ) return this . destroy ( errnoException ( err , 'shutdown' )); } // \u53d1\u9001\u5173\u95ed\u5199\u7aef\u7684\u8bf7\u6c42 function shutdownSocket ( self , callback ) { var req = new ShutdownWrap (); req . oncomplete = callback ; req . handle = self . _handle ; return self . _handle . shutdown ( req ); } Shutdown\u51fd\u6570\u5728stream_base.cc\u4e2d\u5b9a\u4e49\uff0c\u6700\u7ec8\u8c03\u7528uv_shutdown\u5173\u95ed\u6d41\u7684\u5199\u7aef\uff0c\u5728Libuv\u6d41\u7ae0\u8282\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u5173\u95ed\u5199\u7aef\u540e\uff0c\u56de\u8c03\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // \u5173\u95ed\u5199\u7aef\u6210\u529f\u540e\u7684\u56de\u8c03 function afterShutdown ( status , handle , req ) { // handle\u5173\u8054\u7684socket var self = handle . owner ; // \u5df2\u7ecf\u9500\u6bc1\u4e86\uff0c\u5219\u4e0d\u9700\u8981\u5f80\u4e0b\u8d70\u4e86\uff0c\u5426\u5219\u6267\u884c\u9500\u6bc1\u64cd\u4f5c if ( self . destroyed ) return ; // \u5199\u5173\u95ed\u6210\u529f\uff0c\u5e76\u4e14\u8bfb\u4e5f\u7ed3\u675f\u4e86\uff0c\u5219\u9500\u6bc1socket\uff0c\u5426\u5219\u7b49\u5f85\u8bfb\u7ed3\u675f\u518d\u6267\u884c\u9500\u6bc1 if ( self . _readableState . ended ) { self . destroy (); } else { self . once ( '_socketEnd' , self . destroy ); } }","title":"17.1.4 \u5173\u95ed\u5199\u64cd\u4f5c"},{"location":"chapter17-TCP/#1715","text":"\u5f53\u4e00\u4e2asocket\u4e0d\u53ef\u8bfb\u4e5f\u4e0d\u53ef\u5199\u7684\u65f6\u5019\u3001\u88ab\u5173\u95ed\u3001\u53d1\u751f\u9519\u8bef\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u88ab\u9500\u6bc1\u3002\u9500\u6bc1\u4e00\u4e2a\u6d41\u5c31\u662f\u9500\u6bc1\u6d41\u7684\u8bfb\u7aef\u3001\u5199\u7aef\u3002\u7136\u540e\u6267\u884c\u6d41\u5b50\u7c7b\u7684_destory\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0bsocket\u7684_destroy\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // \u9500\u6bc1\u65f6\u6267\u884c\u7684\u94a9\u5b50\u51fd\u6570\uff0cexception\u4ee3\u8868\u662f\u5426\u56e0\u4e3a\u9519\u8bef\u5bfc\u81f4\u7684\u9500\u6bc1 Socket . prototype . _destroy = function ( exception , cb ) { this . connecting = false ; this . readable = this . writable = false ; // \u6e05\u9664\u5b9a\u65f6\u5668 for ( var s = this ; s !== null ; s = s . _parent ) { clearTimeout ( s [ kTimeout ]); } if ( this . _handle ) { // \u662f\u5426\u56e0\u4e3a\u51fa\u9519\u5bfc\u81f4\u9500\u6bc1\u6d41 var isException = exception ? true : false ; // \u5173\u95ed\u5e95\u5c42handle this . _handle . close (() => { // close\u4e8b\u4ef6\u7684\u5165\u53c2\uff0c\u8868\u793a\u662f\u5426\u56e0\u4e3a\u9519\u8bef\u5bfc\u81f4\u7684\u5173\u95ed this . emit ( 'close' , isException ); }); this . _handle . onread = noop ; this . _handle = null ; this . _sockname = null ; } // \u6267\u884c\u56de\u8c03 cb ( exception ); // socket\u6240\u5c5e\u7684server\uff0c\u4f5c\u4e3a\u5ba2\u6237\u7aef\u65f6\u662fnull if ( this . _server ) { // server\u4e0b\u7684\u8fde\u63a5\u6570\u51cf\u4e00 this . _server . _connections -- ; /* \u662f\u5426\u9700\u8981\u89e6\u53d1server\u7684close\u4e8b\u4ef6\uff0c \u5f53\u6240\u6709\u7684\u8fde\u63a5\uff08socket\uff09\u90fd\u5173\u95ed\u65f6\u624d\u89e6\u53d1server\u7684\u662fclose\u4e8b\u4ef6 */ if ( this . _server . _emitCloseIfDrained ) { this . _server . _emitCloseIfDrained (); } } }; _stream_writable.js\u4e2d\u7684destroy\u51fd\u6570\u53ea\u662f\u4fee\u6539\u8bfb\u5199\u6d41\u7684\u72b6\u6001\u548c\u6807\u8bb0\uff0c\u5b50\u7c7b\u9700\u8981\u5b9a\u4e49_destroy\u51fd\u6570\u9500\u6bc1\u76f8\u5173\u7684\u8d44\u6e90\uff0csocket\u901a\u8fc7\u8c03\u7528close\u5173\u95ed\u5e95\u5c42\u5173\u8054\u7684\u8d44\u6e90\uff0c\u5173\u95ed\u540e\u89e6\u53d1socket\u7684close\u4e8b\u4ef6\uff08\u56de\u8c03\u51fd\u6570\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u662fboolean\u7c7b\u578b\uff0c\u8bf4\u660e\u662f\u5426\u56e0\u4e3a\u9519\u8bef\u5bfc\u81f4socket\u5173\u95ed\uff09\u3002\u6700\u540e\u5224\u65ad\u8be5socket\u662f\u5426\u6765\u81ea\u670d\u52a1\u5668\u521b\u5efa\u7684\uff0c\u662f\u7684\u8bdd\u8be5\u670d\u52a1\u5668\u7684\u8fde\u63a5\u6570\u51cf\u4e00\uff0c\u5982\u679c\u670d\u52a1\u5668\u6267\u884c\u4e86close\u5e76\u4e14\u5f53\u524d\u8fde\u63a5\u6570\u4e3a0\uff0c\u5219\u5173\u95ed\u670d\u52a1\u5668\u3002","title":"17.1.5 \u9500\u6bc1"},{"location":"chapter17-TCP/#172-tcp","text":"net\u6a21\u5757\u63d0\u4f9b\u4e86createServer\u51fd\u6570\u521b\u5efa\u4e00\u4e2aTCP\u670d\u52a1\u5668\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 function createServer ( options , connectionListener ) { return new Server ( options , connectionListener ); } function Server ( options , connectionListener ) { EventEmitter . call ( this ); // \u6ce8\u518c\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c\u7684\u56de\u8c03 if ( typeof options === 'function' ) { connectionListener = options ; options = {}; this . on ( 'connection' , connectionListener ); } else if ( options == null || typeof options === 'object' ) { options = options || {}; if ( typeof connectionListener === 'function' ) { this . on ( 'connection' , connectionListener ); } } else { throw new errors . TypeError ( 'ERR_INVALID_ARG_TYPE' , 'options' , 'Object' , options ); } // \u670d\u52a1\u5668\u5efa\u7acb\u7684\u8fde\u63a5\u6570 this . _connections = 0 ; this . _handle = null ; this . _unref = false ; // \u670d\u52a1\u5668\u4e0b\u7684\u6240\u6709\u8fde\u63a5\u662f\u5426\u5141\u8bb8\u534a\u8fde\u63a5 this . allowHalfOpen = options . allowHalfOpen || false ; // \u6709\u8fde\u63a5\u65f6\u662f\u5426\u6ce8\u518c\u8bfb\u4e8b\u4ef6 this . pauseOnConnect = !! options . pauseOnConnect ; } createServer\u8fd4\u56de\u7684\u5c31\u662f\u4e00\u4e2a\u4e00\u822c\u7684JS\u5bf9\u8c61\uff0c\u63a5\u7740\u8c03\u7528listen\u51fd\u6570\u76d1\u542c\u7aef\u53e3\u3002\u770b\u4e00\u4e0blisten\u51fd\u6570\u7684\u903b\u8f91 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 Server . prototype . listen = function (... args ) { /* \u5904\u7406\u5165\u53c2\uff0c\u6839\u636e\u6587\u6863\u6211\u4eec\u77e5\u9053listen\u53ef\u4ee5\u63a5\u6536\u597d\u51e0\u4e2a\u53c2\u6570\uff0c \u5047\u8bbe\u6211\u4eec\u8fd9\u91cc\u662f\u53ea\u4f20\u4e86\u7aef\u53e3\u53f79297 */ var normalized = normalizeArgs ( args ); // normalized = [{port: 9297}, null]; var options = normalized [ 0 ]; var cb = normalized [ 1 ]; // \u7b2c\u4e00\u6b21listen\u7684\u65f6\u5019\u4f1a\u521b\u5efa\uff0c\u5982\u679c\u975e\u7a7a\u8bf4\u660e\u5df2\u7ecflisten\u8fc7 if ( this . _handle ) { throw new errors . Error ( 'ERR_SERVER_ALREADY_LISTEN' ); } // listen\u6210\u529f\u540e\u6267\u884c\u7684\u56de\u8c03 var hasCallback = ( cb !== null ); if ( hasCallback ) { // listen\u6210\u529f\u7684\u56de\u8c03 this . once ( 'listening' , cb ); } options = options . _handle || options . handle || options ; // \u7b2c\u4e00\u79cd\u60c5\u51b5\uff0c\u4f20\u8fdb\u6765\u7684\u662f\u4e00\u4e2aTCP\u670d\u52a1\u5668\uff0c\u800c\u4e0d\u662f\u9700\u8981\u521b\u5efa\u4e00\u4e2a\u670d\u52a1\u5668 if ( options instanceof TCP ) { this . _handle = options ; this [ async_id_symbol ] = this . _handle . getAsyncId (); listenIncluster ( this , null , - 1 , - 1 , backlogFromArgs ); return this ; } // \u7b2c\u4e8c\u79cd\uff0c\u4f20\u8fdb\u6765\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5e76\u4e14\u5e26\u4e86fd if ( typeof options . fd === 'number' && options . fd >= 0 ) { listenIncluster ( this , null , null , null , backlogFromArgs , options . fd ); return this ; } // \u521b\u5efa\u4e00\u4e2atcp\u670d\u52a1\u5668 var backlog ; if ( typeof options . port === 'number' || typeof options . port === 'string' ) { backlog = options . backlog || backlogFromArgs ; // \u7b2c\u4e09\u79cd \u542f\u52a8\u4e00\u4e2aTCP\u670d\u52a1\u5668\uff0c\u4f20\u4e86host\u5219\u5148\u8fdb\u884cDNS\u89e3\u6790 if ( options . host ) { lookupAndListen ( this , options . port | 0 , options . host , backlog , options . exclusive ); } else { listenIncluster ( this , null , options . port | 0 , 4 , backlog , undefined , options . exclusive ); } return this ; } }; \u6211\u4eec\u770b\u5230\u6709\u4e09\u79cd\u60c5\u51b5\uff0c\u5206\u522b\u662f\u4f20\u4e86\u4e00\u4e2a\u670d\u52a1\u5668\u3001\u4f20\u4e86\u4e00\u4e2afd\u3001\u4f20\u4e86\u7aef\u53e3\uff08\u6216\u8005host\uff09\uff0c\u4f46\u662f\u6211\u4eec\u53d1\u73b0\uff0c\u8fd9\u51e0\u79cd\u60c5\u51b5\u6700\u540e\u90fd\u662f\u8c03\u7528\u4e86listenIncluster\uff08lookupAndListen\u662f\u5148DNS\u89e3\u6790\u540e\u518d\u6267\u884clistenIncluster\uff09\uff0c\u53ea\u662f\u5165\u53c2\u4e0d\u4e00\u6837\uff0c\u6240\u4ee5\u6211\u4eec\u76f4\u63a5\u770blistenIncluster\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function listenIncluster ( server , address , port , addressType , backlog , fd , exclusive ) { exclusive = !! exclusive ; if ( cluster === null ) cluster = require ( 'cluster' ); if ( cluster . isMaster || exclusive ) { server . _listen2 ( address , port , addressType , backlog , fd ); return ; } } \u56e0\u4e3a\u6211\u4eec\u662f\u5728\u4e3b\u8fdb\u7a0b\uff0c\u6240\u4ee5\u76f4\u63a5\u6267\u884c_listen2\uff0c\u5b50\u8fdb\u7a0b\u7684\u5728cluster\u6a21\u5757\u5206\u6790\u3002_listen\u5bf9\u5e94\u7684\u51fd\u6570\u662fsetupListenHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 function setupListenHandle ( address , port , addressType , backlog , fd ) { // \u6709handle\u5219\u4e0d\u9700\u8981\u521b\u5efa\u4e86\uff0c\u5426\u5219\u521b\u5efa\u4e00\u4e2a\u5e95\u5c42\u7684handle if ( this . _handle ) { } else { var rval = null ; // \u6ca1\u6709\u4f20fd\uff0c\u5219\u8bf4\u660e\u662f\u76d1\u542c\u7aef\u53e3\u548cIP if ( ! address && typeof fd !== 'number' ) { rval = createServerHandle ( '::' , port , 6 , fd ); /* \u8fd4\u56denumber\u8bf4\u660ebind IPv6\u7248\u672c\u7684handle\u5931\u8d25\uff0c \u56de\u9000\u5230v4\uff0c\u5426\u5219\u8bf4\u660e\u652f\u6301IPv6 */ if ( typeof rval === 'number' ) { // \u8d4b\u503c\u4e3anull\uff0c\u624d\u80fd\u8d70\u4e0b\u9762\u7684createServerHandle rval = null ; address = '0.0.0.0' ; addressType = 4 ; } else { address = '::' ; addressType = 6 ; } } // \u521b\u5efa\u5931\u8d25\u5219\u7ee7\u7eed\u521b\u5efa if ( rval === null ) rval = createServerHandle ( address , port , addressType , fd ); // \u8fd8\u62a5\u9519\u5219\u8bf4\u660e\u521b\u5efa\u670d\u52a1\u5668\u5931\u8d25\uff0c\u62a5\u9519 if ( typeof rval === 'number' ) { var error = exceptionWithHostPort ( rval , 'listen' , address , port ); process . nextTick ( emitErrorNT , this , error ); return ; } this . _handle = rval ; } // \u6709\u5b8c\u6210\u4e09\u6b21\u63e1\u624b\u7684\u8fde\u63a5\u65f6\u6267\u884c\u7684\u56de\u8c03 this . _handle . onconnection = onconnection ; this . _handle . owner = this ; // \u6267\u884cC++\u5c42listen var err = this . _handle . listen ( backlog || 511 ); // \u51fa\u9519\u5219\u62a5\u9519 if ( err ) { var ex = exceptionWithHostPort ( err , 'listen' , address , port ); this . _handle . close (); this . _handle = null ; nextTick ( this [ async_id_symbol ], emitErrorNT , this , ex ); return ; } // \u89e6\u53d1listen\u56de\u8c03 nextTick ( this [ async_id_symbol ], emitListeningNT , this ); } \u4e3b\u8981\u662f\u8c03\u7528createServerHandle\u521b\u5efa\u4e00\u4e2ahandle\uff0c\u7136\u540e\u8c03\u7528listen\u51fd\u6570\u76d1\u542c\u3002\u6211\u4eec\u5148\u770bcreateServerHandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 function createServerHandle ( address , port , addressType , fd ) { var err = 0 ; var handle ; var isTCP = false ; // \u4f20\u4e86fd\u5219\u6839\u636efd\u521b\u5efa\u4e00\u4e2ahandle if ( typeof fd === 'number' && fd >= 0 ) { try { handle = createHandle ( fd , true ); } catch ( e ) { return UV_EINVAL ; } // \u628afd\u5b58\u5230handle\u4e2d handle . open ( fd ); handle . readable = true ; handle . writable = true ; assert ( ! address && ! port ); // \u7ba1\u9053 } else if ( port === - 1 && addressType === - 1 ) { // \u521b\u5efa\u4e00\u4e2aUnix\u57df\u670d\u52a1\u5668 handle = new Pipe ( PipeConstants . SERVER ); } else { // \u521b\u5efa\u4e00\u4e2aTCP\u670d\u52a1\u5668 handle = new TCP ( TCPConstants . SERVER ); isTCP = true ; } /* \u6709\u5730\u5740\u6216\u8005IP\u8bf4\u660e\u662f\u901a\u8fc7IP\u7aef\u53e3\u521b\u5efa\u7684TCP\u670d\u52a1\u5668\uff0c \u9700\u8981\u8c03bind\u7ed1\u5b9a\u5730\u5740 */ if ( address || port || isTCP ) { // \u6ca1\u6709\u5730\u5740\uff0c\u5219\u4f18\u5148\u7ed1\u5b9aIPv6\u7248\u672c\u7684\u672c\u5730\u5730\u5740 if ( ! address ) { // Try binding to IPv6 first err = handle . bind6 ( '::' , port ); // \u5931\u8d25\u5219\u7ed1\u5b9av4\u7684 if ( err ) { handle . close (); // Fallback to IPv4 return createServerHandle ( '0.0.0.0' , port ); } } else if ( addressType === 6 ) { // IPv6\u6216v4 err = handle . bind6 ( address , port ); } else { err = handle . bind ( address , port ); } } if ( err ) { handle . close (); return err ; } return handle ; } createServerHandle\u4e3b\u8981\u662f\u8c03\u7528createHandle\u521b\u5efa\u4e00\u4e2ahandle\u7136\u540e\u6267\u884cbind\u51fd\u6570\u3002\u521b\u5efahandle\u7684\u65b9\u5f0f\u6709\u51e0\u79cd\uff0c\u76f4\u63a5\u8c03\u7528C++\u5c42\u7684\u51fd\u6570\u6216\u8005\u901a\u8fc7fd\u521b\u5efa\u3002\u8c03\u7528createHandle\u53ef\u4ee5\u901a\u8fc7fd\u521b\u5efa\u4e00\u4e2ahandle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // \u901a\u8fc7fd\u521b\u5efa\u4e00\u4e2ahandle\uff0c\u4f5c\u4e3a\u5ba2\u6237\u7aef\u6216\u8005\u670d\u52a1\u5668 function createHandle ( fd , is_server ) { // \u5224\u65adfd\u5bf9\u5e94\u7684\u7c7b\u578b const type = TTYWrap . guessHandleType ( fd ); // Unix\u57df if ( type === 'PIPE' ) { return new Pipe ( is_server ? PipeConstants . SERVER : PipeConstants . SOCKET ); } // tcp if ( type === 'TCP' ) { return new TCP ( is_server ? TCPConstants . SERVER : TCPConstants . SOCKET ); } throw new errors . TypeError ( 'ERR_INVALID_FD_TYPE' , type ); } \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bbind\u51fd\u6570\u7684\u903b\u8f91\uff0c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int uv__tcp_bind ( uv_tcp_t * tcp , const struct sockaddr * addr , unsigned int addrlen , unsigned int flags ) { int err ; int on ; // \u5982\u679c\u6ca1\u6709socket\u5219\u521b\u5efa\u4e00\u4e2a\uff0c\u6709\u5224\u65ad\u662f\u5426\u8bbe\u7f6e\u4e86UV_HANDLE_BOUND\uff0c\u662f\u5219\u6267\u884cbind\uff0c\u5426\u5219\u4e0d\u6267\u884cbind err = maybe_new_socket ( tcp , addr -> sa_family , 0 ); if ( err ) return err ; on = 1 ; // \u8bbe\u7f6e\u5728\u65ad\u5f00\u8fde\u63a5\u76842 msl\u5185\u53ef\u4ee5\u91cd\u7528\u7aef\u53e3\uff0c\u6240\u4ee5Node.js\u670d\u52a1\u5668\u53ef\u4ee5\u5feb\u901f\u91cd\u542f if ( setsockopt ( tcp -> io_watcher . fd , SOL_SOCKET , SO_REUSEADDR , & on , sizeof ( on ))) return UV__ERR ( errno ); errno = 0 ; // \u6267\u884cbind if ( bind ( tcp -> io_watcher . fd , addr , addrlen ) && errno != EADDRINUSE ) { if ( errno == EAFNOSUPPORT ) return UV_EINVAL ; return UV__ERR ( errno ); } // bind\u662f\u5426\u51fa\u9519 tcp -> delayed_error = UV__ERR ( errno ); // \u6253\u4e0a\u5df2\u7ecf\u6267\u884c\u4e86bind\u7684\u6807\u8bb0 tcp -> flags |= UV_HANDLE_BOUND ; if ( addr -> sa_family == AF_INET6 ) tcp -> flags |= UV_HANDLE_IPV6 ; return 0 ; } \u6267\u884c\u5b8cbind\u540e\uff0c\u4f1a\u7ee7\u7eed\u6267\u884clisten\uff0c\u6211\u4eec\u63a5\u7740\u770blisten\u51fd\u6570\u505a\u4e86\u4ec0\u4e48\u3002\u6211\u4eec\u76f4\u63a5\u770btcp_wrap.cc\u7684Listen\u3002 1 2 3 4 5 6 7 8 9 10 11 void TCPWrap::Listen ( const FunctionCallbackInfo < Value >& args ) { TCPWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder (), args . GetReturnValue (). Set ( UV_EBADF )); int backlog = args [ 0 ] -> Int32Value (); int err = uv_listen ( reinterpret_cast < uv_stream_t *> ( & wrap -> handle_ ), backlog , OnConnection ); args . GetReturnValue (). Set ( err ); } C++\u5c42\u51e0\u4e4e\u662f\u900f\u4f20\u5230Libuv\uff0cLibuv\u7684\u5185\u5bb9\u6211\u4eec\u4e0d\u518d\u5177\u4f53\u5c55\u5f00\uff0c\u5f53\u6709\u4e09\u6b21\u63e1\u624b\u7684\u8fde\u63a5\u5b8c\u6210\u65f6\uff0c\u4f1a\u6267\u884cOnConnection 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 template < typename WrapType , typename UVType > void ConnectionWrap < WrapType , UVType >:: OnConnection ( uv_stream_t * handle , int status ) { // TCPWrap WrapType * wrap_data = static_cast < WrapType *> ( handle -> data ); Environment * env = wrap_data -> env (); HandleScope handle_scope ( env -> isolate ()); Context :: Scope context_scope ( env -> context ()); Local < Value > argv [] = { Integer :: New ( env -> isolate (), status ), Undefined ( env -> isolate ()) }; if ( status == 0 ) { // \u65b0\u5efa\u4e00\u4e2a\u8868\u793a\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5bf9\u8c61,\u5fc5\u586bTCPWrap\u5bf9\u8c61 Local < Object > client_obj = WrapType :: Instantiate ( env , wrap_data , WrapType :: SOCKET ); WrapType * wrap ; // \u89e3\u5305\u51fa\u4e00\u4e2aTCPWrap\u5bf9\u8c61\u5b58\u5230wrap ASSIGN_OR_RETURN_UNWRAP ( & wrap , client_obj ); uv_stream_t * client_handle = reinterpret_cast < uv_stream_t *> ( & wrap -> handle_ ); // \u628a\u901a\u4fe1fd\u5b58\u50a8\u5230client_handle\u4e2d if ( uv_accept ( handle , client_handle )) return ; argv [ 1 ] = client_obj ; } // \u56de\u8c03\u4e0a\u5c42\u7684onconnection\u51fd\u6570 wrap_data -> MakeCallback ( env -> onconnection_string (), arraysize ( argv ), argv ); } \u5f53\u5efa\u7acb\u4e86\u65b0\u8fde\u63a5\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u65b0\u5efa\u4e00\u4e2asocket\u8868\u793a\uff0c\u540c\u6837\uff0c\u5728Node.js\u5c42\uff0c\u4e5f\u4f1a\u65b0\u5efa\u4e00\u4e2a\u5bf9\u5e94\u7684\u5bf9\u8c61\u8868\u793a\u548c\u5ba2\u6237\u7aef\u7684\u901a\u4fe1\uff0c\u63a5\u7740\u6211\u4eec\u770bJS\u5c42\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // clientHandle\u4ee3\u8868\u4e00\u4e2a\u548c\u5ba2\u6237\u7aef\u5efa\u7acbTCP\u8fde\u63a5\u7684\u5b9e\u4f53 function onconnection ( err , clientHandle ) { var handle = this ; var self = handle . owner ; // \u9519\u8bef\u5219\u89e6\u53d1\u9519\u8bef\u4e8b\u4ef6 if ( err ) { self . emit ( 'error' , errnoException ( err , 'accept' )); return ; } // \u5efa\u7acb\u8fc7\u591a\uff0c\u5173\u6389 if ( self . maxConnections && self . _connections >= self . maxConnections ) { clientHandle . close (); return ; } //\u65b0\u5efa\u4e00\u4e2asocket\u7528\u4e8e\u901a\u4fe1 var socket = new Socket ({ handle : clientHandle , allowHalfOpen : self . allowHalfOpen , pauseOnCreate : self . pauseOnConnect }); socket . readable = socket . writable = true ; // \u670d\u52a1\u5668\u7684\u8fde\u63a5\u6570\u52a0\u4e00 self . _connections ++ ; socket . server = self ; socket . _server = self ; // \u89e6\u53d1\u7528\u6237\u5c42\u8fde\u63a5\u4e8b\u4ef6 self . emit ( 'connection' , socket ); } \u5728JS\u5c42\u4e5f\u4f1a\u5c01\u88c5\u4e00\u4e2aSocket\u5bf9\u8c61\u7528\u4e8e\u7ba1\u7406\u548c\u5ba2\u6237\u7aef\u7684\u901a\u4fe1\uff0c\u63a5\u7740\u89e6\u53d1connection\u4e8b\u4ef6\u3002\u5269\u4e0b\u7684\u4e8b\u60c5\u5c31\u662f\u5e94\u7528\u5c42\u5904\u7406\u4e86\u3002","title":"17.2 TCP \u670d\u52a1\u5668"},{"location":"chapter17-TCP/#173-keepalive","text":"\u672c\u8282\u5206\u6790\u57fa\u4e8eTCP\u5c42\u7684\u957f\u8fde\u63a5\u95ee\u9898\uff0c\u76f8\u6bd4\u5e94\u7528\u5c42HTTP\u534f\u8bae\u7684\u957f\u8fde\u63a5\uff0cTCP\u5c42\u63d0\u4f9b\u7684\u529f\u80fd\u66f4\u591a\u3002TCP\u5c42\u5b9a\u4e49\u4e86\u4e09\u4e2a\u914d\u7f6e\u3002 1 \u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\uff0c\u5219\u5f00\u59cb\u53d1\u9001\u63a2\u6d4b\u5305\u3002 2 \u6bcf\u9694\u591a\u4e45\uff0c\u518d\u6b21\u53d1\u9001\u63a2\u6d4b\u5305\u3002 3 \u53d1\u9001\u591a\u5c11\u4e2a\u63a2\u6d4b\u5305\u540e\uff0c\u5c31\u65ad\u5f00\u8fde\u63a5\u3002 \u6211\u4eec\u770bLinux\u5185\u6838\u4ee3\u7801\u91cc\u63d0\u4f9b\u7684\u914d\u7f6e\u3002 1 2 3 4 5 6 // \u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5c31\u53d1\u8d77\u63a2\u6d4b\u5305 #define TCP_KEEPALIVE_TIME (120*60*HZ) /* two hours */ // \u63a2\u6d4b\u6b21\u6570 #define TCP_KEEPALIVE_PROBES 9 /* Max of 9 keepalive probes*/ // \u6bcf\u9694\u591a\u4e45\u63a2\u6d4b\u4e00\u6b21 #define TCP_KEEPALIVE_INTVL (75*HZ) \u8fd9\u662fLinux\u63d0\u4f9b\u7684\u9ed8\u8ba4\u503c\u3002\u4e0b\u9762\u518d\u770b\u770b\u9608\u503c 1 2 3 #define MAX_TCP_KEEPIDLE 32767 #define MAX_TCP_KEEPINTVL 32767 #define MAX_TCP_KEEPCNT 127 \u8fd9\u4e09\u4e2a\u914d\u7f6e\u548c\u4e0a\u9762\u4e09\u4e2a\u4e00\u4e00\u5bf9\u5e94\u3002\u662f\u4e0a\u9762\u4e09\u4e2a\u914d\u7f6e\u7684\u9608\u503c\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2dkeep-alive\u7684\u4f7f\u7528\u3002 socket.setKeepAlive([enable][, initialDelay]) enable\uff1a\u662f\u5426\u5f00\u542fkeep-alive\uff0cLinux\u4e0b\u9ed8\u8ba4\u662f\u4e0d\u5f00\u542f\u7684\u3002 initialDelay\uff1a\u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u5c31\u5f00\u59cb\u53d1\u9001\u63a2\u6d4b\u5305\u3002 \u63a5\u7740\u6211\u4eec\u770b\u770b\u8fd9\u4e2aAPI\u5728Libuv\u4e2d\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int uv__tcp_keepalive ( int fd , int on , unsigned int delay ) { if ( setsockopt ( fd , SOL_SOCKET , SO_KEEPALIVE , & on , sizeof ( on ))) return UV__ERR ( errno ); // Linux\u5b9a\u4e49\u4e86\u8fd9\u4e2a\u5b8f #ifdef TCP_KEEPIDLE /* on\u662f1\u624d\u4f1a\u8bbe\u7f6e\uff0c\u6240\u4ee5\u5982\u679c\u6211\u4eec\u5148\u5f00\u542fkeep-alive\uff0c\u5e76\u4e14\u8bbe\u7f6edelay\uff0c \u7136\u540e\u5173\u95edkeep-alive\u7684\u65f6\u5019\uff0c\u662f\u4e0d\u4f1a\u4fee\u6539\u4e4b\u524d\u4fee\u6539\u8fc7\u7684\u914d\u7f6e\u7684\u3002 \u56e0\u4e3a\u8fd9\u4e2a\u914d\u7f6e\u5728keep-alive\u5173\u95ed\u7684\u65f6\u5019\u662f\u6ca1\u7528\u7684 */ if ( on && setsockopt ( fd , IPPROTO_TCP , TCP_KEEPIDLE , & delay , sizeof ( delay ))) return UV__ERR ( errno ); #endif return 0 ; } \u6211\u4eec\u770b\u5230Libuv\u8c03\u7528\u4e86\u540c\u4e00\u4e2a\u7cfb\u7edf\u51fd\u6570\u4e24\u6b21\u3002\u6211\u4eec\u5206\u522b\u770b\u4e00\u4e0b\u8fd9\u4e2a\u51fd\u6570\u7684\u610f\u4e49\u3002\u53c2\u8003Linux2.6.13.1\u7684\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // net\\socket.c asmlinkage long sys_setsockopt ( int fd , int level , int optname , char __user * optval , int optlen ) { int err ; struct socket * sock ; if (( sock = sockfd_lookup ( fd , & err )) != NULL ) { ... if ( level == SOL_SOCKET ) err = sock_setsockopt ( sock , level , optname , optval , optlen ); else err = sock -> ops -> setsockopt ( sock , level , optname , optval , optlen ); sockfd_put ( sock ); } return err ; } \u5f53level\u662fSOL_SOCKET\u4ee3\u8868\u4fee\u6539\u7684socket\u5c42\u9762\u7684\u914d\u7f6e\u3002IPPROTO_TCP\u662f\u4fee\u6539TCP\u5c42\u7684\u914d\u7f6e\uff08\u8be5\u7248\u672c\u4ee3\u7801\u91cc\u662fSOL_TCP\uff09\u3002\u6211\u4eec\u5148\u770bSOL_SOCKET\u5c42\u9762\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 // net\\socket.c -> net\\core\\sock.c -> net\\ipv4\\tcp_timer.c int sock_setsockopt ( struct socket * sock , int level , int optname , char __user * optval , int optlen ) { ... case SO_KEEPALIVE : if ( sk -> sk_protocol == IPPROTO_TCP ) tcp_set_keepalive ( sk , valbool ); // \u8bbe\u7f6eSOCK_KEEPOPEN\u6807\u8bb0\u4f4d1 sock_valbool_flag ( sk , SOCK_KEEPOPEN , valbool ); break ; ... } sock_setcsockopt\u9996\u5148\u8c03\u7528\u4e86tcp_set_keepalive\u51fd\u6570\uff0c\u7136\u540e\u7ed9\u5bf9\u5e94socket\u7684SOCK_KEEPOPEN\u5b57\u6bb5\u6253\u4e0a\u6807\u8bb0\uff080\u6216\u80051\u8868\u793a\u5f00\u542f\u8fd8\u662f\u5173\u95ed\uff09\u3002\u63a5\u4e0b\u6765\u6211\u4eec\u770btcp_set_keepalive 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void tcp_set_keepalive ( struct sock * sk , int val ) { if (( 1 << sk -> sk_state ) & ( TCPF_CLOSE | TCPF_LISTEN )) return ; /* \u5982\u679cval\u662f1\u5e76\u4e14\u4e4b\u524d\u662f0\uff08\u6ca1\u5f00\u542f\uff09\u90a3\u4e48\u5c31\u5f00\u542f\u8ba1\u65f6\uff0c\u8d85\u65f6\u540e\u53d1\u9001\u63a2\u6d4b\u5305\uff0c \u5982\u679c\u4e4b\u524d\u662f1\uff0cval\u53c8\u662f1\uff0c\u5219\u5ffd\u7565\uff0c\u6240\u4ee5\u91cd\u590d\u8bbe\u7f6e\u662f\u65e0\u5bb3\u7684 */ if ( val && ! sock_flag ( sk , SOCK_KEEPOPEN )) tcp_reset_keepalive_timer ( sk , keepalive_time_when ( tcp_sk ( sk ))); else if ( ! val ) // val\u662f0\u8868\u793a\u5173\u95ed\uff0c\u5219\u6e05\u9664\u5b9a\u65f6\u5668\uff0c\u5c31\u4e0d\u53d1\u9001\u63a2\u6d4b\u5305\u4e86 tcp_delete_keepalive_timer ( sk ); } \u6211\u4eec\u770b\u770b\u8d85\u65f6\u540e\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // \u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u5219\u53d1\u9001\u7b2c\u4e00\u4e2a\u63a2\u6d4b\u5305 static inline int keepalive_time_when ( const struct tcp_sock * tp ) { // \u7528\u6237\u8bbe\u7f6e\u7684\uff08TCP_KEEPIDLE\uff09\u548c\u7cfb\u7edf\u9ed8\u8ba4\u7684 return tp -> keepalive_time ? : sysctl_tcp_keepalive_time ; } // \u9694\u591a\u4e45\u53d1\u9001\u4e00\u4e2a\u63a2\u6d4b\u5305 static inline int keepalive_intvl_when ( const struct tcp_sock * tp ) { return tp -> keepalive_intvl ? : sysctl_tcp_keepalive_intvl ; } static void tcp_keepalive_timer ( unsigned long data ) { ... // \u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u4e86 elapsed = tcp_time_stamp - tp -> rcv_tstamp ; // \u662f\u5426\u8d85\u8fc7\u4e86\u9608\u503c if ( elapsed >= keepalive_time_when ( tp )) { // \u53d1\u9001\u7684\u63a2\u6d4b\u5305\u4e2a\u6570\u8fbe\u5230\u9608\u503c\uff0c\u53d1\u9001\u91cd\u7f6e\u5305 if (( ! tp -> keepalive_probes && tp -> probes_out >= sysctl_tcp_keepalive_probes ) || ( tp -> keepalive_probes && tp -> probes_out >= tp -> keepalive_probes )) { tcp_send_active_reset ( sk , GFP_ATOMIC ); tcp_write_err ( sk ); goto out ; } // \u53d1\u9001\u63a2\u6d4b\u5305\uff0c\u5e76\u8ba1\u7b97\u4e0b\u4e00\u4e2a\u63a2\u6d4b\u5305\u7684\u53d1\u9001\u65f6\u95f4\uff08\u8d85\u65f6\u65f6\u95f4\uff09 tcp_write_wakeup ( sk ) tp -> probes_out ++ ; elapsed = keepalive_intvl_when ( tp ); } else { /* \u8fd8\u6ca1\u5230\u671f\u5219\u91cd\u65b0\u8ba1\u7b97\u5230\u671f\u65f6\u95f4\uff0c\u6536\u5230\u6570\u636e\u5305\u7684\u65f6\u5019\u5e94\u8be5\u4f1a\u91cd\u7f6e\u5b9a\u65f6\u5668\uff0c \u6240\u4ee5\u6267\u884c\u8be5\u51fd\u6570\u8bf4\u660e\u7684\u786e\u662f\u8d85\u65f6\u4e86\uff0c\u6309\u7406\u8bf4\u4e0d\u4f1a\u8fdb\u5165\u8fd9\u91cc\u3002 */ elapsed = keepalive_time_when ( tp ) - elapsed ; } TCP_CHECK_TIMER ( sk ); sk_stream_mem_reclaim ( sk ); resched : // \u91cd\u65b0\u8bbe\u7f6e\u5b9a\u65f6\u5668 tcp_reset_keepalive_timer ( sk , elapsed ); ... \u6240\u4ee5\u5728SOL_SOCKET\u5c42\u9762\u662f\u8bbe\u7f6e\u662f\u5426\u5f00\u542fkeep-alive\u673a\u5236\u3002\u5982\u679c\u5f00\u542f\u4e86\uff0c\u5c31\u4f1a\u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u7684\u65f6\u5019\u5c31\u4f1a\u53d1\u9001\u63a2\u6d4b\u5305\u3002\u4f46\u662f\u6211\u4eec\u53d1\u73b0\uff0cSOL_SOCKET\u53ea\u662f\u8bbe\u7f6e\u4e86\u662f\u5426\u5f00\u542f\u63a2\u6d4b\u673a\u5236\uff0c\u5e76\u6ca1\u6709\u5b9a\u4e49\u4e0a\u9762\u4e09\u4e2a\u914d\u7f6e\u7684\u503c\uff0c\u6240\u4ee5\u7cfb\u7edf\u4f1a\u4f7f\u7528\u9ed8\u8ba4\u503c\u8fdb\u884c\u5fc3\u8df3\u673a\u5236\uff08\u5982\u679c\u6211\u4eec\u8bbe\u7f6e\u4e86\u5f00\u542fkeep-alive\u7684\u8bdd\uff09\u3002\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48Libuv\u8c03\u4e86\u4e24\u6b21setsockopt\u51fd\u6570\u3002\u7b2c\u4e8c\u6b21\u7684\u8c03\u7528\u8bbe\u7f6e\u4e86\u5c31\u662f\u4e0a\u9762\u4e09\u4e2a\u914d\u7f6e\u4e2d\u7684\u7b2c\u4e00\u4e2a\uff08\u540e\u9762\u4e24\u4e2a\u4e5f\u53ef\u4ee5\u8bbe\u7f6e\uff0c\u4e0d\u8fc7Libuv\u6ca1\u6709\u63d0\u4f9b\u63a5\u53e3\uff0c\u53ef\u4ee5\u81ea\u5df1\u8c03\u7528setsockopt\u8bbe\u7f6e\uff09\u3002\u90a3\u4e48\u6211\u4eec\u6765\u770b\u4e00\u4e0bLibuv\u7684\u7b2c\u4e8c\u6b21\u8c03\u7528setsockopt\u662f\u505a\u4e86\u4ec0\u4e48\u3002\u6211\u4eec\u76f4\u63a5\u770bTCP\u5c42\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // net\\ipv4\\tcp.c int tcp_setsockopt ( struct sock * sk , int level , int optname , char __user * optval , int optlen ) { ... case TCP_KEEPIDLE : // \u4fee\u6539\u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u5219\u53d1\u9001\u63a2\u6d4b\u5305\u7684\u914d\u7f6e tp -> keepalive_time = val * HZ ; // \u662f\u5426\u5f00\u542f\u4e86keep-alive\u673a\u5236 if ( sock_flag ( sk , SOCK_KEEPOPEN ) && ! (( 1 << sk -> sk_state ) & ( TCPF_CLOSE | TCPF_LISTEN ))) { // \u5f53\u524d\u65f6\u95f4\u51cf\u53bb\u4e0a\u6b21\u6536\u5230\u6570\u636e\u5305\u7684\u65f6\u5019\uff0c\u5373\u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u4e86 __u32 elapsed = tcp_time_stamp - tp -> rcv_tstamp ; // \u7b97\u51fa\u8fd8\u8981\u591a\u4e45\u53ef\u4ee5\u53d1\u9001\u63a2\u6d4b\u5305\uff0c\u8fd8\u662f\u53ef\u4ee5\u76f4\u63a5\u53d1\uff08\u5df2\u7ecf\u89e6\u53d1\u4e86\uff09 if ( tp -> keepalive_time > elapsed ) elapsed = tp -> keepalive_time - elapsed ; else elapsed = 0 ; // \u8bbe\u7f6e\u5b9a\u65f6\u5668 tcp_reset_keepalive_timer ( sk , elapsed ); } ... } \u8be5\u51fd\u6570\u9996\u5148\u4fee\u6539\u914d\u7f6e\uff0c\u7136\u540e\u5224\u65ad\u662f\u5426\u5f00\u542f\u4e86keep-alive\u7684\u673a\u5236\uff0c\u5982\u679c\u5f00\u542f\u4e86\uff0c\u5219\u91cd\u65b0\u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u8d85\u65f6\u7684\u65f6\u5019\u5c31\u4f1a\u53d1\u9001\u63a2\u6d4b\u5305\u3002\u4f46\u662f\u6709\u4e00\u4e2a\u95ee\u9898\u662f\uff0c\u5fc3\u8df3\u673a\u5236\u5e76\u4e0d\u662f\u4ec0\u4e48\u65f6\u5019\u90fd\u597d\u4f7f\uff0c\u5982\u679c\u4e24\u7aef\u90fd\u6ca1\u6709\u6570\u636e\u6765\u5f80\u65f6\uff0c\u5fc3\u8df3\u673a\u5236\u80fd\u5f88\u597d\u5730\u5de5\u4f5c\uff0c\u4f46\u662f\u4e00\u65e6\u672c\u7aef\u6709\u6570\u636e\u53d1\u9001\u7684\u65f6\u5019\uff0c\u5b83\u5c31\u4f1a\u6291\u5236\u5fc3\u8df3\u673a\u5236\u3002\u6211\u4eec\u770b\u4e00\u4e0bLinux\u5185\u68385.7.7\u7684\u4e00\u6bb5\u76f8\u5173\u4ee3\u7801\uff0c\u5982\u56fe17-3\u6240\u793a\u3002 \u56fe17-3 \u4e0a\u9762\u8fd9\u4e00\u6bb5\u662f\u5fc3\u8df3\u673a\u5236\u4e2d\uff0c\u5b9a\u65f6\u5668\u8d85\u65f6\u65f6\uff0c\u6267\u884c\u7684\u4e00\u6bb5\u903b\u8f91\uff0c\u6211\u4eec\u53ea\u9700\u8981\u5173\u6ce8\u7ea2\u8272\u6846\u91cc\u7684\u4ee3\u7801\u3002\u4e00\u822c\u6765\u8bf4\uff0c\u5fc3\u8df3\u5b9a\u65f6\u5668\u8d85\u65f6\uff0c\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u53d1\u9001\u4e00\u4e2a\u65b0\u7684\u5fc3\u8df3\u5305\uff0c\u4f46\u662f\u5982\u679c\u53d1\u9001\u961f\u5217\u91cc\u8fd8\u6709\u6570\u636e\u6ca1\u6709\u53d1\u9001\uff0c\u90a3\u4e48\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u4f18\u5148\u53d1\u9001\u3002\u6216\u8005\u53d1\u9001\u51fa\u53bb\u7684\u6ca1\u6709ack\uff0c\u4e5f\u4f1a\u4f18\u5148\u89e6\u53d1\u91cd\u4f20\u3002\u8fd9\u65f6\u5019\u5fc3\u8df3\u673a\u5236\u5c31\u5931\u6548\u4e86\u3002\u5bf9\u4e8e\u8fd9\u4e2a\u95ee\u9898\uff0cLinux\u63d0\u4f9b\u4e86\u53e6\u4e00\u4e2a\u5c5e\u6027TCP_USER_TIMEOUT\u3002\u8fd9\u4e2a\u5c5e\u6027\u7684\u529f\u80fd\u662f\uff0c\u53d1\u9001\u4e86\u6570\u636e\uff0c\u591a\u4e45\u6ca1\u6709\u6536\u5230ack\u540e\uff0c\u64cd\u4f5c\u7cfb\u7edf\u5c31\u8ba4\u4e3a\u8fd9\u4e2a\u8fde\u63a5\u65ad\u5f00\u4e86\u3002\u770b\u4e00\u4e0b\u76f8\u5173\u4ee3\u7801\uff0c\u5982\u56fe17-4\u6240\u793a\u3002 \u56fe17-4 \u4e0b\u9762\u662f\u8bbe\u7f6e\u9608\u503c\u7684\u4ee3\u7801\uff0c\u5982\u56fe17-5\u6240\u793a\u3002 \u56fe17-5 \u8fd9\u662f\u8d85\u65f6\u65f6\u5224\u65ad\u662f\u5426\u65ad\u5f00\u8fde\u63a5\u7684\u4ee3\u7801\u3002\u6211\u4eec\u770b\u5230\u6709\u4e24\u4e2a\u60c5\u51b5\u4e0b\u64cd\u4f5c\u7cfb\u7edf\u4f1a\u8ba4\u4e3a\u8fde\u63a5\u65ad\u5f00\u4e86\u3002 1 \u8bbe\u7f6e\u4e86TCP_USER_TIMEOUT\u65f6\uff0c\u5982\u679c\u53d1\u9001\u5305\u6570\u91cf\u5927\u4e8e1\u5e76\u4e14\u5f53\u524d\u65f6\u95f4\u8ddd\u79bb\u4e0a\u6b21\u6536\u5230\u5305\u7684\u65f6\u95f4\u95f4\u9694\u5df2\u7ecf\u8fbe\u5230\u9608\u503c\u3002 2 \u6ca1\u6709\u8bbe\u7f6eTCP_USER_TIMEOUT\uff0c\u4f46\u662f\u5fc3\u8df3\u5305\u53d1\u9001\u6570\u91cf\u8fbe\u5230\u9608\u503c\u3002 \u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u540c\u65f6\u8bbe\u7f6e\u8fd9\u4e24\u4e2a\u5c5e\u6027\u3002\u4fdd\u8bc1\u5fc3\u8df3\u673a\u5236\u53ef\u4ee5\u6b63\u5e38\u8fd0\u884c\uff0c Node.js\u7684keep-alive\u6709\u4e24\u4e2a\u5c42\u9762\u7684\u5185\u5bb9\uff0c\u7b2c\u4e00\u4e2a\u662f\u662f\u5426\u5f00\u542f\uff0c\u7b2c\u4e8c\u4e2a\u662f\u5f00\u542f\u540e\uff0c\u4f7f\u7528\u7684\u914d\u7f6e\u3002Node.js\u7684setKeepAlive\u5c31\u662f\u505a\u4e86\u8fd9\u4e24\u4ef6\u4e8b\u60c5\u3002\u53ea\u4e0d\u8fc7\u5b83\u53ea\u652f\u6301\u4fee\u6539\u4e00\u4e2a\u914d\u7f6e\u3002Node.js\u53ea\u652f\u6301TCP_KEEPALIVE_TIME\u3002\u53e6\u5916\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4e00\u4e0b\u4ee3\u7801\u5224\u65ad\u914d\u7f6e\u7684\u503c\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 include < stdio . h > #include <netinet/tcp.h> int main ( int argc , const char * argv []) { int sockfd ; int optval ; socklen_t optlen = sizeof ( optval ); sockfd = socket ( AF_INET , SOCK_STREAM , 0 ); getsockopt ( sockfd , SOL_SOCKET , SO_KEEPALIVE , & optval , & optlen ); printf ( \"\u9ed8\u8ba4\u662f\u5426\u5f00\u542fkeep-alive\uff1a%d \\n \" , optval ); getsockopt ( sockfd , SOL_TCP , TCP_KEEPIDLE , & optval , & optlen ); printf ( \"\u591a\u4e45\u6ca1\u6709\u6536\u5230\u6570\u636e\u5305\u5219\u53d1\u9001\u63a2\u6d4b\u5305\uff1a%d seconds \\n \" , optval ); getsockopt ( sockfd , SOL_TCP , TCP_KEEPINTVL , & optval , & optlen ); printf ( \"\u591a\u4e45\u53d1\u9001\u4e00\u6b21\u63a2\u6d4b\u5305\uff1a%d seconds \\n \" , optval ); getsockopt ( sockfd , SOL_TCP , TCP_KEEPCNT , & optval , & optlen ); printf ( \"\u6700\u591a\u53d1\u9001\u51e0\u4e2a\u63a2\u6d4b\u5305\u5c31\u65ad\u5f00\u8fde\u63a5\uff1a%d \\n \" , optval ); return 0 ; } \u8f93\u51fa\u5982\u56fe17-6\u6240\u793a\u3002 \u56fe17-6 \u518d\u770b\u4e00\u4e0bwireshark\u4e0b\u7684keepalive\u5305\uff0c\u5982\u56fe17-7\u6240\u793a\u3002 \u56fe17-7","title":"17.3 keepalive"},{"location":"chapter17-TCP/#174-allowhalfopen","text":"\u6211\u4eec\u77e5\u9053TCP\u8fde\u63a5\u5728\u6b63\u5e38\u65ad\u5f00\u7684\u65f6\u5019\uff0c\u4f1a\u8d70\u56db\u6b21\u6325\u624b\u7684\u6d41\u7a0b\uff0c\u5728Node.js\u4e2d\uff0c\u5f53\u6536\u5230\u5bf9\u7aef\u53d1\u9001\u8fc7\u6765\u7684fin\u5305\u65f6\uff0c\u56de\u590dack\u540e\uff0c\u9ed8\u8ba4\u4f1a\u53d1\u9001fin\u5305\u7ed9\u5bf9\u7aef\uff0c\u4ee5\u5b8c\u6210\u56db\u6b21\u6325\u624b\u3002\u4f46\u662f\u6211\u4eec\u53ef\u80fd\u4f1a\u6709\u8fd9\u6837\u7684\u573a\u666f\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u5b8c\u6570\u636e\u540e\uff0c\u53d1\u9001fin\u5305\u8868\u793a\u81ea\u5df1\u6ca1\u6709\u6570\u636e\u53ef\u5199\u4e86\uff0c\u53ea\u9700\u8981\u7b49\u5f85\u670d\u52a1\u5668\u8fd4\u56de\u3002\u8fd9\u65f6\u5019\u5982\u679c\u670d\u52a1\u5668\u5728\u6536\u5230fin\u5305\u540e\uff0c\u4e5f\u56de\u590dfin\uff0c\u90a3\u5c31\u4f1a\u6709\u95ee\u9898\u3002\u5728Node.js\u4e2d\u63d0\u4f9b\u4e86allowHalfOpen\u9009\u9879\u652f\u6301\u534a\u5173\u95ed\uff0c\u6211\u4eec\u77e5\u9053TCP\u662f\u5168\u53cc\u5de5\u7684\uff0c\u4e24\u7aef\u53ef\u4ee5\u540c\u65f6\u4e92\u76f8\u53d1\u9001\u6570\u636e\uff0callowHalfOpen\u76f8\u5f53\u4e8e\u628a\u4e00\u7aef\u5173\u95ed\u4e86\uff0c\u5141\u8bb8\u6570\u636e\u5355\u5411\u4f20\u8f93\u3002\u6211\u4eec\u770b\u4e00\u4e0ballowHalfOpen\u7684\u5b9e\u73b0\u3002allowHalfOpen\u662f\u5c5e\u4e8eSocket\u7684\u9009\u9879\u3002\u6211\u4eec\u4eceNode.js\u6536\u5230\u4e00\u4e2afin\u5305\u5f00\u59cb\u5206\u6790\u6574\u4e2a\u6d41\u7a0b\u3002\u9996\u5148\u5728\u65b0\u5efaSocket\u5bf9\u8c61\u7684\u65f6\u5019\uff0c\u6ce8\u518c\u5bf9\u5e94\u4e8b\u4ef6\u3002 socket.on('_socketEnd', onSocketEnd); \u5f53\u64cd\u4f5c\u7cfb\u7edf\u6536\u5230fin\u5305\u7684\u65f6\u5019\uff0c\u4f1a\u89e6\u53d1socket\u7684\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u6267\u884cNode.js\u7684\u8bfb\u56de\u8c03\u3002Node.js\u6267\u884c\u8bfb\u53d6\u7684\u65f6\u5019\u53d1\u73b0\uff0c\u8bfb\u53d6\u5df2\u7ed3\u675f\uff0c\u56e0\u4e3a\u5bf9\u7aef\u53d1\u9001\u4e86fin\u5305\u3002\u8fd9\u65f6\u5019\u4f1a\u89e6\u53d1_socketEnd\u4e8b\u4ef6\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u76f8\u5173\u4ee3\u7801\u3002 1 2 3 4 5 6 7 function onSocketEnd () { // ... if ( ! this . allowHalfOpen ) { this . write = writeAfterFIN ; this . destroySoon (); } } allowHalfOpen\u9ed8\u8ba4\u662ffalse\u3002onSocketEnd\u9996\u5148\u8bbe\u7f6ewrite\u51fd\u6570\u4e3awriteAfterFIN\uff0c\u6211\u4eec\u770b\u770b\u8fd9\u65f6\u5019\u5982\u679c\u6211\u4eec\u5199\u4f1a\u600e\u6837\u3002\u6211\u4eec\u4f1a\u6536\u5230\u4e00\u4e2a\u9519\u8bef\u3002 1 2 3 4 5 6 7 8 function writeAfterFIN ( chunk , encoding , cb ) { var er = new Error ( 'This socket has been ended by the other party' ); er . code = 'EPIPE' ; this . emit ( 'error' , er ); if ( typeof cb === 'function' ) { nextTick ( this [ async_id_symbol ], cb , er ); } } \u8bbe\u7f6e\u5b8cwrite\u540e\uff0c\u63a5\u7740Node.js\u4f1a\u53d1\u9001fin\u5305\u3002 1 2 3 4 5 6 7 8 9 10 Socket . prototype . destroySoon = function () { // \u5173\u95ed\u5199\u6d41 if ( this . writable ) this . end (); // \u5173\u95ed\u6210\u529f\u540e\u9500\u6bc1\u6d41 if ( this . _writableState . finished ) this . destroy (); else this . once ( 'finish' , this . destroy ); }; \u9996\u5148\u5173\u95ed\u5199\u6d41\uff0c\u7136\u540e\u6267\u884cdestroy\u51fd\u6570\u9500\u6bc1\u6d41\u3002\u5728destroy\u4e2d\u4f1a\u6267\u884c_destroy\u3002_destroy\u4f1a\u6267\u884c\u5177\u4f53\u7684\u5173\u95ed\u64cd\u4f5c\uff0c\u5373\u53d1\u9001fin\u5305\u3002 1 2 3 this._handle.close(() => { this.emit('close', isException); }); \u6211\u4eec\u770b\u5230C++\u5c42\u7684close\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void HandleWrap::Close ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); HandleWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder ()); // \u5173\u95edhandle uv_close ( wrap -> handle_ , OnClose ); wrap -> state_ = kClosing ; // \u6267\u884c\u56de\u8c03\uff0c\u89e6\u53d1close\u4e8b\u4ef6 if ( args [ 0 ] -> IsFunction ()) { wrap -> object () -> Set ( env -> onclose_string (), args [ 0 ]); wrap -> state_ = kClosingWithCallback ; } } \u6211\u4eec\u7ee7\u7eed\u5f80Libuv\u770b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 void uv_close ( uv_handle_t * handle , uv_close_cb cb ) { uv_loop_t * loop = handle -> loop ; handle -> close_cb = cb ; switch ( handle -> type ) { case UV_TCP : uv_tcp_close ( loop , ( uv_tcp_t * ) handle ); return ; // ... } } uv_tcp_close\u4f1a\u5bf9close\u7684\u5c01\u88c5\uff0c\u6211\u4eec\u770btcp close\u7684\u5927\u81f4\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 static void tcp_close ( struct sock * sk , int timeout ) { // \u76d1\u542c\u578b\u7684socket\u8981\u5173\u95ed\u5efa\u7acb\u7684\u8fde\u63a5 if ( sk -> state == TCP_LISTEN ) { /* Special case */ tcp_set_state ( sk , TCP_CLOSE ); // \u5173\u95ed\u5df2\u7ecf\u5efa\u7acb\u7684\u8fde\u63a5 tcp_close_pending ( sk ); release_sock ( sk ); return ; } struct sk_buff * skb ; // \u9500\u6bc1\u63a5\u6536\u961f\u5217\u4e2d\u672a\u5904\u7406\u7684\u6570\u636e while (( skb = skb_dequeue ( & sk -> receive_queue )) != NULL ) kfree_skb ( skb , FREE_READ ); // \u53d1\u9001fin\u5305 tcp_send_fin ( sk ); release_sock ( sk ); } \u4ee5\u4e0a\u662fNode.js\u4e2dsocket\u6536\u5230fin\u5305\u65f6\u7684\u9ed8\u8ba4\u5904\u7406\u6d41\u7a0b\uff0c\u5f53\u6211\u4eec\u8bbe\u7f6eallowHalfOpen\u4e3atrue\u7684\u65f6\u5019\uff0c\u5c31\u53ef\u4ee5\u4fee\u6539\u8fd9\u4e2a\u9ed8\u8ba4\u7684\u884c\u4e3a\uff0c\u5141\u8bb8\u534a\u5173\u95ed\u72b6\u6001\u7684\u8fde\u63a5\u3002","title":"17.4 allowHalfOpen"},{"location":"chapter17-TCP/#175-server-close","text":"\u8c03\u7528close\u53ef\u4ee5\u5173\u95ed\u4e00\u4e2a\u670d\u52a1\u5668\uff0c\u9996\u5148\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u6587\u6863\u5173\u4e8eclose\u51fd\u6570\u7684\u89e3\u91ca Stops the server from accepting new connections and keeps existing connections. This function is asynchronous, the server is finally closed when all connections are ended and the server emits a 'close' event. The optional callback will be called once the 'close' event occurs. Unlike that event, it will be called with an Error as its only argument if the server was not open when it was closed. \u5728Node.js\u4e2d \uff0c\u5f53\u6211\u4eec\u4f7f\u7528close\u5173\u95ed\u4e00\u4e2aserver\u65f6\uff0cserver\u4f1a\u7b49\u6240\u6709\u7684\u8fde\u63a5\u5173\u95ed\u540e\u624d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u3002\u6211\u4eec\u770bclose\u7684\u5b9e\u73b0\uff0c\u4e00\u63a2\u7a76\u7adf\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Server . prototype . close = function ( cb ) { // \u89e6\u53d1\u56de\u8c03 if ( typeof cb === 'function' ) { if ( ! this . _handle ) { this . once ( 'close' , function close () { cb ( new errors . Error ( 'ERR_SERVER_NOT_RUNNING' )); }); } else { this . once ( 'close' , cb ); } } // \u5173\u95ed\u5e95\u5c42\u8d44\u6e90 if ( this . _handle ) { this . _handle . close (); this . _handle = null ; } // \u5224\u65ad\u662f\u5426\u9700\u8981\u7acb\u523b\u89e6\u53d1close\u4e8b\u4ef6 this . _emitCloseIfDrained (); return this ; }; close\u7684\u4ee3\u7801\u6bd4\u8f83\u7b80\u5355\uff0c\u9996\u5148\u76d1\u542cclose\u4e8b\u4ef6\uff0c\u7136\u540e\u5173\u95edserver\u5bf9\u5e94\u7684handle\uff0c\u6240\u4ee5server\u4e0d\u4f1a\u518d\u63a5\u6536\u65b0\u7684\u8bf7\u6c42\u4e86\u3002\u6700\u540e\u8c03\u7528_emitCloseIfDrained\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u51fd\u6570\u662f\u5e72\u561b\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Server . prototype . _emitCloseIfDrained = function () { // \u8fd8\u6709\u8fde\u63a5\u6216\u8005handle\u975e\u7a7a\u8bf4\u660ehandle\u8fd8\u6ca1\u6709\u5173\u95ed\uff0c\u5219\u5148\u4e0d\u89e6\u53d1close\u4e8b\u4ef6 if ( this . _handle || this . _connections ) { return ; } // \u89e6\u53d1close\u4e8b\u4ef6 const asyncId = this . _handle ? this [ async_id_symbol ] : null ; nextTick ( asyncId , emitCloseNT , this ); }; function emitCloseNT ( self ) { self . emit ( 'close' ); } _emitCloseIfDrained\u4e2d\u6709\u4e00\u4e2a\u62e6\u622a\u7684\u5224\u65ad\uff0chandle\u975e\u7a7a\u6216\u8005\u8fde\u63a5\u6570\u975e0\u3002\u7531\u4e4b\u524d\u7684\u4ee3\u7801\u6211\u4eec\u5df2\u7ecf\u77e5\u9053handle\u662fnull\uff0c\u4f46\u662f\u5982\u679c\u8fd9\u65f6\u5019\u8fde\u63a5\u6570\u975e0\uff0c\u4e5f\u4e0d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u3002\u90a3\u4ec0\u4e48\u65f6\u5019\u624d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u5462\uff1f\u5728socket\u7684_destroy\u51fd\u6570\u4e2d\u6211\u4eec\u627e\u5230\u4fee\u6539\u8fde\u63a5\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 Socket . prototype . _destroy = function ( exception , cb ) { ... // socket\u6240\u5c5e\u7684server if ( this . _server ) { // server\u4e0b\u7684\u8fde\u63a5\u6570\u51cf\u4e00 this . _server . _connections -- ; // \u662f\u5426\u9700\u8981\u89e6\u53d1server\u7684close\u4e8b\u4ef6\uff0c\u5f53\u6240\u6709\u7684\u8fde\u63a5\uff08socket\uff09\u90fd\u5173\u95ed\u65f6\u624d\u89e6\u53d1server\u7684\u662fclose\u4e8b\u4ef6 if ( this . _server . _emitCloseIfDrained ) { this . _server . _emitCloseIfDrained (); } } }; \u6211\u4eec\u770b\u5230\u6bcf\u4e00\u4e2a\u8fde\u63a5\u5173\u95ed\u7684\u65f6\u5019\uff0c\u90fd\u4f1a\u5bfc\u81f4\u8fde\u63a5\u6570\u51cf\u4e00\uff0c\u76f4\u5230\u4e3a0\u7684\u65f6\u5019\u624d\u4f1a\u89e6\u53d1close\u4e8b\u4ef6\u3002\u5047\u8bbe\u6211\u4eec\u542f\u52a8\u4e86\u4e00\u4e2a\u670d\u52a1\u5668\uff0c\u63a5\u6536\u5230\u4e86\u4e00\u4e9b\u5ba2\u6237\u7aef\u7684\u8bf7\u6c42\uff0c\u8fd9\u65f6\u5019\uff0c\u5982\u679c\u6211\u4eec\u60f3\u4fee\u6539\u4e00\u4e2a\u4ee3\u7801\u53d1\u5e03\uff0c\u9700\u8981\u91cd\u542f\u670d\u52a1\u5668\uff0c\u600e\u4e48\u529e\uff1f\u5047\u8bbe\u6211\u4eec\u6709\u4ee5\u4e0b\u4ee3\u7801\u3002 server.js 1 2 const net = require ( 'net' ); const server = net . createServer (). listen ( 80 ); client.js 1 2 const net = require('net'); net.connect({port:80}) \u5982\u679c\u6211\u4eec\u76f4\u63a5\u6740\u6b7b\u8fdb\u7a0b\uff0c\u90a3\u4e48\u5b58\u91cf\u7684\u8bf7\u6c42\u5c31\u4f1a\u65e0\u6cd5\u6b63\u5e38\u88ab\u5904\u7406\u3002\u8fd9\u4f1a\u5f71\u54cd\u6211\u4eec\u7684\u670d\u52a1\u8d28\u91cf\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u5982\u4f55\u5728\u91cd\u542f\u65f6\u4f18\u96c5\u5730\u9000\u51fa\uff0c\u6240\u8c13\u4f18\u96c5\uff0c\u5373\u8ba9Node.js\u8fdb\u7a0b\u5904\u7406\u5b8c\u5b58\u91cf\u8bf7\u6c42\u540e\u518d\u9000\u51fa\u3002Server\u7684close\u7684\u5b9e\u73b0\u7ed9\u4e86\u6211\u4eec\u4e00\u4e9b\u601d\u8def\u3002\u6211\u4eec\u53ef\u4ee5\u76d1\u542cserver\u7684close\u4e8b\u4ef6\uff0c\u7b49\u5230\u89e6\u53d1close\u4e8b\u4ef6\u540e\u624d\u9000\u51fa\u8fdb\u7a0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 const net = require ( 'net' ); const server = net . createServer (). listen ( 80 ); server . on ( 'close' , () => { process . exit (); }); // \u9632\u6b62\u8fdb\u7a0b\u63d0\u524d\u6302\u6389 process . on ( 'uncaughtException' , () => { }); process . on ( 'SIGINT' , function () { server . close (); }) \u6211\u4eec\u9996\u5148\u76d1\u542cSIGINT\u4fe1\u53f7\uff0c\u5f53\u6211\u4eec\u4f7f\u7528SIGINT\u4fe1\u53f7\u6740\u6b7b\u8fdb\u7a0b\u65f6\uff0c\u9996\u5148\u8c03\u7528server.close\uff0c\u7b49\u5230\u6240\u6709\u7684\u8fde\u63a5\u65ad\u5f00\uff0c\u89e6\u53d1close\u65f6\u5019\u65f6\uff0c\u518d\u9000\u51fa\u8fdb\u7a0b\u3002\u6211\u4eec\u9996\u5148\u5f00\u542f\u670d\u52a1\u5668\uff0c\u7136\u540e\u5f00\u542f\u4e24\u4e2a\u5ba2\u6237\u7aef\u3002\u63a5\u7740\u6309\u4e0bctrl+c\uff0c\u6211\u4eec\u53d1\u73b0\u8fd9\u65f6\u5019\u670d\u52a1\u5668\u4e0d\u4f1a\u9000\u51fa\uff0c\u7136\u540e\u6211\u4eec\u5173\u95ed\u4e24\u4e2a\u5ba2\u6237\u7aef\uff0c\u8fd9\u65f6\u5019server\u5c31\u4f1a\u4f18\u96c5\u5730\u9000\u51fa\u3002","title":"17.5 server close"},{"location":"chapter18-HTTP/","text":"HTTP\u6a21\u5757\u5b9e\u73b0\u4e86HTTP\u670d\u52a1\u5668\u548c\u5ba2\u6237\u7aef\u7684\u529f\u80fd\uff0c\u662fNode.js\u7684\u6838\u5fc3\u6a21\u5757\uff0c\u4e5f\u662f\u6211\u4eec\u4f7f\u7528\u5f97\u6700\u591a\u7684\u6a21\u5757\u3002\u672c\u7ae0\u6211\u4eec\u6765\u5206\u6790HTTP\u6a21\u5757\uff0c\u4ece\u4e2d\u6211\u4eec\u53ef\u4ee5\u5b66\u4e60\u5230\u4e00\u4e2aHTTP\u670d\u52a1\u5668\u548c\u5ba2\u6237\u7aef\u662f\u600e\u4e48\u5b9e\u73b0\u7684\uff0c\u4ee5\u53caHTTP\u534f\u8bae\u672c\u8eab\u7684\u4e00\u4e9b\u539f\u7406\u548c\u4f18\u5316\u3002 18.1 HTTP\u89e3\u6790\u5668 \u00b6 HTTP\u89e3\u6790\u5668\u662fHTTP\u6a21\u5757\u7684\u6838\u5fc3\uff0c\u4e0d\u7ba1\u662f\u4f5c\u4e3a\u670d\u52a1\u5668\u5904\u7406\u8bf7\u6c42\u8fd8\u662f\u5ba2\u6237\u7aef\u5904\u7406\u54cd\u5e94\u90fd\u9700\u8981\u4f7f\u7528HTTP\u89e3\u6790\u5668\u89e3\u6790HTTP\u534f\u8bae\u3002\u65b0\u7248Node.js\u4f7f\u7528\u4e86\u65b0\u7684HTTP\u89e3\u6790\u5668llhttp\u3002\u6839\u636e\u5b98\u65b9\u8bf4\u660ellhttp\u6bd4\u65e7\u7248\u7684http_parser\u5728\u6027\u80fd\u4e0a\u6709\u4e86\u975e\u5e38\u5927\u7684\u63d0\u9ad8\u3002\u672c\u8282\u6211\u4eec\u5206\u6790\u5206\u6790llhttp\u7684\u57fa\u7840\u539f\u7406\u548c\u4f7f\u7528\u3002HTTP\u89e3\u6790\u5668\u662f\u4e00\u4e2a\u975e\u5e38\u590d\u6742\u7684\u72b6\u6001\u673a\uff0c\u5728\u89e3\u6790\u6570\u636e\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4f1a\u4e0d\u65ad\u89e6\u53d1\u94a9\u5b50\u51fd\u6570\u3002\u4e0b\u9762\u662fllhttp\u652f\u6301\u7684\u94a9\u5b50\u51fd\u6570\u3002\u5982\u679c\u7528\u6237\u5b9a\u4e49\u4e86\u5bf9\u5e94\u7684\u94a9\u5b50\uff0c\u5728\u89e3\u6790\u7684\u8fc7\u7a0b\u4e2d\u5c31\u4f1a\u88ab\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 // \u5f00\u59cb\u89e3\u6790HTTP\u534f\u8bae int llhttp__on_message_begin ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_message_begin , s ); return err ; } // \u89e3\u6790\u51fa\u8bf7\u6c42url\u65f6\u7684\u56de\u8c03\uff0c\u6700\u540e\u62ff\u5230\u4e00\u4e2aurl int llhttp__on_url ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_url , s , p , endp - p ); return err ; } // \u89e3\u6790\u51faHTTP\u54cd\u5e94\u72b6\u6001\u7684\u56de\u8c03 int llhttp__on_status ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_status , s , p , endp - p ); return err ; } // \u89e3\u6790\u51fa\u5934\u90e8\u952e\u65f6\u7684\u56de\u8c03 int llhttp__on_header_field ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_header_field , s , p , endp - p ); return err ; } // \u89e3\u6790\u51fa\u5934\u90e8\u503c\u65f6\u7684\u56de\u8c03 int llhttp__on_header_value ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_header_value , s , p , endp - p ); return err ; } // \u89e3\u6790HTTP\u5934\u5b8c\u6210\u65f6\u7684\u56de\u8c03 int llhttp__on_headers_complete ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_headers_complete , s ); return err ; } // \u89e3\u6790\u5b8cbody\u7684\u56de\u8c03 int llhttp__on_message_complete ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_message_complete , s ); return err ; } // \u89e3\u6790body\u65f6\u7684\u56de\u8c03 int llhttp__on_body ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_body , s , p , endp - p ); return err ; } // \u89e3\u6790\u5230\u4e00\u4e2achunk\u7ed3\u6784\u5934\u65f6\u7684\u56de\u8c03 int llhttp__on_chunk_header ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_chunk_header , s ); return err ; } // \u89e3\u6790\u5b8c\u4e00\u4e2achunk\u65f6\u7684\u56de\u8c03 int llhttp__on_chunk_complete ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_chunk_complete , s ); return err ; } Node.js\u5728node_http_parser.cc\u4e2d\u5bf9llhttp\u8fdb\u884c\u4e86\u5c01\u88c5\u3002\u8be5\u6a21\u5757\u5bfc\u51fa\u4e86\u4e00\u4e2aHTTPParser\u3002 1 2 3 4 5 6 7 Local < FunctionTemplate > t = env -> NewFunctionTemplate ( Parser :: New ); t -> InstanceTemplate () -> SetInternalFieldCount ( 1 ); t -> SetClassName ( FIXED_ONE_BYTE_STRING ( env -> isolate (), \"HTTPParser\" )); target -> Set ( env -> context (), FIXED_ONE_BYTE_STRING ( env -> isolate (), \"HTTPParser\" ), t -> GetFunction ( env -> context ()). ToLocalChecked ()). Check (); \u5728Node.js\u4e2d\u6211\u4eec\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u4f7f\u7528HTTPParser\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const parser = new HTTPParser (); cleanParser ( parser ); parser . onIncoming = null ; parser [ kOnHeaders ] = parserOnHeaders ; parser [ kOnHeadersComplete ] = parserOnHeadersComplete ; parser [ kOnBody ] = parserOnBody ; parser [ kOnMessageComplete ] = parserOnMessageComplete ; // \u521d\u59cb\u5316HTTP\u89e3\u6790\u5668\u5904\u7406\u7684\u62a5\u6587\u7c7b\u578b\uff0c\u8fd9\u91cc\u662f\u54cd\u5e94\u62a5\u6587 parser . initialize ( HTTPParser . RESPONSE , new HTTPClientAsyncResource ( 'HTTPINCOMINGMESSAGE' , req ), req . maxHeaderSize || 0 , req . insecureHTTPParser === undefined ? isLenient () : req . insecureHTTPParser ); // \u6536\u5230\u6570\u636e\u540e\u4f20\u7ed9\u89e3\u6790\u5668\u5904\u7406 const ret = parser . execute ( data ); } \u6211\u4eec\u770b\u4e00\u4e0binitialize\u548cexecute\u7684\u4ee3\u7801\u3002Initialize\u51fd\u6570\u7528\u4e8e\u521d\u59cb\u5316llhttp\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 static void Initialize ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); bool lenient = args [ 3 ] -> IsTrue (); uint64_t max_http_header_size = 0 ; // \u5934\u90e8\u7684\u6700\u5927\u5927\u5c0f if ( args . Length () > 2 ) { max_http_header_size = args [ 2 ]. As < Number > () -> Value (); } // \u6ca1\u6709\u8bbe\u7f6e\u5219\u53d6Node.js\u7684\u9ed8\u8ba4\u503c if ( max_http_header_size == 0 ) { max_http_header_size = env -> options () -> max_http_header_size ; } // \u89e3\u6790\u7684\u62a5\u6587\u7c7b\u578b llhttp_type_t type = static_cast < llhttp_type_t > ( args [ 0 ]. As < Int32 > () -> Value ()); CHECK ( type == HTTP_REQUEST || type == HTTP_RESPONSE ); Parser * parser ; ASSIGN_OR_RETURN_UNWRAP ( & parser , args . Holder ()); parser -> Init ( type , max_http_header_size , lenient ); } Initialize\u505a\u4e86\u4e00\u4e9b\u9884\u5904\u7406\u540e\u8c03\u7528Init\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 void Init ( llhttp_type_t type , uint64_t max_http_header_size , bool lenient ) { // \u521d\u59cb\u5316llhttp llhttp_init ( & parser_ , type , & settings ); llhttp_set_lenient ( & parser_ , lenient ); header_nread_ = 0 ; url_ . Reset (); status_message_ . Reset (); num_fields_ = 0 ; num_values_ = 0 ; have_flushed_ = false ; got_exception_ = false ; max_http_header_size_ = max_http_header_size ; } Init\u505a\u4e86\u4e00\u4e9b\u5b57\u6bb5\u7684\u521d\u59cb\u5316\uff0c\u6700\u91cd\u8981\u7684\u662f\u8c03\u7528\u4e86llhttp_init\u5bf9llhttp\u8fdb\u884c\u4e86\u521d\u59cb\u5316\uff0c\u53e6\u5916kOn\u5f00\u5934\u7684\u5c5e\u6027\u662f\u94a9\u5b50\u51fd\u6570\uff0c\u7531node_http_parser.cc\u4e2d\u7684\u56de\u8c03\uff0c\u800cnode_http_parser.cc\u4e5f\u4f1a\u5b9a\u4e49\u94a9\u5b50\u51fd\u6570\uff0c\u7531llhttp\u56de\u8c03\uff0c\u6211\u4eec\u770b\u4e00\u4e0bnode_http_parser.cc\u94a9\u5b50\u51fd\u6570\u7684\u5b9a\u4e49\u548c\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 const llhttp_settings_t Parser :: settings = { Proxy < Call , & Parser :: on_message_begin >:: Raw , Proxy < DataCall , & Parser :: on_url >:: Raw , Proxy < DataCall , & Parser :: on_status >:: Raw , Proxy < DataCall , & Parser :: on_header_field >:: Raw , Proxy < DataCall , & Parser :: on_header_value >:: Raw , Proxy < Call , & Parser :: on_headers_complete >:: Raw , Proxy < DataCall , & Parser :: on_body >:: Raw , Proxy < Call , & Parser :: on_message_complete >:: Raw , Proxy < Call , & Parser :: on_chunk_header >:: Raw , Proxy < Call , & Parser :: on_chunk_complete >:: Raw , }; 1 \u5f00\u59cb\u89e3\u6790\u62a5\u6587\u7684\u56de\u8c03 1 2 3 4 5 6 7 // \u5f00\u59cb\u89e3\u6790\u62a5\u6587\uff0c\u4e00\u4e2aTCP\u8fde\u63a5\u53ef\u80fd\u4f1a\u6709\u591a\u4e2a\u62a5\u6587 int on_message_begin () { num_fields_ = num_values_ = 0 ; url_ . Reset (); status_message_ . Reset (); return 0 ; } 2 \u89e3\u6790url\u65f6\u7684\u56de\u8c03 1 2 3 4 5 6 7 8 9 int on_url ( const char * at , size_t length ) { int rv = TrackHeader ( length ); if ( rv != 0 ) { return rv ; } url_ . Update ( at , length ); return 0 ; } 3\u89e3\u6790HTTP\u54cd\u5e94\u65f6\u7684\u56de\u8c03 1 2 3 4 5 6 7 8 9 int on_status ( const char * at , size_t length ) { int rv = TrackHeader ( length ); if ( rv != 0 ) { return rv ; } status_message_ . Update ( at , length ); return 0 ; } 4\u89e3\u6790\u5230HTTP\u5934\u7684\u952e\u65f6\u56de\u8c03 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int on_header_field ( const char * at , size_t length ) { int rv = TrackHeader ( length ); if ( rv != 0 ) { return rv ; } // \u76f8\u7b49\u8bf4\u660e\u952e\u5bf9\u503c\u7684\u89e3\u6790\u662f\u4e00\u4e00\u5bf9\u5e94\u7684 if ( num_fields_ == num_values_ ) { // start of new field name // \u952e\u7684\u6570\u52a0\u4e00 num_fields_ ++ ; // \u8d85\u8fc7\u9608\u503c\u5219\u5148\u56de\u8c03js\u6d88\u8d39\u6389 if ( num_fields_ == kMaxHeaderFieldsCount ) { // ran out of space - flush to javascript land Flush (); // \u91cd\u65b0\u5f00\u59cb num_fields_ = 1 ; num_values_ = 0 ; } // \u521d\u59cb\u5316 fields_ [ num_fields_ - 1 ]. Reset (); } // \u4fdd\u5b58\u952e fields_ [ num_fields_ - 1 ]. Update ( at , length ); return 0 ; } \u5f53\u89e3\u6790\u7684\u5934\u90e8\u4e2a\u6570\u8fbe\u5230\u9608\u503c\u65f6\uff0cNode.js\u4f1a\u5148\u901a\u8fc7Flush\u51fd\u6570\u56de\u8c03JS\u5c42\u4fdd\u5b58\u5f53\u524d\u7684\u4e00\u4e9b\u6570\u636e\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void Flush () { HandleScope scope ( env () -> isolate ()); Local < Object > obj = object (); // JS\u5c42\u7684\u94a9\u5b50 Local < Value > cb = obj -> Get ( env () -> context (), kOnHeaders ). ToLocalChecked (); if ( ! cb -> IsFunction ()) return ; Local < Value > argv [ 2 ] = { CreateHeaders (), url_ . ToString ( env ()) }; MaybeLocal < Value > r = MakeCallback ( cb . As < Function > (), arraysize ( argv ), argv ); url_ . Reset (); have_flushed_ = true ; } Local < Array > CreateHeaders () { // HTTP\u5934\u7684\u4e2a\u6570\u4e58\u4ee52\uff0c\u56e0\u4e3a\u4e00\u4e2a\u5934\u7531\u952e\u548c\u503c\u7ec4\u6210 Local < Value > headers_v [ kMaxHeaderFieldsCount * 2 ]; // \u4fdd\u5b58\u952e\u548c\u503c\u5230HTTP\u5934 for ( size_t i = 0 ; i < num_values_ ; ++ i ) { headers_v [ i * 2 ] = fields_ [ i ]. ToString ( env ()); headers_v [ i * 2 + 1 ] = values_ [ i ]. ToString ( env ()); } return Array :: New ( env () -> isolate (), headers_v , num_values_ * 2 ); } Flush\u4f1a\u8c03\u7528JS\u5c42\u7684kOnHeaders\u94a9\u5b50\u51fd\u6570\u3002 5\u89e3\u6790\u5230HTTP\u5934\u7684\u503c\u65f6\u56de\u8c03 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int on_header_value ( const char * at , size_t length ) { int rv = TrackHeader ( length ); if ( rv != 0 ) { return rv ; } /* \u503c\u7684\u4e2a\u6570\u4e0d\u7b49\u4e8e\u952e\u7684\u4e2a\u6570\u8bf4\u660e\u6b63\u89e3\u6790\u5230\u952e\u5bf9\u5e94\u7684\u503c\uff0c\u5373\u4e00\u4e00\u5bf9\u5e94\u3002 \u5426\u5219\u8bf4\u660e\u4e00\u4e2a\u952e\u5b58\u5728\u591a\u4e2a\u503c\uff0c\u5219\u4e0d\u66f4\u65b0\u503c\u7684\u4e2a\u6570\uff0c\u591a\u4e2a\u503c\u7d2f\u52a0\u5230\u4e00\u4e2aslot */ if ( num_values_ != num_fields_ ) { // start of new header value num_values_ ++ ; values_ [ num_values_ - 1 ]. Reset (); } CHECK_LT ( num_values_ , arraysize ( values_ )); CHECK_EQ ( num_values_ , num_fields_ ); values_ [ num_values_ - 1 ]. Update ( at , length ); return 0 ; } 6\u89e3\u6790\u5b8cHTTP\u5934\u540e\u7684\u56de\u8c03 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 int on_headers_complete () { header_nread_ = 0 ; enum on_headers_complete_arg_index { A_VERSION_MAJOR = 0 , A_VERSION_MINOR , A_HEADERS , A_METHOD , A_URL , A_STATUS_CODE , A_STATUS_MESSAGE , A_UPGRADE , A_SHOULD_KEEP_ALIVE , A_MAX }; Local < Value > argv [ A_MAX ]; Local < Object > obj = object (); Local < Value > cb = obj -> Get ( env () -> context (), kOnHeadersComplete ). ToLocalChecked (); Local < Value > undefined = Undefined ( env () -> isolate ()); for ( size_t i = 0 ; i < arraysize ( argv ); i ++ ) argv [ i ] = undefined ; // \u4e4b\u524dflush\u8fc7\uff0c\u5219\u7ee7\u7eedflush\u5230JS\u5c42\uff0c\u5426\u5219\u8fd4\u56de\u5168\u90e8\u5934\u7ed9js if ( have_flushed_ ) { // Slow case, flush remaining headers. Flush (); } else { // Fast case, pass headers and URL to JS land. argv [ A_HEADERS ] = CreateHeaders (); if ( parser_ . type == HTTP_REQUEST ) argv [ A_URL ] = url_ . ToString ( env ()); } num_fields_ = 0 ; num_values_ = 0 ; // METHOD if ( parser_ . type == HTTP_REQUEST ) { argv [ A_METHOD ] = Uint32 :: NewFromUnsigned ( env () -> isolate (), parser_ . method ); } // STATUS if ( parser_ . type == HTTP_RESPONSE ) { argv [ A_STATUS_CODE ] = Integer :: New ( env () -> isolate (), parser_ . status_code ); argv [ A_STATUS_MESSAGE ] = status_message_ . ToString ( env ()); } // VERSION argv [ A_VERSION_MAJOR ] = Integer :: New ( env () -> isolate (), parser_ . http_major ); argv [ A_VERSION_MINOR ] = Integer :: New ( env () -> isolate (), parser_ . http_minor ); bool should_keep_alive ; // \u662f\u5426\u5b9a\u4e49\u4e86keepalive\u5934 should_keep_alive = llhttp_should_keep_alive ( & parser_ ); argv [ A_SHOULD_KEEP_ALIVE ] = Boolean :: New ( env () -> isolate (), should_keep_alive ); // \u662f\u5426\u662f\u5347\u7ea7\u534f\u8bae argv [ A_UPGRADE ] = Boolean :: New ( env () -> isolate (), parser_ . upgrade ); MaybeLocal < Value > head_response ; { InternalCallbackScope callback_scope ( this , InternalCallbackScope :: kSkipTaskQueues ); head_response = cb . As < Function > () -> Call ( env () -> context (), object (), arraysize ( argv ), argv ); } int64_t val ; if ( head_response . IsEmpty () || ! head_response . ToLocalChecked () -> IntegerValue ( env () -> context ()) . To ( & val )) { got_exception_ = true ; return -1 ; } return val ; } on_headers_complete\u4f1a\u6267\u884cJS\u5c42\u7684kOnHeadersComplete\u94a9\u5b50\u3002 7 \u89e3\u6790body\u65f6\u7684\u56de\u8c03 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int on_body ( const char * at , size_t length ) { EscapableHandleScope scope ( env () -> isolate ()); Local < Object > obj = object (); Local < Value > cb = obj -> Get ( env () -> context (), kOnBody ). ToLocalChecked (); // We came from consumed stream if ( current_buffer_ . IsEmpty ()) { // Make sure Buffer will be in parent HandleScope current_buffer_ = scope . Escape ( Buffer :: Copy ( env () -> isolate (), current_buffer_data_ , current_buffer_len_ ). ToLocalChecked ()); } Local < Value > argv [ 3 ] = { // \u5f53\u524d\u89e3\u6790\u4e2d\u7684\u6570\u636e current_buffer_ , // body\u5f00\u59cb\u7684\u4f4d\u7f6e Integer :: NewFromUnsigned ( env () -> isolate (), at - current_buffer_data_ ), // body\u5f53\u524d\u957f\u5ea6 Integer :: NewFromUnsigned ( env () -> isolate (), length ) }; MaybeLocal < Value > r = MakeCallback ( cb . As < Function > (), arraysize ( argv ), argv ); return 0 ; } Node.js\u4e2d\u5e76\u4e0d\u662f\u6bcf\u6b21\u89e3\u6790HTTP\u62a5\u6587\u7684\u65f6\u5019\u5c31\u65b0\u5efa\u4e00\u4e2aHTTP\u89e3\u6790\u5668\uff0cNode.js\u4f7f\u7528FreeList\u6570\u636e\u7ed3\u6784\u5bf9HTTP\u89e3\u6790\u5668\u5b9e\u4f8b\u8fdb\u884c\u4e86\u7ba1\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class FreeList { constructor ( name , max , ctor ) { this . name = name ; // \u6784\u9020\u51fd\u6570 this . ctor = ctor ; // \u8282\u70b9\u7684\u6700\u5927\u503c this . max = max ; // \u5b9e\u4f8b\u5217\u8868 this . list = []; } // \u5206\u914d\u4e00\u4e2a\u5b9e\u4f8b alloc () { // \u6709\u7a7a\u95f2\u7684\u5219\u76f4\u63a5\u8fd4\u56de\uff0c\u5426\u5219\u65b0\u5efa\u4e00\u4e2a return this . list . length > 0 ? this . list . pop () : ReflectApply ( this . ctor , this , arguments ); } // \u91ca\u653e\u5b9e\u4f8b free ( obj ) { // \u5c0f\u4e8e\u9608\u503c\u5219\u653e\u5230\u7a7a\u95f2\u5217\u8868\uff0c\u5426\u5219\u91ca\u653e\uff08\u8c03\u7528\u65b9\u8d1f\u8d23\u91ca\u653e\uff09 if ( this . list . length < this . max ) { this . list . push ( obj ); return true ; } return false ; } } \u6211\u4eec\u770b\u4e00\u4e0b\u5728Node.js\u4e2d\u5bf9FreeList\u7684\u4f7f\u7528\u3002\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 const parsers = new FreeList ( 'parsers' , 1000 , function parsersCb () { const parser = new HTTPParser (); // \u521d\u59cb\u5316\u5b57\u6bb5 cleanParser ( parser ); // \u8bbe\u7f6e\u94a9\u5b50 parser . onIncoming = null ; parser [ kOnHeaders ] = parserOnHeaders ; parser [ kOnHeadersComplete ] = parserOnHeadersComplete ; parser [ kOnBody ] = parserOnBody ; parser [ kOnMessageComplete ] = parserOnMessageComplete ; return parser ; }); HTTP\u89e3\u6790\u5668\u7684\u4f7f\u7528 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 var HTTPParser = process . binding ( 'http_parser' ). HTTPParser ; var parser = new HTTPParser ( HTTPParser . REQUEST ); const kOnHeaders = HTTPParser . kOnHeaders ; const kOnHeadersComplete = HTTPParser . kOnHeadersComplete ; const kOnBody = HTTPParser . kOnBody ; const kOnMessageComplete = HTTPParser . kOnMessageComplete ; const kOnExecute = HTTPParser . kOnExecute ; parser [ kOnHeaders ] = function ( headers , url ) { console . log ( 'kOnHeaders' , headers . length , url ); } parser [ kOnHeadersComplete ] = function ( versionMajor , versionMinor , headers , method , url , statusCode , statusMessage , upgrade , shouldKeepAlive ) { console . log ( 'kOnHeadersComplete' , headers ); } parser [ kOnBody ] = function ( b , start , len ) { console . log ( 'kOnBody' , b . slice ( start ). toString ( 'utf-8' )); } parser [ kOnMessageComplete ] = function () { console . log ( 'kOnMessageComplete' ); } parser [ kOnExecute ] = function () { console . log ( 'kOnExecute' ); } parser . execute ( Buffer . from ( 'GET / HTTP/1.1\\r\\n' + 'Host: http://localhost\\r\\n\\r\\n' )); \u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa 1 2 kOnHeadersComplete [ 'Host', 'http://localhost' ] kOnMessageComplete \u6211\u4eec\u770b\u5230\u53ea\u6267\u884c\u4e86kOnHeadersComplete\u548c kOnMessageComplete\u3002\u90a3\u5176\u5b83\u51e0\u4e2a\u56de\u8c03\u4ec0\u4e48\u65f6\u5019\u4f1a\u6267\u884c\u5462\uff1f\u6211\u4eec\u63a5\u7740\u770b\u3002\u6211\u4eec\u628a\u8f93\u5165\u6539\u4e00\u4e0b\u3002 1 2 3 4 5 6 parser . execute ( Buffer . from ( 'GET / HTTP/1.1\\r\\n' + 'Host: http://localhost\\r\\n' + 'content-length: 1\\r\\n\\r\\n' + '1' )); \u4e0a\u9762\u4ee3\u7801\u7684\u8f93\u51fa 1 2 3 kOnHeadersComplete [ 'Host', 'http://localhost', 'content-length', '1' ] kOnBody 1 kOnMessageComplete \u6211\u4eec\u770b\u5230\u591a\u4e86\u4e00\u4e2a\u56de\u8c03kOnBody\uff0c\u56e0\u4e3a\u6211\u4eec\u52a0\u4e86\u4e00\u4e2aHTTP\u5934content-length\u6307\u793a\u6709body\uff0c\u6240\u4ee5HTTP\u89e3\u6790\u5668\u89e3\u6790\u5230body\u7684\u65f6\u5019\u5c31\u4f1a\u56de\u8c03kOnBody\u3002\u90a3kOnHeaders\u4ec0\u4e48\u65f6\u5019\u4f1a\u6267\u884c\u5462\uff1f\u6211\u4eec\u7ee7\u7eed\u4fee\u6539\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 parser . execute ( Buffer . from ( 'GET / HTTP/1.1\\r\\n' + 'Host: http://localhost\\r\\n' + 'a: b\\r\\n' + // \u5f88\u591a'a: b\\r\\n'+ 'content-length: 1\\r\\n\\r\\n' + '1' )); \u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa 1 2 3 4 5 kOnHeaders 62 / kOnHeaders 22 kOnHeadersComplete undefined kOnBody 1 kOnMessageComplete \u6211\u4eec\u770b\u5230kOnHeaders\u88ab\u6267\u884c\u4e86\uff0c\u5e76\u4e14\u6267\u884c\u4e86\u4e24\u6b21\u3002\u56e0\u4e3a\u5982\u679cHTTP\u5934\u7684\u4e2a\u6570\u8fbe\u5230\u9608\u503c\uff0c\u5728\u89e3\u6790HTTP\u5934\u90e8\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5c31\u5148flush\u5230JS\u5c42\uff08\u5982\u679c\u591a\u6b21\u8fbe\u5230\u9608\u503c\uff0c\u5219\u56de\u8c03\u591a\u6b21\uff09\uff0c\u5e76\u4e14\u5728\u89e3\u6790\u5b8c\u6240\u6709HTTP\u5934\u540e\uff0c\u4f1a\u5728kOnHeadersComplet\u56de\u8c03\u4e4b\u524d\u518d\u6b21\u56de\u8c03kOnHeaders\uff08\u5982\u679c\u8fd8\u6709\u7684\u8bdd\uff09\u3002\u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0bkOnExecute\u5982\u4f55\u89e6\u53d1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 var HTTPParser = process . binding ( 'http_parser' ). HTTPParser ; var parser = new HTTPParser ( HTTPParser . REQUEST ); var net = require ( 'net' ); const kOnHeaders = HTTPParser . kOnHeaders ; const kOnHeadersComplete = HTTPParser . kOnHeadersComplete ; const kOnBody = HTTPParser . kOnBody ; const kOnMessageComplete = HTTPParser . kOnMessageComplete ; const kOnExecute = HTTPParser . kOnExecute ; parser [ kOnHeaders ] = function ( headers , url ) { console . log ( 'kOnHeaders' , headers . length , url ); } parser [ kOnHeadersComplete ] = function ( versionMajor , versionMinor , headers , method , url , statusCode , statusMessage , upgrade , shouldKeepAlive ) { console . log ( 'kOnHeadersComplete' , headers ); } parser [ kOnBody ] = function ( b , start , len ) { console . log ( 'kOnBody' , b . slice ( start ). toString ( 'utf-8' )); } parser [ kOnMessageComplete ] = function () { console . log ( 'kOnMessageComplete' ); } parser [ kOnExecute ] = function ( a , b ) { console . log ( 'kOnExecute,\u89e3\u6790\u7684\u5b57\u8282\u6570\uff1a' , a ); } // \u542f\u52a8\u4e00\u4e2a\u670d\u52a1\u5668 net . createServer (( socket ) => { parser . consume ( socket . _handle ); }). listen ( 80 ); // \u542f\u52a8\u4e00\u4e2a\u5ba2\u6237\u7aef setTimeout (() => { var socket = net . connect ({ port : 80 }); socket . end ( 'GET / HTTP/1.1\\r\\n' + 'Host: http://localhost\\r\\n' + 'content-length: 1\\r\\n\\r\\n' + '1' ); }, 1000 ); \u6211\u4eec\u9700\u8981\u8c03\u7528parser.consume\u65b9\u6cd5\u5e76\u4e14\u4f20\u5165\u4e00\u4e2aisStreamBase\u7684\u6d41\uff08stream_base.cc\u5b9a\u4e49\uff09\uff0c\u624d\u4f1a\u89e6\u53d1kOnExecute\u3002\u56e0\u4e3akOnExecute\u662f\u5728StreamBase\u6d41\u53ef\u8bfb\u65f6\u89e6\u53d1\u7684\u3002 18.2 HTTP\u5ba2\u6237\u7aef \u00b6 \u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u4f7f\u7528Node.js\u4f5c\u4e3a\u5ba2\u6237\u7aef\u7684\u4f8b\u5b50\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const data = querystring . stringify ({ 'msg' : 'hi' }); const options = { hostname : 'your domain' , path : '/' , method : 'POST' , headers : { 'Content-Type' : 'application/x-www-form-urlencoded' , 'Content-Length' : Buffer . byteLength ( data ) } }; const req = http . request ( options , ( res ) => { res . setEncoding ( 'utf8' ); res . on ( 'data' , ( chunk ) => { console . log ( ` ${ chunk } ` ); }); res . on ( 'end' , () => { console . log ( 'end' ); }); }); req . on ( 'error' , ( e ) => { console . error ( ` ${ e . message } ` ); }); // \u53d1\u9001\u8bf7\u6c42\u7684\u6570\u636e req . write ( data ); // \u8bbe\u7f6e\u8bf7\u6c42\u7ed3\u675f req . end (); \u6211\u4eec\u770b\u4e00\u4e0bhttp.request\u7684\u5b9e\u73b0\u3002 1 2 3 function request ( url , options , cb ) { return new ClientRequest ( url , options , cb ); } HTTP\u5ba2\u6237\u7aef\u901a\u8fc7_http_client.js\u7684ClientRequest\u5b9e\u73b0\uff0cClientRequest\u7684\u4ee3\u7801\u975e\u5e38\u591a\uff0c\u6211\u4eec\u53ea\u5206\u6790\u6838\u5fc3\u7684\u6d41\u7a0b\u3002\u6211\u4eec\u770b\u521d\u59cb\u5316\u4e00\u4e2a\u8bf7\u6c42\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 function ClientRequest ( input , options , cb ) { // \u7ee7\u627fOutgoingMessage OutgoingMessage . call ( this ); // \u662f\u5426\u4f7f\u7528agent let agent = options . agent ; // \u5ffd\u7565agent\u7684\u5904\u7406\uff0c\u5177\u4f53\u53c2\u8003_http_agent.js\uff0c\u4e3b\u8981\u7528\u4e8e\u590d\u7528TCP\u8fde\u63a5 this . agent = agent ; // \u5efa\u7acb\u8fde\u63a5\u7684\u8d85\u65f6\u65f6\u95f4 if ( options . timeout !== undefined ) this . timeout = getTimerDuration ( options . timeout , 'timeout' ); // HTTP\u5934\u4e2a\u6570\u7684\u9608\u503c const maxHeaderSize = options . maxHeaderSize ; this . maxHeaderSize = maxHeaderSize ; // \u76d1\u542c\u54cd\u5e94\u4e8b\u4ef6 if ( cb ) { this . once ( 'response' , cb ); } // \u5ffd\u7565\u8bbe\u7f6ehttp\u534f\u8bae\u7684\u8bf7\u6c42\u884c\u6216\u8bf7\u6c42\u5934\u7684\u903b\u8f91 // \u5efa\u7acbTCP\u8fde\u63a5\u540e\u7684\u56de\u8c03 const oncreate = ( err , socket ) => { if ( called ) return ; called = true ; if ( err ) { process . nextTick (() => this . emit ( 'error' , err )); return ; } // \u5efa\u7acb\u8fde\u63a5\u6210\u529f\uff0c\u6267\u884c\u56de\u8c03 this . onSocket ( socket ); // \u8fde\u63a5\u6210\u529f\u540e\u53d1\u9001\u6570\u636e this . _deferToConnect ( null , null , () => this . _flush ()); }; // \u4f7f\u7528agent\u65f6\uff0csocket\u7531agent\u63d0\u4f9b\uff0c\u5426\u5219\u81ea\u5df1\u521b\u5efasocket if ( this . agent ) { this . agent . addRequest ( this , options ); } else { // \u4e0d\u4f7f\u7528agent\u5219\u6bcf\u6b21\u521b\u5efa\u4e00\u4e2asocket\uff0c\u9ed8\u8ba4\u4f7f\u7528net\u6a21\u5757\u7684\u63a5\u53e3 if ( typeof options . createConnection === 'function' ) { const newSocket = options . createConnection ( options , oncreate ); if ( newSocket && ! called ) { called = true ; this . onSocket ( newSocket ); } else { return ; } } else { this . onSocket ( net . createConnection ( options )); } } // \u8fde\u63a5\u6210\u529f\u540e\u53d1\u9001\u5f85\u7f13\u5b58\u7684\u6570\u636e this . _deferToConnect ( null , null , () => this . _flush ()); } \u83b7\u53d6\u4e00\u4e2aClientRequest\u5b9e\u4f8b\u540e\uff0c\u4e0d\u7ba1\u662f\u901a\u8fc7agent\u8fd8\u662f\u81ea\u5df1\u521b\u5efa\u4e00\u4e2aTCP\u8fde\u63a5\uff0c\u5728\u8fde\u63a5\u6210\u529f\u540e\u90fd\u4f1a\u6267\u884conSocket\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // socket\u53ef\u7528\u65f6\u7684\u56de\u8c03 ClientRequest . prototype . onSocket = function onSocket ( socket ) { process . nextTick ( onSocketNT , this , socket ); }; function onSocketNT ( req , socket ) { // \u7533\u8bf7socket\u8fc7\u7a0b\u4e2d\uff0c\u8bf7\u6c42\u5df2\u7ecf\u7ec8\u6b62 if ( req . aborted ) { // \u4e0d\u4f7f\u7528agent\uff0c\u76f4\u63a5\u9500\u6bc1socekt if ( ! req . agent ) { socket . destroy (); } else { // \u4f7f\u7528agent\u89e6\u53d1free\u4e8b\u4ef6\uff0c\u7531agent\u5904\u7406socekt req . emit ( 'close' ); socket . emit ( 'free' ); } } else { // \u5904\u7406socket tickOnSocket ( req , socket ); } } \u6211\u4eec\u7ee7\u7eed\u770btickOnSocket 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // \u521d\u59cb\u5316HTTP\u89e3\u6790\u5668\u548c\u6ce8\u518cdata\u4e8b\u4ef6\u7b49\uff0c\u7b49\u5f85\u54cd\u5e94 function tickOnSocket ( req , socket ) { // \u5206\u914d\u4e00\u4e2aHTTP\u89e3\u6790\u5668 const parser = parsers . alloc (); req . socket = socket ; // \u521d\u59cb\u5316\uff0c\u5904\u7406\u54cd\u5e94\u62a5\u6587 parser . initialize ( HTTPParser . RESPONSE , new HTTPClientAsyncResource ( 'HTTPINCOMINGMESSAGE' , req ), req . maxHeaderSize || 0 , req . insecureHTTPParser === undefined ? isLenient () : req . insecureHTTPParser ); parser . socket = socket ; parser . outgoing = req ; req . parser = parser ; socket . parser = parser ; // socket\u6b63\u5904\u7406\u7684\u8bf7\u6c42 socket . _httpMessage = req ; // Propagate headers limit from request object to parser if ( typeof req . maxHeadersCount === 'number' ) { parser . maxHeaderPairs = req . maxHeadersCount << 1 ; } // \u89e3\u6790\u5b8cHTTP\u5934\u90e8\u7684\u56de\u8c03 parser . onIncoming = parserOnIncomingClient ; socket . removeListener ( 'error' , freeSocketErrorListener ); socket . on ( 'error' , socketErrorListener ); socket . on ( 'data' , socketOnData ); socket . on ( 'end' , socketOnEnd ); socket . on ( 'close' , socketCloseListener ); socket . on ( 'drain' , ondrain ); if ( req . timeout !== undefined || ( req . agent && req . agent . options && req . agent . options . timeout ) ) { // \u5904\u7406\u8d85\u65f6\u65f6\u95f4 listenSocketTimeout ( req ); } req . emit ( 'socket' , socket ); } \u62ff\u5230\u4e00\u4e2asocket\u540e\uff0c\u5c31\u5f00\u59cb\u76d1\u542csocket\u4e0ahttp\u62a5\u6587\u7684\u5230\u6765\u3002\u5e76\u4e14\u7533\u8bf7\u4e00\u4e2aHTTP\u89e3\u6790\u5668\u51c6\u5907\u89e3\u6790http\u62a5\u6587\uff0c\u6211\u4eec\u4e3b\u8981\u5206\u6790\u8d85\u65f6\u65f6\u95f4\u7684\u5904\u7406\u548cdata\u4e8b\u4ef6\u7684\u5904\u7406\u903b\u8f91\u3002 1 \u8d85\u65f6\u65f6\u95f4\u7684\u5904\u7406 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function listenSocketTimeout ( req ) { // \u8bbe\u7f6e\u8fc7\u4e86\u5219\u8fd4\u56de if ( req . timeoutCb ) { return ; } // \u8d85\u65f6\u56de\u8c03 req . timeoutCb = emitRequestTimeout ; // Delegate socket timeout event. // \u8bbe\u7f6esocket\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u5373socket\u4e0a\u4e00\u5b9a\u65f6\u95f4\u540e\u6ca1\u6709\u54cd\u5e94\u5219\u89e6\u53d1\u8d85\u65f6 if ( req . socket ) { req . socket . once ( 'timeout' , emitRequestTimeout ); } else { req . on ( 'socket' , ( socket ) => { socket . once ( 'timeout' , emitRequestTimeout ); }); } } function emitRequestTimeout () { const req = this . _httpMessage ; if ( req ) { req . emit ( 'timeout' ); } } 2 \u5904\u7406\u54cd\u5e94\u6570\u636e 1 2 3 4 5 6 7 8 function socketOnData ( d ) { const socket = this ; const req = this . _httpMessage ; const parser = this . parser ; // \u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406 const ret = parser . execute ( d ); // ... } \u5f53Node.js\u6536\u5230\u54cd\u5e94\u62a5\u6587\u65f6\uff0c\u4f1a\u628a\u6570\u636e\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\u3002http\u89e3\u6790\u5728\u89e3\u6790\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u4e0d\u65ad\u89e6\u53d1\u94a9\u5b50\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0bJS\u5c42\u5404\u4e2a\u94a9\u5b50\u51fd\u6570\u7684\u903b\u8f91\u3002 1 \u89e3\u6790\u5934\u90e8\u8fc7\u7a0b\u4e2d\u6267\u884c\u7684\u56de\u8c03 1 2 3 4 5 6 7 8 function parserOnHeaders ( headers , url ) { // \u4fdd\u5b58\u5934\u548curl if ( this . maxHeaderPairs <= 0 || this . _headers . length < this . maxHeaderPairs ) { this . _headers = this . _headers . concat ( headers ); } this . _url += url ; } 2 \u89e3\u6790\u5b8c\u5934\u90e8\u7684\u56de\u8c03 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 function parserOnHeadersComplete ( versionMajor , versionMinor , headers , method , url , statusCode , statusMessage , upgrade , shouldKeepAlive ) { const parser = this ; const { socket } = parser ; // \u5269\u4e0b\u7684HTTP\u5934 if ( headers === undefined ) { headers = parser . _headers ; parser . _headers = []; } if ( url === undefined ) { url = parser . _url ; parser . _url = '' ; } // Parser is also used by http client // IncomingMessage const ParserIncomingMessage = ( socket && socket . server && socket . server [ kIncomingMessage ] ) || IncomingMessage ; // \u65b0\u5efa\u4e00\u4e2aIncomingMessage\u5bf9\u8c61 const incoming = parser . incoming = new ParserIncomingMessage ( socket ); incoming . httpVersionMajor = versionMajor ; incoming . httpVersionMinor = versionMinor ; incoming . httpVersion = ` ${ versionMajor } . ${ versionMinor } ` ; incoming . url = url ; incoming . upgrade = upgrade ; let n = headers . length ; // If parser.maxHeaderPairs <= 0 assume that there's no limit. if ( parser . maxHeaderPairs > 0 ) n = MathMin ( n , parser . maxHeaderPairs ); // \u66f4\u65b0\u5230\u4fdd\u5b58HTTP\u5934\u7684\u5bf9\u8c61 incoming . _addHeaderLines ( headers , n ); // \u8bf7\u6c42\u65b9\u6cd5\u6216\u54cd\u5e94\u884c\u4fe1\u606f if ( typeof method === 'number' ) { // server only incoming . method = methods [ method ]; } else { // client only incoming . statusCode = statusCode ; incoming . statusMessage = statusMessage ; } // \u6267\u884c\u56de\u8c03 return parser . onIncoming ( incoming , shouldKeepAlive ); } \u6211\u4eec\u770b\u5230\u89e3\u6790\u5b8c\u5934\u90e8\u540e\u4f1a\u6267\u884c\u53e6\u4e00\u4e2a\u56de\u8c03onIncoming\uff0c\u5e76\u4f20\u5165IncomingMessage\u5b9e\u4f8b\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u4f7f\u7528\u7684res\u3002\u5728\u524d\u9762\u5206\u6790\u8fc7\uff0conIncoming\u8bbe\u7f6e\u7684\u503c\u662fparserOnIncomingClient\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function parserOnIncomingClient ( res , shouldKeepAlive ) { const socket = this . socket ; // \u8bf7\u6c42\u5bf9\u8c61 const req = socket . _httpMessage ; // \u670d\u52a1\u5668\u53d1\u9001\u4e86\u591a\u4e2a\u54cd\u5e94 if ( req . res ) { socket . destroy (); return 0 ; } req . res = res ; if ( statusIsInformational ( res . statusCode )) { req . res = null ; // \u8bf7\u6c42\u65f6\u8bbe\u7f6e\u4e86expect\u5934\uff0c\u5219\u54cd\u5e94\u7801\u4e3a100\uff0c\u53ef\u4ee5\u7ee7\u7eed\u53d1\u9001\u6570\u636e if ( res . statusCode === 100 ) { req . emit ( 'continue' ); } return 1 ; } req . res = res ; res . req = req ; // \u7b49\u5f85\u54cd\u5e94\u7ed3\u675f\uff0c\u54cd\u5e94\u7ed3\u675f\u540e\u4f1a\u6e05\u9664\u5b9a\u65f6\u5668 res . on ( 'end' , responseOnEnd ); // \u8bf7\u6c42\u7ec8\u6b62\u4e86\u6216\u89e6\u53d1response\u4e8b\u4ef6\uff0c\u8fd4\u56defalse\u8bf4\u660e\u6ca1\u6709\u76d1\u542cresponse\u4e8b\u4ef6\uff0c\u5219\u4e22\u5f03\u6570\u636e if ( req . aborted || ! req . emit ( 'response' , res )) res . _dump (); } \u4ece\u6e90\u7801\u4e2d\u6211\u4eec\u770b\u51fa\u5728\u89e3\u6790\u5b8cHTTP\u54cd\u5e94\u5934\u65f6\uff0c\u5c31\u6267\u884c\u4e86http.request\u8bbe\u7f6e\u7684\u56de\u8c03\u51fd\u6570\u3002\u4f8b\u5982\u4e0b\u9762\u4ee3\u7801\u4e2d\u7684\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 http . request ( 'domain' , { agent }, ( res ) => { // \u89e3\u6790body res . on ( 'data' , ( data ) => { // }); // \u89e3\u6790body\u7ed3\u675f\uff0c\u54cd\u5e94\u7ed3\u675f res . on ( 'end' , ( data ) => { // }); }); // ... \u5728\u56de\u8c03\u91cc\u6211\u4eec\u53ef\u4ee5\u628ares\u4f5c\u4e3a\u4e00\u4e2a\u6d41\u4f7f\u7528\uff0c\u5728\u89e3\u6790\u5b8cHTTP\u5934\u540e\uff0cHTTP\u89e3\u6790\u5668\u4f1a\u7ee7\u7eed\u89e3\u6790HTTP body\u3002\u6211\u4eec\u770b\u4e00\u4e0bHTTP\u89e3\u6790\u5668\u5728\u89e3\u6790body\u8fc7\u7a0b\u4e2d\u6267\u884c\u7684\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 function parserOnBody ( b , start , len ) { const stream = this . incoming ; if ( len > 0 && ! stream . _dumped ) { const slice = b . slice ( start , start + len ); // \u628a\u6570\u636epush\u5230\u6d41\u4e2d\uff0c\u6d41\u4f1a\u89e6\u53d1data\u4e8b\u4ef6 const ret = stream . push ( slice ); // \u6570\u636e\u8fc7\u8f7d\uff0c\u6682\u505c\u63a5\u6536 if ( ! ret ) readStop ( this . socket ); } } \u6700\u540e\u6211\u4eec\u518d\u770b\u4e00\u4e0b\u89e3\u6790\u5b8cbody\u65f6HTTP\u89e3\u6790\u5668\u6267\u884c\u7684\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function parserOnMessageComplete () { const parser = this ; const stream = parser . incoming ; if ( stream !== null ) { // body\u89e3\u6790\u5b8c\u4e86 stream . complete = true ; // \u5728body\u540e\u53ef\u80fd\u6709trailer\u5934\uff0c\u4fdd\u5b58\u4e0b\u6765 const headers = parser . _headers ; if ( headers . length ) { stream . _addHeaderLines ( headers , headers . length ); parser . _headers = []; parser . _url = '' ; } // \u6d41\u7ed3\u675f stream . push ( null ); } // \u8bfb\u53d6\u4e0b\u4e00\u4e2a\u54cd\u5e94\uff0c\u5982\u679c\u6709\u7684\u8bdd readStart ( parser . socket ); } \u6211\u4eec\u770b\u5230\u5728\u89e3\u6790body\u8fc7\u7a0b\u4e2d\u4f1a\u4e0d\u65ad\u5f80\u6d41\u4e2dpush\u6570\u636e\uff0c\u4ece\u800c\u4e0d\u65ad\u89e6\u53d1res\u7684data\u4e8b\u4ef6\uff0c\u6700\u540e\u89e3\u6790body\u7ed3\u675f\u540e\uff0c\u901a\u8fc7push(null)\u901a\u77e5\u6d41\u7ed3\u675f\uff0c\u4ece\u800c\u89e6\u53d1res.end\u4e8b\u4ef6\u3002\u6211\u4eec\u6cbf\u7740onSocket\u51fd\u6570\u5206\u6790\u5b8c\u5904\u7406\u54cd\u5e94\u540e\u6211\u4eec\u518d\u6765\u5206\u6790\u8bf7\u6c42\u7684\u8fc7\u7a0b\u3002\u6267\u884c\u5b8chttp.request\u540e\u6211\u4eec\u4f1a\u5f97\u5230\u4e00\u4e2a\u6807\u8bb0\u8bf7\u6c42\u7684\u5b9e\u4f8b\u3002\u7136\u540e\u6267\u884c\u5b83\u7684write\u65b9\u6cd5\u53d1\u9001\u6570\u636e\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 OutgoingMessage . prototype . write = function write ( chunk , encoding , callback ) { const ret = write_ ( this , chunk , encoding , callback , false ); // \u8fd4\u56defalse\u8bf4\u660e\u9700\u8981\u7b49\u5f85drain\u4e8b\u4ef6 if ( ! ret ) this [ kNeedDrain ] = true ; return ret ; }; function write_ ( msg , chunk , encoding , callback , fromEnd ) { // \u8fd8\u6ca1\u6709\u8bbe\u7f6ethis._header\u5b57\u6bb5\uff0c\u5219\u628a\u8bf7\u6c42\u884c\u548cHTTP\u5934\u62fc\u63a5\u5230this._header\u5b57\u6bb5 if ( ! msg . _header ) { msg . _implicitHeader (); } let ret ; // chunk\u6a21\u5f0f\u5219\u9700\u8981\u989d\u5916\u52a0\u4e00\u4e0b\u5b57\u6bb5\uff0c\u5426\u5219\u76f4\u63a5\u53d1\u9001 if ( msg . chunkedEncoding && chunk . length !== 0 ) { let len ; if ( typeof chunk === 'string' ) len = Buffer . byteLength ( chunk , encoding ); else len = chunk . length ; /* chunk\u6a21\u5f0f\u65f6\uff0chttp\u62a5\u6587\u7684\u683c\u5f0f\u5982\u4e0b chunk\u957f\u5ea6 \u56de\u8f66\u6362\u884c \u6570\u636e \u56de\u8f66\u6362\u884c */ msg . _send ( len . toString ( 16 ), 'latin1' , null ); msg . _send ( crlf_buf , null , null ); msg . _send ( chunk , encoding , null ); ret = msg . _send ( crlf_buf , null , callback ); } else { ret = msg . _send ( chunk , encoding , callback ); } return ret ; } \u6211\u4eec\u63a5\u7740\u770b_send\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 OutgoingMessage . prototype . _send = function _send ( data , encoding , callback ) { // \u5934\u90e8\u8fd8\u6ca1\u6709\u53d1\u9001 if ( ! this . _headerSent ) { // \u662f\u5b57\u7b26\u4e32\u5219\u8ffd\u52a0\u5230\u5934\u90e8\uff0cthis._header\u4fdd\u5b58\u4e86HTTP\u8bf7\u6c42\u884c\u548cHTTP\u5934 if ( typeof data === 'string' && ( encoding === 'utf8' || encoding === 'latin1' || ! encoding )) { data = this . _header + data ; } else { // \u5426\u5219\u7f13\u5b58\u8d77\u6765 const header = this . _header ; // HTTP\u5934\u9700\u8981\u653e\u5230\u6700\u524d\u9762 if ( this . outputData . length === 0 ) { this . outputData = [{ data : header , encoding : 'latin1' , callback : null }]; } else { this . outputData . unshift ({ data : header , encoding : 'latin1' , callback : null }); } // \u66f4\u65b0\u7f13\u5b58\u5927\u5c0f this . outputSize += header . length ; this . _onPendingData ( header . length ); } // \u5df2\u7ecf\u5728\u6392\u961f\u7b49\u5f85\u53d1\u9001\u4e86\uff0c\u4e0d\u80fd\u4fee\u6539 this . _headerSent = true ; } return this . _writeRaw ( data , encoding , callback ); }; \u6211\u4eec\u7ee7\u7eed\u770b_writeRaw 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 OutgoingMessage . prototype . _writeRaw = function _writeRaw ( data , encoding , callback ) { // \u53ef\u5199\u7684\u65f6\u5019\u76f4\u63a5\u53d1\u9001 if ( conn && conn . _httpMessage === this && conn . writable ) { // There might be pending data in the this.output buffer. // \u5982\u679c\u6709\u7f13\u5b58\u7684\u6570\u636e\u5219\u5148\u53d1\u9001\u7f13\u5b58\u7684\u6570\u636e if ( this . outputData . length ) { this . _flushOutput ( conn ); } // \u63a5\u7740\u53d1\u9001\u5f53\u524d\u9700\u8981\u53d1\u9001\u7684 return conn . write ( data , encoding , callback ); } // \u5426\u5148\u7f13\u5b58 this . outputData . push ({ data , encoding , callback }); this . outputSize += data . length ; this . _onPendingData ( data . length ); return this . outputSize < HIGH_WATER_MARK ; } OutgoingMessage . prototype . _flushOutput = function _flushOutput ( socket ) { // \u4e4b\u524d\u8bbe\u7f6e\u4e86\u52a0\u585e\uff0c\u5219\u64cd\u4f5csocket\u5148\u79ef\u6512\u6570\u636e while ( this [ kCorked ]) { this [ kCorked ] -- ; socket . cork (); } const outputLength = this . outputData . length ; if ( outputLength <= 0 ) return undefined ; const outputData = this . outputData ; socket . cork (); // \u628a\u7f13\u5b58\u7684\u6570\u636e\u5199\u5230socket let ret ; for ( let i = 0 ; i < outputLength ; i ++ ) { const { data , encoding , callback } = outputData [ i ]; ret = socket . write ( data , encoding , callback ); } socket . uncork (); this . outputData = []; this . _onPendingData ( - this . outputSize ); this . outputSize = 0 ; return ret ; }; \u5199\u5b8c\u6570\u636e\u540e\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u6267\u884cend\u51fd\u6570\u6807\u8bb0HTTP\u8bf7\u6c42\u7684\u7ed3\u675f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 OutgoingMessage . prototype . end = function end ( chunk , encoding , callback ) { // \u8fd8\u6ca1\u7ed3\u675f // \u52a0\u585e if ( this . socket ) { this . socket . cork (); } // \u6d41\u7ed3\u675f\u540e\u56de\u8c03 if ( typeof callback === 'function' ) this . once ( 'finish' , callback ); // \u6570\u636e\u5199\u5165\u5e95\u5c42\u540e\u7684\u56de\u8c03 const finish = onFinish . bind ( undefined , this ); // chunk\u6a21\u5f0f\u540e\u9762\u9700\u8981\u53d1\u9001\u4e00\u4e2a0\\r\\n\u7ed3\u675f\u6807\u8bb0\uff0c\u5426\u5219\u4e0d\u9700\u8981\u7ed3\u675f\u6807\u8bb0 if ( this . _hasBody && this . chunkedEncoding ) { this . _send ( '0\\r\\n' + this . _trailer + '\\r\\n' , 'latin1' , finish ); } else { this . _send ( '' , 'latin1' , finish ); } // uncork\u89e3\u9664\u585e\u5b50\uff0c\u53d1\u9001\u6570\u636e if ( this . socket ) { // Fully uncork connection on end(). this . socket . _writableState . corked = 1 ; this . socket . uncork (); } this [ kCorked ] = 0 ; // \u6807\u8bb0\u6267\u884c\u4e86end this . finished = true ; // \u6570\u636e\u53d1\u5b8c\u4e86 if ( this . outputData . length === 0 && this . socket && this . socket . _httpMessage === this ) { this . _finish (); } return this ; }; 18.3 HTTP\u670d\u52a1\u5668 \u00b6 \u672c\u8282\u6211\u4eec\u6765\u5206\u6790\u4f7f\u7528Node.js\u4f5c\u4e3a\u670d\u52a1\u5668\u7684\u4f8b\u5b50\u3002 1 2 3 4 5 6 const http = require ( 'http' ); http . createServer (( req , res ) => { res . write ( 'hello' ); res . end (); }) . listen ( 3000 ); \u63a5\u7740\u6211\u4eec\u6cbf\u7740createServer\u5206\u6790Node.js\u4f5c\u4e3a\u670d\u52a1\u5668\u7684\u539f\u7406\u3002 1 2 3 function createServer ( opts , requestListener ) { return new Server ( opts , requestListener ); } \u6211\u4eec\u770bServer\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 function Server ( options , requestListener ) { // \u53ef\u4ee5\u81ea\u5b9a\u4e49\u8868\u793a\u8bf7\u6c42\u7684\u5bf9\u8c61\u548c\u54cd\u5e94\u7684\u5bf9\u8c61 this [ kIncomingMessage ] = options . IncomingMessage || IncomingMessage ; this [ kServerResponse ] = options . ServerResponse || ServerResponse ; // HTTP\u5934\u4e2a\u6570\u7684\u9608\u503c const maxHeaderSize = options . maxHeaderSize ; this . maxHeaderSize = maxHeaderSize ; // \u5141\u8bb8\u534a\u5173\u95ed net . Server . call ( this , { allowHalfOpen : true }); // \u6709\u8bf7\u6c42\u65f6\u7684\u56de\u8c03 if ( requestListener ) { this . on ( 'request' , requestListener ); } // \u670d\u52a1\u5668socket\u8bfb\u7aef\u5173\u95ed\u65f6\u662f\u5426\u5141\u8bb8\u7ee7\u7eed\u5904\u7406\u961f\u5217\u91cc\u7684\u54cd\u5e94\uff08tcp\u4e0a\u6709\u591a\u4e2a\u8bf7\u6c42\uff0c\u7ba1\u9053\u5316\uff09 this . httpAllowHalfOpen = false ; // \u6709\u8fde\u63a5\u65f6\u7684\u56de\u8c03\uff0c\u7531net\u6a21\u5757\u89e6\u53d1 this . on ( 'connection' , connectionListener ); // \u670d\u52a1\u5668\u4e0b\u6240\u6709\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u8d85\u65f6\u65f6\u95f4 this . timeout = 0 ; // \u540c\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\uff0c\u4e24\u4e2a\u8bf7\u6c42\u4e4b\u524d\u6700\u591a\u95f4\u9694\u7684\u65f6\u95f4 this . keepAliveTimeout = 5000 ; this . maxHeadersCount = null ; // \u89e3\u6790\u5934\u90e8\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u9632\u6b62ddos this . headersTimeout = 60 * 1000 ; // 60 seconds } \u63a5\u7740\u8c03\u7528listen\u51fd\u6570\uff0c\u56e0\u4e3aHTTP Server\u7ee7\u627f\u4e8enet.Server\uff0cnet.Server\u7684listen\u51fd\u6570\u524d\u9762\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u5c31\u4e0d\u518d\u5206\u6790\u3002\u5f53\u6709\u8bf7\u6c42\u5230\u6765\u65f6\uff0c\u4f1a\u89e6\u53d1connection\u4e8b\u4ef6\u3002\u4ece\u800c\u6267\u884cconnectionListener\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 function connectionListener ( socket ) { defaultTriggerAsyncIdScope ( getOrSetAsyncId ( socket ), connectionListenerInternal , this , socket ); } // socket\u8868\u793a\u65b0\u8fde\u63a5 function connectionListenerInternal ( server , socket ) { // socket\u6240\u5c5eserver socket . server = server ; // \u8bbe\u7f6e\u8fde\u63a5\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u8d85\u65f6\u5904\u7406\u51fd\u6570\u4e3asocketOnTimeout if ( server . timeout && typeof socket . setTimeout === 'function' ) socket . setTimeout ( server . timeout ); socket . on ( 'timeout' , socketOnTimeout ); // \u5206\u914d\u4e00\u4e2aHTTP\u89e3\u6790\u5668 const parser = parsers . alloc (); // \u89e3\u6790\u8bf7\u6c42\u62a5\u6587 parser . initialize ( HTTPParser . REQUEST , new HTTPServerAsyncResource ( 'HTTPINCOMINGMESSAGE' , socket ), server . maxHeaderSize || 0 , server . insecureHTTPParser === undefined ? isLenient () : server . insecureHTTPParser , ); parser . socket = socket ; // \u8bb0\u5f55\u5f00\u59cb\u89e3\u6790\u5934\u90e8\u7684\u5f00\u59cb\u65f6\u95f4 parser . parsingHeadersStart = nowDate (); socket . parser = parser ; if ( typeof server . maxHeadersCount === 'number' ) { parser . maxHeaderPairs = server . maxHeadersCount << 1 ; } const state = { onData : null , onEnd : null , onClose : null , onDrain : null , // \u540c\u4e00TCP\u8fde\u63a5\u4e0a\uff0c\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u7684\u961f\u5217\uff0c\u7ebf\u5934\u963b\u585e\u7684\u539f\u7406 outgoing : [], incoming : [], // \u5f85\u53d1\u9001\u7684\u5b57\u8282\u6570\uff0c\u5982\u679c\u8d85\u8fc7\u9608\u503c\uff0c\u5219\u5148\u6682\u505c\u63a5\u6536\u8bf7\u6c42\u7684\u6570\u636e outgoingData : 0 , /* \u662f\u5426\u91cd\u65b0\u8bbe\u7f6e\u4e86timeout\uff0c\u7528\u4e8e\u54cd\u5e94\u4e00\u4e2a\u8bf7\u6c42\u65f6\uff0c \u6807\u8bb0\u662f\u5426\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\u7684\u6807\u8bb0 */ keepAliveTimeoutSet : false }; // \u76d1\u542ctcp\u4e0a\u7684\u6570\u636e\uff0c\u5f00\u59cb\u89e3\u6790http\u62a5\u6587 state . onData = socketOnData . bind ( undefined , server , socket , parser , state ); state . onEnd = socketOnEnd . bind ( undefined , server , socket , parser , state ); state . onClose = socketOnClose . bind ( undefined , socket , state ); state . onDrain = socketOnDrain . bind ( undefined , socket , state ); socket . on ( 'data' , state . onData ); socket . on ( 'error' , socketOnError ); socket . on ( 'end' , state . onEnd ); socket . on ( 'close' , state . onClose ); socket . on ( 'drain' , state . onDrain ); // \u89e3\u6790HTTP\u5934\u90e8\u5b8c\u6210\u540e\u6267\u884c\u7684\u56de\u8c03 parser . onIncoming = parserOnIncoming . bind ( undefined , server , socket , state ); socket . on ( 'resume' , onSocketResume ); socket . on ( 'pause' , onSocketPause ); /* \u5982\u679chandle\u662f\u7ee7\u627fStreamBase\u7684\u6d41\u5219\u6267\u884cconsume\u6d88\u8d39http \u8bf7\u6c42\u62a5\u6587\uff0c\u800c\u4e0d\u662f\u4e0a\u9762\u7684onData\uff0ctcp\u6a21\u5757\u7684isStreamBase\u4e3atrue */ if ( socket . _handle && socket . _handle . isStreamBase && ! socket . _handle . _consumed ) { parser . _consumed = true ; socket . _handle . _consumed = true ; parser . consume ( socket . _handle ); } parser [ kOnExecute ] = onParserExecute . bind ( undefined , server , socket , parser , state ); socket . _paused = false ; } \u6267\u884c\u5b8cconnectionListener\u540e\u5c31\u5f00\u59cb\u7b49\u5f85tcp\u4e0a\u6570\u636e\u7684\u5230\u6765\uff0c\u5373HTTP\u8bf7\u6c42\u62a5\u6587\u3002\u4e0a\u9762\u4ee3\u7801\u4e2dNode.js\u76d1\u542c\u4e86socket\u7684data\u4e8b\u4ef6\uff0c\u540c\u65f6\u6ce8\u518c\u4e86\u94a9\u5b50kOnExecute\u3002data\u4e8b\u4ef6\u6211\u4eec\u90fd\u77e5\u9053\u662f\u6d41\u4e0a\u6709\u6570\u636e\u5230\u6765\u65f6\u89e6\u53d1\u7684\u4e8b\u4ef6\u3002\u6211\u4eec\u770b\u4e00\u4e0bsocketOnData\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002 1 2 3 4 5 function socketOnData ( server , socket , parser , state , d ) { // \u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\uff0c\u8fd4\u56de\u5df2\u7ecf\u89e3\u6790\u7684\u5b57\u8282\u6570 const ret = parser . execute ( d ); onParserExecuteCommon ( server , socket , parser , state , ret , d ); } socketOnData\u7684\u5904\u7406\u903b\u8f91\u662f\u5f53socket\u4e0a\u6709\u6570\u636e\uff0c\u7136\u540e\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\u3002\u8fd9\u770b\u8d77\u6765\u6ca1\u4ec0\u4e48\u95ee\u9898\uff0c\u90a3\u4e48kOnExecute\u662f\u505a\u4ec0\u4e48\u7684\u5462\uff1fkOnExecute\u94a9\u5b50\u51fd\u6570\u7684\u503c\u662fonParserExecute\uff0c\u8fd9\u4e2a\u770b\u8d77\u6765\u4e5f\u662f\u89e3\u6790tcp\u4e0a\u7684\u6570\u636e\u7684\uff0c\u770b\u8d77\u6765\u548conSocketData\u662f\u4e00\u6837\u7684\u4f5c\u7528\uff0c\u96be\u9053tcp\u4e0a\u7684\u6570\u636e\u6709\u4e24\u4e2a\u6d88\u8d39\u8005\uff1f\u6211\u4eec\u770b\u4e00\u4e0bkOnExecute\u4ec0\u4e48\u65f6\u5019\u88ab\u56de\u8c03\u7684\u3002 1 2 3 4 5 6 7 void OnStreamRead ( ssize_t nread , const uv_buf_t & buf ) override { Local < Value > ret = Execute ( buf . base , nread ); Local < Value > cb = object () -> Get ( env () -> context (), kOnExecute ). ToLocalChecked (); MakeCallback ( cb . As < Function > (), 1 , & ret ); } OnStreamRead\u662fnode_http_parser.cc\u5b9e\u73b0\u7684\u51fd\u6570\uff0c\u6240\u4ee5kOnExecute\u5728node_http_parser.cc\u4e2d\u7684OnStreamRead\u4e2d\u88ab\u56de\u8c03\uff0c\u90a3\u4e48OnStreamRead\u53c8\u662f\u4ec0\u4e48\u65f6\u5019\u88ab\u56de\u8c03\u7684\u5462\uff1f\u5728C++\u5c42\u7ae0\u8282\u6211\u4eec\u5206\u6790\u8fc7\uff0cOnStreamRead\u662fNode.js\u4e2dC++\u5c42\u6d41\u64cd\u4f5c\u7684\u901a\u7528\u51fd\u6570\uff0c\u5f53\u6d41\u6709\u6570\u636e\u7684\u65f6\u5019\u5c31\u4f1a\u6267\u884c\u8be5\u56de\u8c03\u3002\u800c\u4e14OnStreamRead\u4e2d\u4e5f\u4f1a\u628a\u6570\u636e\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u89e3\u6790\u3002\u8fd9\u770b\u8d77\u6765\u771f\u7684\u6709\u4e24\u4e2a\u6d88\u8d39\u8005\uff1f\u8fd9\u5c31\u5f88\u5947\u602a\uff0c\u4e3a\u4ec0\u4e48\u4e00\u4efd\u6570\u636e\u4f1a\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\u4e24\u6b21\uff1f 1 2 3 4 5 if ( socket . _handle && socket . _handle . isStreamBase && ! socket . _handle . _consumed ) { parser . _consumed = true ; socket . _handle . _consumed = true ; parser . consume ( socket . _handle ); } \u56e0\u4e3aTCP\u6d41\u662f\u7ee7\u627fStreamBase\u7c7b\u7684\uff0c\u6240\u4ee5if\u6210\u7acb\u3002\u6211\u4eec\u770b\u4e00\u4e0bconsume\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 static void Consume ( const FunctionCallbackInfo < Value >& args ) { Parser * parser ; ASSIGN_OR_RETURN_UNWRAP ( & parser , args . Holder ()); CHECK ( args [ 0 ] -> IsObject ()); StreamBase * stream = StreamBase :: FromObjject ( args [ 0 ]. As < Object > ()); CHECK_NOT_NULL ( stream ); stream -> PushStreamListener ( parser ); } HTTP\u89e3\u6790\u5668\u628a\u81ea\u5df1\u6ce8\u518c\u4e3aTCP stream\u7684\u4e00\u4e2alistener\u3002\u8fd9\u4f1a\u4f7f\u5f97TCP\u6d41\u4e0a\u7684\u6570\u636e\u7531node_http_parser.cc\u7684OnStreamRead\u76f4\u63a5\u6d88\u8d39\uff0c\u800c\u4e0d\u662f\u89e6\u53d1onData\u4e8b\u4ef6\u3002\u5728OnStreamRead\u4e2d\u4f1a\u6e90\u6e90\u4e0d\u65ad\u5730\u628a\u6570\u636e\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\uff0c\u5728\u89e3\u6790\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4f1a\u4e0d\u65ad\u89e6\u53d1\u5bf9\u5e94\u7684\u94a9\u5b50\u51fd\u6570\uff0c\u76f4\u5230\u89e3\u6790\u5b8cHTTP\u5934\u90e8\u540e\u6267\u884cparserOnIncoming\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 function parserOnIncoming ( server , socket , state , req , keepAlive ) { // \u9700\u8981\u91cd\u7f6e\u5b9a\u65f6\u5668 resetSocketTimeout ( server , socket , state ); // \u8bbe\u7f6e\u4e86keepAlive\u5219\u54cd\u5e94\u540e\u9700\u8981\u91cd\u7f6e\u4e00\u4e9b\u72b6\u6001 if ( server . keepAliveTimeout > 0 ) { req . on ( 'end' , resetHeadersTimeoutOnReqEnd ); } // \u6807\u8bb0\u5934\u90e8\u89e3\u6790\u5b8c\u6bd5 socket . parser . parsingHeadersStart = 0 ; // \u8bf7\u6c42\u5165\u961f\uff08\u5f85\u5904\u7406\u7684\u8bf7\u6c42\u961f\u5217\uff09 state . incoming . push ( req ); if ( ! socket . _paused ) { const ws = socket . _writableState ; // \u5f85\u53d1\u9001\u7684\u6570\u636e\u8fc7\u591a\uff0c\u5148\u6682\u505c\u63a5\u6536\u8bf7\u6c42\u6570\u636e if ( ws . needDrain || state . outgoingData >= socket . writableHighWaterMark ) { socket . _paused = true ; socket . pause (); } } // \u65b0\u5efa\u4e00\u4e2a\u8868\u793a\u54cd\u5e94\u7684\u5bf9\u8c61 const res = new server [ kServerResponse ]( req ); // \u8bbe\u7f6e\u6570\u636e\u5199\u5165\u5f85\u53d1\u9001\u961f\u5217\u65f6\u89e6\u53d1\u7684\u56de\u8c03\uff0c\u89c1OutgoingMessage res . _onPendingData = updateOutgoingData . bind ( undefined , socket , state ); // \u6839\u636e\u8bf7\u6c42\u7684HTTP\u5934\u8bbe\u7f6e\u662f\u5426\u652f\u6301keepalive\uff08\u7ba1\u9053\u5316\uff09 res . shouldKeepAlive = keepAlive ; /* socket\u5f53\u524d\u5df2\u7ecf\u5728\u5904\u7406\u5176\u5b83\u8bf7\u6c42\u7684\u54cd\u5e94\uff0c\u5219\u5148\u6392\u961f\uff0c \u5426\u5219\u6302\u8f7d\u54cd\u5e94\u5bf9\u8c61\u5230socket\uff0c\u4f5c\u4e3a\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94 */ if ( socket . _httpMessage ) { state . outgoing . push ( res ); } else { res . assignSocket ( socket ); } // \u54cd\u5e94\u5904\u7406\u5b8c\u6bd5\u540e\uff0c\u9700\u8981\u505a\u4e00\u4e9b\u5904\u7406 res . on ( 'finish' , resOnFinish . bind ( undefined , req , res , socket , state , server )); // \u6709expect\u8bf7\u6c42\u5934\uff0c\u5e76\u4e14\u662fhttp1.1 if ( req . headers . expect !== undefined && ( req . httpVersionMajor === 1 && req . httpVersionMinor === 1 ) ) { // Expect\u5934\u7684\u503c\u662f\u5426\u662f100-continue if ( continueExpression . test ( req . headers . expect )) { res . _expect_continue = true ; /* \u76d1\u542c\u4e86checkContinue\u4e8b\u4ef6\u5219\u89e6\u53d1\uff0c \u5426\u5219\u76f4\u63a5\u8fd4\u56de\u5141\u8bb8\u7ee7\u7eed\u8bf7\u6c42\u5e76\u89e6\u53d1request\u4e8b\u4ef6 */ if ( server . listenerCount ( 'checkContinue' ) > 0 ) { server . emit ( 'checkContinue' , req , res ); } else { res . writeContinue (); server . emit ( 'request' , req , res ); } } else if ( server . listenerCount ( 'checkExpectation' ) > 0 ) { /* \u503c\u5f02\u5e38\uff0c\u76d1\u542c\u4e86checkExpectation\u4e8b\u4ef6\uff0c \u5219\u89e6\u53d1\uff0c\u5426\u5219\u8fd4\u56de417\u62d2\u7edd\u8bf7\u6c42 */ server . emit ( 'checkExpectation' , req , res ); } else { res . writeHead ( 417 ); res . end (); } } else { // \u89e6\u53d1request\u4e8b\u4ef6\u8bf4\u660e\u6709\u8bf7\u6c42\u5230\u6765 server . emit ( 'request' , req , res ); } return 0 ; // No special treatment. } \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u4f1a\u89e6\u53d1request\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u6709\u65b0\u8bf7\u6c42\u5230\u6765\uff0c\u7528\u6237\u5c31\u53ef\u4ee5\u5904\u7406\u8bf7\u6c42\u4e86\u3002\u6211\u4eec\u770b\u5230Node.js\u89e3\u6790\u5934\u90e8\u7684\u65f6\u5019\u5c31\u4f1a\u6267\u884c\u4e0a\u5c42\u56de\u8c03\uff0c\u901a\u77e5\u6709\u65b0\u8bf7\u6c42\u5230\u6765\uff0c\u5e76\u4f20\u5165request\u548cresponse\u4f5c\u4e3a\u53c2\u6570\uff0c\u5206\u522b\u5bf9\u5e94\u7684\u662f\u8868\u793a\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u5bf9\u8c61\u3002\u53e6\u5916Node.js\u672c\u8eab\u662f\u4e0d\u4f1a\u89e3\u6790body\u90e8\u5206\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u83b7\u53d6body\u7684\u6570\u636e\u3002 1 2 3 4 5 6 7 8 const server = http . createServer (( request , response ) => { request . on ( 'data' , ( chunk ) => { // \u5904\u7406body }); request . on ( 'end' , () => { // body\u7ed3\u675f }); }) 18.3.1 HTTP\u7ba1\u9053\u5316\u7684\u539f\u7406\u548c\u5b9e\u73b0 \u00b6 HTTP1.0\u7684\u65f6\u5019\uff0c\u4e0d\u652f\u6301\u7ba1\u9053\u5316\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u4e00\u4e2a\u8bf7\u6c42\u7684\u65f6\u5019\uff0c\u9996\u5148\u5efa\u7acbTCP\u8fde\u63a5\uff0c\u7136\u540e\u670d\u52a1\u5668\u8fd4\u56de\u4e00\u4e2a\u54cd\u5e94\uff0c\u6700\u540e\u65ad\u5f00TCP\u8fde\u63a5\uff0c\u8fd9\u79cd\u662f\u6700\u7b80\u5355\u7684\u5b9e\u73b0\u65b9\u5f0f\uff0c\u4f46\u662f\u6bcf\u6b21\u53d1\u9001\u8bf7\u6c42\u90fd\u9700\u8981\u8d70\u4e09\u6b21\u63e1\u624b\u663e\u7136\u4f1a\u5e26\u6765\u4e00\u5b9a\u7684\u65f6\u95f4\u635f\u8017\uff0c\u6240\u4ee5HTTP1.1\u7684\u65f6\u5019\uff0c\u652f\u6301\u4e86\u7ba1\u9053\u5316\u3002\u7ba1\u9053\u5316\u7684\u610f\u601d\u5c31\u662f\u53ef\u4ee5\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u53d1\u9001\u591a\u4e2a\u8bf7\u6c42\uff0c\u8fd9\u6837\u670d\u52a1\u5668\u5c31\u53ef\u4ee5\u540c\u65f6\u5904\u7406\u591a\u4e2a\u8bf7\u6c42\uff0c\u4f46\u662f\u7531\u4e8eHTTP1.1\u7684\u9650\u5236\uff0c\u591a\u4e2a\u8bf7\u6c42\u7684\u54cd\u5e94\u9700\u8981\u6309\u5e8f\u8fd4\u56de\u3002\u56e0\u4e3a\u5728HTTP1.1\u4e2d\uff0c\u6ca1\u6709\u6807\u8bb0\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u5bf9\u5e94\u5173\u7cfb\u3002\u6240\u4ee5HTTP\u5ba2\u6237\u7aef\u4f1a\u5047\u8bbe\u7b2c\u4e00\u4e2a\u8fd4\u56de\u7684\u54cd\u5e94\u662f\u5bf9\u5e94\u7b2c\u4e00\u4e2a\u8bf7\u6c42\u7684\u3002\u5982\u679c\u4e71\u5e8f\u8fd4\u56de\uff0c\u5c31\u4f1a\u5bfc\u81f4\u95ee\u9898\uff0c\u5982\u56fe18-2\u6240\u793a\u3002 \u56fe18-2 \u800c\u5728HTTP 2.0\u4e2d\uff0c\u6bcf\u4e2a\u8bf7\u6c42\u4f1a\u5206\u914d\u4e00\u4e2aid\uff0c\u54cd\u5e94\u4e2d\u4e5f\u4f1a\u8fd4\u56de\u5bf9\u5e94\u7684id\uff0c\u8fd9\u6837\u5c31\u7b97\u4e71\u5e8f\u8fd4\u56de\uff0cHTTP\u5ba2\u6237\u7aef\u4e5f\u53ef\u4ee5\u77e5\u9053\u54cd\u5e94\u6240\u5bf9\u5e94\u7684\u8bf7\u6c42\u3002\u5728HTTP 1.1\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0cHTTP\u670d\u52a1\u5668\u7684\u5b9e\u73b0\u5c31\u4f1a\u53d8\u5f97\u590d\u6742\uff0c\u670d\u52a1\u5668\u53ef\u4ee5\u4ee5\u4e32\u884c\u7684\u65b9\u5f0f\u5904\u7406\u8bf7\u6c42\uff0c\u5f53\u524d\u9762\u8bf7\u6c42\u7684\u54cd\u5e94\u8fd4\u56de\u5230\u5ba2\u6237\u7aef\u540e\uff0c\u518d\u7ee7\u7eed\u5904\u7406\u4e0b\u4e00\u4e2a\u8bf7\u6c42\uff0c\u8fd9\u79cd\u5b9e\u73b0\u65b9\u5f0f\u662f\u76f8\u5bf9\u7b80\u5355\u7684\uff0c\u4f46\u662f\u5f88\u660e\u663e\uff0c\u8fd9\u79cd\u65b9\u5f0f\u76f8\u5bf9\u6765\u8bf4\u8fd8\u662f\u6bd4\u8f83\u4f4e\u6548\u7684\uff0c\u53e6\u4e00\u79cd\u5b9e\u73b0\u65b9\u5f0f\u662f\u5e76\u884c\u5904\u7406\u8bf7\u6c42\uff0c\u4e32\u884c\u8fd4\u56de\uff0c\u8fd9\u6837\u53ef\u4ee5\u8ba9\u8bf7\u6c42\u5f97\u5230\u5c3d\u5feb\u7684\u5904\u7406\uff0c\u6bd4\u5982\u4e24\u4e2a\u8bf7\u6c42\u90fd\u8bbf\u95ee\u6570\u636e\u5e93\uff0c\u90a3\u5e76\u884c\u5904\u7406\u4e24\u4e2a\u8bf7\u6c42\u5c31\u4f1a\u6bd4\u4e32\u884c\u5feb\u5f97\u591a\uff0c\u4f46\u662f\u8fd9\u79cd\u5b9e\u73b0\u65b9\u5f0f\u76f8\u5bf9\u6bd4\u8f83\u590d\u6742\uff0cNode.js\u5c31\u662f\u5c5e\u4e8e\u8fd9\u79cd\u65b9\u5f0f\uff0c\u4e0b\u9762\u6211\u4eec\u6765\u770b\u4e00\u4e0bNode.js\u4e2d\u662f\u5982\u4f55\u5b9e\u73b0\u7684\u3002\u524d\u9762\u5206\u6790\u8fc7\uff0cNode.js\u5728\u89e3\u6790\u5b8cHTTP\u5934\u90e8\u7684\u65f6\u5019\u4f1a\u6267\u884cparserOnIncoming\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function parserOnIncoming ( server , socket , state , req , keepAlive ) { // \u6807\u8bb0\u5934\u90e8\u89e3\u6790\u5b8c\u6bd5 socket . parser . parsingHeadersStart = 0 ; // \u8bf7\u6c42\u5165\u961f state . incoming . push ( req ); // \u65b0\u5efa\u4e00\u4e2a\u8868\u793a\u54cd\u5e94\u7684\u5bf9\u8c61\uff0c\u4e00\u822c\u662fServerResponse const res = new server [ kServerResponse ]( req ); /* socket\u5f53\u524d\u5df2\u7ecf\u5728\u5904\u7406\u5176\u5b83\u8bf7\u6c42\u7684\u54cd\u5e94\uff0c\u5219\u5148\u6392\u961f\uff0c \u5426\u5219\u6302\u8f7d\u54cd\u5e94\u5bf9\u8c61\u5230socket\uff0c\u4f5c\u4e3a\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94 */ if ( socket . _httpMessage ) { state . outgoing . push ( res ); } else { res . assignSocket ( socket ); // socket._httpMessage = res; } // \u54cd\u5e94\u5904\u7406\u5b8c\u6bd5\u540e\uff0c\u9700\u8981\u505a\u4e00\u4e9b\u5904\u7406 res . on ( 'finish' , resOnFinish . bind ( undefined , req , res , socket , state , server )); // \u89e6\u53d1request\u4e8b\u4ef6\u8bf4\u660e\u6709\u8bf7\u6c42\u5230\u6765 server . emit ( 'request' , req , res ); return 0 ; } \u5f53Node.js\u89e3\u6790HTTP\u8bf7\u6c42\u5934\u5b8c\u6210\u540e\uff0c\u5c31\u4f1a\u521b\u5efa\u4e00\u4e2aServerResponse\u5bf9\u8c61\u8868\u793a\u54cd\u5e94\u3002\u7136\u540e\u5224\u65ad\u5f53\u524d\u662f\u5426\u6709\u6b63\u5728\u5904\u7406\u7684\u54cd\u5e94\uff0c\u5982\u679c\u6709\u5219\u6392\u961f\u7b49\u5f85\u5904\u7406\uff0c\u5426\u5219\u628a\u65b0\u5efa\u7684ServerResponse\u5bf9\u8c61\u4f5c\u4e3a\u5f53\u524d\u9700\u8981\u5904\u7406\u7684\u54cd\u5e94\u3002\u6700\u540e\u89e6\u53d1request\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u5c42\u3002\u7528\u6237\u5c31\u53ef\u4ee5\u8fdb\u884c\u8bf7\u6c42\u7684\u5904\u7406\u4e86\u3002\u6211\u4eec\u770b\u5230Node.js\u7ef4\u62a4\u4e86\u4e24\u4e2a\u961f\u5217\uff0c\u5206\u522b\u662f\u8bf7\u6c42\u548c\u54cd\u5e94\u961f\u5217\uff0c\u5982\u56fe18-3\u6240\u793a\u3002 \u56fe18-3 \u5f53\u524d\u5904\u7406\u7684\u8bf7\u6c42\u5728\u8bf7\u6c42\u961f\u5217\u7684\u961f\u9996\uff0c\u8be5\u8bf7\u6c42\u5bf9\u5e94\u7684\u54cd\u5e94\u4f1a\u6302\u8f7d\u5230socket\u7684_httpMessage\u5c5e\u6027\u4e0a\u3002\u4f46\u662f\u6211\u4eec\u770b\u5230Node.js\u4f1a\u89e6\u53d1request\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u6709\u65b0\u8bf7\u6c42\u5230\u6765\uff0c\u6240\u6709\u5728\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0cNode.js\u4f1a\u5e76\u884c\u5904\u7406\u591a\u4e2a\u8bf7\u6c42\uff08\u5982\u679c\u662fcpu\u5bc6\u96c6\u578b\u7684\u8bf7\u6c42\u5219\u5b9e\u9645\u4e0a\u8fd8\u662f\u4f1a\u53d8\u6210\u4e32\u884c\uff0c\u8fd9\u548cNode.js\u7684\u5355\u7ebf\u7a0b\u76f8\u5173\uff09\u3002\u90a3Node.js\u662f\u5982\u4f55\u63a7\u5236\u54cd\u5e94\u7684\u987a\u5e8f\u7684\u5462\uff1f\u6211\u4eec\u77e5\u9053\u6bcf\u6b21\u89e6\u53d1request\u4e8b\u4ef6\u7684\u65f6\u5019\uff0c\u6211\u4eec\u90fd\u4f1a\u6267\u884c\u4e00\u4e2a\u51fd\u6570\u3002\u6bd4\u5982\u4e0b\u9762\u7684\u4ee3\u7801\u3002 1 2 3 4 5 http . createServer (( req , res ) => { // \u4e00\u4e9b\u7f51\u7edcIO res . writeHead ( 200 , { 'Content-Type' : 'text/plain' }); res . end ( 'okay' ); }); \u6211\u4eec\u770b\u5230\u6bcf\u4e2a\u8bf7\u6c42\u7684\u5904\u7406\u662f\u72ec\u7acb\u7684\u3002\u5047\u8bbe\u6bcf\u4e2a\u8bf7\u6c42\u90fd\u53bb\u64cd\u4f5c\u6570\u636e\u5e93\uff0c\u5982\u679c\u8bf7\u6c422\u6bd4\u8bf7\u6c421\u5148\u5b8c\u6210\u6570\u636e\u5e93\u7684\u64cd\u4f5c\uff0c\u4ece\u800c\u8bf7\u6c422\u5148\u6267\u884cres.write\u548cres.end\u3002\u90a3\u5c82\u4e0d\u662f\u8bf7\u6c422\u5148\u8fd4\u56de\uff1f\u6211\u4eec\u770b\u4e00\u4e0bServerResponse\u548cOutgoingMessage\u7684\u5b9e\u73b0\uff0c\u63ed\u5f00\u8ff7\u96fe\u3002ServerResponse\u662fOutgoingMessage\u7684\u5b50\u7c7b\u3002write\u51fd\u6570\u662f\u5728OutgoingMessage\u4e2d\u5b9e\u73b0\u7684\uff0cwrite\u7684\u8c03\u7528\u94fe\u8def\u5f88\u957f\uff0c\u6211\u4eec\u4e0d\u5c42\u5c42\u5206\u6790\uff0c\u76f4\u63a5\u770b\u6700\u540e\u7684\u8282\u70b9\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function _writeRaw ( data , encoding , callback ) { const conn = this . socket ; // socket\u5bf9\u5e94\u7684\u54cd\u5e94\u662f\u81ea\u5df1\u5e76\u4e14\u53ef\u5199 if ( conn && conn . _httpMessage === this && conn . writable ) { // \u5982\u679c\u6709\u7f13\u5b58\u7684\u6570\u636e\u5219\u5148\u53d1\u9001\u7f13\u5b58\u7684\u6570\u636e if ( this . outputData . length ) { this . _flushOutput ( conn ); } // \u63a5\u7740\u53d1\u9001\u5f53\u524d\u9700\u8981\u53d1\u9001\u7684 return conn . write ( data , encoding , callback ); } // socket\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94\u5bf9\u8c61\u4e0d\u662f\u81ea\u5df1\uff0c\u5219\u5148\u7f13\u5b58\u6570\u636e\u3002 this . outputData . push ({ data , encoding , callback }); this . outputSize += data . length ; this . _onPendingData ( data . length ); return this . outputSize < HIGH_WATER_MARK ; } \u6211\u4eec\u770b\u5230\u6211\u4eec\u8c03\u7528res.write\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u9996\u5148\u5224\u65ad\uff0cres\u662f\u4e0d\u662f\u5c5e\u4e8e\u5f53\u524d\u5904\u7406\u4e2d\u54cd\u5e94\uff0c\u5982\u679c\u662f\u624d\u4f1a\u771f\u6b63\u53d1\u9001\u6570\u636e\uff0c\u5426\u5219\u4f1a\u5148\u628a\u6570\u636e\u7f13\u5b58\u8d77\u6765\u3002\u5206\u6790\u5230\u8fd9\u91cc\uff0c\u76f8\u4fe1\u5927\u5bb6\u5df2\u7ecf\u5dee\u4e0d\u591a\u660e\u767dNode.js\u662f\u5982\u4f55\u63a7\u5236\u54cd\u5e94\u6309\u5e8f\u8fd4\u56de\u7684\u3002\u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e9b\u7f13\u5b58\u7684\u6570\u636e\u4ec0\u4e48\u65f6\u5019\u4f1a\u88ab\u53d1\u9001\u51fa\u53bb\u3002\u524d\u9762\u4ee3\u7801\u5df2\u7ecf\u8d34\u8fc7\uff0c\u5f53\u4e00\u4e2a\u54cd\u5e94\u7ed3\u675f\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u505a\u4e00\u4e9b\u5904\u7406\u3002 1 2 3 4 5 6 res . on ( 'finish' , resOnFinish . bind ( undefined , req , res , socket , state , server )); \u6211\u4eec\u770b\u770bresOnFinish 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 function resOnFinish ( req , res , socket , state , server ) { // \u5220\u9664\u54cd\u5e94\u5bf9\u5e94\u7684\u8bf7\u6c42 state . incoming . shift (); clearIncoming ( req ); // \u89e3\u9664socket\u4e0a\u6302\u8f7d\u7684\u54cd\u5e94\u5bf9\u8c61 res . detachSocket ( socket ); req . emit ( 'close' ); process . nextTick ( emitCloseNT , res ); // \u662f\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94 if ( res . _last ) { // \u662f\u5219\u9500\u6bc1socket if ( typeof socket . destroySoon === 'function' ) { socket . destroySoon (); } else { socket . end (); } } else if ( state . outgoing . length === 0 ) { /* \u6ca1\u6709\u5f85\u5904\u7406\u7684\u54cd\u5e94\u4e86\uff0c\u5219\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff0c \u7b49\u5f85\u8bf7\u6c42\u7684\u5230\u6765\uff0c\u4e00\u5b9a\u65f6\u95f4\u5185\u6ca1\u6709\u8bf7\u6c42\u5219\u89e6\u53d1timeout\u4e8b\u4ef6 */ if ( server . keepAliveTimeout && typeof socket . setTimeout === 'function' ) { socket . setTimeout ( server . keepAliveTimeout ); state . keepAliveTimeoutSet = true ; } } else { // \u83b7\u53d6\u4e0b\u4e00\u4e2a\u8981\u5904\u7406\u7684\u54cd\u5e94 const m = state . outgoing . shift (); // \u6302\u8f7d\u5230socket\u4f5c\u4e3a\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94 if ( m ) { m . assignSocket ( socket ); } } } \u6211\u4eec\u770b\u5230\uff0cNode.js\u5904\u7406\u5b8c\u4e00\u4e2a\u54cd\u5e94\u540e\uff0c\u4f1a\u505a\u4e00\u4e9b\u5224\u65ad\u3002\u5206\u522b\u6709\u4e09\u79cd\u60c5\u51b5\uff0c\u6211\u4eec\u5206\u5f00\u5206\u6790\u3002 1 \u662f\u5426\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94 \u4ec0\u4e48\u60c5\u51b5\u4e0b\uff0c\u4f1a\u88ab\u8ba4\u4e3a\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u7684\uff1f\u56e0\u4e3a\u54cd\u5e94\u548c\u8bf7\u6c42\u662f\u4e00\u4e00\u5bf9\u5e94\u7684\uff0c\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u5c31\u610f\u5473\u7740\u6700\u540e\u4e00\u4e2a\u8bf7\u6c42\u4e86\uff0c\u90a3\u4e48\u4ec0\u4e48\u65f6\u5019\u88ab\u8ba4\u4e3a\u662f\u6700\u540e\u4e00\u4e2a\u8bf7\u6c42\u5462\uff1f\u5f53\u975e\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0c\u4e00\u4e2a\u8bf7\u6c42\u4e00\u4e2a\u54cd\u5e94\uff0c\u7136\u540e\u5173\u95edTCP\u8fde\u63a5\uff0c\u6240\u4ee5\u975e\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0ctcp\u4e0a\u7684\u7b2c\u4e00\u4e2a\u4e5f\u662f\u552f\u4e00\u4e00\u4e2a\u8bf7\u6c42\u5c31\u662f\u6700\u540e\u4e00\u4e2a\u8bf7\u6c42\u3002\u5728\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0c\u7406\u8bba\u4e0a\u5c31\u6ca1\u6709\u6240\u8c13\u7684\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u3002\u4f46\u662f\u5b9e\u73b0\u4e0a\u4f1a\u505a\u4e00\u4e9b\u9650\u5236\u3002\u5728\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0c\u6bcf\u4e00\u4e2a\u54cd\u5e94\u53ef\u4ee5\u901a\u8fc7\u8bbe\u7f6eHTTP\u54cd\u5e94\u5934connection\u6765\u5b9a\u4e49\u662f\u5426\u53d1\u9001\u8be5\u54cd\u5e94\u540e\u5c31\u65ad\u5f00\u8fde\u63a5\uff0c\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // \u662f\u5426\u663e\u793a\u5220\u9664\u8fc7connection\u5934\uff0c\u662f\u5219\u54cd\u5e94\u540e\u65ad\u5f00\u8fde\u63a5\uff0c\u5e76\u6807\u8bb0\u5f53\u524d\u54cd\u5e94\u662f\u6700\u540e\u4e00\u4e2a if ( this . _removedConnection ) { this . _last = true ; this . shouldKeepAlive = false ; } else if ( ! state . connection ) { /* \u6ca1\u6709\u663e\u793a\u8bbe\u7f6e\u4e86connection\u5934\uff0c\u5219\u53d6\u9ed8\u8ba4\u884c\u4e3a 1 Node.js\u7684shouldKeepAlive\u9ed8\u8ba4\u4e3atrue\uff0c\u4e5f\u53ef\u4ee5\u6839\u636e\u8bf7\u6c42\u62a5\u6587\u91cc \u7684connection\u5934\u5b9a\u4e49 2 \u8bbe\u7f6econtent-length\u6216\u4f7f\u7528chunk\u6a21\u5f0f\u624d\u80fd\u533a\u5206\u54cd\u5e94\u62a5\u6587\u7f16\u8fb9\u754c\uff0c \u624d\u80fd\u652f\u6301keepalive 3 \u4f7f\u7528\u4e86\u4ee3\u7406\uff0c\u4ee3\u7406\u662f\u590d\u7528TCP\u8fde\u63a5\u7684\uff0c\u652f\u6301keepalive */ const shouldSendKeepAlive = this . shouldKeepAlive && ( state . contLen || this . useChunkedEncodingByDefault || this . agent ); if ( shouldSendKeepAlive ) { header += 'Connection: keep-alive\\r\\n' ; } else { this . _last = true ; header += 'Connection: close\\r\\n' ; } } \u53e6\u5916\u5f53\u8bfb\u7aef\u5173\u95ed\u7684\u65f6\u5019\uff0c\u4e5f\u88ab\u8ba4\u4e3a\u662f\u6700\u540e\u4e00\u4e2a\u8bf7\u6c42\uff0c\u6bd5\u7adf\u4e0d\u4f1a\u518d\u53d1\u9001\u8bf7\u6c42\u4e86\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8bfb\u7aef\u5173\u95ed\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function socketOnEnd ( server , socket , parser , state ) { const ret = parser . finish (); if ( ret instanceof Error ) { socketOnError . call ( socket , ret ); return ; } // \u4e0d\u5141\u8bb8\u534a\u5f00\u5173\u5219\u7ec8\u6b62\u8bf7\u6c42\u7684\u5904\u7406\uff0c\u4e0d\u54cd\u5e94\uff0c\u5173\u95ed\u5199\u7aef if ( ! server . httpAllowHalfOpen ) { abortIncoming ( state . incoming ); if ( socket . writable ) socket . end (); } else if ( state . outgoing . length ) { /* \u5141\u8bb8\u534a\u5f00\u5173\uff0c\u5e76\u4e14\u8fd8\u6709\u54cd\u5e94\u9700\u8981\u5904\u7406\uff0c \u6807\u8bb0\u54cd\u5e94\u961f\u5217\u6700\u540e\u4e00\u4e2a\u8282\u70b9\u4e3a\u6700\u540e\u7684\u54cd\u5e94\uff0c \u5904\u7406\u5b8c\u5c31\u5173\u95edsocket\u5199\u7aef */ state . outgoing [ state . outgoing . length - 1 ]. _last = true ; } else if ( socket . _httpMessage ) { /* \u6ca1\u6709\u7b49\u5f85\u5904\u7406\u7684\u54cd\u5e94\u4e86\uff0c\u4f46\u662f\u8fd8\u6709\u6b63\u5728\u5904\u7406\u7684\u54cd\u5e94\uff0c \u5219\u6807\u8bb0\u4e3a\u6700\u540e\u4e00\u4e2a\u54cd\u5e94 */ socket . _httpMessage . _last = true ; } else if ( socket . writable ) { // \u5426\u5219\u5173\u95edsocket\u5199\u7aef socket . end (); } } \u4ee5\u4e0a\u5c31\u662fNode.js\u4e2d\u5224\u65ad\u662f\u5426\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u7684\u60c5\u51b5\uff0c\u5982\u679c\u4e00\u4e2a\u54cd\u5e94\u88ab\u8ba4\u4e3a\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\uff0c\u90a3\u4e48\u53d1\u9001\u54cd\u5e94\u540e\u5c31\u4f1a\u5173\u95ed\u8fde\u63a5\u3002 2 \u54cd\u5e94\u961f\u5217\u4e3a\u7a7a \u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0b\u5982\u679c\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u7684\u65f6\u5019\uff0cNode.js\u53c8\u662f\u600e\u4e48\u5904\u7406\u7684\u3002\u5982\u679c\u5f53\u524d\u7684\u5f85\u5904\u7406\u54cd\u5e94\u961f\u5217\u4e3a\u7a7a\uff0c\u8bf4\u660e\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94\u662f\u76ee\u524d\u6700\u540e\u4e00\u4e2a\u9700\u8981\u5904\u7406\u7684\uff0c\u4f46\u662f\u4e0d\u662fTCP\u8fde\u63a5\u4e0a\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\uff0c\u8fd9\u65f6\u5019\uff0cNode.js\u4f1a\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff0c\u5982\u679c\u8d85\u65f6\u8fd8\u6ca1\u6709\u65b0\u7684\u8bf7\u6c42\uff0c\u5219Node.js\u4f1a\u5173\u95ed\u8fde\u63a5\u3002 3 \u54cd\u5e94\u961f\u5217\u975e\u7a7a \u5982\u679c\u5f53\u524d\u5f85\u5904\u7406\u961f\u5217\u975e\u7a7a\uff0c\u5904\u7406\u5b8c\u5f53\u524d\u8bf7\u6c42\u540e\u4f1a\u7ee7\u7eed\u5904\u7406\u4e0b\u4e00\u4e2a\u54cd\u5e94\u3002\u5e76\u4ece\u961f\u5217\u4e2d\u5220\u9664\u8be5\u54cd\u5e94\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u662f\u5982\u4f55\u5904\u7406\u4e0b\u4e00\u4e2a\u54cd\u5e94\u7684\u3002 1 2 3 4 5 6 7 8 9 // \u628a\u54cd\u5e94\u5bf9\u8c61\u6302\u8f7d\u5230socket\uff0c\u6807\u8bb0socket\u5f53\u524d\u6b63\u5728\u5904\u7406\u7684\u54cd\u5e94 ServerResponse . prototype . assignSocket = function assignSocket ( socket ) { // \u6302\u8f7d\u5230socket\u4e0a\uff0c\u6807\u8bb0\u662f\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94 socket . _httpMessage = this ; socket . on ( 'close' , onServerResponseClose ); this . socket = socket ; this . emit ( 'socket' , socket ); this . _flush (); }; \u6211\u4eec\u770b\u5230Node.js\u662f\u901a\u8fc7_httpMessage\u6807\u8bb0\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94\u7684\uff0c\u914d\u5408\u54cd\u5e94\u961f\u5217\u6765\u5b9e\u73b0\u54cd\u5e94\u7684\u6309\u5e8f\u8fd4\u56de\u3002\u6807\u8bb0\u5b8c\u540e\u6267\u884c_flush\u53d1\u9001\u54cd\u5e94\u7684\u6570\u636e\uff08\u5982\u679c\u8fd9\u65f6\u5019\u8bf7\u6c42\u5df2\u7ecf\u88ab\u5904\u7406\u5b8c\u6210\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 OutgoingMessage . prototype . _flush = function _flush () { const socket = this . socket ; if ( socket && socket . writable ) { const ret = this . _flushOutput ( socket ); }; OutgoingMessage . prototype . _flushOutput = function _flushOutput ( socket ) { // \u4e4b\u524d\u8bbe\u7f6e\u4e86\u52a0\u585e\uff0c\u5219\u64cd\u4f5csocket\u5148\u79ef\u6512\u6570\u636e while ( this [ kCorked ]) { this [ kCorked ] -- ; socket . cork (); } const outputLength = this . outputData . length ; // \u6ca1\u6709\u6570\u636e\u9700\u8981\u53d1\u9001 if ( outputLength <= 0 ) return undefined ; const outputData = this . outputData ; // \u52a0\u585e\uff0c\u8ba9\u6570\u636e\u4e00\u8d77\u53d1\u9001\u51fa\u53bb socket . cork (); // \u628a\u7f13\u5b58\u7684\u6570\u636e\u5199\u5230socket let ret ; for ( let i = 0 ; i < outputLength ; i ++ ) { const { data , encoding , callback } = outputData [ i ]; ret = socket . write ( data , encoding , callback ); } socket . uncork (); this . outputData = []; this . _onPendingData ( - this . outputSize ); this . outputSize = 0 ; return ret ; } \u4ee5\u4e0a\u5c31\u662fNode.js\u4e2d\u5bf9\u4e8e\u7ba1\u9053\u5316\u7684\u5b9e\u73b0\u3002 18.3.2 HTTP Connect\u65b9\u6cd5\u7684\u539f\u7406\u548c\u5b9e\u73b0 \u00b6 \u5206\u6790HTTP Connect\u5b9e\u73b0\u4e4b\u524d\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u4e3a\u4ec0\u4e48\u9700\u8981HTTP Connect\u65b9\u6cd5\u6216\u8005\u8bf4\u5b83\u51fa\u73b0\u7684\u80cc\u666f\u3002Connect\u65b9\u6cd5\u4e3b\u8981\u7528\u4e8e\u4ee3\u7406\u670d\u52a1\u5668\u7684\u8bf7\u6c42\u8f6c\u53d1\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4f20\u7edfHTTP\u670d\u52a1\u5668\u7684\u5de5\u4f5c\u539f\u7406\uff0c\u5982\u56fe18-4\u6240\u793a\u3002 \u56fe18-4 1 \u5ba2\u6237\u7aef\u548c\u4ee3\u7406\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5 2 \u5ba2\u6237\u7aef\u53d1\u9001HTTP\u8bf7\u6c42\u7ed9\u4ee3\u7406\u670d\u52a1\u5668 3 \u4ee3\u7406\u670d\u52a1\u5668\u89e3\u6790HTTP\u534f\u8bae\uff0c\u6839\u636e\u914d\u7f6e\u62ff\u5230\u4e1a\u52a1\u670d\u52a1\u5668\u7684\u5730\u5740 4 \u4ee3\u7406\u670d\u52a1\u5668\u548c\u4e1a\u52a1\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\uff0c\u901a\u8fc7HTTP\u534f\u8bae\u6216\u8005\u5176\u5b83\u534f\u8bae\u8f6c\u53d1\u8bf7\u6c42 5 \u4e1a\u52a1\u670d\u52a1\u5668\u8fd4\u56de\u6570\u636e\uff0c\u4ee3\u7406\u670d\u52a1\u5668\u56de\u590dHTTP\u62a5\u6587\u7ed9\u5ba2\u6237\u7aef\u3002 \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bHTTPS\u670d\u52a1\u5668\u7684\u539f\u7406\u3002 1 \u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5 2 \u670d\u52a1\u5668\u901a\u8fc7TLS\u62a5\u6587\u8fd4\u56de\u8bc1\u4e66\u4fe1\u606f\uff0c\u5e76\u548c\u5ba2\u6237\u7aef\u5b8c\u6210\u540e\u7eed\u7684TLS\u901a\u4fe1\u3002 3 \u5b8c\u6210TLS\u901a\u4fe1\u540e\uff0c\u540e\u7eed\u53d1\u9001\u7684HTTP\u62a5\u6587\u4f1a\u7ecf\u8fc7TLS\u5c42\u52a0\u5bc6\u89e3\u5bc6\u540e\u518d\u4f20\u8f93\u3002 \u90a3\u4e48\u5982\u679c\u6211\u4eec\u60f3\u5b9e\u73b0\u4e00\u4e2aHTTPS\u7684\u4ee3\u7406\u670d\u52a1\u5668\u600e\u4e48\u505a\u5462\uff1f\u56e0\u4e3a\u5ba2\u6237\u7aef\u53ea\u7ba1\u548c\u76f4\u63a5\u76f8\u8fde\u7684\u670d\u52a1\u5668\u8fdb\u884cHTTPS\u7684\u901a\u4fe1\uff0c\u5982\u679c\u6211\u4eec\u7684\u4e1a\u52a1\u670d\u52a1\u5668\u524d\u9762\u8fd8\u6709\u4ee3\u7406\u670d\u52a1\u5668\uff0c\u90a3\u4e48\u4ee3\u7406\u670d\u52a1\u5668\u5c31\u5fc5\u987b\u8981\u6709\u8bc1\u4e66\u624d\u80fd\u548c\u5ba2\u6237\u7aef\u5b8c\u6210TLS\u63e1\u624b\uff0c\u4ece\u800c\u8fdb\u884cHTTPS\u901a\u4fe1\u3002\u4ee3\u7406\u670d\u52a1\u5668\u548c\u4e1a\u52a1\u670d\u52a1\u5668\u4f7f\u7528HTTP\u6216\u8005HTTPS\u8fd8\u662f\u5176\u5b83\u534f\u8bae\u90fd\u53ef\u4ee5\u3002\u8fd9\u6837\u5c31\u610f\u5473\u7740\u6211\u4eec\u6240\u6709\u7684\u670d\u52a1\u7684\u8bc1\u4e66\u90fd\u9700\u8981\u653e\u5230\u4ee3\u7406\u670d\u52a1\u5668\u4e0a\uff0c\u8fd9\u79cd\u573a\u666f\u7684\u9650\u5236\u662f\uff0c\u4ee3\u7406\u670d\u52a1\u5668\u548c\u4e1a\u52a1\u670d\u52a1\u5668\u90fd\u7531\u6211\u4eec\u81ea\u5df1\u7ba1\u7406\u6216\u8005\u516c\u53f8\u7edf\u4e00\u7ba1\u7406\u3002\u5982\u679c\u6211\u4eec\u60f3\u52a0\u4e00\u4e2a\u4ee3\u7406\u5bf9\u4e1a\u52a1\u670d\u52a1\u5668\u4e0d\u611f\u77e5\u90a3\u600e\u4e48\u529e\u5462\uff08\u6bd4\u5982\u5199\u4e00\u4e2a\u4ee3\u7406\u670d\u52a1\u5668\u7528\u4e8e\u5f00\u53d1\u8c03\u8bd5\uff09\uff1f\u6709\u4e00\u79cd\u65b9\u5f0f\u5c31\u662f\u4e3a\u6211\u4eec\u7684\u4ee3\u7406\u670d\u52a1\u5668\u7533\u8bf7\u4e00\u4e2a\u8bc1\u4e66\uff0c\u8fd9\u6837\u5ba2\u6237\u7aef\u548c\u4ee3\u7406\u670d\u52a1\u5668\u5c31\u53ef\u4ee5\u5b8c\u6210\u6b63\u5e38\u7684HTTPS\u901a\u4fe1\u4e86\u3002\u4ece\u800c\u4e5f\u5c31\u53ef\u4ee5\u5b8c\u6210\u4ee3\u7406\u7684\u529f\u80fd\u3002\u53e6\u5916\u4e00\u79cd\u65b9\u5f0f\u5c31\u662fHTTP Connect\u65b9\u6cd5\u3002HTTP Connect\u65b9\u6cd5\u7684\u4f5c\u7528\u662f\u6307\u793a\u670d\u52a1\u5668\u5e2e\u5fd9\u5efa\u7acb\u4e00\u6761TCP\u8fde\u63a5\u5230\u771f\u6b63\u7684\u4e1a\u52a1\u670d\u52a1\u5668\uff0c\u5e76\u4e14\u900f\u4f20\u540e\u7eed\u7684\u6570\u636e\uff0c\u8fd9\u6837\u4e0d\u7533\u8bf7\u8bc1\u4e66\u4e5f\u53ef\u4ee5\u5b8c\u6210\u4ee3\u7406\u7684\u529f\u80fd\uff0c\u5982\u56fe18-5\u6240\u793a\u3002 \u56fe18-5 \u8fd9\u65f6\u5019\u4ee3\u7406\u670d\u52a1\u5668\u53ea\u8d1f\u8d23\u900f\u4f20\u4e24\u7aef\u7684\u6570\u636e\uff0c\u4e0d\u50cf\u4f20\u7edf\u7684\u65b9\u5f0f\u4e00\u6837\u89e3\u6790\u8bf7\u6c42\u7136\u540e\u518d\u8f6c\u53d1\u3002\u8fd9\u6837\u5ba2\u6237\u7aef\u548c\u4e1a\u52a1\u670d\u52a1\u5668\u5c31\u53ef\u4ee5\u81ea\u5df1\u5b8c\u6210TLS\u63e1\u624b\u548cHTTPS\u901a\u4fe1\u3002\u4ee3\u7406\u670d\u52a1\u5668\u5c31\u50cf\u4e0d\u5b58\u5728\u4e00\u6837\u3002\u4e86\u89e3\u4e86Connect\u7684\u539f\u7406\u540e\u770b\u4e00\u4e0b\u6765\u81eaNode.js\u5b98\u65b9\u7684\u4e00\u4e2a\u4f8b\u5b50\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 const http = require ( 'http' ); const net = require ( 'net' ); const { URL } = require ( 'url' ); // \u521b\u5efa\u4e00\u4e2aHTTP\u670d\u52a1\u5668\u4f5c\u4e3a\u4ee3\u7406\u670d\u52a1\u5668 const proxy = http . createServer (( req , res ) => { res . writeHead ( 200 , { 'Content-Type' : 'text/plain' }); res . end ( 'okay' ); }); // \u76d1\u542cconnect\u4e8b\u4ef6\uff0c\u6709http connect\u8bf7\u6c42\u65f6\u89e6\u53d1 proxy . on ( 'connect' , ( req , clientSocket , head ) => { // \u83b7\u53d6\u771f\u6b63\u8981\u8fde\u63a5\u7684\u670d\u52a1\u5668\u5730\u5740\u5e76\u53d1\u8d77\u8fde\u63a5 const { port , hostname } = new URL ( `http:// ${ req . url } ` ); const serverSocket = net . connect ( port || 80 , hostname , () => { // \u8fde\u63a5\u6210\u529f\u544a\u8bc9\u5ba2\u6237\u7aef clientSocket . write ( 'HTTP/1.1 200 Connection Established\\r\\n' + 'Proxy-agent: Node.js-Proxy\\r\\n' + '\\r\\n' ); // \u900f\u4f20\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u7684\u6570\u636e serverSocket . write ( head ); serverSocket . pipe ( clientSocket ); clientSocket . pipe ( serverSocket ); }); }); proxy . listen ( 1337 , '127.0.0.1' , () => { const options = { port : 1337 , // \u8fde\u63a5\u7684\u4ee3\u7406\u670d\u52a1\u5668\u5730\u5740 host : '127.0.0.1' , method : 'CONNECT' , // \u6211\u4eec\u9700\u8981\u771f\u6b63\u60f3\u8bbf\u95ee\u7684\u670d\u52a1\u5668\u5730\u5740 path : 'www.baidu.com' , }; // \u53d1\u8d77http connect\u8bf7\u6c42 const req = http . request ( options ); req . end (); // connect\u8bf7\u6c42\u6210\u529f\u540e\u89e6\u53d1 req . on ( 'connect' , ( res , socket , head ) => { // \u53d1\u9001\u771f\u6b63\u7684\u8bf7\u6c42 socket . write ( 'GET / HTTP/1.1\\r\\n' + 'Host: www.baidu.com\\r\\n' + 'Connection: close\\r\\n' + '\\r\\n' ); socket . on ( 'data' , ( chunk ) => { console . log ( chunk . toString ()); }); socket . on ( 'end' , () => { proxy . close (); }); }); }); \u5b98\u7f51\u7684\u8fd9\u4e2a\u4f8b\u5b50\u5f88\u597d\u5730\u8bf4\u660e\u4e86Connect\u7684\u539f\u7406\uff0c\u5982\u56fe18-6\u6240\u793a\u3002 \u56fe18-6 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2dConnect\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u4eceHTTP Connect\u8bf7\u6c42\u5f00\u59cb\u3002\u4e4b\u524d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u5ba2\u6237\u7aef\u548cNode.js\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\u540e\uff0cNode.js\u6536\u5230\u6570\u636e\u7684\u65f6\u5019\u4f1a\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\uff0c 1 2 3 4 5 6 // \u8fde\u63a5\u4e0a\u6709\u6570\u636e\u5230\u6765 function socketOnData ( server , socket , parser , state , d ) { // \u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\uff0c\u8fd4\u56de\u5df2\u7ecf\u89e3\u6790\u7684\u5b57\u8282\u6570 const ret = parser . execute ( d ); onParserExecuteCommon ( server , socket , parser , state , ret , d ); } HTTP\u89e3\u6790\u6570\u636e\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u4e0d\u65ad\u56de\u8c03Node.js\u7684\u56de\u8c03\uff0c\u7136\u540e\u6267\u884conParserExecuteCommon\u3002\u6211\u4eec\u8fd9\u91cc\u53ea\u5173\u6ce8\u5f53Node.js\u89e3\u6790\u5b8c\u6240\u6709HTTP\u8bf7\u6c42\u5934\u540e\u6267\u884cparserOnHeadersComplete\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function parserOnHeadersComplete ( versionMajor , versionMinor , headers , method , url , statusCode , statusMessage , upgrade , shouldKeepAlive ) { const parser = this ; const { socket } = parser ; // IncomingMessage const ParserIncomingMessage = ( socket && socket . server && socket . server [ kIncomingMessage ]) || IncomingMessage ; // \u65b0\u5efa\u4e00\u4e2aIncomingMessage\u5bf9\u8c61 const incoming = parser . incoming = new ParserIncomingMessage ( socket ); incoming . httpVersionMajor = versionMajor ; incoming . httpVersionMinor = versionMinor ; incoming . httpVersion = ` ${ versionMajor } . ${ versionMinor } ` ; incoming . url = url ; // \u662f\u5426\u662fconnect\u8bf7\u6c42\u6216\u8005upgrade\u8bf7\u6c42 incoming . upgrade = upgrade ; // \u6267\u884c\u56de\u8c03 return parser . onIncoming ( incoming , shouldKeepAlive ); } \u6211\u4eec\u770b\u5230\u89e3\u6790\u5b8cHTTP\u5934\u540e\uff0cNode.js\u4f1a\u521b\u5efa\u4e00\u4e2a\u8868\u793a\u8bf7\u6c42\u7684\u5bf9\u8c61IncomingMessage\uff0c\u7136\u540e\u56de\u8c03onIncoming\u3002 1 2 3 4 5 6 7 8 9 10 function parserOnIncoming ( server , socket , state , req , keepAlive ) { // \u8bf7\u6c42\u662f\u5426\u662fconnect\u6216\u8005upgrade if ( req . upgrade ) { req . upgrade = req . method === 'CONNECT' || server . listenerCount ( 'upgrade' ) > 0 ; if ( req . upgrade ) return 2 ; } // ... } Node.js\u89e3\u6790\u5b8c\u5934\u90e8\u5e76\u4e14\u6267\u884c\u4e86\u54cd\u5e94\u7684\u94a9\u5b50\u51fd\u6570\u540e\uff0c\u4f1a\u6267\u884conParserExecuteCommon\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function onParserExecuteCommon ( server , socket , parser , state , ret , d ) { if ( ret instanceof Error ) { prepareError ( ret , parser , d ); ret . rawPacket = d || parser . getCurrentBuffer (); socketOnError . call ( socket , ret ); } else if ( parser . incoming && parser . incoming . upgrade ) { // \u5904\u7406Upgrade\u6216\u8005CONNECT\u8bf7\u6c42 const req = parser . incoming ; const eventName = req . method === 'CONNECT' ? 'connect' : 'upgrade' ; // \u76d1\u542c\u4e86\u5bf9\u5e94\u7684\u4e8b\u4ef6\u5219\u5904\u7406\uff0c\u5426\u5219\u5173\u95ed\u8fde\u63a5 if ( eventName === 'upgrade' || server . listenerCount ( eventName ) > 0 ) { // \u8fd8\u6ca1\u6709\u89e3\u6790\u7684\u6570\u636e const bodyHead = d . slice ( ret , d . length ); socket . readableFlowing = null ; server . emit ( eventName , req , socket , bodyHead ); } else { socket . destroy (); } } } \u8fd9\u65f6\u5019Node.js\u4f1a\u5224\u65ad\u8bf7\u6c42\u662f\u4e0d\u662fConnect\u6216\u8005\u534f\u8bae\u5347\u7ea7\u7684upgrade\u8bf7\u6c42\uff0c\u662f\u7684\u8bdd\u7ee7\u7eed\u5224\u65ad\u662f\u5426\u6709\u5904\u7406\u8be5\u4e8b\u4ef6\u7684\u51fd\u6570\uff0c\u6ca1\u6709\u5219\u5173\u95ed\u8fde\u63a5\uff0c\u5426\u5219\u89e6\u53d1\u5bf9\u5e94\u7684\u4e8b\u4ef6\u8fdb\u884c\u5904\u7406\u3002\u6240\u4ee5\u8fd9\u65f6\u5019Node.js\u4f1a\u89e6\u53d1Connect\u65b9\u6cd5\u3002Connect\u4e8b\u4ef6\u7684\u5904\u7406\u903b\u8f91\u6b63\u5982\u6211\u4eec\u5f00\u59cb\u7ed9\u51fa\u7684\u4f8b\u5b50\u4e2d\u90a3\u6837\u3002\u6211\u4eec\u9996\u5148\u548c\u771f\u6b63\u7684\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\uff0c\u7136\u540e\u8fd4\u56de\u54cd\u5e94\u5934\u7ed9\u5ba2\u6237\u7aef\uff0c\u540e\u7eed\u5ba2\u6237\u5c31\u53ef\u4ee5\u548c\u771f\u6b63\u7684\u670d\u52a1\u5668\u771f\u6b63\u8fdb\u884cTLS\u63e1\u624b\u548cHTTPS\u901a\u4fe1\u4e86\u3002\u8fd9\u5c31\u662fNode.js\u4e2dConnect\u7684\u539f\u7406\u548c\u5b9e\u73b0\u3002 \u4e0d\u8fc7\u5728\u4ee3\u7801\u4e2d\u6211\u4eec\u53d1\u73b0\u4e00\u4e2a\u597d\u73a9\u7684\u5730\u65b9\u3002\u90a3\u5c31\u662f\u5728\u89e6\u53d1connect\u4e8b\u4ef6\u7684\u65f6\u5019\uff0cNode.js\u7ed9\u56de\u8c03\u51fd\u6570\u4f20\u5165\u7684\u53c2\u6570\u3002 1 server . emit ( 'connect' , req , socket , bodyHead ); \u7b2c\u4e00\u7b2c\u4e8c\u4e2a\u53c2\u6570\u6ca1\u4ec0\u4e48\u7279\u522b\u7684\uff0c\u4f46\u662f\u7b2c\u4e09\u4e2a\u53c2\u6570\u5c31\u6709\u610f\u601d\u4e86\uff0cbodyHead\u4ee3\u8868\u7684\u662fHTTP Connect\u8bf7\u6c42\u4e2d\u9664\u4e86\u8bf7\u6c42\u884c\u548cHTTP\u5934\u4e4b\u5916\u7684\u6570\u636e\u3002\u56e0\u4e3aNode.js\u89e3\u6790\u5b8cHTTP\u5934\u540e\u5c31\u4e0d\u7ee7\u7eed\u5904\u7406\u4e86\u3002\u628a\u5269\u4e0b\u7684\u6570\u636e\u4ea4\u7ed9\u4e86\u7528\u6237\u3002\u6211\u4eec\u6765\u505a\u4e00\u4e9b\u597d\u73a9\u7684\u4e8b\u60c5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const http = require ( 'http' ); const net = require ( 'net' ); const { URL } = require ( 'url' ); const proxy = http . createServer (( req , res ) => { res . writeHead ( 200 , { 'Content-Type' : 'text/plain' }); res . end ( 'okay' ); }); proxy . on ( 'connect' , ( req , clientSocket , head ) => { const { port , hostname } = new URL ( `http:// ${ req . url } ` ); const serverSocket = net . connect ( port || 80 , hostname , () => { clientSocket . write ( 'HTTP/1.1 200 Connection Established\\r\\n' + 'Proxy-agent: Node.js-Proxy\\r\\n' + '\\r\\n' ); // \u628aconnect\u8bf7\u6c42\u5269\u4e0b\u7684\u6570\u636e\u8f6c\u53d1\u7ed9\u670d\u52a1\u5668 serverSocket . write ( head ); serverSocket . pipe ( clientSocket ); clientSocket . pipe ( serverSocket ); }); }); proxy . listen ( 1337 , '127.0.0.1' , () => { const net = require ( 'net' ); const body = 'GET http://www.baidu.com:80 HTTP/1.1\\r\\n\\r\\n' ; const length = body . length ; const socket = net . connect ({ host : '127.0.0.1' , port : 1337 }); socket . write ( `CONNECT www.baidu.com:80 HTTP/1.1\\r\\n\\r\\n ${ body } ` ); socket . setEncoding ( 'utf-8' ); socket . on ( 'data' , ( chunk ) => { console . log ( chunk ) }); }); \u6211\u4eec\u65b0\u5efa\u4e00\u4e2asocket\uff0c\u7136\u540e\u81ea\u5df1\u6784\u9020HTTP Connect\u62a5\u6587\uff0c\u5e76\u4e14\u5728HTTP\u884c\u540e\u9762\u52a0\u4e00\u4e2a\u989d\u5916\u7684\u5b57\u7b26\u4e32\uff0c\u8fd9\u4e2a\u5b57\u7b26\u4e32\u662f\u4e24\u4e00\u4e2aHTTP\u8bf7\u6c42\u3002\u5f53Node.js\u670d\u52a1\u5668\u6536\u5230Connect\u8bf7\u6c42\u540e\uff0c\u6211\u4eec\u5728connect\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\u4e2d\uff0c\u628aConnect\u8bf7\u6c42\u591a\u4f59\u7684\u90a3\u4e00\u90e8\u5206\u6570\u636e\u4f20\u7ed9\u771f\u6b63\u7684\u670d\u52a1\u5668\u3002\u8fd9\u6837\u5c31\u8282\u7701\u4e86\u53d1\u9001\u4e00\u4e2a\u8bf7\u6c42\u7684\u65f6\u95f4\u3002 18.3.3 \u8d85\u65f6\u7ba1\u7406 \u00b6 \u5728\u89e3\u6790HTTP\u534f\u8bae\u6216\u8005\u652f\u6301\u957f\u8fde\u63a5\u7684\u65f6\u5019\uff0cNode.js\u9700\u8981\u8bbe\u7f6e\u4e00\u4e9b\u8d85\u65f6\u7684\u673a\u5236\uff0c\u5426\u5219\u4f1a\u9020\u6210\u653b\u51fb\u6216\u8005\u8d44\u6e90\u6d6a\u8d39\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bHTTP\u670d\u52a1\u5668\u4e2d\u6d89\u53ca\u5230\u8d85\u65f6\u7684\u4e00\u4e9b\u903b\u8f91\u3002 1 \u89e3\u6790HTTP\u5934\u90e8\u8d85\u65f6 \u5f53\u6536\u5230\u4e00\u4e2aHTTP\u8bf7\u6c42\u62a5\u6587\u65f6\uff0c\u4f1a\u4eceHTTP\u8bf7\u6c42\u884c\uff0cHTTP\u5934\uff0cHTTP body\u7684\u987a\u5e8f\u8fdb\u884c\u89e3\u6790\uff0c\u5982\u679c\u7528\u6237\u6784\u9020\u8bf7\u6c42\uff0c\u53ea\u53d1\u9001HTTP\u5934\u7684\u4e00\u90e8\u5206\u3002\u90a3\u4e48HTTP\u89e3\u6790\u5668\u5c31\u4f1a\u4e00\u76f4\u5728\u7b49\u5f85\u540e\u7eed\u6570\u636e\u7684\u5230\u6765\u3002\u8fd9\u4f1a\u5bfc\u81f4DDOS\u653b\u51fb\uff0c\u6240\u4ee5Node.js\u4e2d\u8bbe\u7f6e\u4e86\u89e3\u6790HTTP\u5934\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u9608\u503c\u662f60\u79d2\u3002\u5982\u679c60\u79d2\u5185\u6ca1\u6709\u89e3\u6790\u5b8cHTTP\u5934\u90e8\uff0c\u5219\u4f1a\u89e6\u53d1timeout\u4e8b\u4ef6\u3002\u5982\u679c\u7528\u6237\u4e0d\u5904\u7406\uff0c\u5219Node.js\u4f1a\u81ea\u52a8\u5173\u95ed\u8fde\u63a5\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u7684\u5b9e\u73b0\u3002Node.js\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u4f1a\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\u3002 1 2 3 4 5 this . headersTimeout = 60 * 1000 ; // 60 seconds // Node.js\u5728\u5efa\u7acbTCP\u8fde\u63a5\u6210\u529f\u540e\u521d\u59cb\u5316\u89e3\u6790HTTP\u5934\u7684\u5f00\u59cb\u65f6\u95f4\u3002 function connectionListenerInternal ( server , socket ) { parser . parsingHeadersStart = nowDate (); } \u7136\u540e\u5728\u6bcf\u6b21\u6536\u5230\u6570\u636e\u7684\u65f6\u5019\u5224\u65adHTTP\u5934\u90e8\u662f\u5426\u89e3\u6790\u5b8c\u6210\uff0c\u5982\u679c\u6ca1\u6709\u89e3\u6790\u5b8c\u6210\u5e76\u4e14\u8d85\u65f6\u4e86\u5219\u4f1a\u89e6\u53d1timeout\u4e8b\u4ef6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function onParserExecute ( server , socket , parser , state , ret ) { socket . _unrefTimer (); const start = parser . parsingHeadersStart ; // start\u7b49\u4e8e0\uff0c\u8bf4\u660eHTTP\u5934\u5df2\u7ecf\u89e3\u6790\u5b8c\u6bd5\uff0c\u5426\u5219\u8bf4\u660e\u6b63\u5728\u89e3\u6790\u5934\uff0c\u7136\u540e\u518d\u5224\u65ad\u89e3\u6790\u65f6\u95f4\u662f\u5426\u8d85\u65f6\u4e86 if ( start !== 0 && nowDate () - start > server . headersTimeout ) { // \u89e6\u53d1timeout\uff0c\u5982\u679c\u6ca1\u6709\u76d1\u542ctimeout\uff0c\u5219\u9ed8\u8ba4\u4f1a\u9500\u6bc1socket\uff0c\u5373\u5173\u95ed\u8fde\u63a5 const serverTimeout = server . emit ( 'timeout' , socket ); if ( ! serverTimeout ) socket . destroy (); return ; } onParserExecuteCommon ( server , socket , parser , state , ret , undefined ); } \u5982\u679c\u5728\u8d85\u65f6\u4e4b\u524d\u89e3\u6790HTTP\u5934\u5b8c\u6210\uff0c\u5219\u628aparsingHeadersStart\u7f6e\u4e3a0\u8868\u793a\u89e3\u6790\u5b8c\u6210\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function parserOnIncoming ( server , socket , state , req , keepAlive ) { // \u8bbe\u7f6e\u4e86keepAlive\u5219\u54cd\u5e94\u540e\u9700\u8981\u91cd\u7f6e\u4e00\u4e9b\u72b6\u6001 if ( server . keepAliveTimeout > 0 ) { req . on ( 'end' , resetHeadersTimeoutOnReqEnd ); } // \u6807\u8bb0\u5934\u90e8\u89e3\u6790\u5b8c\u6bd5 socket . parser . parsingHeadersStart = 0 ; } function resetHeadersTimeoutOnReqEnd () { if ( parser ) { parser . parsingHeadersStart = nowDate (); } } \u53e6\u5916\u5982\u679c\u652f\u6301\u957f\u8fde\u63a5\uff0c\u5373\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u53ef\u4ee5\u53d1\u9001\u591a\u4e2a\u8bf7\u6c42\u3002\u5219\u5728\u6bcf\u4e2a\u54cd\u5e94\u7ed3\u675f\u4e4b\u540e\uff0c\u9700\u8981\u91cd\u65b0\u521d\u59cb\u5316\u89e3\u6790HTTP\u5934\u7684\u5f00\u59cb\u65f6\u95f4\u3002\u5f53\u4e0b\u4e00\u4e2a\u8bf7\u6c42\u6570\u636e\u5230\u6765\u65f6\u518d\u6b21\u5224\u65ad\u89e3\u6790HTTP\u5934\u90e8\u662f\u5426\u8d85\u65f6\u3002\u8fd9\u91cc\u662f\u54cd\u5e94\u7ed3\u675f\u540e\u5c31\u5f00\u59cb\u8ba1\u7b97\u3002\u800c\u4e0d\u662f\u4e0b\u4e00\u4e2a\u8bf7\u6c42\u5230\u6765\u65f6\u3002 2 \u652f\u6301\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0c\u591a\u4e2a\u8bf7\u6c42\u7684\u65f6\u95f4\u95f4\u9694 Node.js\u652f\u6301\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u53d1\u9001\u591a\u4e2aHTTP\u8bf7\u6c42\uff0c\u6240\u4ee5\u9700\u8981\u8bbe\u7f6e\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u5982\u679c\u8d85\u65f6\u90fd\u6ca1\u6709\u65b0\u7684\u8bf7\u6c42\u5230\u6765\uff0c\u5219\u89e6\u53d1\u8d85\u65f6\u4e8b\u4ef6\u3002\u8fd9\u91cc\u6d89\u53ca\u5b9a\u65f6\u5668\u7684\u8bbe\u7f6e\u548c\u91cd\u7f6e\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // \u662f\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94 if ( res . _last ) { // \u662f\u5219\u9500\u6bc1socket if ( typeof socket . destroySoon === 'function' ) { socket . destroySoon (); } else { socket . end (); } } else if ( state . outgoing . length === 0 ) { // \u6ca1\u6709\u5f85\u5904\u7406\u7684\u54cd\u5e94\u4e86\uff0c\u5219\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff0c\u7b49\u5f85\u8bf7\u6c42\u7684\u5230\u6765\uff0c\u4e00\u5b9a\u65f6\u95f4\u5185\u6ca1\u6709\u8bf7\u6c42\u5219\u89e6\u53d1timeout\u4e8b\u4ef6 if ( server . keepAliveTimeout && typeof socket . setTimeout === 'function' ) { socket . setTimeout ( server . keepAliveTimeout ); state . keepAliveTimeoutSet = true ; } } \u6bcf\u6b21\u54cd\u5e94\u7ed3\u675f\u7684\u65f6\u5019\uff0cNode.js\u9996\u5148\u4f1a\u5224\u65ad\u5f53\u524d\u54cd\u5e94\u662f\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\uff0c\u4f8b\u5982\u8bfb\u7aef\u4e0d\u53ef\u8bfb\u4e86\uff0c\u8bf4\u660e\u4e0d\u4f1a\u53c8\u8bf7\u6c42\u5230\u6765\u4e86\uff0c\u4e5f\u4e0d\u4f1a\u6709\u54cd\u5e94\u4e86\uff0c\u90a3\u4e48\u5c31\u4e0d\u9700\u8981\u4fdd\u6301\u8fd9\u4e2aTCP\u8fde\u63a5\u3002\u5982\u679c\u5f53\u524d\u54cd\u5e94\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\uff0c\u5219Node.js\u4f1a\u6839\u636ekeepAliveTimeout\u7684\u503c\u505a\u4e0b\u4e00\u6b65\u5224\u65ad\uff0c\u5982\u679ckeepAliveTimeout \u975e\u7a7a\uff0c\u5219\u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u5982\u679ckeepAliveTimeout \u65f6\u95f4\u5185\u90fd\u6ca1\u6709\u65b0\u7684\u8bf7\u6c42\u5219\u89e6\u53d1timeout\u4e8b\u4ef6\u3002\u90a3\u4e48\u5982\u679c\u6709\u65b0\u8bf7\u6c42\u5230\u6765\uff0c\u5219\u9700\u8981\u91cd\u7f6e\u8fd9\u4e2a\u5b9a\u65f6\u5668\u3002Node.js\u5728\u6536\u5230\u65b0\u8bf7\u6c42\u7684\u7b2c\u4e00\u4e2a\u8bf7\u6c42\u5305\u4e2d\uff0c\u91cd\u7f6e\u8be5\u5b9a\u65f6\u5668\u3002 1 2 3 4 5 6 7 8 9 10 11 function onParserExecuteCommon ( server , socket , parser , state , ret , d ) { resetSocketTimeout ( server , socket , state ); } function resetSocketTimeout ( server , socket , state ) { if ( ! state . keepAliveTimeoutSet ) return ; socket . setTimeout ( server . timeout || 0 ); state . keepAliveTimeoutSet = false ; } onParserExecuteCommon\u4f1a\u5728\u6bcf\u6b21\u6536\u5230\u6570\u636e\u65f6\u6267\u884c\uff0c\u7136\u540eNode.js\u4f1a\u91cd\u7f6e\u5b9a\u65f6\u5668\u4e3aserver.timeout\u7684\u503c\u3002 18.4 Agent \u00b6 \u672c\u8282\u6211\u4eec\u5148\u5206\u6790Agent\u6a21\u5757\u7684\u5b9e\u73b0\uff0cAgent\u5bf9TCP\u8fde\u63a5\u8fdb\u884c\u4e86\u6c60\u5316\u7ba1\u7406\u3002\u7b80\u5355\u7684\u60c5\u51b5\u4e0b\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u4e00\u4e2aHTTP\u8bf7\u6c42\u4e4b\u524d\uff0c\u9996\u5148\u5efa\u7acb\u4e00\u4e2aTCP\u8fde\u63a5\uff0c\u6536\u5230\u54cd\u5e94\u540e\u4f1a\u7acb\u523b\u5173\u95edTCP\u8fde\u63a5\u3002\u4f46\u662f\u6211\u4eec\u77e5\u9053TCP\u7684\u4e09\u6b21\u63e1\u624b\u662f\u6bd4\u8f83\u8017\u65f6\u7684\u3002\u6240\u4ee5\u5982\u679c\u6211\u4eec\u80fd\u590d\u7528TCP\u8fde\u63a5\uff0c\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u53d1\u9001\u591a\u4e2aHTTP\u8bf7\u6c42\u548c\u63a5\u6536\u591a\u4e2aHTTP\u54cd\u5e94\uff0c\u90a3\u4e48\u5728\u6027\u80fd\u4e0a\u9762\u5c31\u4f1a\u5f97\u5230\u5f88\u5927\u7684\u63d0\u5347\u3002Agent\u7684\u4f5c\u7528\u5c31\u662f\u590d\u7528TCP\u8fde\u63a5\u3002\u4e0d\u8fc7Agent\u7684\u6a21\u5f0f\u662f\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u4e32\u884c\u5730\u53d1\u9001\u8bf7\u6c42\u548c\u63a5\u6536\u54cd\u5e94\uff0c\u4e0d\u652f\u6301HTTP PipeLine\u6a21\u5f0f\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bAgent\u6a21\u5757\u7684\u5177\u4f53\u5b9e\u73b0\u3002\u770b\u5b83\u662f\u5982\u4f55\u5b9e\u73b0TCP\u8fde\u63a5\u590d\u7528\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 function Agent ( options ) { if ( ! ( this instanceof Agent )) return new Agent ( options ); EventEmitter . call ( this ); this . defaultPort = 80 ; this . protocol = 'http:' ; this . options = { ... options }; // path\u5b57\u6bb5\u8868\u793a\u662f\u672c\u673a\u7684\u8fdb\u7a0b\u95f4\u901a\u4fe1\u65f6\u4f7f\u7528\u7684\u8def\u5f84\uff0c\u6bd4\u5982Unix\u57df\u8def\u5f84 this . options . path = null ; // socket\u4e2a\u6570\u8fbe\u5230\u9608\u503c\u540e\uff0c\u7b49\u5f85\u7a7a\u95f2socket\u7684\u8bf7\u6c42 this . requests = {}; // \u6b63\u5728\u4f7f\u7528\u7684socket this . sockets = {}; // \u7a7a\u95f2socket this . freeSockets = {}; // \u7a7a\u95f2socket\u7684\u5b58\u6d3b\u65f6\u95f4 this . keepAliveMsecs = this . options . keepAliveMsecs || 1000 ; /* \u7528\u5b8c\u7684socket\u662f\u5426\u653e\u5230\u7a7a\u95f2\u961f\u5217\uff0c \u5f00\u542fkeepalive\u624d\u4f1a\u653e\u5230\u7a7a\u95f2\u961f\u5217\uff0c \u4e0d\u5f00\u542fkeepalive \u8fd8\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u5219\u590d\u7528socket \u6ca1\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u5219\u76f4\u63a5\u9500\u6bc1socket */ this . keepAlive = this . options . keepAlive || false ; // \u6700\u5927\u7684socket\u4e2a\u6570\uff0c\u5305\u62ec\u6b63\u5728\u4f7f\u7528\u7684\u548c\u7a7a\u95f2\u7684socket this . maxSockets = this . options . maxSockets || Agent . defaultMaxSockets ; // \u6700\u5927\u7684\u7a7a\u95f2socket\u4e2a\u6570 this . maxFreeSockets = this . options . maxFreeSockets || 256 ; } Agent\u7ef4\u62a4\u4e86\u51e0\u4e2a\u6570\u636e\u7ed3\u6784\uff0c\u5206\u522b\u662f\u7b49\u5f85socket\u7684\u8bf7\u6c42\u3001\u6b63\u5728\u4f7f\u7528\u7684socket\u3001\u7a7a\u95f2socket\u3002\u6bcf\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u662f\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5bf9\u8c61\u7684key\u662f\u6839\u636eHTTP\u8bf7\u6c42\u53c2\u6570\u8ba1\u7b97\u7684\u3002\u5bf9\u8c61\u7684\u503c\u662f\u4e00\u4e2a\u961f\u5217\u3002\u5177\u4f53\u7ed3\u6784\u5982\u56fe18-7\u6240\u793a\u3002 \u56fe18-7 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bAgent\u6a21\u5757\u7684\u5177\u4f53\u5b9e\u73b0\u3002 18.4.1 key\u7684\u8ba1\u7b97 \u00b6 key\u7684\u8ba1\u7b97\u662f\u6c60\u5316\u7ba1\u7406\u7684\u6838\u5fc3\u3002\u6b63\u786e\u5730\u8bbe\u8ba1key\u7684\u8ba1\u7b97\u89c4\u5219\uff0c\u624d\u80fd\u66f4\u597d\u5730\u5229\u7528\u6c60\u5316\u5e26\u6765\u7684\u597d\u5904\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // \u4e00\u4e2a\u8bf7\u6c42\u5bf9\u5e94\u7684key Agent . prototype . getName = function getName ( options ) { let name = options . host || 'localhost' ; name += ':' ; if ( options . port ) name += options . port ; name += ':' ; if ( options . localAddress ) name += options . localAddress ; if ( options . family === 4 || options . family === 6 ) name += `: ${ options . family } ` ; if ( options . socketPath ) name += `: ${ options . socketPath } ` ; return name ; }; \u6211\u4eec\u770b\u5230key\u7531host\u3001port\u3001\u672c\u5730\u5730\u5740\u3001\u5730\u5740\u7c07\u7c7b\u578b\u3001unix\u8def\u5f84\u8ba1\u7b97\u800c\u6765\u3002\u6240\u4ee5\u4e0d\u540c\u7684\u8bf7\u6c42\u53ea\u6709\u8fd9\u4e9b\u56e0\u5b50\u90fd\u4e00\u6837\u7684\u60c5\u51b5\u4e0b\u624d\u80fd\u590d\u7528\u8fde\u63a5\u3002\u53e6\u5916\u6211\u4eec\u770b\u5230Agent\u652f\u6301Unix\u57df\u3002 18.4.2 \u521b\u5efa\u4e00\u4e2asocket \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 function createSocket ( req , options , cb ) { options = { ... options , ... this . options }; // \u8ba1\u7b97key const name = this . getName ( options ); options . _agentKey = name ; options . encoding = null ; let called = false ; // \u521b\u5efasocket\u5b8c\u6bd5\u540e\u6267\u884c\u7684\u56de\u8c03 const oncreate = ( err , s ) => { if ( called ) return ; called = true ; if ( err ) return cb ( err ); if ( ! this . sockets [ name ]) { this . sockets [ name ] = []; } // \u63d2\u5165\u6b63\u5728\u4f7f\u7528\u7684socket\u961f\u5217 this . sockets [ name ]. push ( s ); // \u76d1\u542csocket\u7684\u4e00\u4e9b\u4e8b\u4ef6\uff0c\u7528\u4e8e\u56de\u6536socket installListeners ( this , s , options ); // \u6709\u53ef\u7528socket\uff0c\u901a\u77e5\u8c03\u7528\u65b9 cb ( null , s ); }; // \u521b\u5efa\u4e00\u4e2a\u65b0\u7684socket\uff0c\u4f7f\u7528net.createConnection const newSocket = this . createConnection ( options , oncreate ); if ( newSocket ) oncreate ( null , newSocket ); } function installListeners ( agent , s , options ) { /* socket\u89e6\u53d1\u7a7a\u95f2\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\uff0c\u544a\u8bc9agent\u8be5socket\u7a7a\u95f2\u4e86\uff0c agent\u4f1a\u56de\u6536\u8be5socket\u5230\u7a7a\u95f2\u961f\u5217 */ function onFree () { agent . emit ( 'free' , s , options ); } /* \u76d1\u542csocket\u7a7a\u95f2\u4e8b\u4ef6\uff0c\u8c03\u7528\u65b9\u4f7f\u7528\u5b8csocket\u540e\u89e6\u53d1\uff0c \u901a\u77e5agent socket\u7528\u5b8c\u4e86 */ s . on ( 'free' , onFree ); function onClose ( err ) { agent . removeSocket ( s , options ); } // socket\u5173\u95ed\u5219agent\u4f1a\u4ecesocket\u961f\u5217\u4e2d\u5220\u9664\u5b83 s . on ( 'close' , onClose ); function onRemove () { agent . removeSocket ( s , options ); s . removeListener ( 'close' , onClose ); s . removeListener ( 'free' , onFree ); s . removeListener ( 'agentRemove' , onRemove ); } // agent\u88ab\u79fb\u9664 s . on ( 'agentRemove' , onRemove ); } \u521b\u5efasocket\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 \u8c03\u7528net\u6a21\u5757\u521b\u5efa\u4e00\u4e2asocket\uff08TCP\u6216\u8005Unix\u57df\uff09\uff0c\u7136\u540e\u63d2\u5165\u4f7f\u7528\u4e2d\u7684socket\u961f\u5217\uff0c\u6700\u540e\u901a\u77e5\u8c03\u7528\u65b9socket\u521b\u5efa\u6210\u529f\u3002 2 \u76d1\u542csocket\u7684close\u3001free\u4e8b\u4ef6\u548cagentRemove\u4e8b\u4ef6\uff0c\u89e6\u53d1\u65f6\u4ece\u961f\u5217\u4e2d\u5220\u9664socket\u3002 18.4.3 \u5220\u9664socket \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // \u628asocket\u4ece\u6b63\u5728\u4f7f\u7528\u961f\u5217\u6216\u8005\u7a7a\u95f2\u961f\u5217\u4e2d\u79fb\u51fa function removeSocket ( s , options ) { const name = this . getName ( options ); const sets = [ this . sockets ]; /* socket\u4e0d\u53ef\u5199\u4e86\uff0c\u5219\u6709\u53ef\u80fd\u662f\u5b58\u5728\u7a7a\u95f2\u7684\u961f\u5217\u4e2d\uff0c \u6240\u4ee5\u9700\u8981\u904d\u5386\u7a7a\u95f2\u961f\u5217\uff0c\u56e0\u4e3aremoveSocket\u53ea\u4f1a\u5728 \u4f7f\u7528\u5b8csocket\u6216\u8005socket\u5173\u95ed\u7684\u65f6\u5019\u88ab\u8c03\u7528\uff0c\u524d\u8005\u53ea\u6709\u5728 \u53ef\u5199\u72b6\u6001\u65f6\u4f1a\u8c03\u7528\uff0c\u540e\u8005\u662f\u4e0d\u53ef\u5199\u7684 */ if ( ! s . writable ) sets . push ( this . freeSockets ); // \u4ece\u961f\u5217\u4e2d\u5220\u9664\u5bf9\u5e94\u7684socket for ( const sockets of sets ) { if ( sockets [ name ]) { const index = sockets [ name ]. indexOf ( s ); if ( index !== - 1 ) { sockets [ name ]. splice ( index , 1 ); // Don't leak if ( sockets [ name ]. length === 0 ) delete sockets [ name ]; } } } /* \u5982\u679c\u8fd8\u6709\u5728\u7b49\u5f85socekt\u7684\u8bf7\u6c42\uff0c\u5219\u521b\u5efasocket\u53bb\u5904\u7406\u5b83\uff0c \u56e0\u4e3asocket\u6570\u5df2\u7ecf\u51cf\u4e00\u4e86\uff0c\u8bf4\u660esocket\u4e2a\u6570\u8fd8\u6ca1\u6709\u8fbe\u5230\u9608\u503c \u4f46\u662f\u8fd9\u91cc\u5e94\u8be5\u5148\u5224\u65ad\u662f\u5426\u8fd8\u6709\u7a7a\u95f2\u7684socket\uff0c\u6709\u5219\u53ef\u4ee5\u590d\u7528\uff0c \u6ca1\u6709\u5219\u521b\u5efa\u65b0\u7684socket */ if ( this . requests [ name ] && this . requests [ name ]. length ) { const req = this . requests [ name ][ 0 ]; const socketCreationHandler = handleSocketCreation ( this , req , false ); this . createSocket ( req , options , socketCreationHandler ); } }; \u524d\u9762\u5df2\u7ecf\u5206\u6790\u8fc7\uff0cAgent\u7ef4\u62a4\u4e86\u4e24\u4e2asocket\u961f\u5217\uff0c\u5220\u9664socket\u5c31\u662f\u4ece\u8fd9\u4e24\u4e2a\u961f\u5217\u4e2d\u627e\u5230\u5bf9\u5e94\u7684socket\uff0c\u7136\u540e\u79fb\u9664\u5b83\u3002\u79fb\u9664\u540e\u9700\u8981\u5224\u65ad\u4e00\u4e0b\u662f\u5426\u8fd8\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u961f\u5217\uff0c\u6709\u7684\u8bdd\u5c31\u65b0\u5efa\u4e00\u4e2asocket\u53bb\u5904\u7406\u5b83\u3002\u56e0\u4e3a\u79fb\u9664\u4e86\u4e00\u4e2asocket\uff0c\u5c31\u8bf4\u660e\u53ef\u4ee5\u65b0\u589e\u4e00\u4e2asocket\u3002 18.4.4 \u8bbe\u7f6esocket keepalive \u00b6 \u5f53socket\u88ab\u4f7f\u7528\u5b8c\u5e76\u4e14\u88ab\u63d2\u5165\u7a7a\u95f2\u961f\u5217\u540e\uff0c\u9700\u8981\u91cd\u65b0\u8bbe\u7f6esocket\u7684keepalive\u503c\u3002\u7b49\u5230\u8d85\u65f6\u4f1a\u81ea\u52a8\u5173\u95edsocket\u3002\u5728\u4e00\u4e2asocket\u4e0a\u8c03\u7528\u4e00\u6b21setKeepAlive\u5c31\u53ef\u4ee5\u4e86\uff0c\u8fd9\u91cc\u53ef\u80fd\u4f1a\u5bfc\u81f4\u591a\u6b21\u8c03\u7528setKeepAlive\uff0c\u4e0d\u8fc7\u4e5f\u6ca1\u6709\u5f71\u54cd\u3002 1 2 3 4 5 function keepSocketAlive ( socket ) { socket . setKeepAlive ( true , this . keepAliveMsecs ); socket . unref (); return true ; }; \u53e6\u5916\u9700\u8981\u8bbe\u7f6eref\u6807\u8bb0\uff0c\u9632\u6b62\u8be5socket\u963b\u6b62\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\uff0c\u56e0\u4e3a\u8be5socket\u662f\u7a7a\u95f2\u7684\uff0c\u4e0d\u5e94\u8be5\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002 18.4.5 \u590d\u7528socket \u00b6 1 2 3 4 function reuseSocket ( socket , req ) { req . reusedSocket = true ; socket . ref (); }; \u91cd\u65b0\u4f7f\u7528\u8be5socket\uff0c\u9700\u8981\u4fee\u6539ref\u6807\u8bb0\uff0c\u963b\u6b62\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\uff0c\u5e76\u6807\u8bb0\u8bf7\u6c42\u4f7f\u7528\u7684\u662f\u590d\u7528socket\u3002 18.4.6 \u9500\u6bc1Agent \u00b6 1 2 3 4 5 6 7 8 9 function destroy () { for ( const set of [ this . freeSockets , this . sockets ]) { for ( const key of ObjectKeys ( set )) { for ( const setName of set [ key ]) { setName . destroy (); } } } }; \u56e0\u4e3aAgent\u672c\u8d28\u4e0a\u662f\u4e00\u4e2asocket\u6c60\uff0c\u9500\u6bc1Agent\u5373\u9500\u6bc1\u6c60\u91cc\u7ef4\u62a4\u7684\u6240\u6709socket\u3002 18.4.7 \u4f7f\u7528\u8fde\u63a5\u6c60 \u00b6 \u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u4f7f\u7528Agent\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 function addRequest ( req , options , port , localAddress ) { // \u53c2\u6570\u5904\u7406 if ( typeof options === 'string' ) { options = { host : options , port , localAddress }; } options = { ... options , ... this . options }; if ( options . socketPath ) options . path = options . socketPath ; if ( ! options . servername && options . servername !== '' ) options . servername = calculateServerName ( options , req ); // \u62ff\u5230\u8bf7\u6c42\u5bf9\u5e94\u7684key const name = this . getName ( options ); // \u8be5key\u8fd8\u6ca1\u6709\u5728\u4f7f\u7528\u7684socekt\u5219\u521d\u59cb\u5316\u6570\u636e\u7ed3\u6784 if ( ! this . sockets [ name ]) { this . sockets [ name ] = []; } // \u8be5key\u5bf9\u5e94\u7684\u7a7a\u95f2socket\u5217\u8868 const freeLen = this . freeSockets [ name ] ? this . freeSockets [ name ]. length : 0 ; // \u8be5key\u5bf9\u5e94\u7684\u6240\u6709socket\u4e2a\u6570 const sockLen = freeLen + this . sockets [ name ]. length ; // \u8be5key\u6709\u5bf9\u5e94\u7684\u7a7a\u95f2socekt if ( freeLen ) { // \u83b7\u53d6\u4e00\u4e2a\u8be5key\u5bf9\u5e94\u7684\u7a7a\u95f2socket const socket = this . freeSockets [ name ]. shift (); // \u53d6\u5b8c\u4e86\u5220\u9664\uff0c\u9632\u6b62\u5185\u5b58\u6cc4\u6f0f if ( ! this . freeSockets [ name ]. length ) delete this . freeSockets [ name ]; // \u8bbe\u7f6eref\u6807\u8bb0\uff0c\u56e0\u4e3a\u6b63\u5728\u4f7f\u7528\u8be5socket this . reuseSocket ( socket , req ); // \u8bbe\u7f6e\u8bf7\u6c42\u5bf9\u5e94\u7684socket setRequestSocket ( this , req , socket ); // \u63d2\u5165\u6b63\u5728\u4f7f\u7528\u7684socket\u961f\u5217 this . sockets [ name ]. push ( socket ); } else if ( sockLen < this . maxSockets ) { /* \u5982\u679c\u8be5key\u6ca1\u6709\u5bf9\u5e94\u7684\u7a7a\u95f2socket\u5e76\u4e14\u4f7f\u7528\u7684 socket\u4e2a\u6570\u8fd8\u6ca1\u6709\u5f97\u5230\u9608\u503c\uff0c\u5219\u7ee7\u7eed\u521b\u5efa */ this . createSocket ( req , options , handleSocketCreation ( this , req , true )); } else { // \u7b49\u5f85\u8be5key\u4e0b\u6709\u7a7a\u95f2\u7684socket if ( ! this . requests [ name ]) { this . requests [ name ] = []; } this . requests [ name ]. push ( req ); } } \u5f53\u6211\u4eec\u9700\u8981\u53d1\u9001\u4e00\u4e2aHTTP\u8bf7\u6c42\u7684\u65f6\u5019\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7Agent\u7684addRequest\u65b9\u6cd5\u628a\u8bf7\u6c42\u6258\u7ba1\u5230Agent\u4e2d\uff0c\u5f53\u6709\u53ef\u7528\u7684socket\u65f6\uff0cAgent\u4f1a\u901a\u77e5\u6211\u4eec\u3002addRequest\u7684\u4ee3\u7801\u5f88\u957f\uff0c\u4e3b\u8981\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5\u3002 1 \u6709\u7a7a\u95f2socket\uff0c\u5219\u76f4\u63a5\u590d\u7528\uff0c\u5e76\u63d2\u5165\u6b63\u5728\u4f7f\u7528\u7684socket\u961f\u5217\u4e2d \u6211\u4eec\u4e3b\u8981\u770b\u4e00\u4e0bsetRequestSocket\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function setRequestSocket ( agent , req , socket ) { // \u901a\u77e5\u8bf7\u6c42socket\u521b\u5efa\u6210\u529f req . onSocket ( socket ); const agentTimeout = agent . options . timeout || 0 ; if ( req . timeout === undefined || req . timeout === agentTimeout ) { return ; } // \u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u8fc7\u671f\u540e\u89e6\u53d1timeout\u4e8b\u4ef6 socket . setTimeout ( req . timeout ); /* \u76d1\u542c\u54cd\u5e94\u4e8b\u4ef6\uff0c\u54cd\u5e94\u7ed3\u675f\u540e\u9700\u8981\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff0c \u5f00\u542f\u4e0b\u4e00\u4e2a\u8bf7\u6c42\u7684\u8d85\u65f6\u8ba1\u7b97\uff0c\u5426\u5219\u4f1a\u63d0\u524d\u8fc7\u671f */ req . once ( 'response' , ( res ) => { res . once ( 'end' , () => { if ( socket . timeout !== agentTimeout ) { socket . setTimeout ( agentTimeout ); } }); }); } setRequestSocket\u51fd\u6570\u901a\u8fc7req.onSocket(socket)\u901a\u77e5\u8c03\u7528\u65b9\u6709\u53ef\u7528socket\u3002\u7136\u540e\u5982\u679c\u8bf7\u6c42\u8bbe\u7f6e\u4e86\u8d85\u65f6\u65f6\u95f4\u5219\u8bbe\u7f6esocket\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u5373\u8bf7\u6c42\u7684\u8d85\u65f6\u65f6\u95f4\u3002\u6700\u540e\u76d1\u542c\u54cd\u5e94\u7ed3\u675f\u4e8b\u4ef6\uff0c\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\u3002 2 \u6ca1\u6709\u7a7a\u95f2socket\uff0c\u4f46\u662f\u4f7f\u7528\u7684socket\u4e2a\u6570\u8fd8\u6ca1\u6709\u8fbe\u5230\u9608\u503c\uff0c\u5219\u521b\u5efa\u65b0\u7684socket\u3002 \u6211\u4eec\u4e3b\u8981\u5206\u6790\u521b\u5efasocket\u540e\u7684\u56de\u8c03handleSocketCreation\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function handleSocketCreation ( agent , request , informRequest ) { return function handleSocketCreation_Inner ( err , socket ) { if ( err ) { process . nextTick ( emitErrorNT , request , err ); return ; } /* \u662f\u5426\u9700\u8981\u76f4\u63a5\u901a\u77e5\u8bf7\u6c42\u65b9\uff0c\u8fd9\u65f6\u5019request\u4e0d\u662f\u6765\u81ea\u7b49\u5f85 socket\u7684requests\u961f\u5217\uff0c \u800c\u662f\u6765\u81ea\u8c03\u7528\u65b9\uff0c\u89c1addRequest */ if ( informRequest ) setRequestSocket ( agent , request , socket ); else /* \u4e0d\u76f4\u63a5\u901a\u77e5\uff0c\u5148\u544a\u8bc9agent\u6709\u7a7a\u95f2\u7684socket\uff0c agent\u4f1a\u5224\u65ad\u662f\u5426\u6709\u6b63\u5728\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u6709\u5219\u5904\u7406 */ socket . emit ( 'free' ); }; } 3 \u4e0d\u6ee1\u8db31,2\uff0c\u5219\u628a\u8bf7\u6c42\u63d2\u5165\u7b49\u5f85socket\u961f\u5217\u3002 \u63d2\u5165\u7b49\u5f85socket\u961f\u5217\u540e\uff0c\u5f53\u6709socket\u7a7a\u95f2\u65f6\u4f1a\u89e6\u53d1free\u4e8b\u4ef6\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8be5\u4e8b\u4ef6\u7684\u5904\u7406\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // \u76d1\u542csocket\u7a7a\u95f2\u4e8b\u4ef6 this . on ( 'free' , ( socket , options ) => { const name = this . getName ( options ); // socket\u8fd8\u53ef\u5199\u5e76\u4e14\u8fd8\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u5219\u590d\u7528socket if ( socket . writable && this . requests [ name ] && this . requests [ name ]. length ) { // \u62ff\u5230\u4e00\u4e2a\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u7136\u540e\u901a\u77e5\u5b83\u6709socket\u53ef\u7528 const req = this . requests [ name ]. shift (); setRequestSocket ( this , req , socket ); // \u6ca1\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u5219\u5220\u9664\uff0c\u9632\u6b62\u5185\u5b58\u6cc4\u6f0f if ( this . requests [ name ]. length === 0 ) { // don't leak delete this . requests [ name ]; } } else { // socket\u4e0d\u53ef\u7528\u5199\u6216\u8005\u6ca1\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u4e86 const req = socket . _httpMessage ; // socket\u53ef\u5199\u5e76\u4e14\u8bf7\u6c42\u8bbe\u7f6e\u4e86\u5141\u8bb8\u4f7f\u7528\u590d\u7528\u7684socket if ( req && req . shouldKeepAlive && socket . writable && this . keepAlive ) { let freeSockets = this . freeSockets [ name ]; // \u8be5key\u4e0b\u5f53\u524d\u7684\u7a7a\u95f2socket\u4e2a\u6570 const freeLen = freeSockets ? freeSockets . length : 0 ; let count = freeLen ; // \u6b63\u5728\u4f7f\u7528\u7684socket\u4e2a\u6570 if ( this . sockets [ name ]) count += this . sockets [ name ]. length ; /* \u8be5key\u4f7f\u7528\u7684socket\u4e2a\u6570\u8fbe\u5230\u9608\u503c\u6216\u8005\u7a7a\u95f2socket\u8fbe\u5230\u9608\u503c\uff0c \u5219\u4e0d\u590d\u7528socket\uff0c\u76f4\u63a5\u9500\u6bc1socket */ if ( count > this . maxSockets || freeLen >= this . maxFreeSockets ) { socket . destroy (); } else if ( this . keepSocketAlive ( socket )) { /* \u91cd\u65b0\u8bbe\u7f6esocket\u7684\u5b58\u6d3b\u65f6\u95f4\uff0c\u8bbe\u7f6e\u5931\u8d25\u8bf4\u660e\u65e0\u6cd5\u91cd\u65b0\u8bbe\u7f6e\u5b58\u6d3b\u65f6 \u95f4\uff0c\u5219\u8bf4\u660e\u53ef\u80fd\u4e0d\u652f\u6301\u590d\u7528 */ freeSockets = freeSockets || []; this . freeSockets [ name ] = freeSockets ; socket [ async_id_symbol ] = - 1 ; socket . _httpMessage = null ; // \u628asocket\u4ece\u6b63\u5728\u4f7f\u7528\u961f\u5217\u4e2d\u79fb\u9664 this . removeSocket ( socket , options ); // \u63d2\u5165socket\u7a7a\u95f2\u961f\u5217 freeSockets . push ( socket ); } else { // \u4e0d\u590d\u7528\u5219\u76f4\u63a5\u9500\u6bc1 socket . destroy (); } } else { socket . destroy (); } } }); \u5f53\u6709socket\u7a7a\u95f2\u65f6\uff0c\u5206\u4e3a\u4ee5\u4e0b\u51e0\u79cd\u60c5\u51b5 1 \u5982\u679c\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u5219\u76f4\u63a5\u590d\u7528socket\u3002 2 \u5982\u679c\u6ca1\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u5141\u8bb8\u590d\u7528\u5e76\u4e14socket\u4e2a\u6570\u6ca1\u6709\u8fbe\u5230\u9608\u503c\u5219\u63d2\u5165\u7a7a\u95f2\u961f\u5217\u3002 3 \u76f4\u63a5\u9500\u6bc1 18.4.8 \u6d4b\u8bd5\u4f8b\u5b50 \u00b6 \u5ba2\u6237\u7aef 1 2 3 4 5 6 7 const http = require ( 'http' ); const keepAliveAgent = new http . Agent ({ keepAlive : true , maxSockets : 1 }); const options = { port : 10000 , method : 'GET' , host : '127.0.0.1' ,} options . agent = keepAliveAgent ; http . get ( options , () => {}); http . get ( options , () => {}); console . log ( options . agent . requests ) \u670d\u52a1\u5668 1 2 3 4 5 let i = 0 ; const net = require ( 'net' ); net . createServer (( socket ) => { console . log ( ++ i ); }). listen ( 10000 ); \u5728\u4f8b\u5b50\u4e2d\uff0c\u9996\u5148\u521b\u5efa\u4e86\u4e00\u4e2atcp\u670d\u52a1\u5668\u3002\u7136\u540e\u5728\u5ba2\u6237\u7aef\u4f7f\u7528agent\u3002\u4f46\u662fmaxSocket\u7684\u503c\u4e3a1\uff0c\u4ee3\u8868\u6700\u591a\u53ea\u80fd\u6709\u4e00\u4e2asocket\uff0c\u800c\u8fd9\u65f6\u5019\u5ba2\u6237\u7aef\u53d1\u9001\u4e24\u4e2a\u8bf7\u6c42\uff0c\u6240\u4ee5\u6709\u4e00\u4e2a\u8bf7\u6c42\u5c31\u4f1a\u5728\u6392\u961f\u3002\u670d\u52a1\u5668\u4e5f\u53ea\u6536\u5230\u4e86\u4e00\u4e2a\u8fde\u63a5\u3002","title":"18-HTTP"},{"location":"chapter18-HTTP/#181-http","text":"HTTP\u89e3\u6790\u5668\u662fHTTP\u6a21\u5757\u7684\u6838\u5fc3\uff0c\u4e0d\u7ba1\u662f\u4f5c\u4e3a\u670d\u52a1\u5668\u5904\u7406\u8bf7\u6c42\u8fd8\u662f\u5ba2\u6237\u7aef\u5904\u7406\u54cd\u5e94\u90fd\u9700\u8981\u4f7f\u7528HTTP\u89e3\u6790\u5668\u89e3\u6790HTTP\u534f\u8bae\u3002\u65b0\u7248Node.js\u4f7f\u7528\u4e86\u65b0\u7684HTTP\u89e3\u6790\u5668llhttp\u3002\u6839\u636e\u5b98\u65b9\u8bf4\u660ellhttp\u6bd4\u65e7\u7248\u7684http_parser\u5728\u6027\u80fd\u4e0a\u6709\u4e86\u975e\u5e38\u5927\u7684\u63d0\u9ad8\u3002\u672c\u8282\u6211\u4eec\u5206\u6790\u5206\u6790llhttp\u7684\u57fa\u7840\u539f\u7406\u548c\u4f7f\u7528\u3002HTTP\u89e3\u6790\u5668\u662f\u4e00\u4e2a\u975e\u5e38\u590d\u6742\u7684\u72b6\u6001\u673a\uff0c\u5728\u89e3\u6790\u6570\u636e\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4f1a\u4e0d\u65ad\u89e6\u53d1\u94a9\u5b50\u51fd\u6570\u3002\u4e0b\u9762\u662fllhttp\u652f\u6301\u7684\u94a9\u5b50\u51fd\u6570\u3002\u5982\u679c\u7528\u6237\u5b9a\u4e49\u4e86\u5bf9\u5e94\u7684\u94a9\u5b50\uff0c\u5728\u89e3\u6790\u7684\u8fc7\u7a0b\u4e2d\u5c31\u4f1a\u88ab\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 // \u5f00\u59cb\u89e3\u6790HTTP\u534f\u8bae int llhttp__on_message_begin ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_message_begin , s ); return err ; } // \u89e3\u6790\u51fa\u8bf7\u6c42url\u65f6\u7684\u56de\u8c03\uff0c\u6700\u540e\u62ff\u5230\u4e00\u4e2aurl int llhttp__on_url ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_url , s , p , endp - p ); return err ; } // \u89e3\u6790\u51faHTTP\u54cd\u5e94\u72b6\u6001\u7684\u56de\u8c03 int llhttp__on_status ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_status , s , p , endp - p ); return err ; } // \u89e3\u6790\u51fa\u5934\u90e8\u952e\u65f6\u7684\u56de\u8c03 int llhttp__on_header_field ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_header_field , s , p , endp - p ); return err ; } // \u89e3\u6790\u51fa\u5934\u90e8\u503c\u65f6\u7684\u56de\u8c03 int llhttp__on_header_value ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_header_value , s , p , endp - p ); return err ; } // \u89e3\u6790HTTP\u5934\u5b8c\u6210\u65f6\u7684\u56de\u8c03 int llhttp__on_headers_complete ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_headers_complete , s ); return err ; } // \u89e3\u6790\u5b8cbody\u7684\u56de\u8c03 int llhttp__on_message_complete ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_message_complete , s ); return err ; } // \u89e3\u6790body\u65f6\u7684\u56de\u8c03 int llhttp__on_body ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_body , s , p , endp - p ); return err ; } // \u89e3\u6790\u5230\u4e00\u4e2achunk\u7ed3\u6784\u5934\u65f6\u7684\u56de\u8c03 int llhttp__on_chunk_header ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_chunk_header , s ); return err ; } // \u89e3\u6790\u5b8c\u4e00\u4e2achunk\u65f6\u7684\u56de\u8c03 int llhttp__on_chunk_complete ( llhttp_t * s , const char * p , const char * endp ) { int err ; CALLBACK_MAYBE ( s , on_chunk_complete , s ); return err ; } Node.js\u5728node_http_parser.cc\u4e2d\u5bf9llhttp\u8fdb\u884c\u4e86\u5c01\u88c5\u3002\u8be5\u6a21\u5757\u5bfc\u51fa\u4e86\u4e00\u4e2aHTTPParser\u3002 1 2 3 4 5 6 7 Local < FunctionTemplate > t = env -> NewFunctionTemplate ( Parser :: New ); t -> InstanceTemplate () -> SetInternalFieldCount ( 1 ); t -> SetClassName ( FIXED_ONE_BYTE_STRING ( env -> isolate (), \"HTTPParser\" )); target -> Set ( env -> context (), FIXED_ONE_BYTE_STRING ( env -> isolate (), \"HTTPParser\" ), t -> GetFunction ( env -> context ()). ToLocalChecked ()). Check (); \u5728Node.js\u4e2d\u6211\u4eec\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u4f7f\u7528HTTPParser\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const parser = new HTTPParser (); cleanParser ( parser ); parser . onIncoming = null ; parser [ kOnHeaders ] = parserOnHeaders ; parser [ kOnHeadersComplete ] = parserOnHeadersComplete ; parser [ kOnBody ] = parserOnBody ; parser [ kOnMessageComplete ] = parserOnMessageComplete ; // \u521d\u59cb\u5316HTTP\u89e3\u6790\u5668\u5904\u7406\u7684\u62a5\u6587\u7c7b\u578b\uff0c\u8fd9\u91cc\u662f\u54cd\u5e94\u62a5\u6587 parser . initialize ( HTTPParser . RESPONSE , new HTTPClientAsyncResource ( 'HTTPINCOMINGMESSAGE' , req ), req . maxHeaderSize || 0 , req . insecureHTTPParser === undefined ? isLenient () : req . insecureHTTPParser ); // \u6536\u5230\u6570\u636e\u540e\u4f20\u7ed9\u89e3\u6790\u5668\u5904\u7406 const ret = parser . execute ( data ); } \u6211\u4eec\u770b\u4e00\u4e0binitialize\u548cexecute\u7684\u4ee3\u7801\u3002Initialize\u51fd\u6570\u7528\u4e8e\u521d\u59cb\u5316llhttp\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 static void Initialize ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); bool lenient = args [ 3 ] -> IsTrue (); uint64_t max_http_header_size = 0 ; // \u5934\u90e8\u7684\u6700\u5927\u5927\u5c0f if ( args . Length () > 2 ) { max_http_header_size = args [ 2 ]. As < Number > () -> Value (); } // \u6ca1\u6709\u8bbe\u7f6e\u5219\u53d6Node.js\u7684\u9ed8\u8ba4\u503c if ( max_http_header_size == 0 ) { max_http_header_size = env -> options () -> max_http_header_size ; } // \u89e3\u6790\u7684\u62a5\u6587\u7c7b\u578b llhttp_type_t type = static_cast < llhttp_type_t > ( args [ 0 ]. As < Int32 > () -> Value ()); CHECK ( type == HTTP_REQUEST || type == HTTP_RESPONSE ); Parser * parser ; ASSIGN_OR_RETURN_UNWRAP ( & parser , args . Holder ()); parser -> Init ( type , max_http_header_size , lenient ); } Initialize\u505a\u4e86\u4e00\u4e9b\u9884\u5904\u7406\u540e\u8c03\u7528Init\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 void Init ( llhttp_type_t type , uint64_t max_http_header_size , bool lenient ) { // \u521d\u59cb\u5316llhttp llhttp_init ( & parser_ , type , & settings ); llhttp_set_lenient ( & parser_ , lenient ); header_nread_ = 0 ; url_ . Reset (); status_message_ . Reset (); num_fields_ = 0 ; num_values_ = 0 ; have_flushed_ = false ; got_exception_ = false ; max_http_header_size_ = max_http_header_size ; } Init\u505a\u4e86\u4e00\u4e9b\u5b57\u6bb5\u7684\u521d\u59cb\u5316\uff0c\u6700\u91cd\u8981\u7684\u662f\u8c03\u7528\u4e86llhttp_init\u5bf9llhttp\u8fdb\u884c\u4e86\u521d\u59cb\u5316\uff0c\u53e6\u5916kOn\u5f00\u5934\u7684\u5c5e\u6027\u662f\u94a9\u5b50\u51fd\u6570\uff0c\u7531node_http_parser.cc\u4e2d\u7684\u56de\u8c03\uff0c\u800cnode_http_parser.cc\u4e5f\u4f1a\u5b9a\u4e49\u94a9\u5b50\u51fd\u6570\uff0c\u7531llhttp\u56de\u8c03\uff0c\u6211\u4eec\u770b\u4e00\u4e0bnode_http_parser.cc\u94a9\u5b50\u51fd\u6570\u7684\u5b9a\u4e49\u548c\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 const llhttp_settings_t Parser :: settings = { Proxy < Call , & Parser :: on_message_begin >:: Raw , Proxy < DataCall , & Parser :: on_url >:: Raw , Proxy < DataCall , & Parser :: on_status >:: Raw , Proxy < DataCall , & Parser :: on_header_field >:: Raw , Proxy < DataCall , & Parser :: on_header_value >:: Raw , Proxy < Call , & Parser :: on_headers_complete >:: Raw , Proxy < DataCall , & Parser :: on_body >:: Raw , Proxy < Call , & Parser :: on_message_complete >:: Raw , Proxy < Call , & Parser :: on_chunk_header >:: Raw , Proxy < Call , & Parser :: on_chunk_complete >:: Raw , }; 1 \u5f00\u59cb\u89e3\u6790\u62a5\u6587\u7684\u56de\u8c03 1 2 3 4 5 6 7 // \u5f00\u59cb\u89e3\u6790\u62a5\u6587\uff0c\u4e00\u4e2aTCP\u8fde\u63a5\u53ef\u80fd\u4f1a\u6709\u591a\u4e2a\u62a5\u6587 int on_message_begin () { num_fields_ = num_values_ = 0 ; url_ . Reset (); status_message_ . Reset (); return 0 ; } 2 \u89e3\u6790url\u65f6\u7684\u56de\u8c03 1 2 3 4 5 6 7 8 9 int on_url ( const char * at , size_t length ) { int rv = TrackHeader ( length ); if ( rv != 0 ) { return rv ; } url_ . Update ( at , length ); return 0 ; } 3\u89e3\u6790HTTP\u54cd\u5e94\u65f6\u7684\u56de\u8c03 1 2 3 4 5 6 7 8 9 int on_status ( const char * at , size_t length ) { int rv = TrackHeader ( length ); if ( rv != 0 ) { return rv ; } status_message_ . Update ( at , length ); return 0 ; } 4\u89e3\u6790\u5230HTTP\u5934\u7684\u952e\u65f6\u56de\u8c03 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int on_header_field ( const char * at , size_t length ) { int rv = TrackHeader ( length ); if ( rv != 0 ) { return rv ; } // \u76f8\u7b49\u8bf4\u660e\u952e\u5bf9\u503c\u7684\u89e3\u6790\u662f\u4e00\u4e00\u5bf9\u5e94\u7684 if ( num_fields_ == num_values_ ) { // start of new field name // \u952e\u7684\u6570\u52a0\u4e00 num_fields_ ++ ; // \u8d85\u8fc7\u9608\u503c\u5219\u5148\u56de\u8c03js\u6d88\u8d39\u6389 if ( num_fields_ == kMaxHeaderFieldsCount ) { // ran out of space - flush to javascript land Flush (); // \u91cd\u65b0\u5f00\u59cb num_fields_ = 1 ; num_values_ = 0 ; } // \u521d\u59cb\u5316 fields_ [ num_fields_ - 1 ]. Reset (); } // \u4fdd\u5b58\u952e fields_ [ num_fields_ - 1 ]. Update ( at , length ); return 0 ; } \u5f53\u89e3\u6790\u7684\u5934\u90e8\u4e2a\u6570\u8fbe\u5230\u9608\u503c\u65f6\uff0cNode.js\u4f1a\u5148\u901a\u8fc7Flush\u51fd\u6570\u56de\u8c03JS\u5c42\u4fdd\u5b58\u5f53\u524d\u7684\u4e00\u4e9b\u6570\u636e\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 void Flush () { HandleScope scope ( env () -> isolate ()); Local < Object > obj = object (); // JS\u5c42\u7684\u94a9\u5b50 Local < Value > cb = obj -> Get ( env () -> context (), kOnHeaders ). ToLocalChecked (); if ( ! cb -> IsFunction ()) return ; Local < Value > argv [ 2 ] = { CreateHeaders (), url_ . ToString ( env ()) }; MaybeLocal < Value > r = MakeCallback ( cb . As < Function > (), arraysize ( argv ), argv ); url_ . Reset (); have_flushed_ = true ; } Local < Array > CreateHeaders () { // HTTP\u5934\u7684\u4e2a\u6570\u4e58\u4ee52\uff0c\u56e0\u4e3a\u4e00\u4e2a\u5934\u7531\u952e\u548c\u503c\u7ec4\u6210 Local < Value > headers_v [ kMaxHeaderFieldsCount * 2 ]; // \u4fdd\u5b58\u952e\u548c\u503c\u5230HTTP\u5934 for ( size_t i = 0 ; i < num_values_ ; ++ i ) { headers_v [ i * 2 ] = fields_ [ i ]. ToString ( env ()); headers_v [ i * 2 + 1 ] = values_ [ i ]. ToString ( env ()); } return Array :: New ( env () -> isolate (), headers_v , num_values_ * 2 ); } Flush\u4f1a\u8c03\u7528JS\u5c42\u7684kOnHeaders\u94a9\u5b50\u51fd\u6570\u3002 5\u89e3\u6790\u5230HTTP\u5934\u7684\u503c\u65f6\u56de\u8c03 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int on_header_value ( const char * at , size_t length ) { int rv = TrackHeader ( length ); if ( rv != 0 ) { return rv ; } /* \u503c\u7684\u4e2a\u6570\u4e0d\u7b49\u4e8e\u952e\u7684\u4e2a\u6570\u8bf4\u660e\u6b63\u89e3\u6790\u5230\u952e\u5bf9\u5e94\u7684\u503c\uff0c\u5373\u4e00\u4e00\u5bf9\u5e94\u3002 \u5426\u5219\u8bf4\u660e\u4e00\u4e2a\u952e\u5b58\u5728\u591a\u4e2a\u503c\uff0c\u5219\u4e0d\u66f4\u65b0\u503c\u7684\u4e2a\u6570\uff0c\u591a\u4e2a\u503c\u7d2f\u52a0\u5230\u4e00\u4e2aslot */ if ( num_values_ != num_fields_ ) { // start of new header value num_values_ ++ ; values_ [ num_values_ - 1 ]. Reset (); } CHECK_LT ( num_values_ , arraysize ( values_ )); CHECK_EQ ( num_values_ , num_fields_ ); values_ [ num_values_ - 1 ]. Update ( at , length ); return 0 ; } 6\u89e3\u6790\u5b8cHTTP\u5934\u540e\u7684\u56de\u8c03 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 int on_headers_complete () { header_nread_ = 0 ; enum on_headers_complete_arg_index { A_VERSION_MAJOR = 0 , A_VERSION_MINOR , A_HEADERS , A_METHOD , A_URL , A_STATUS_CODE , A_STATUS_MESSAGE , A_UPGRADE , A_SHOULD_KEEP_ALIVE , A_MAX }; Local < Value > argv [ A_MAX ]; Local < Object > obj = object (); Local < Value > cb = obj -> Get ( env () -> context (), kOnHeadersComplete ). ToLocalChecked (); Local < Value > undefined = Undefined ( env () -> isolate ()); for ( size_t i = 0 ; i < arraysize ( argv ); i ++ ) argv [ i ] = undefined ; // \u4e4b\u524dflush\u8fc7\uff0c\u5219\u7ee7\u7eedflush\u5230JS\u5c42\uff0c\u5426\u5219\u8fd4\u56de\u5168\u90e8\u5934\u7ed9js if ( have_flushed_ ) { // Slow case, flush remaining headers. Flush (); } else { // Fast case, pass headers and URL to JS land. argv [ A_HEADERS ] = CreateHeaders (); if ( parser_ . type == HTTP_REQUEST ) argv [ A_URL ] = url_ . ToString ( env ()); } num_fields_ = 0 ; num_values_ = 0 ; // METHOD if ( parser_ . type == HTTP_REQUEST ) { argv [ A_METHOD ] = Uint32 :: NewFromUnsigned ( env () -> isolate (), parser_ . method ); } // STATUS if ( parser_ . type == HTTP_RESPONSE ) { argv [ A_STATUS_CODE ] = Integer :: New ( env () -> isolate (), parser_ . status_code ); argv [ A_STATUS_MESSAGE ] = status_message_ . ToString ( env ()); } // VERSION argv [ A_VERSION_MAJOR ] = Integer :: New ( env () -> isolate (), parser_ . http_major ); argv [ A_VERSION_MINOR ] = Integer :: New ( env () -> isolate (), parser_ . http_minor ); bool should_keep_alive ; // \u662f\u5426\u5b9a\u4e49\u4e86keepalive\u5934 should_keep_alive = llhttp_should_keep_alive ( & parser_ ); argv [ A_SHOULD_KEEP_ALIVE ] = Boolean :: New ( env () -> isolate (), should_keep_alive ); // \u662f\u5426\u662f\u5347\u7ea7\u534f\u8bae argv [ A_UPGRADE ] = Boolean :: New ( env () -> isolate (), parser_ . upgrade ); MaybeLocal < Value > head_response ; { InternalCallbackScope callback_scope ( this , InternalCallbackScope :: kSkipTaskQueues ); head_response = cb . As < Function > () -> Call ( env () -> context (), object (), arraysize ( argv ), argv ); } int64_t val ; if ( head_response . IsEmpty () || ! head_response . ToLocalChecked () -> IntegerValue ( env () -> context ()) . To ( & val )) { got_exception_ = true ; return -1 ; } return val ; } on_headers_complete\u4f1a\u6267\u884cJS\u5c42\u7684kOnHeadersComplete\u94a9\u5b50\u3002 7 \u89e3\u6790body\u65f6\u7684\u56de\u8c03 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 int on_body ( const char * at , size_t length ) { EscapableHandleScope scope ( env () -> isolate ()); Local < Object > obj = object (); Local < Value > cb = obj -> Get ( env () -> context (), kOnBody ). ToLocalChecked (); // We came from consumed stream if ( current_buffer_ . IsEmpty ()) { // Make sure Buffer will be in parent HandleScope current_buffer_ = scope . Escape ( Buffer :: Copy ( env () -> isolate (), current_buffer_data_ , current_buffer_len_ ). ToLocalChecked ()); } Local < Value > argv [ 3 ] = { // \u5f53\u524d\u89e3\u6790\u4e2d\u7684\u6570\u636e current_buffer_ , // body\u5f00\u59cb\u7684\u4f4d\u7f6e Integer :: NewFromUnsigned ( env () -> isolate (), at - current_buffer_data_ ), // body\u5f53\u524d\u957f\u5ea6 Integer :: NewFromUnsigned ( env () -> isolate (), length ) }; MaybeLocal < Value > r = MakeCallback ( cb . As < Function > (), arraysize ( argv ), argv ); return 0 ; } Node.js\u4e2d\u5e76\u4e0d\u662f\u6bcf\u6b21\u89e3\u6790HTTP\u62a5\u6587\u7684\u65f6\u5019\u5c31\u65b0\u5efa\u4e00\u4e2aHTTP\u89e3\u6790\u5668\uff0cNode.js\u4f7f\u7528FreeList\u6570\u636e\u7ed3\u6784\u5bf9HTTP\u89e3\u6790\u5668\u5b9e\u4f8b\u8fdb\u884c\u4e86\u7ba1\u7406\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class FreeList { constructor ( name , max , ctor ) { this . name = name ; // \u6784\u9020\u51fd\u6570 this . ctor = ctor ; // \u8282\u70b9\u7684\u6700\u5927\u503c this . max = max ; // \u5b9e\u4f8b\u5217\u8868 this . list = []; } // \u5206\u914d\u4e00\u4e2a\u5b9e\u4f8b alloc () { // \u6709\u7a7a\u95f2\u7684\u5219\u76f4\u63a5\u8fd4\u56de\uff0c\u5426\u5219\u65b0\u5efa\u4e00\u4e2a return this . list . length > 0 ? this . list . pop () : ReflectApply ( this . ctor , this , arguments ); } // \u91ca\u653e\u5b9e\u4f8b free ( obj ) { // \u5c0f\u4e8e\u9608\u503c\u5219\u653e\u5230\u7a7a\u95f2\u5217\u8868\uff0c\u5426\u5219\u91ca\u653e\uff08\u8c03\u7528\u65b9\u8d1f\u8d23\u91ca\u653e\uff09 if ( this . list . length < this . max ) { this . list . push ( obj ); return true ; } return false ; } } \u6211\u4eec\u770b\u4e00\u4e0b\u5728Node.js\u4e2d\u5bf9FreeList\u7684\u4f7f\u7528\u3002\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 const parsers = new FreeList ( 'parsers' , 1000 , function parsersCb () { const parser = new HTTPParser (); // \u521d\u59cb\u5316\u5b57\u6bb5 cleanParser ( parser ); // \u8bbe\u7f6e\u94a9\u5b50 parser . onIncoming = null ; parser [ kOnHeaders ] = parserOnHeaders ; parser [ kOnHeadersComplete ] = parserOnHeadersComplete ; parser [ kOnBody ] = parserOnBody ; parser [ kOnMessageComplete ] = parserOnMessageComplete ; return parser ; }); HTTP\u89e3\u6790\u5668\u7684\u4f7f\u7528 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 var HTTPParser = process . binding ( 'http_parser' ). HTTPParser ; var parser = new HTTPParser ( HTTPParser . REQUEST ); const kOnHeaders = HTTPParser . kOnHeaders ; const kOnHeadersComplete = HTTPParser . kOnHeadersComplete ; const kOnBody = HTTPParser . kOnBody ; const kOnMessageComplete = HTTPParser . kOnMessageComplete ; const kOnExecute = HTTPParser . kOnExecute ; parser [ kOnHeaders ] = function ( headers , url ) { console . log ( 'kOnHeaders' , headers . length , url ); } parser [ kOnHeadersComplete ] = function ( versionMajor , versionMinor , headers , method , url , statusCode , statusMessage , upgrade , shouldKeepAlive ) { console . log ( 'kOnHeadersComplete' , headers ); } parser [ kOnBody ] = function ( b , start , len ) { console . log ( 'kOnBody' , b . slice ( start ). toString ( 'utf-8' )); } parser [ kOnMessageComplete ] = function () { console . log ( 'kOnMessageComplete' ); } parser [ kOnExecute ] = function () { console . log ( 'kOnExecute' ); } parser . execute ( Buffer . from ( 'GET / HTTP/1.1\\r\\n' + 'Host: http://localhost\\r\\n\\r\\n' )); \u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa 1 2 kOnHeadersComplete [ 'Host', 'http://localhost' ] kOnMessageComplete \u6211\u4eec\u770b\u5230\u53ea\u6267\u884c\u4e86kOnHeadersComplete\u548c kOnMessageComplete\u3002\u90a3\u5176\u5b83\u51e0\u4e2a\u56de\u8c03\u4ec0\u4e48\u65f6\u5019\u4f1a\u6267\u884c\u5462\uff1f\u6211\u4eec\u63a5\u7740\u770b\u3002\u6211\u4eec\u628a\u8f93\u5165\u6539\u4e00\u4e0b\u3002 1 2 3 4 5 6 parser . execute ( Buffer . from ( 'GET / HTTP/1.1\\r\\n' + 'Host: http://localhost\\r\\n' + 'content-length: 1\\r\\n\\r\\n' + '1' )); \u4e0a\u9762\u4ee3\u7801\u7684\u8f93\u51fa 1 2 3 kOnHeadersComplete [ 'Host', 'http://localhost', 'content-length', '1' ] kOnBody 1 kOnMessageComplete \u6211\u4eec\u770b\u5230\u591a\u4e86\u4e00\u4e2a\u56de\u8c03kOnBody\uff0c\u56e0\u4e3a\u6211\u4eec\u52a0\u4e86\u4e00\u4e2aHTTP\u5934content-length\u6307\u793a\u6709body\uff0c\u6240\u4ee5HTTP\u89e3\u6790\u5668\u89e3\u6790\u5230body\u7684\u65f6\u5019\u5c31\u4f1a\u56de\u8c03kOnBody\u3002\u90a3kOnHeaders\u4ec0\u4e48\u65f6\u5019\u4f1a\u6267\u884c\u5462\uff1f\u6211\u4eec\u7ee7\u7eed\u4fee\u6539\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 parser . execute ( Buffer . from ( 'GET / HTTP/1.1\\r\\n' + 'Host: http://localhost\\r\\n' + 'a: b\\r\\n' + // \u5f88\u591a'a: b\\r\\n'+ 'content-length: 1\\r\\n\\r\\n' + '1' )); \u4ee5\u4e0a\u4ee3\u7801\u7684\u8f93\u51fa 1 2 3 4 5 kOnHeaders 62 / kOnHeaders 22 kOnHeadersComplete undefined kOnBody 1 kOnMessageComplete \u6211\u4eec\u770b\u5230kOnHeaders\u88ab\u6267\u884c\u4e86\uff0c\u5e76\u4e14\u6267\u884c\u4e86\u4e24\u6b21\u3002\u56e0\u4e3a\u5982\u679cHTTP\u5934\u7684\u4e2a\u6570\u8fbe\u5230\u9608\u503c\uff0c\u5728\u89e3\u6790HTTP\u5934\u90e8\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5c31\u5148flush\u5230JS\u5c42\uff08\u5982\u679c\u591a\u6b21\u8fbe\u5230\u9608\u503c\uff0c\u5219\u56de\u8c03\u591a\u6b21\uff09\uff0c\u5e76\u4e14\u5728\u89e3\u6790\u5b8c\u6240\u6709HTTP\u5934\u540e\uff0c\u4f1a\u5728kOnHeadersComplet\u56de\u8c03\u4e4b\u524d\u518d\u6b21\u56de\u8c03kOnHeaders\uff08\u5982\u679c\u8fd8\u6709\u7684\u8bdd\uff09\u3002\u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0bkOnExecute\u5982\u4f55\u89e6\u53d1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 var HTTPParser = process . binding ( 'http_parser' ). HTTPParser ; var parser = new HTTPParser ( HTTPParser . REQUEST ); var net = require ( 'net' ); const kOnHeaders = HTTPParser . kOnHeaders ; const kOnHeadersComplete = HTTPParser . kOnHeadersComplete ; const kOnBody = HTTPParser . kOnBody ; const kOnMessageComplete = HTTPParser . kOnMessageComplete ; const kOnExecute = HTTPParser . kOnExecute ; parser [ kOnHeaders ] = function ( headers , url ) { console . log ( 'kOnHeaders' , headers . length , url ); } parser [ kOnHeadersComplete ] = function ( versionMajor , versionMinor , headers , method , url , statusCode , statusMessage , upgrade , shouldKeepAlive ) { console . log ( 'kOnHeadersComplete' , headers ); } parser [ kOnBody ] = function ( b , start , len ) { console . log ( 'kOnBody' , b . slice ( start ). toString ( 'utf-8' )); } parser [ kOnMessageComplete ] = function () { console . log ( 'kOnMessageComplete' ); } parser [ kOnExecute ] = function ( a , b ) { console . log ( 'kOnExecute,\u89e3\u6790\u7684\u5b57\u8282\u6570\uff1a' , a ); } // \u542f\u52a8\u4e00\u4e2a\u670d\u52a1\u5668 net . createServer (( socket ) => { parser . consume ( socket . _handle ); }). listen ( 80 ); // \u542f\u52a8\u4e00\u4e2a\u5ba2\u6237\u7aef setTimeout (() => { var socket = net . connect ({ port : 80 }); socket . end ( 'GET / HTTP/1.1\\r\\n' + 'Host: http://localhost\\r\\n' + 'content-length: 1\\r\\n\\r\\n' + '1' ); }, 1000 ); \u6211\u4eec\u9700\u8981\u8c03\u7528parser.consume\u65b9\u6cd5\u5e76\u4e14\u4f20\u5165\u4e00\u4e2aisStreamBase\u7684\u6d41\uff08stream_base.cc\u5b9a\u4e49\uff09\uff0c\u624d\u4f1a\u89e6\u53d1kOnExecute\u3002\u56e0\u4e3akOnExecute\u662f\u5728StreamBase\u6d41\u53ef\u8bfb\u65f6\u89e6\u53d1\u7684\u3002","title":"18.1 HTTP\u89e3\u6790\u5668"},{"location":"chapter18-HTTP/#182-http","text":"\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u4f7f\u7528Node.js\u4f5c\u4e3a\u5ba2\u6237\u7aef\u7684\u4f8b\u5b50\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const data = querystring . stringify ({ 'msg' : 'hi' }); const options = { hostname : 'your domain' , path : '/' , method : 'POST' , headers : { 'Content-Type' : 'application/x-www-form-urlencoded' , 'Content-Length' : Buffer . byteLength ( data ) } }; const req = http . request ( options , ( res ) => { res . setEncoding ( 'utf8' ); res . on ( 'data' , ( chunk ) => { console . log ( ` ${ chunk } ` ); }); res . on ( 'end' , () => { console . log ( 'end' ); }); }); req . on ( 'error' , ( e ) => { console . error ( ` ${ e . message } ` ); }); // \u53d1\u9001\u8bf7\u6c42\u7684\u6570\u636e req . write ( data ); // \u8bbe\u7f6e\u8bf7\u6c42\u7ed3\u675f req . end (); \u6211\u4eec\u770b\u4e00\u4e0bhttp.request\u7684\u5b9e\u73b0\u3002 1 2 3 function request ( url , options , cb ) { return new ClientRequest ( url , options , cb ); } HTTP\u5ba2\u6237\u7aef\u901a\u8fc7_http_client.js\u7684ClientRequest\u5b9e\u73b0\uff0cClientRequest\u7684\u4ee3\u7801\u975e\u5e38\u591a\uff0c\u6211\u4eec\u53ea\u5206\u6790\u6838\u5fc3\u7684\u6d41\u7a0b\u3002\u6211\u4eec\u770b\u521d\u59cb\u5316\u4e00\u4e2a\u8bf7\u6c42\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 function ClientRequest ( input , options , cb ) { // \u7ee7\u627fOutgoingMessage OutgoingMessage . call ( this ); // \u662f\u5426\u4f7f\u7528agent let agent = options . agent ; // \u5ffd\u7565agent\u7684\u5904\u7406\uff0c\u5177\u4f53\u53c2\u8003_http_agent.js\uff0c\u4e3b\u8981\u7528\u4e8e\u590d\u7528TCP\u8fde\u63a5 this . agent = agent ; // \u5efa\u7acb\u8fde\u63a5\u7684\u8d85\u65f6\u65f6\u95f4 if ( options . timeout !== undefined ) this . timeout = getTimerDuration ( options . timeout , 'timeout' ); // HTTP\u5934\u4e2a\u6570\u7684\u9608\u503c const maxHeaderSize = options . maxHeaderSize ; this . maxHeaderSize = maxHeaderSize ; // \u76d1\u542c\u54cd\u5e94\u4e8b\u4ef6 if ( cb ) { this . once ( 'response' , cb ); } // \u5ffd\u7565\u8bbe\u7f6ehttp\u534f\u8bae\u7684\u8bf7\u6c42\u884c\u6216\u8bf7\u6c42\u5934\u7684\u903b\u8f91 // \u5efa\u7acbTCP\u8fde\u63a5\u540e\u7684\u56de\u8c03 const oncreate = ( err , socket ) => { if ( called ) return ; called = true ; if ( err ) { process . nextTick (() => this . emit ( 'error' , err )); return ; } // \u5efa\u7acb\u8fde\u63a5\u6210\u529f\uff0c\u6267\u884c\u56de\u8c03 this . onSocket ( socket ); // \u8fde\u63a5\u6210\u529f\u540e\u53d1\u9001\u6570\u636e this . _deferToConnect ( null , null , () => this . _flush ()); }; // \u4f7f\u7528agent\u65f6\uff0csocket\u7531agent\u63d0\u4f9b\uff0c\u5426\u5219\u81ea\u5df1\u521b\u5efasocket if ( this . agent ) { this . agent . addRequest ( this , options ); } else { // \u4e0d\u4f7f\u7528agent\u5219\u6bcf\u6b21\u521b\u5efa\u4e00\u4e2asocket\uff0c\u9ed8\u8ba4\u4f7f\u7528net\u6a21\u5757\u7684\u63a5\u53e3 if ( typeof options . createConnection === 'function' ) { const newSocket = options . createConnection ( options , oncreate ); if ( newSocket && ! called ) { called = true ; this . onSocket ( newSocket ); } else { return ; } } else { this . onSocket ( net . createConnection ( options )); } } // \u8fde\u63a5\u6210\u529f\u540e\u53d1\u9001\u5f85\u7f13\u5b58\u7684\u6570\u636e this . _deferToConnect ( null , null , () => this . _flush ()); } \u83b7\u53d6\u4e00\u4e2aClientRequest\u5b9e\u4f8b\u540e\uff0c\u4e0d\u7ba1\u662f\u901a\u8fc7agent\u8fd8\u662f\u81ea\u5df1\u521b\u5efa\u4e00\u4e2aTCP\u8fde\u63a5\uff0c\u5728\u8fde\u63a5\u6210\u529f\u540e\u90fd\u4f1a\u6267\u884conSocket\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // socket\u53ef\u7528\u65f6\u7684\u56de\u8c03 ClientRequest . prototype . onSocket = function onSocket ( socket ) { process . nextTick ( onSocketNT , this , socket ); }; function onSocketNT ( req , socket ) { // \u7533\u8bf7socket\u8fc7\u7a0b\u4e2d\uff0c\u8bf7\u6c42\u5df2\u7ecf\u7ec8\u6b62 if ( req . aborted ) { // \u4e0d\u4f7f\u7528agent\uff0c\u76f4\u63a5\u9500\u6bc1socekt if ( ! req . agent ) { socket . destroy (); } else { // \u4f7f\u7528agent\u89e6\u53d1free\u4e8b\u4ef6\uff0c\u7531agent\u5904\u7406socekt req . emit ( 'close' ); socket . emit ( 'free' ); } } else { // \u5904\u7406socket tickOnSocket ( req , socket ); } } \u6211\u4eec\u7ee7\u7eed\u770btickOnSocket 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // \u521d\u59cb\u5316HTTP\u89e3\u6790\u5668\u548c\u6ce8\u518cdata\u4e8b\u4ef6\u7b49\uff0c\u7b49\u5f85\u54cd\u5e94 function tickOnSocket ( req , socket ) { // \u5206\u914d\u4e00\u4e2aHTTP\u89e3\u6790\u5668 const parser = parsers . alloc (); req . socket = socket ; // \u521d\u59cb\u5316\uff0c\u5904\u7406\u54cd\u5e94\u62a5\u6587 parser . initialize ( HTTPParser . RESPONSE , new HTTPClientAsyncResource ( 'HTTPINCOMINGMESSAGE' , req ), req . maxHeaderSize || 0 , req . insecureHTTPParser === undefined ? isLenient () : req . insecureHTTPParser ); parser . socket = socket ; parser . outgoing = req ; req . parser = parser ; socket . parser = parser ; // socket\u6b63\u5904\u7406\u7684\u8bf7\u6c42 socket . _httpMessage = req ; // Propagate headers limit from request object to parser if ( typeof req . maxHeadersCount === 'number' ) { parser . maxHeaderPairs = req . maxHeadersCount << 1 ; } // \u89e3\u6790\u5b8cHTTP\u5934\u90e8\u7684\u56de\u8c03 parser . onIncoming = parserOnIncomingClient ; socket . removeListener ( 'error' , freeSocketErrorListener ); socket . on ( 'error' , socketErrorListener ); socket . on ( 'data' , socketOnData ); socket . on ( 'end' , socketOnEnd ); socket . on ( 'close' , socketCloseListener ); socket . on ( 'drain' , ondrain ); if ( req . timeout !== undefined || ( req . agent && req . agent . options && req . agent . options . timeout ) ) { // \u5904\u7406\u8d85\u65f6\u65f6\u95f4 listenSocketTimeout ( req ); } req . emit ( 'socket' , socket ); } \u62ff\u5230\u4e00\u4e2asocket\u540e\uff0c\u5c31\u5f00\u59cb\u76d1\u542csocket\u4e0ahttp\u62a5\u6587\u7684\u5230\u6765\u3002\u5e76\u4e14\u7533\u8bf7\u4e00\u4e2aHTTP\u89e3\u6790\u5668\u51c6\u5907\u89e3\u6790http\u62a5\u6587\uff0c\u6211\u4eec\u4e3b\u8981\u5206\u6790\u8d85\u65f6\u65f6\u95f4\u7684\u5904\u7406\u548cdata\u4e8b\u4ef6\u7684\u5904\u7406\u903b\u8f91\u3002 1 \u8d85\u65f6\u65f6\u95f4\u7684\u5904\u7406 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function listenSocketTimeout ( req ) { // \u8bbe\u7f6e\u8fc7\u4e86\u5219\u8fd4\u56de if ( req . timeoutCb ) { return ; } // \u8d85\u65f6\u56de\u8c03 req . timeoutCb = emitRequestTimeout ; // Delegate socket timeout event. // \u8bbe\u7f6esocket\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u5373socket\u4e0a\u4e00\u5b9a\u65f6\u95f4\u540e\u6ca1\u6709\u54cd\u5e94\u5219\u89e6\u53d1\u8d85\u65f6 if ( req . socket ) { req . socket . once ( 'timeout' , emitRequestTimeout ); } else { req . on ( 'socket' , ( socket ) => { socket . once ( 'timeout' , emitRequestTimeout ); }); } } function emitRequestTimeout () { const req = this . _httpMessage ; if ( req ) { req . emit ( 'timeout' ); } } 2 \u5904\u7406\u54cd\u5e94\u6570\u636e 1 2 3 4 5 6 7 8 function socketOnData ( d ) { const socket = this ; const req = this . _httpMessage ; const parser = this . parser ; // \u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406 const ret = parser . execute ( d ); // ... } \u5f53Node.js\u6536\u5230\u54cd\u5e94\u62a5\u6587\u65f6\uff0c\u4f1a\u628a\u6570\u636e\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\u3002http\u89e3\u6790\u5728\u89e3\u6790\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u4e0d\u65ad\u89e6\u53d1\u94a9\u5b50\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0bJS\u5c42\u5404\u4e2a\u94a9\u5b50\u51fd\u6570\u7684\u903b\u8f91\u3002 1 \u89e3\u6790\u5934\u90e8\u8fc7\u7a0b\u4e2d\u6267\u884c\u7684\u56de\u8c03 1 2 3 4 5 6 7 8 function parserOnHeaders ( headers , url ) { // \u4fdd\u5b58\u5934\u548curl if ( this . maxHeaderPairs <= 0 || this . _headers . length < this . maxHeaderPairs ) { this . _headers = this . _headers . concat ( headers ); } this . _url += url ; } 2 \u89e3\u6790\u5b8c\u5934\u90e8\u7684\u56de\u8c03 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 function parserOnHeadersComplete ( versionMajor , versionMinor , headers , method , url , statusCode , statusMessage , upgrade , shouldKeepAlive ) { const parser = this ; const { socket } = parser ; // \u5269\u4e0b\u7684HTTP\u5934 if ( headers === undefined ) { headers = parser . _headers ; parser . _headers = []; } if ( url === undefined ) { url = parser . _url ; parser . _url = '' ; } // Parser is also used by http client // IncomingMessage const ParserIncomingMessage = ( socket && socket . server && socket . server [ kIncomingMessage ] ) || IncomingMessage ; // \u65b0\u5efa\u4e00\u4e2aIncomingMessage\u5bf9\u8c61 const incoming = parser . incoming = new ParserIncomingMessage ( socket ); incoming . httpVersionMajor = versionMajor ; incoming . httpVersionMinor = versionMinor ; incoming . httpVersion = ` ${ versionMajor } . ${ versionMinor } ` ; incoming . url = url ; incoming . upgrade = upgrade ; let n = headers . length ; // If parser.maxHeaderPairs <= 0 assume that there's no limit. if ( parser . maxHeaderPairs > 0 ) n = MathMin ( n , parser . maxHeaderPairs ); // \u66f4\u65b0\u5230\u4fdd\u5b58HTTP\u5934\u7684\u5bf9\u8c61 incoming . _addHeaderLines ( headers , n ); // \u8bf7\u6c42\u65b9\u6cd5\u6216\u54cd\u5e94\u884c\u4fe1\u606f if ( typeof method === 'number' ) { // server only incoming . method = methods [ method ]; } else { // client only incoming . statusCode = statusCode ; incoming . statusMessage = statusMessage ; } // \u6267\u884c\u56de\u8c03 return parser . onIncoming ( incoming , shouldKeepAlive ); } \u6211\u4eec\u770b\u5230\u89e3\u6790\u5b8c\u5934\u90e8\u540e\u4f1a\u6267\u884c\u53e6\u4e00\u4e2a\u56de\u8c03onIncoming\uff0c\u5e76\u4f20\u5165IncomingMessage\u5b9e\u4f8b\uff0c\u8fd9\u5c31\u662f\u6211\u4eec\u5e73\u65f6\u4f7f\u7528\u7684res\u3002\u5728\u524d\u9762\u5206\u6790\u8fc7\uff0conIncoming\u8bbe\u7f6e\u7684\u503c\u662fparserOnIncomingClient\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function parserOnIncomingClient ( res , shouldKeepAlive ) { const socket = this . socket ; // \u8bf7\u6c42\u5bf9\u8c61 const req = socket . _httpMessage ; // \u670d\u52a1\u5668\u53d1\u9001\u4e86\u591a\u4e2a\u54cd\u5e94 if ( req . res ) { socket . destroy (); return 0 ; } req . res = res ; if ( statusIsInformational ( res . statusCode )) { req . res = null ; // \u8bf7\u6c42\u65f6\u8bbe\u7f6e\u4e86expect\u5934\uff0c\u5219\u54cd\u5e94\u7801\u4e3a100\uff0c\u53ef\u4ee5\u7ee7\u7eed\u53d1\u9001\u6570\u636e if ( res . statusCode === 100 ) { req . emit ( 'continue' ); } return 1 ; } req . res = res ; res . req = req ; // \u7b49\u5f85\u54cd\u5e94\u7ed3\u675f\uff0c\u54cd\u5e94\u7ed3\u675f\u540e\u4f1a\u6e05\u9664\u5b9a\u65f6\u5668 res . on ( 'end' , responseOnEnd ); // \u8bf7\u6c42\u7ec8\u6b62\u4e86\u6216\u89e6\u53d1response\u4e8b\u4ef6\uff0c\u8fd4\u56defalse\u8bf4\u660e\u6ca1\u6709\u76d1\u542cresponse\u4e8b\u4ef6\uff0c\u5219\u4e22\u5f03\u6570\u636e if ( req . aborted || ! req . emit ( 'response' , res )) res . _dump (); } \u4ece\u6e90\u7801\u4e2d\u6211\u4eec\u770b\u51fa\u5728\u89e3\u6790\u5b8cHTTP\u54cd\u5e94\u5934\u65f6\uff0c\u5c31\u6267\u884c\u4e86http.request\u8bbe\u7f6e\u7684\u56de\u8c03\u51fd\u6570\u3002\u4f8b\u5982\u4e0b\u9762\u4ee3\u7801\u4e2d\u7684\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 http . request ( 'domain' , { agent }, ( res ) => { // \u89e3\u6790body res . on ( 'data' , ( data ) => { // }); // \u89e3\u6790body\u7ed3\u675f\uff0c\u54cd\u5e94\u7ed3\u675f res . on ( 'end' , ( data ) => { // }); }); // ... \u5728\u56de\u8c03\u91cc\u6211\u4eec\u53ef\u4ee5\u628ares\u4f5c\u4e3a\u4e00\u4e2a\u6d41\u4f7f\u7528\uff0c\u5728\u89e3\u6790\u5b8cHTTP\u5934\u540e\uff0cHTTP\u89e3\u6790\u5668\u4f1a\u7ee7\u7eed\u89e3\u6790HTTP body\u3002\u6211\u4eec\u770b\u4e00\u4e0bHTTP\u89e3\u6790\u5668\u5728\u89e3\u6790body\u8fc7\u7a0b\u4e2d\u6267\u884c\u7684\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 function parserOnBody ( b , start , len ) { const stream = this . incoming ; if ( len > 0 && ! stream . _dumped ) { const slice = b . slice ( start , start + len ); // \u628a\u6570\u636epush\u5230\u6d41\u4e2d\uff0c\u6d41\u4f1a\u89e6\u53d1data\u4e8b\u4ef6 const ret = stream . push ( slice ); // \u6570\u636e\u8fc7\u8f7d\uff0c\u6682\u505c\u63a5\u6536 if ( ! ret ) readStop ( this . socket ); } } \u6700\u540e\u6211\u4eec\u518d\u770b\u4e00\u4e0b\u89e3\u6790\u5b8cbody\u65f6HTTP\u89e3\u6790\u5668\u6267\u884c\u7684\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function parserOnMessageComplete () { const parser = this ; const stream = parser . incoming ; if ( stream !== null ) { // body\u89e3\u6790\u5b8c\u4e86 stream . complete = true ; // \u5728body\u540e\u53ef\u80fd\u6709trailer\u5934\uff0c\u4fdd\u5b58\u4e0b\u6765 const headers = parser . _headers ; if ( headers . length ) { stream . _addHeaderLines ( headers , headers . length ); parser . _headers = []; parser . _url = '' ; } // \u6d41\u7ed3\u675f stream . push ( null ); } // \u8bfb\u53d6\u4e0b\u4e00\u4e2a\u54cd\u5e94\uff0c\u5982\u679c\u6709\u7684\u8bdd readStart ( parser . socket ); } \u6211\u4eec\u770b\u5230\u5728\u89e3\u6790body\u8fc7\u7a0b\u4e2d\u4f1a\u4e0d\u65ad\u5f80\u6d41\u4e2dpush\u6570\u636e\uff0c\u4ece\u800c\u4e0d\u65ad\u89e6\u53d1res\u7684data\u4e8b\u4ef6\uff0c\u6700\u540e\u89e3\u6790body\u7ed3\u675f\u540e\uff0c\u901a\u8fc7push(null)\u901a\u77e5\u6d41\u7ed3\u675f\uff0c\u4ece\u800c\u89e6\u53d1res.end\u4e8b\u4ef6\u3002\u6211\u4eec\u6cbf\u7740onSocket\u51fd\u6570\u5206\u6790\u5b8c\u5904\u7406\u54cd\u5e94\u540e\u6211\u4eec\u518d\u6765\u5206\u6790\u8bf7\u6c42\u7684\u8fc7\u7a0b\u3002\u6267\u884c\u5b8chttp.request\u540e\u6211\u4eec\u4f1a\u5f97\u5230\u4e00\u4e2a\u6807\u8bb0\u8bf7\u6c42\u7684\u5b9e\u4f8b\u3002\u7136\u540e\u6267\u884c\u5b83\u7684write\u65b9\u6cd5\u53d1\u9001\u6570\u636e\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 OutgoingMessage . prototype . write = function write ( chunk , encoding , callback ) { const ret = write_ ( this , chunk , encoding , callback , false ); // \u8fd4\u56defalse\u8bf4\u660e\u9700\u8981\u7b49\u5f85drain\u4e8b\u4ef6 if ( ! ret ) this [ kNeedDrain ] = true ; return ret ; }; function write_ ( msg , chunk , encoding , callback , fromEnd ) { // \u8fd8\u6ca1\u6709\u8bbe\u7f6ethis._header\u5b57\u6bb5\uff0c\u5219\u628a\u8bf7\u6c42\u884c\u548cHTTP\u5934\u62fc\u63a5\u5230this._header\u5b57\u6bb5 if ( ! msg . _header ) { msg . _implicitHeader (); } let ret ; // chunk\u6a21\u5f0f\u5219\u9700\u8981\u989d\u5916\u52a0\u4e00\u4e0b\u5b57\u6bb5\uff0c\u5426\u5219\u76f4\u63a5\u53d1\u9001 if ( msg . chunkedEncoding && chunk . length !== 0 ) { let len ; if ( typeof chunk === 'string' ) len = Buffer . byteLength ( chunk , encoding ); else len = chunk . length ; /* chunk\u6a21\u5f0f\u65f6\uff0chttp\u62a5\u6587\u7684\u683c\u5f0f\u5982\u4e0b chunk\u957f\u5ea6 \u56de\u8f66\u6362\u884c \u6570\u636e \u56de\u8f66\u6362\u884c */ msg . _send ( len . toString ( 16 ), 'latin1' , null ); msg . _send ( crlf_buf , null , null ); msg . _send ( chunk , encoding , null ); ret = msg . _send ( crlf_buf , null , callback ); } else { ret = msg . _send ( chunk , encoding , callback ); } return ret ; } \u6211\u4eec\u63a5\u7740\u770b_send\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 OutgoingMessage . prototype . _send = function _send ( data , encoding , callback ) { // \u5934\u90e8\u8fd8\u6ca1\u6709\u53d1\u9001 if ( ! this . _headerSent ) { // \u662f\u5b57\u7b26\u4e32\u5219\u8ffd\u52a0\u5230\u5934\u90e8\uff0cthis._header\u4fdd\u5b58\u4e86HTTP\u8bf7\u6c42\u884c\u548cHTTP\u5934 if ( typeof data === 'string' && ( encoding === 'utf8' || encoding === 'latin1' || ! encoding )) { data = this . _header + data ; } else { // \u5426\u5219\u7f13\u5b58\u8d77\u6765 const header = this . _header ; // HTTP\u5934\u9700\u8981\u653e\u5230\u6700\u524d\u9762 if ( this . outputData . length === 0 ) { this . outputData = [{ data : header , encoding : 'latin1' , callback : null }]; } else { this . outputData . unshift ({ data : header , encoding : 'latin1' , callback : null }); } // \u66f4\u65b0\u7f13\u5b58\u5927\u5c0f this . outputSize += header . length ; this . _onPendingData ( header . length ); } // \u5df2\u7ecf\u5728\u6392\u961f\u7b49\u5f85\u53d1\u9001\u4e86\uff0c\u4e0d\u80fd\u4fee\u6539 this . _headerSent = true ; } return this . _writeRaw ( data , encoding , callback ); }; \u6211\u4eec\u7ee7\u7eed\u770b_writeRaw 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 OutgoingMessage . prototype . _writeRaw = function _writeRaw ( data , encoding , callback ) { // \u53ef\u5199\u7684\u65f6\u5019\u76f4\u63a5\u53d1\u9001 if ( conn && conn . _httpMessage === this && conn . writable ) { // There might be pending data in the this.output buffer. // \u5982\u679c\u6709\u7f13\u5b58\u7684\u6570\u636e\u5219\u5148\u53d1\u9001\u7f13\u5b58\u7684\u6570\u636e if ( this . outputData . length ) { this . _flushOutput ( conn ); } // \u63a5\u7740\u53d1\u9001\u5f53\u524d\u9700\u8981\u53d1\u9001\u7684 return conn . write ( data , encoding , callback ); } // \u5426\u5148\u7f13\u5b58 this . outputData . push ({ data , encoding , callback }); this . outputSize += data . length ; this . _onPendingData ( data . length ); return this . outputSize < HIGH_WATER_MARK ; } OutgoingMessage . prototype . _flushOutput = function _flushOutput ( socket ) { // \u4e4b\u524d\u8bbe\u7f6e\u4e86\u52a0\u585e\uff0c\u5219\u64cd\u4f5csocket\u5148\u79ef\u6512\u6570\u636e while ( this [ kCorked ]) { this [ kCorked ] -- ; socket . cork (); } const outputLength = this . outputData . length ; if ( outputLength <= 0 ) return undefined ; const outputData = this . outputData ; socket . cork (); // \u628a\u7f13\u5b58\u7684\u6570\u636e\u5199\u5230socket let ret ; for ( let i = 0 ; i < outputLength ; i ++ ) { const { data , encoding , callback } = outputData [ i ]; ret = socket . write ( data , encoding , callback ); } socket . uncork (); this . outputData = []; this . _onPendingData ( - this . outputSize ); this . outputSize = 0 ; return ret ; }; \u5199\u5b8c\u6570\u636e\u540e\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u6267\u884cend\u51fd\u6570\u6807\u8bb0HTTP\u8bf7\u6c42\u7684\u7ed3\u675f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 OutgoingMessage . prototype . end = function end ( chunk , encoding , callback ) { // \u8fd8\u6ca1\u7ed3\u675f // \u52a0\u585e if ( this . socket ) { this . socket . cork (); } // \u6d41\u7ed3\u675f\u540e\u56de\u8c03 if ( typeof callback === 'function' ) this . once ( 'finish' , callback ); // \u6570\u636e\u5199\u5165\u5e95\u5c42\u540e\u7684\u56de\u8c03 const finish = onFinish . bind ( undefined , this ); // chunk\u6a21\u5f0f\u540e\u9762\u9700\u8981\u53d1\u9001\u4e00\u4e2a0\\r\\n\u7ed3\u675f\u6807\u8bb0\uff0c\u5426\u5219\u4e0d\u9700\u8981\u7ed3\u675f\u6807\u8bb0 if ( this . _hasBody && this . chunkedEncoding ) { this . _send ( '0\\r\\n' + this . _trailer + '\\r\\n' , 'latin1' , finish ); } else { this . _send ( '' , 'latin1' , finish ); } // uncork\u89e3\u9664\u585e\u5b50\uff0c\u53d1\u9001\u6570\u636e if ( this . socket ) { // Fully uncork connection on end(). this . socket . _writableState . corked = 1 ; this . socket . uncork (); } this [ kCorked ] = 0 ; // \u6807\u8bb0\u6267\u884c\u4e86end this . finished = true ; // \u6570\u636e\u53d1\u5b8c\u4e86 if ( this . outputData . length === 0 && this . socket && this . socket . _httpMessage === this ) { this . _finish (); } return this ; };","title":"18.2 HTTP\u5ba2\u6237\u7aef"},{"location":"chapter18-HTTP/#183-http","text":"\u672c\u8282\u6211\u4eec\u6765\u5206\u6790\u4f7f\u7528Node.js\u4f5c\u4e3a\u670d\u52a1\u5668\u7684\u4f8b\u5b50\u3002 1 2 3 4 5 6 const http = require ( 'http' ); http . createServer (( req , res ) => { res . write ( 'hello' ); res . end (); }) . listen ( 3000 ); \u63a5\u7740\u6211\u4eec\u6cbf\u7740createServer\u5206\u6790Node.js\u4f5c\u4e3a\u670d\u52a1\u5668\u7684\u539f\u7406\u3002 1 2 3 function createServer ( opts , requestListener ) { return new Server ( opts , requestListener ); } \u6211\u4eec\u770bServer\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 function Server ( options , requestListener ) { // \u53ef\u4ee5\u81ea\u5b9a\u4e49\u8868\u793a\u8bf7\u6c42\u7684\u5bf9\u8c61\u548c\u54cd\u5e94\u7684\u5bf9\u8c61 this [ kIncomingMessage ] = options . IncomingMessage || IncomingMessage ; this [ kServerResponse ] = options . ServerResponse || ServerResponse ; // HTTP\u5934\u4e2a\u6570\u7684\u9608\u503c const maxHeaderSize = options . maxHeaderSize ; this . maxHeaderSize = maxHeaderSize ; // \u5141\u8bb8\u534a\u5173\u95ed net . Server . call ( this , { allowHalfOpen : true }); // \u6709\u8bf7\u6c42\u65f6\u7684\u56de\u8c03 if ( requestListener ) { this . on ( 'request' , requestListener ); } // \u670d\u52a1\u5668socket\u8bfb\u7aef\u5173\u95ed\u65f6\u662f\u5426\u5141\u8bb8\u7ee7\u7eed\u5904\u7406\u961f\u5217\u91cc\u7684\u54cd\u5e94\uff08tcp\u4e0a\u6709\u591a\u4e2a\u8bf7\u6c42\uff0c\u7ba1\u9053\u5316\uff09 this . httpAllowHalfOpen = false ; // \u6709\u8fde\u63a5\u65f6\u7684\u56de\u8c03\uff0c\u7531net\u6a21\u5757\u89e6\u53d1 this . on ( 'connection' , connectionListener ); // \u670d\u52a1\u5668\u4e0b\u6240\u6709\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u8d85\u65f6\u65f6\u95f4 this . timeout = 0 ; // \u540c\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\uff0c\u4e24\u4e2a\u8bf7\u6c42\u4e4b\u524d\u6700\u591a\u95f4\u9694\u7684\u65f6\u95f4 this . keepAliveTimeout = 5000 ; this . maxHeadersCount = null ; // \u89e3\u6790\u5934\u90e8\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u9632\u6b62ddos this . headersTimeout = 60 * 1000 ; // 60 seconds } \u63a5\u7740\u8c03\u7528listen\u51fd\u6570\uff0c\u56e0\u4e3aHTTP Server\u7ee7\u627f\u4e8enet.Server\uff0cnet.Server\u7684listen\u51fd\u6570\u524d\u9762\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u5c31\u4e0d\u518d\u5206\u6790\u3002\u5f53\u6709\u8bf7\u6c42\u5230\u6765\u65f6\uff0c\u4f1a\u89e6\u53d1connection\u4e8b\u4ef6\u3002\u4ece\u800c\u6267\u884cconnectionListener\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 function connectionListener ( socket ) { defaultTriggerAsyncIdScope ( getOrSetAsyncId ( socket ), connectionListenerInternal , this , socket ); } // socket\u8868\u793a\u65b0\u8fde\u63a5 function connectionListenerInternal ( server , socket ) { // socket\u6240\u5c5eserver socket . server = server ; // \u8bbe\u7f6e\u8fde\u63a5\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u8d85\u65f6\u5904\u7406\u51fd\u6570\u4e3asocketOnTimeout if ( server . timeout && typeof socket . setTimeout === 'function' ) socket . setTimeout ( server . timeout ); socket . on ( 'timeout' , socketOnTimeout ); // \u5206\u914d\u4e00\u4e2aHTTP\u89e3\u6790\u5668 const parser = parsers . alloc (); // \u89e3\u6790\u8bf7\u6c42\u62a5\u6587 parser . initialize ( HTTPParser . REQUEST , new HTTPServerAsyncResource ( 'HTTPINCOMINGMESSAGE' , socket ), server . maxHeaderSize || 0 , server . insecureHTTPParser === undefined ? isLenient () : server . insecureHTTPParser , ); parser . socket = socket ; // \u8bb0\u5f55\u5f00\u59cb\u89e3\u6790\u5934\u90e8\u7684\u5f00\u59cb\u65f6\u95f4 parser . parsingHeadersStart = nowDate (); socket . parser = parser ; if ( typeof server . maxHeadersCount === 'number' ) { parser . maxHeaderPairs = server . maxHeadersCount << 1 ; } const state = { onData : null , onEnd : null , onClose : null , onDrain : null , // \u540c\u4e00TCP\u8fde\u63a5\u4e0a\uff0c\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u7684\u961f\u5217\uff0c\u7ebf\u5934\u963b\u585e\u7684\u539f\u7406 outgoing : [], incoming : [], // \u5f85\u53d1\u9001\u7684\u5b57\u8282\u6570\uff0c\u5982\u679c\u8d85\u8fc7\u9608\u503c\uff0c\u5219\u5148\u6682\u505c\u63a5\u6536\u8bf7\u6c42\u7684\u6570\u636e outgoingData : 0 , /* \u662f\u5426\u91cd\u65b0\u8bbe\u7f6e\u4e86timeout\uff0c\u7528\u4e8e\u54cd\u5e94\u4e00\u4e2a\u8bf7\u6c42\u65f6\uff0c \u6807\u8bb0\u662f\u5426\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\u7684\u6807\u8bb0 */ keepAliveTimeoutSet : false }; // \u76d1\u542ctcp\u4e0a\u7684\u6570\u636e\uff0c\u5f00\u59cb\u89e3\u6790http\u62a5\u6587 state . onData = socketOnData . bind ( undefined , server , socket , parser , state ); state . onEnd = socketOnEnd . bind ( undefined , server , socket , parser , state ); state . onClose = socketOnClose . bind ( undefined , socket , state ); state . onDrain = socketOnDrain . bind ( undefined , socket , state ); socket . on ( 'data' , state . onData ); socket . on ( 'error' , socketOnError ); socket . on ( 'end' , state . onEnd ); socket . on ( 'close' , state . onClose ); socket . on ( 'drain' , state . onDrain ); // \u89e3\u6790HTTP\u5934\u90e8\u5b8c\u6210\u540e\u6267\u884c\u7684\u56de\u8c03 parser . onIncoming = parserOnIncoming . bind ( undefined , server , socket , state ); socket . on ( 'resume' , onSocketResume ); socket . on ( 'pause' , onSocketPause ); /* \u5982\u679chandle\u662f\u7ee7\u627fStreamBase\u7684\u6d41\u5219\u6267\u884cconsume\u6d88\u8d39http \u8bf7\u6c42\u62a5\u6587\uff0c\u800c\u4e0d\u662f\u4e0a\u9762\u7684onData\uff0ctcp\u6a21\u5757\u7684isStreamBase\u4e3atrue */ if ( socket . _handle && socket . _handle . isStreamBase && ! socket . _handle . _consumed ) { parser . _consumed = true ; socket . _handle . _consumed = true ; parser . consume ( socket . _handle ); } parser [ kOnExecute ] = onParserExecute . bind ( undefined , server , socket , parser , state ); socket . _paused = false ; } \u6267\u884c\u5b8cconnectionListener\u540e\u5c31\u5f00\u59cb\u7b49\u5f85tcp\u4e0a\u6570\u636e\u7684\u5230\u6765\uff0c\u5373HTTP\u8bf7\u6c42\u62a5\u6587\u3002\u4e0a\u9762\u4ee3\u7801\u4e2dNode.js\u76d1\u542c\u4e86socket\u7684data\u4e8b\u4ef6\uff0c\u540c\u65f6\u6ce8\u518c\u4e86\u94a9\u5b50kOnExecute\u3002data\u4e8b\u4ef6\u6211\u4eec\u90fd\u77e5\u9053\u662f\u6d41\u4e0a\u6709\u6570\u636e\u5230\u6765\u65f6\u89e6\u53d1\u7684\u4e8b\u4ef6\u3002\u6211\u4eec\u770b\u4e00\u4e0bsocketOnData\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002 1 2 3 4 5 function socketOnData ( server , socket , parser , state , d ) { // \u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\uff0c\u8fd4\u56de\u5df2\u7ecf\u89e3\u6790\u7684\u5b57\u8282\u6570 const ret = parser . execute ( d ); onParserExecuteCommon ( server , socket , parser , state , ret , d ); } socketOnData\u7684\u5904\u7406\u903b\u8f91\u662f\u5f53socket\u4e0a\u6709\u6570\u636e\uff0c\u7136\u540e\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\u3002\u8fd9\u770b\u8d77\u6765\u6ca1\u4ec0\u4e48\u95ee\u9898\uff0c\u90a3\u4e48kOnExecute\u662f\u505a\u4ec0\u4e48\u7684\u5462\uff1fkOnExecute\u94a9\u5b50\u51fd\u6570\u7684\u503c\u662fonParserExecute\uff0c\u8fd9\u4e2a\u770b\u8d77\u6765\u4e5f\u662f\u89e3\u6790tcp\u4e0a\u7684\u6570\u636e\u7684\uff0c\u770b\u8d77\u6765\u548conSocketData\u662f\u4e00\u6837\u7684\u4f5c\u7528\uff0c\u96be\u9053tcp\u4e0a\u7684\u6570\u636e\u6709\u4e24\u4e2a\u6d88\u8d39\u8005\uff1f\u6211\u4eec\u770b\u4e00\u4e0bkOnExecute\u4ec0\u4e48\u65f6\u5019\u88ab\u56de\u8c03\u7684\u3002 1 2 3 4 5 6 7 void OnStreamRead ( ssize_t nread , const uv_buf_t & buf ) override { Local < Value > ret = Execute ( buf . base , nread ); Local < Value > cb = object () -> Get ( env () -> context (), kOnExecute ). ToLocalChecked (); MakeCallback ( cb . As < Function > (), 1 , & ret ); } OnStreamRead\u662fnode_http_parser.cc\u5b9e\u73b0\u7684\u51fd\u6570\uff0c\u6240\u4ee5kOnExecute\u5728node_http_parser.cc\u4e2d\u7684OnStreamRead\u4e2d\u88ab\u56de\u8c03\uff0c\u90a3\u4e48OnStreamRead\u53c8\u662f\u4ec0\u4e48\u65f6\u5019\u88ab\u56de\u8c03\u7684\u5462\uff1f\u5728C++\u5c42\u7ae0\u8282\u6211\u4eec\u5206\u6790\u8fc7\uff0cOnStreamRead\u662fNode.js\u4e2dC++\u5c42\u6d41\u64cd\u4f5c\u7684\u901a\u7528\u51fd\u6570\uff0c\u5f53\u6d41\u6709\u6570\u636e\u7684\u65f6\u5019\u5c31\u4f1a\u6267\u884c\u8be5\u56de\u8c03\u3002\u800c\u4e14OnStreamRead\u4e2d\u4e5f\u4f1a\u628a\u6570\u636e\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u89e3\u6790\u3002\u8fd9\u770b\u8d77\u6765\u771f\u7684\u6709\u4e24\u4e2a\u6d88\u8d39\u8005\uff1f\u8fd9\u5c31\u5f88\u5947\u602a\uff0c\u4e3a\u4ec0\u4e48\u4e00\u4efd\u6570\u636e\u4f1a\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\u4e24\u6b21\uff1f 1 2 3 4 5 if ( socket . _handle && socket . _handle . isStreamBase && ! socket . _handle . _consumed ) { parser . _consumed = true ; socket . _handle . _consumed = true ; parser . consume ( socket . _handle ); } \u56e0\u4e3aTCP\u6d41\u662f\u7ee7\u627fStreamBase\u7c7b\u7684\uff0c\u6240\u4ee5if\u6210\u7acb\u3002\u6211\u4eec\u770b\u4e00\u4e0bconsume\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 static void Consume ( const FunctionCallbackInfo < Value >& args ) { Parser * parser ; ASSIGN_OR_RETURN_UNWRAP ( & parser , args . Holder ()); CHECK ( args [ 0 ] -> IsObject ()); StreamBase * stream = StreamBase :: FromObjject ( args [ 0 ]. As < Object > ()); CHECK_NOT_NULL ( stream ); stream -> PushStreamListener ( parser ); } HTTP\u89e3\u6790\u5668\u628a\u81ea\u5df1\u6ce8\u518c\u4e3aTCP stream\u7684\u4e00\u4e2alistener\u3002\u8fd9\u4f1a\u4f7f\u5f97TCP\u6d41\u4e0a\u7684\u6570\u636e\u7531node_http_parser.cc\u7684OnStreamRead\u76f4\u63a5\u6d88\u8d39\uff0c\u800c\u4e0d\u662f\u89e6\u53d1onData\u4e8b\u4ef6\u3002\u5728OnStreamRead\u4e2d\u4f1a\u6e90\u6e90\u4e0d\u65ad\u5730\u628a\u6570\u636e\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\uff0c\u5728\u89e3\u6790\u7684\u8fc7\u7a0b\u4e2d\uff0c\u4f1a\u4e0d\u65ad\u89e6\u53d1\u5bf9\u5e94\u7684\u94a9\u5b50\u51fd\u6570\uff0c\u76f4\u5230\u89e3\u6790\u5b8cHTTP\u5934\u90e8\u540e\u6267\u884cparserOnIncoming\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 function parserOnIncoming ( server , socket , state , req , keepAlive ) { // \u9700\u8981\u91cd\u7f6e\u5b9a\u65f6\u5668 resetSocketTimeout ( server , socket , state ); // \u8bbe\u7f6e\u4e86keepAlive\u5219\u54cd\u5e94\u540e\u9700\u8981\u91cd\u7f6e\u4e00\u4e9b\u72b6\u6001 if ( server . keepAliveTimeout > 0 ) { req . on ( 'end' , resetHeadersTimeoutOnReqEnd ); } // \u6807\u8bb0\u5934\u90e8\u89e3\u6790\u5b8c\u6bd5 socket . parser . parsingHeadersStart = 0 ; // \u8bf7\u6c42\u5165\u961f\uff08\u5f85\u5904\u7406\u7684\u8bf7\u6c42\u961f\u5217\uff09 state . incoming . push ( req ); if ( ! socket . _paused ) { const ws = socket . _writableState ; // \u5f85\u53d1\u9001\u7684\u6570\u636e\u8fc7\u591a\uff0c\u5148\u6682\u505c\u63a5\u6536\u8bf7\u6c42\u6570\u636e if ( ws . needDrain || state . outgoingData >= socket . writableHighWaterMark ) { socket . _paused = true ; socket . pause (); } } // \u65b0\u5efa\u4e00\u4e2a\u8868\u793a\u54cd\u5e94\u7684\u5bf9\u8c61 const res = new server [ kServerResponse ]( req ); // \u8bbe\u7f6e\u6570\u636e\u5199\u5165\u5f85\u53d1\u9001\u961f\u5217\u65f6\u89e6\u53d1\u7684\u56de\u8c03\uff0c\u89c1OutgoingMessage res . _onPendingData = updateOutgoingData . bind ( undefined , socket , state ); // \u6839\u636e\u8bf7\u6c42\u7684HTTP\u5934\u8bbe\u7f6e\u662f\u5426\u652f\u6301keepalive\uff08\u7ba1\u9053\u5316\uff09 res . shouldKeepAlive = keepAlive ; /* socket\u5f53\u524d\u5df2\u7ecf\u5728\u5904\u7406\u5176\u5b83\u8bf7\u6c42\u7684\u54cd\u5e94\uff0c\u5219\u5148\u6392\u961f\uff0c \u5426\u5219\u6302\u8f7d\u54cd\u5e94\u5bf9\u8c61\u5230socket\uff0c\u4f5c\u4e3a\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94 */ if ( socket . _httpMessage ) { state . outgoing . push ( res ); } else { res . assignSocket ( socket ); } // \u54cd\u5e94\u5904\u7406\u5b8c\u6bd5\u540e\uff0c\u9700\u8981\u505a\u4e00\u4e9b\u5904\u7406 res . on ( 'finish' , resOnFinish . bind ( undefined , req , res , socket , state , server )); // \u6709expect\u8bf7\u6c42\u5934\uff0c\u5e76\u4e14\u662fhttp1.1 if ( req . headers . expect !== undefined && ( req . httpVersionMajor === 1 && req . httpVersionMinor === 1 ) ) { // Expect\u5934\u7684\u503c\u662f\u5426\u662f100-continue if ( continueExpression . test ( req . headers . expect )) { res . _expect_continue = true ; /* \u76d1\u542c\u4e86checkContinue\u4e8b\u4ef6\u5219\u89e6\u53d1\uff0c \u5426\u5219\u76f4\u63a5\u8fd4\u56de\u5141\u8bb8\u7ee7\u7eed\u8bf7\u6c42\u5e76\u89e6\u53d1request\u4e8b\u4ef6 */ if ( server . listenerCount ( 'checkContinue' ) > 0 ) { server . emit ( 'checkContinue' , req , res ); } else { res . writeContinue (); server . emit ( 'request' , req , res ); } } else if ( server . listenerCount ( 'checkExpectation' ) > 0 ) { /* \u503c\u5f02\u5e38\uff0c\u76d1\u542c\u4e86checkExpectation\u4e8b\u4ef6\uff0c \u5219\u89e6\u53d1\uff0c\u5426\u5219\u8fd4\u56de417\u62d2\u7edd\u8bf7\u6c42 */ server . emit ( 'checkExpectation' , req , res ); } else { res . writeHead ( 417 ); res . end (); } } else { // \u89e6\u53d1request\u4e8b\u4ef6\u8bf4\u660e\u6709\u8bf7\u6c42\u5230\u6765 server . emit ( 'request' , req , res ); } return 0 ; // No special treatment. } \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u4f1a\u89e6\u53d1request\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u6709\u65b0\u8bf7\u6c42\u5230\u6765\uff0c\u7528\u6237\u5c31\u53ef\u4ee5\u5904\u7406\u8bf7\u6c42\u4e86\u3002\u6211\u4eec\u770b\u5230Node.js\u89e3\u6790\u5934\u90e8\u7684\u65f6\u5019\u5c31\u4f1a\u6267\u884c\u4e0a\u5c42\u56de\u8c03\uff0c\u901a\u77e5\u6709\u65b0\u8bf7\u6c42\u5230\u6765\uff0c\u5e76\u4f20\u5165request\u548cresponse\u4f5c\u4e3a\u53c2\u6570\uff0c\u5206\u522b\u5bf9\u5e94\u7684\u662f\u8868\u793a\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u5bf9\u8c61\u3002\u53e6\u5916Node.js\u672c\u8eab\u662f\u4e0d\u4f1a\u89e3\u6790body\u90e8\u5206\u7684\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u83b7\u53d6body\u7684\u6570\u636e\u3002 1 2 3 4 5 6 7 8 const server = http . createServer (( request , response ) => { request . on ( 'data' , ( chunk ) => { // \u5904\u7406body }); request . on ( 'end' , () => { // body\u7ed3\u675f }); })","title":"18.3 HTTP\u670d\u52a1\u5668"},{"location":"chapter18-HTTP/#1831-http","text":"HTTP1.0\u7684\u65f6\u5019\uff0c\u4e0d\u652f\u6301\u7ba1\u9053\u5316\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u4e00\u4e2a\u8bf7\u6c42\u7684\u65f6\u5019\uff0c\u9996\u5148\u5efa\u7acbTCP\u8fde\u63a5\uff0c\u7136\u540e\u670d\u52a1\u5668\u8fd4\u56de\u4e00\u4e2a\u54cd\u5e94\uff0c\u6700\u540e\u65ad\u5f00TCP\u8fde\u63a5\uff0c\u8fd9\u79cd\u662f\u6700\u7b80\u5355\u7684\u5b9e\u73b0\u65b9\u5f0f\uff0c\u4f46\u662f\u6bcf\u6b21\u53d1\u9001\u8bf7\u6c42\u90fd\u9700\u8981\u8d70\u4e09\u6b21\u63e1\u624b\u663e\u7136\u4f1a\u5e26\u6765\u4e00\u5b9a\u7684\u65f6\u95f4\u635f\u8017\uff0c\u6240\u4ee5HTTP1.1\u7684\u65f6\u5019\uff0c\u652f\u6301\u4e86\u7ba1\u9053\u5316\u3002\u7ba1\u9053\u5316\u7684\u610f\u601d\u5c31\u662f\u53ef\u4ee5\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u53d1\u9001\u591a\u4e2a\u8bf7\u6c42\uff0c\u8fd9\u6837\u670d\u52a1\u5668\u5c31\u53ef\u4ee5\u540c\u65f6\u5904\u7406\u591a\u4e2a\u8bf7\u6c42\uff0c\u4f46\u662f\u7531\u4e8eHTTP1.1\u7684\u9650\u5236\uff0c\u591a\u4e2a\u8bf7\u6c42\u7684\u54cd\u5e94\u9700\u8981\u6309\u5e8f\u8fd4\u56de\u3002\u56e0\u4e3a\u5728HTTP1.1\u4e2d\uff0c\u6ca1\u6709\u6807\u8bb0\u8bf7\u6c42\u548c\u54cd\u5e94\u7684\u5bf9\u5e94\u5173\u7cfb\u3002\u6240\u4ee5HTTP\u5ba2\u6237\u7aef\u4f1a\u5047\u8bbe\u7b2c\u4e00\u4e2a\u8fd4\u56de\u7684\u54cd\u5e94\u662f\u5bf9\u5e94\u7b2c\u4e00\u4e2a\u8bf7\u6c42\u7684\u3002\u5982\u679c\u4e71\u5e8f\u8fd4\u56de\uff0c\u5c31\u4f1a\u5bfc\u81f4\u95ee\u9898\uff0c\u5982\u56fe18-2\u6240\u793a\u3002 \u56fe18-2 \u800c\u5728HTTP 2.0\u4e2d\uff0c\u6bcf\u4e2a\u8bf7\u6c42\u4f1a\u5206\u914d\u4e00\u4e2aid\uff0c\u54cd\u5e94\u4e2d\u4e5f\u4f1a\u8fd4\u56de\u5bf9\u5e94\u7684id\uff0c\u8fd9\u6837\u5c31\u7b97\u4e71\u5e8f\u8fd4\u56de\uff0cHTTP\u5ba2\u6237\u7aef\u4e5f\u53ef\u4ee5\u77e5\u9053\u54cd\u5e94\u6240\u5bf9\u5e94\u7684\u8bf7\u6c42\u3002\u5728HTTP 1.1\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0cHTTP\u670d\u52a1\u5668\u7684\u5b9e\u73b0\u5c31\u4f1a\u53d8\u5f97\u590d\u6742\uff0c\u670d\u52a1\u5668\u53ef\u4ee5\u4ee5\u4e32\u884c\u7684\u65b9\u5f0f\u5904\u7406\u8bf7\u6c42\uff0c\u5f53\u524d\u9762\u8bf7\u6c42\u7684\u54cd\u5e94\u8fd4\u56de\u5230\u5ba2\u6237\u7aef\u540e\uff0c\u518d\u7ee7\u7eed\u5904\u7406\u4e0b\u4e00\u4e2a\u8bf7\u6c42\uff0c\u8fd9\u79cd\u5b9e\u73b0\u65b9\u5f0f\u662f\u76f8\u5bf9\u7b80\u5355\u7684\uff0c\u4f46\u662f\u5f88\u660e\u663e\uff0c\u8fd9\u79cd\u65b9\u5f0f\u76f8\u5bf9\u6765\u8bf4\u8fd8\u662f\u6bd4\u8f83\u4f4e\u6548\u7684\uff0c\u53e6\u4e00\u79cd\u5b9e\u73b0\u65b9\u5f0f\u662f\u5e76\u884c\u5904\u7406\u8bf7\u6c42\uff0c\u4e32\u884c\u8fd4\u56de\uff0c\u8fd9\u6837\u53ef\u4ee5\u8ba9\u8bf7\u6c42\u5f97\u5230\u5c3d\u5feb\u7684\u5904\u7406\uff0c\u6bd4\u5982\u4e24\u4e2a\u8bf7\u6c42\u90fd\u8bbf\u95ee\u6570\u636e\u5e93\uff0c\u90a3\u5e76\u884c\u5904\u7406\u4e24\u4e2a\u8bf7\u6c42\u5c31\u4f1a\u6bd4\u4e32\u884c\u5feb\u5f97\u591a\uff0c\u4f46\u662f\u8fd9\u79cd\u5b9e\u73b0\u65b9\u5f0f\u76f8\u5bf9\u6bd4\u8f83\u590d\u6742\uff0cNode.js\u5c31\u662f\u5c5e\u4e8e\u8fd9\u79cd\u65b9\u5f0f\uff0c\u4e0b\u9762\u6211\u4eec\u6765\u770b\u4e00\u4e0bNode.js\u4e2d\u662f\u5982\u4f55\u5b9e\u73b0\u7684\u3002\u524d\u9762\u5206\u6790\u8fc7\uff0cNode.js\u5728\u89e3\u6790\u5b8cHTTP\u5934\u90e8\u7684\u65f6\u5019\u4f1a\u6267\u884cparserOnIncoming\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function parserOnIncoming ( server , socket , state , req , keepAlive ) { // \u6807\u8bb0\u5934\u90e8\u89e3\u6790\u5b8c\u6bd5 socket . parser . parsingHeadersStart = 0 ; // \u8bf7\u6c42\u5165\u961f state . incoming . push ( req ); // \u65b0\u5efa\u4e00\u4e2a\u8868\u793a\u54cd\u5e94\u7684\u5bf9\u8c61\uff0c\u4e00\u822c\u662fServerResponse const res = new server [ kServerResponse ]( req ); /* socket\u5f53\u524d\u5df2\u7ecf\u5728\u5904\u7406\u5176\u5b83\u8bf7\u6c42\u7684\u54cd\u5e94\uff0c\u5219\u5148\u6392\u961f\uff0c \u5426\u5219\u6302\u8f7d\u54cd\u5e94\u5bf9\u8c61\u5230socket\uff0c\u4f5c\u4e3a\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94 */ if ( socket . _httpMessage ) { state . outgoing . push ( res ); } else { res . assignSocket ( socket ); // socket._httpMessage = res; } // \u54cd\u5e94\u5904\u7406\u5b8c\u6bd5\u540e\uff0c\u9700\u8981\u505a\u4e00\u4e9b\u5904\u7406 res . on ( 'finish' , resOnFinish . bind ( undefined , req , res , socket , state , server )); // \u89e6\u53d1request\u4e8b\u4ef6\u8bf4\u660e\u6709\u8bf7\u6c42\u5230\u6765 server . emit ( 'request' , req , res ); return 0 ; } \u5f53Node.js\u89e3\u6790HTTP\u8bf7\u6c42\u5934\u5b8c\u6210\u540e\uff0c\u5c31\u4f1a\u521b\u5efa\u4e00\u4e2aServerResponse\u5bf9\u8c61\u8868\u793a\u54cd\u5e94\u3002\u7136\u540e\u5224\u65ad\u5f53\u524d\u662f\u5426\u6709\u6b63\u5728\u5904\u7406\u7684\u54cd\u5e94\uff0c\u5982\u679c\u6709\u5219\u6392\u961f\u7b49\u5f85\u5904\u7406\uff0c\u5426\u5219\u628a\u65b0\u5efa\u7684ServerResponse\u5bf9\u8c61\u4f5c\u4e3a\u5f53\u524d\u9700\u8981\u5904\u7406\u7684\u54cd\u5e94\u3002\u6700\u540e\u89e6\u53d1request\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u5c42\u3002\u7528\u6237\u5c31\u53ef\u4ee5\u8fdb\u884c\u8bf7\u6c42\u7684\u5904\u7406\u4e86\u3002\u6211\u4eec\u770b\u5230Node.js\u7ef4\u62a4\u4e86\u4e24\u4e2a\u961f\u5217\uff0c\u5206\u522b\u662f\u8bf7\u6c42\u548c\u54cd\u5e94\u961f\u5217\uff0c\u5982\u56fe18-3\u6240\u793a\u3002 \u56fe18-3 \u5f53\u524d\u5904\u7406\u7684\u8bf7\u6c42\u5728\u8bf7\u6c42\u961f\u5217\u7684\u961f\u9996\uff0c\u8be5\u8bf7\u6c42\u5bf9\u5e94\u7684\u54cd\u5e94\u4f1a\u6302\u8f7d\u5230socket\u7684_httpMessage\u5c5e\u6027\u4e0a\u3002\u4f46\u662f\u6211\u4eec\u770b\u5230Node.js\u4f1a\u89e6\u53d1request\u4e8b\u4ef6\u901a\u77e5\u7528\u6237\u6709\u65b0\u8bf7\u6c42\u5230\u6765\uff0c\u6240\u6709\u5728\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0cNode.js\u4f1a\u5e76\u884c\u5904\u7406\u591a\u4e2a\u8bf7\u6c42\uff08\u5982\u679c\u662fcpu\u5bc6\u96c6\u578b\u7684\u8bf7\u6c42\u5219\u5b9e\u9645\u4e0a\u8fd8\u662f\u4f1a\u53d8\u6210\u4e32\u884c\uff0c\u8fd9\u548cNode.js\u7684\u5355\u7ebf\u7a0b\u76f8\u5173\uff09\u3002\u90a3Node.js\u662f\u5982\u4f55\u63a7\u5236\u54cd\u5e94\u7684\u987a\u5e8f\u7684\u5462\uff1f\u6211\u4eec\u77e5\u9053\u6bcf\u6b21\u89e6\u53d1request\u4e8b\u4ef6\u7684\u65f6\u5019\uff0c\u6211\u4eec\u90fd\u4f1a\u6267\u884c\u4e00\u4e2a\u51fd\u6570\u3002\u6bd4\u5982\u4e0b\u9762\u7684\u4ee3\u7801\u3002 1 2 3 4 5 http . createServer (( req , res ) => { // \u4e00\u4e9b\u7f51\u7edcIO res . writeHead ( 200 , { 'Content-Type' : 'text/plain' }); res . end ( 'okay' ); }); \u6211\u4eec\u770b\u5230\u6bcf\u4e2a\u8bf7\u6c42\u7684\u5904\u7406\u662f\u72ec\u7acb\u7684\u3002\u5047\u8bbe\u6bcf\u4e2a\u8bf7\u6c42\u90fd\u53bb\u64cd\u4f5c\u6570\u636e\u5e93\uff0c\u5982\u679c\u8bf7\u6c422\u6bd4\u8bf7\u6c421\u5148\u5b8c\u6210\u6570\u636e\u5e93\u7684\u64cd\u4f5c\uff0c\u4ece\u800c\u8bf7\u6c422\u5148\u6267\u884cres.write\u548cres.end\u3002\u90a3\u5c82\u4e0d\u662f\u8bf7\u6c422\u5148\u8fd4\u56de\uff1f\u6211\u4eec\u770b\u4e00\u4e0bServerResponse\u548cOutgoingMessage\u7684\u5b9e\u73b0\uff0c\u63ed\u5f00\u8ff7\u96fe\u3002ServerResponse\u662fOutgoingMessage\u7684\u5b50\u7c7b\u3002write\u51fd\u6570\u662f\u5728OutgoingMessage\u4e2d\u5b9e\u73b0\u7684\uff0cwrite\u7684\u8c03\u7528\u94fe\u8def\u5f88\u957f\uff0c\u6211\u4eec\u4e0d\u5c42\u5c42\u5206\u6790\uff0c\u76f4\u63a5\u770b\u6700\u540e\u7684\u8282\u70b9\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function _writeRaw ( data , encoding , callback ) { const conn = this . socket ; // socket\u5bf9\u5e94\u7684\u54cd\u5e94\u662f\u81ea\u5df1\u5e76\u4e14\u53ef\u5199 if ( conn && conn . _httpMessage === this && conn . writable ) { // \u5982\u679c\u6709\u7f13\u5b58\u7684\u6570\u636e\u5219\u5148\u53d1\u9001\u7f13\u5b58\u7684\u6570\u636e if ( this . outputData . length ) { this . _flushOutput ( conn ); } // \u63a5\u7740\u53d1\u9001\u5f53\u524d\u9700\u8981\u53d1\u9001\u7684 return conn . write ( data , encoding , callback ); } // socket\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94\u5bf9\u8c61\u4e0d\u662f\u81ea\u5df1\uff0c\u5219\u5148\u7f13\u5b58\u6570\u636e\u3002 this . outputData . push ({ data , encoding , callback }); this . outputSize += data . length ; this . _onPendingData ( data . length ); return this . outputSize < HIGH_WATER_MARK ; } \u6211\u4eec\u770b\u5230\u6211\u4eec\u8c03\u7528res.write\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u9996\u5148\u5224\u65ad\uff0cres\u662f\u4e0d\u662f\u5c5e\u4e8e\u5f53\u524d\u5904\u7406\u4e2d\u54cd\u5e94\uff0c\u5982\u679c\u662f\u624d\u4f1a\u771f\u6b63\u53d1\u9001\u6570\u636e\uff0c\u5426\u5219\u4f1a\u5148\u628a\u6570\u636e\u7f13\u5b58\u8d77\u6765\u3002\u5206\u6790\u5230\u8fd9\u91cc\uff0c\u76f8\u4fe1\u5927\u5bb6\u5df2\u7ecf\u5dee\u4e0d\u591a\u660e\u767dNode.js\u662f\u5982\u4f55\u63a7\u5236\u54cd\u5e94\u6309\u5e8f\u8fd4\u56de\u7684\u3002\u6700\u540e\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e9b\u7f13\u5b58\u7684\u6570\u636e\u4ec0\u4e48\u65f6\u5019\u4f1a\u88ab\u53d1\u9001\u51fa\u53bb\u3002\u524d\u9762\u4ee3\u7801\u5df2\u7ecf\u8d34\u8fc7\uff0c\u5f53\u4e00\u4e2a\u54cd\u5e94\u7ed3\u675f\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u505a\u4e00\u4e9b\u5904\u7406\u3002 1 2 3 4 5 6 res . on ( 'finish' , resOnFinish . bind ( undefined , req , res , socket , state , server )); \u6211\u4eec\u770b\u770bresOnFinish 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 function resOnFinish ( req , res , socket , state , server ) { // \u5220\u9664\u54cd\u5e94\u5bf9\u5e94\u7684\u8bf7\u6c42 state . incoming . shift (); clearIncoming ( req ); // \u89e3\u9664socket\u4e0a\u6302\u8f7d\u7684\u54cd\u5e94\u5bf9\u8c61 res . detachSocket ( socket ); req . emit ( 'close' ); process . nextTick ( emitCloseNT , res ); // \u662f\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94 if ( res . _last ) { // \u662f\u5219\u9500\u6bc1socket if ( typeof socket . destroySoon === 'function' ) { socket . destroySoon (); } else { socket . end (); } } else if ( state . outgoing . length === 0 ) { /* \u6ca1\u6709\u5f85\u5904\u7406\u7684\u54cd\u5e94\u4e86\uff0c\u5219\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff0c \u7b49\u5f85\u8bf7\u6c42\u7684\u5230\u6765\uff0c\u4e00\u5b9a\u65f6\u95f4\u5185\u6ca1\u6709\u8bf7\u6c42\u5219\u89e6\u53d1timeout\u4e8b\u4ef6 */ if ( server . keepAliveTimeout && typeof socket . setTimeout === 'function' ) { socket . setTimeout ( server . keepAliveTimeout ); state . keepAliveTimeoutSet = true ; } } else { // \u83b7\u53d6\u4e0b\u4e00\u4e2a\u8981\u5904\u7406\u7684\u54cd\u5e94 const m = state . outgoing . shift (); // \u6302\u8f7d\u5230socket\u4f5c\u4e3a\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94 if ( m ) { m . assignSocket ( socket ); } } } \u6211\u4eec\u770b\u5230\uff0cNode.js\u5904\u7406\u5b8c\u4e00\u4e2a\u54cd\u5e94\u540e\uff0c\u4f1a\u505a\u4e00\u4e9b\u5224\u65ad\u3002\u5206\u522b\u6709\u4e09\u79cd\u60c5\u51b5\uff0c\u6211\u4eec\u5206\u5f00\u5206\u6790\u3002 1 \u662f\u5426\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94 \u4ec0\u4e48\u60c5\u51b5\u4e0b\uff0c\u4f1a\u88ab\u8ba4\u4e3a\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u7684\uff1f\u56e0\u4e3a\u54cd\u5e94\u548c\u8bf7\u6c42\u662f\u4e00\u4e00\u5bf9\u5e94\u7684\uff0c\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u5c31\u610f\u5473\u7740\u6700\u540e\u4e00\u4e2a\u8bf7\u6c42\u4e86\uff0c\u90a3\u4e48\u4ec0\u4e48\u65f6\u5019\u88ab\u8ba4\u4e3a\u662f\u6700\u540e\u4e00\u4e2a\u8bf7\u6c42\u5462\uff1f\u5f53\u975e\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0c\u4e00\u4e2a\u8bf7\u6c42\u4e00\u4e2a\u54cd\u5e94\uff0c\u7136\u540e\u5173\u95edTCP\u8fde\u63a5\uff0c\u6240\u4ee5\u975e\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0ctcp\u4e0a\u7684\u7b2c\u4e00\u4e2a\u4e5f\u662f\u552f\u4e00\u4e00\u4e2a\u8bf7\u6c42\u5c31\u662f\u6700\u540e\u4e00\u4e2a\u8bf7\u6c42\u3002\u5728\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0c\u7406\u8bba\u4e0a\u5c31\u6ca1\u6709\u6240\u8c13\u7684\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u3002\u4f46\u662f\u5b9e\u73b0\u4e0a\u4f1a\u505a\u4e00\u4e9b\u9650\u5236\u3002\u5728\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0c\u6bcf\u4e00\u4e2a\u54cd\u5e94\u53ef\u4ee5\u901a\u8fc7\u8bbe\u7f6eHTTP\u54cd\u5e94\u5934connection\u6765\u5b9a\u4e49\u662f\u5426\u53d1\u9001\u8be5\u54cd\u5e94\u540e\u5c31\u65ad\u5f00\u8fde\u63a5\uff0c\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // \u662f\u5426\u663e\u793a\u5220\u9664\u8fc7connection\u5934\uff0c\u662f\u5219\u54cd\u5e94\u540e\u65ad\u5f00\u8fde\u63a5\uff0c\u5e76\u6807\u8bb0\u5f53\u524d\u54cd\u5e94\u662f\u6700\u540e\u4e00\u4e2a if ( this . _removedConnection ) { this . _last = true ; this . shouldKeepAlive = false ; } else if ( ! state . connection ) { /* \u6ca1\u6709\u663e\u793a\u8bbe\u7f6e\u4e86connection\u5934\uff0c\u5219\u53d6\u9ed8\u8ba4\u884c\u4e3a 1 Node.js\u7684shouldKeepAlive\u9ed8\u8ba4\u4e3atrue\uff0c\u4e5f\u53ef\u4ee5\u6839\u636e\u8bf7\u6c42\u62a5\u6587\u91cc \u7684connection\u5934\u5b9a\u4e49 2 \u8bbe\u7f6econtent-length\u6216\u4f7f\u7528chunk\u6a21\u5f0f\u624d\u80fd\u533a\u5206\u54cd\u5e94\u62a5\u6587\u7f16\u8fb9\u754c\uff0c \u624d\u80fd\u652f\u6301keepalive 3 \u4f7f\u7528\u4e86\u4ee3\u7406\uff0c\u4ee3\u7406\u662f\u590d\u7528TCP\u8fde\u63a5\u7684\uff0c\u652f\u6301keepalive */ const shouldSendKeepAlive = this . shouldKeepAlive && ( state . contLen || this . useChunkedEncodingByDefault || this . agent ); if ( shouldSendKeepAlive ) { header += 'Connection: keep-alive\\r\\n' ; } else { this . _last = true ; header += 'Connection: close\\r\\n' ; } } \u53e6\u5916\u5f53\u8bfb\u7aef\u5173\u95ed\u7684\u65f6\u5019\uff0c\u4e5f\u88ab\u8ba4\u4e3a\u662f\u6700\u540e\u4e00\u4e2a\u8bf7\u6c42\uff0c\u6bd5\u7adf\u4e0d\u4f1a\u518d\u53d1\u9001\u8bf7\u6c42\u4e86\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u8bfb\u7aef\u5173\u95ed\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function socketOnEnd ( server , socket , parser , state ) { const ret = parser . finish (); if ( ret instanceof Error ) { socketOnError . call ( socket , ret ); return ; } // \u4e0d\u5141\u8bb8\u534a\u5f00\u5173\u5219\u7ec8\u6b62\u8bf7\u6c42\u7684\u5904\u7406\uff0c\u4e0d\u54cd\u5e94\uff0c\u5173\u95ed\u5199\u7aef if ( ! server . httpAllowHalfOpen ) { abortIncoming ( state . incoming ); if ( socket . writable ) socket . end (); } else if ( state . outgoing . length ) { /* \u5141\u8bb8\u534a\u5f00\u5173\uff0c\u5e76\u4e14\u8fd8\u6709\u54cd\u5e94\u9700\u8981\u5904\u7406\uff0c \u6807\u8bb0\u54cd\u5e94\u961f\u5217\u6700\u540e\u4e00\u4e2a\u8282\u70b9\u4e3a\u6700\u540e\u7684\u54cd\u5e94\uff0c \u5904\u7406\u5b8c\u5c31\u5173\u95edsocket\u5199\u7aef */ state . outgoing [ state . outgoing . length - 1 ]. _last = true ; } else if ( socket . _httpMessage ) { /* \u6ca1\u6709\u7b49\u5f85\u5904\u7406\u7684\u54cd\u5e94\u4e86\uff0c\u4f46\u662f\u8fd8\u6709\u6b63\u5728\u5904\u7406\u7684\u54cd\u5e94\uff0c \u5219\u6807\u8bb0\u4e3a\u6700\u540e\u4e00\u4e2a\u54cd\u5e94 */ socket . _httpMessage . _last = true ; } else if ( socket . writable ) { // \u5426\u5219\u5173\u95edsocket\u5199\u7aef socket . end (); } } \u4ee5\u4e0a\u5c31\u662fNode.js\u4e2d\u5224\u65ad\u662f\u5426\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u7684\u60c5\u51b5\uff0c\u5982\u679c\u4e00\u4e2a\u54cd\u5e94\u88ab\u8ba4\u4e3a\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\uff0c\u90a3\u4e48\u53d1\u9001\u54cd\u5e94\u540e\u5c31\u4f1a\u5173\u95ed\u8fde\u63a5\u3002 2 \u54cd\u5e94\u961f\u5217\u4e3a\u7a7a \u6211\u4eec\u7ee7\u7eed\u770b\u4e00\u4e0b\u5982\u679c\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\u7684\u65f6\u5019\uff0cNode.js\u53c8\u662f\u600e\u4e48\u5904\u7406\u7684\u3002\u5982\u679c\u5f53\u524d\u7684\u5f85\u5904\u7406\u54cd\u5e94\u961f\u5217\u4e3a\u7a7a\uff0c\u8bf4\u660e\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94\u662f\u76ee\u524d\u6700\u540e\u4e00\u4e2a\u9700\u8981\u5904\u7406\u7684\uff0c\u4f46\u662f\u4e0d\u662fTCP\u8fde\u63a5\u4e0a\u6700\u540e\u4e00\u4e2a\u54cd\u5e94\uff0c\u8fd9\u65f6\u5019\uff0cNode.js\u4f1a\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff0c\u5982\u679c\u8d85\u65f6\u8fd8\u6ca1\u6709\u65b0\u7684\u8bf7\u6c42\uff0c\u5219Node.js\u4f1a\u5173\u95ed\u8fde\u63a5\u3002 3 \u54cd\u5e94\u961f\u5217\u975e\u7a7a \u5982\u679c\u5f53\u524d\u5f85\u5904\u7406\u961f\u5217\u975e\u7a7a\uff0c\u5904\u7406\u5b8c\u5f53\u524d\u8bf7\u6c42\u540e\u4f1a\u7ee7\u7eed\u5904\u7406\u4e0b\u4e00\u4e2a\u54cd\u5e94\u3002\u5e76\u4ece\u961f\u5217\u4e2d\u5220\u9664\u8be5\u54cd\u5e94\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u662f\u5982\u4f55\u5904\u7406\u4e0b\u4e00\u4e2a\u54cd\u5e94\u7684\u3002 1 2 3 4 5 6 7 8 9 // \u628a\u54cd\u5e94\u5bf9\u8c61\u6302\u8f7d\u5230socket\uff0c\u6807\u8bb0socket\u5f53\u524d\u6b63\u5728\u5904\u7406\u7684\u54cd\u5e94 ServerResponse . prototype . assignSocket = function assignSocket ( socket ) { // \u6302\u8f7d\u5230socket\u4e0a\uff0c\u6807\u8bb0\u662f\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94 socket . _httpMessage = this ; socket . on ( 'close' , onServerResponseClose ); this . socket = socket ; this . emit ( 'socket' , socket ); this . _flush (); }; \u6211\u4eec\u770b\u5230Node.js\u662f\u901a\u8fc7_httpMessage\u6807\u8bb0\u5f53\u524d\u5904\u7406\u7684\u54cd\u5e94\u7684\uff0c\u914d\u5408\u54cd\u5e94\u961f\u5217\u6765\u5b9e\u73b0\u54cd\u5e94\u7684\u6309\u5e8f\u8fd4\u56de\u3002\u6807\u8bb0\u5b8c\u540e\u6267\u884c_flush\u53d1\u9001\u54cd\u5e94\u7684\u6570\u636e\uff08\u5982\u679c\u8fd9\u65f6\u5019\u8bf7\u6c42\u5df2\u7ecf\u88ab\u5904\u7406\u5b8c\u6210\uff09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 OutgoingMessage . prototype . _flush = function _flush () { const socket = this . socket ; if ( socket && socket . writable ) { const ret = this . _flushOutput ( socket ); }; OutgoingMessage . prototype . _flushOutput = function _flushOutput ( socket ) { // \u4e4b\u524d\u8bbe\u7f6e\u4e86\u52a0\u585e\uff0c\u5219\u64cd\u4f5csocket\u5148\u79ef\u6512\u6570\u636e while ( this [ kCorked ]) { this [ kCorked ] -- ; socket . cork (); } const outputLength = this . outputData . length ; // \u6ca1\u6709\u6570\u636e\u9700\u8981\u53d1\u9001 if ( outputLength <= 0 ) return undefined ; const outputData = this . outputData ; // \u52a0\u585e\uff0c\u8ba9\u6570\u636e\u4e00\u8d77\u53d1\u9001\u51fa\u53bb socket . cork (); // \u628a\u7f13\u5b58\u7684\u6570\u636e\u5199\u5230socket let ret ; for ( let i = 0 ; i < outputLength ; i ++ ) { const { data , encoding , callback } = outputData [ i ]; ret = socket . write ( data , encoding , callback ); } socket . uncork (); this . outputData = []; this . _onPendingData ( - this . outputSize ); this . outputSize = 0 ; return ret ; } \u4ee5\u4e0a\u5c31\u662fNode.js\u4e2d\u5bf9\u4e8e\u7ba1\u9053\u5316\u7684\u5b9e\u73b0\u3002","title":"18.3.1 HTTP\u7ba1\u9053\u5316\u7684\u539f\u7406\u548c\u5b9e\u73b0"},{"location":"chapter18-HTTP/#1832-http-connect","text":"\u5206\u6790HTTP Connect\u5b9e\u73b0\u4e4b\u524d\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0b\u4e3a\u4ec0\u4e48\u9700\u8981HTTP Connect\u65b9\u6cd5\u6216\u8005\u8bf4\u5b83\u51fa\u73b0\u7684\u80cc\u666f\u3002Connect\u65b9\u6cd5\u4e3b\u8981\u7528\u4e8e\u4ee3\u7406\u670d\u52a1\u5668\u7684\u8bf7\u6c42\u8f6c\u53d1\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4f20\u7edfHTTP\u670d\u52a1\u5668\u7684\u5de5\u4f5c\u539f\u7406\uff0c\u5982\u56fe18-4\u6240\u793a\u3002 \u56fe18-4 1 \u5ba2\u6237\u7aef\u548c\u4ee3\u7406\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5 2 \u5ba2\u6237\u7aef\u53d1\u9001HTTP\u8bf7\u6c42\u7ed9\u4ee3\u7406\u670d\u52a1\u5668 3 \u4ee3\u7406\u670d\u52a1\u5668\u89e3\u6790HTTP\u534f\u8bae\uff0c\u6839\u636e\u914d\u7f6e\u62ff\u5230\u4e1a\u52a1\u670d\u52a1\u5668\u7684\u5730\u5740 4 \u4ee3\u7406\u670d\u52a1\u5668\u548c\u4e1a\u52a1\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\uff0c\u901a\u8fc7HTTP\u534f\u8bae\u6216\u8005\u5176\u5b83\u534f\u8bae\u8f6c\u53d1\u8bf7\u6c42 5 \u4e1a\u52a1\u670d\u52a1\u5668\u8fd4\u56de\u6570\u636e\uff0c\u4ee3\u7406\u670d\u52a1\u5668\u56de\u590dHTTP\u62a5\u6587\u7ed9\u5ba2\u6237\u7aef\u3002 \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bHTTPS\u670d\u52a1\u5668\u7684\u539f\u7406\u3002 1 \u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5 2 \u670d\u52a1\u5668\u901a\u8fc7TLS\u62a5\u6587\u8fd4\u56de\u8bc1\u4e66\u4fe1\u606f\uff0c\u5e76\u548c\u5ba2\u6237\u7aef\u5b8c\u6210\u540e\u7eed\u7684TLS\u901a\u4fe1\u3002 3 \u5b8c\u6210TLS\u901a\u4fe1\u540e\uff0c\u540e\u7eed\u53d1\u9001\u7684HTTP\u62a5\u6587\u4f1a\u7ecf\u8fc7TLS\u5c42\u52a0\u5bc6\u89e3\u5bc6\u540e\u518d\u4f20\u8f93\u3002 \u90a3\u4e48\u5982\u679c\u6211\u4eec\u60f3\u5b9e\u73b0\u4e00\u4e2aHTTPS\u7684\u4ee3\u7406\u670d\u52a1\u5668\u600e\u4e48\u505a\u5462\uff1f\u56e0\u4e3a\u5ba2\u6237\u7aef\u53ea\u7ba1\u548c\u76f4\u63a5\u76f8\u8fde\u7684\u670d\u52a1\u5668\u8fdb\u884cHTTPS\u7684\u901a\u4fe1\uff0c\u5982\u679c\u6211\u4eec\u7684\u4e1a\u52a1\u670d\u52a1\u5668\u524d\u9762\u8fd8\u6709\u4ee3\u7406\u670d\u52a1\u5668\uff0c\u90a3\u4e48\u4ee3\u7406\u670d\u52a1\u5668\u5c31\u5fc5\u987b\u8981\u6709\u8bc1\u4e66\u624d\u80fd\u548c\u5ba2\u6237\u7aef\u5b8c\u6210TLS\u63e1\u624b\uff0c\u4ece\u800c\u8fdb\u884cHTTPS\u901a\u4fe1\u3002\u4ee3\u7406\u670d\u52a1\u5668\u548c\u4e1a\u52a1\u670d\u52a1\u5668\u4f7f\u7528HTTP\u6216\u8005HTTPS\u8fd8\u662f\u5176\u5b83\u534f\u8bae\u90fd\u53ef\u4ee5\u3002\u8fd9\u6837\u5c31\u610f\u5473\u7740\u6211\u4eec\u6240\u6709\u7684\u670d\u52a1\u7684\u8bc1\u4e66\u90fd\u9700\u8981\u653e\u5230\u4ee3\u7406\u670d\u52a1\u5668\u4e0a\uff0c\u8fd9\u79cd\u573a\u666f\u7684\u9650\u5236\u662f\uff0c\u4ee3\u7406\u670d\u52a1\u5668\u548c\u4e1a\u52a1\u670d\u52a1\u5668\u90fd\u7531\u6211\u4eec\u81ea\u5df1\u7ba1\u7406\u6216\u8005\u516c\u53f8\u7edf\u4e00\u7ba1\u7406\u3002\u5982\u679c\u6211\u4eec\u60f3\u52a0\u4e00\u4e2a\u4ee3\u7406\u5bf9\u4e1a\u52a1\u670d\u52a1\u5668\u4e0d\u611f\u77e5\u90a3\u600e\u4e48\u529e\u5462\uff08\u6bd4\u5982\u5199\u4e00\u4e2a\u4ee3\u7406\u670d\u52a1\u5668\u7528\u4e8e\u5f00\u53d1\u8c03\u8bd5\uff09\uff1f\u6709\u4e00\u79cd\u65b9\u5f0f\u5c31\u662f\u4e3a\u6211\u4eec\u7684\u4ee3\u7406\u670d\u52a1\u5668\u7533\u8bf7\u4e00\u4e2a\u8bc1\u4e66\uff0c\u8fd9\u6837\u5ba2\u6237\u7aef\u548c\u4ee3\u7406\u670d\u52a1\u5668\u5c31\u53ef\u4ee5\u5b8c\u6210\u6b63\u5e38\u7684HTTPS\u901a\u4fe1\u4e86\u3002\u4ece\u800c\u4e5f\u5c31\u53ef\u4ee5\u5b8c\u6210\u4ee3\u7406\u7684\u529f\u80fd\u3002\u53e6\u5916\u4e00\u79cd\u65b9\u5f0f\u5c31\u662fHTTP Connect\u65b9\u6cd5\u3002HTTP Connect\u65b9\u6cd5\u7684\u4f5c\u7528\u662f\u6307\u793a\u670d\u52a1\u5668\u5e2e\u5fd9\u5efa\u7acb\u4e00\u6761TCP\u8fde\u63a5\u5230\u771f\u6b63\u7684\u4e1a\u52a1\u670d\u52a1\u5668\uff0c\u5e76\u4e14\u900f\u4f20\u540e\u7eed\u7684\u6570\u636e\uff0c\u8fd9\u6837\u4e0d\u7533\u8bf7\u8bc1\u4e66\u4e5f\u53ef\u4ee5\u5b8c\u6210\u4ee3\u7406\u7684\u529f\u80fd\uff0c\u5982\u56fe18-5\u6240\u793a\u3002 \u56fe18-5 \u8fd9\u65f6\u5019\u4ee3\u7406\u670d\u52a1\u5668\u53ea\u8d1f\u8d23\u900f\u4f20\u4e24\u7aef\u7684\u6570\u636e\uff0c\u4e0d\u50cf\u4f20\u7edf\u7684\u65b9\u5f0f\u4e00\u6837\u89e3\u6790\u8bf7\u6c42\u7136\u540e\u518d\u8f6c\u53d1\u3002\u8fd9\u6837\u5ba2\u6237\u7aef\u548c\u4e1a\u52a1\u670d\u52a1\u5668\u5c31\u53ef\u4ee5\u81ea\u5df1\u5b8c\u6210TLS\u63e1\u624b\u548cHTTPS\u901a\u4fe1\u3002\u4ee3\u7406\u670d\u52a1\u5668\u5c31\u50cf\u4e0d\u5b58\u5728\u4e00\u6837\u3002\u4e86\u89e3\u4e86Connect\u7684\u539f\u7406\u540e\u770b\u4e00\u4e0b\u6765\u81eaNode.js\u5b98\u65b9\u7684\u4e00\u4e2a\u4f8b\u5b50\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 const http = require ( 'http' ); const net = require ( 'net' ); const { URL } = require ( 'url' ); // \u521b\u5efa\u4e00\u4e2aHTTP\u670d\u52a1\u5668\u4f5c\u4e3a\u4ee3\u7406\u670d\u52a1\u5668 const proxy = http . createServer (( req , res ) => { res . writeHead ( 200 , { 'Content-Type' : 'text/plain' }); res . end ( 'okay' ); }); // \u76d1\u542cconnect\u4e8b\u4ef6\uff0c\u6709http connect\u8bf7\u6c42\u65f6\u89e6\u53d1 proxy . on ( 'connect' , ( req , clientSocket , head ) => { // \u83b7\u53d6\u771f\u6b63\u8981\u8fde\u63a5\u7684\u670d\u52a1\u5668\u5730\u5740\u5e76\u53d1\u8d77\u8fde\u63a5 const { port , hostname } = new URL ( `http:// ${ req . url } ` ); const serverSocket = net . connect ( port || 80 , hostname , () => { // \u8fde\u63a5\u6210\u529f\u544a\u8bc9\u5ba2\u6237\u7aef clientSocket . write ( 'HTTP/1.1 200 Connection Established\\r\\n' + 'Proxy-agent: Node.js-Proxy\\r\\n' + '\\r\\n' ); // \u900f\u4f20\u5ba2\u6237\u7aef\u548c\u670d\u52a1\u5668\u7684\u6570\u636e serverSocket . write ( head ); serverSocket . pipe ( clientSocket ); clientSocket . pipe ( serverSocket ); }); }); proxy . listen ( 1337 , '127.0.0.1' , () => { const options = { port : 1337 , // \u8fde\u63a5\u7684\u4ee3\u7406\u670d\u52a1\u5668\u5730\u5740 host : '127.0.0.1' , method : 'CONNECT' , // \u6211\u4eec\u9700\u8981\u771f\u6b63\u60f3\u8bbf\u95ee\u7684\u670d\u52a1\u5668\u5730\u5740 path : 'www.baidu.com' , }; // \u53d1\u8d77http connect\u8bf7\u6c42 const req = http . request ( options ); req . end (); // connect\u8bf7\u6c42\u6210\u529f\u540e\u89e6\u53d1 req . on ( 'connect' , ( res , socket , head ) => { // \u53d1\u9001\u771f\u6b63\u7684\u8bf7\u6c42 socket . write ( 'GET / HTTP/1.1\\r\\n' + 'Host: www.baidu.com\\r\\n' + 'Connection: close\\r\\n' + '\\r\\n' ); socket . on ( 'data' , ( chunk ) => { console . log ( chunk . toString ()); }); socket . on ( 'end' , () => { proxy . close (); }); }); }); \u5b98\u7f51\u7684\u8fd9\u4e2a\u4f8b\u5b50\u5f88\u597d\u5730\u8bf4\u660e\u4e86Connect\u7684\u539f\u7406\uff0c\u5982\u56fe18-6\u6240\u793a\u3002 \u56fe18-6 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u4e2dConnect\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u4eceHTTP Connect\u8bf7\u6c42\u5f00\u59cb\u3002\u4e4b\u524d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u5ba2\u6237\u7aef\u548cNode.js\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\u540e\uff0cNode.js\u6536\u5230\u6570\u636e\u7684\u65f6\u5019\u4f1a\u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\uff0c 1 2 3 4 5 6 // \u8fde\u63a5\u4e0a\u6709\u6570\u636e\u5230\u6765 function socketOnData ( server , socket , parser , state , d ) { // \u4ea4\u7ed9HTTP\u89e3\u6790\u5668\u5904\u7406\uff0c\u8fd4\u56de\u5df2\u7ecf\u89e3\u6790\u7684\u5b57\u8282\u6570 const ret = parser . execute ( d ); onParserExecuteCommon ( server , socket , parser , state , ret , d ); } HTTP\u89e3\u6790\u6570\u636e\u7684\u8fc7\u7a0b\u4e2d\u4f1a\u4e0d\u65ad\u56de\u8c03Node.js\u7684\u56de\u8c03\uff0c\u7136\u540e\u6267\u884conParserExecuteCommon\u3002\u6211\u4eec\u8fd9\u91cc\u53ea\u5173\u6ce8\u5f53Node.js\u89e3\u6790\u5b8c\u6240\u6709HTTP\u8bf7\u6c42\u5934\u540e\u6267\u884cparserOnHeadersComplete\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function parserOnHeadersComplete ( versionMajor , versionMinor , headers , method , url , statusCode , statusMessage , upgrade , shouldKeepAlive ) { const parser = this ; const { socket } = parser ; // IncomingMessage const ParserIncomingMessage = ( socket && socket . server && socket . server [ kIncomingMessage ]) || IncomingMessage ; // \u65b0\u5efa\u4e00\u4e2aIncomingMessage\u5bf9\u8c61 const incoming = parser . incoming = new ParserIncomingMessage ( socket ); incoming . httpVersionMajor = versionMajor ; incoming . httpVersionMinor = versionMinor ; incoming . httpVersion = ` ${ versionMajor } . ${ versionMinor } ` ; incoming . url = url ; // \u662f\u5426\u662fconnect\u8bf7\u6c42\u6216\u8005upgrade\u8bf7\u6c42 incoming . upgrade = upgrade ; // \u6267\u884c\u56de\u8c03 return parser . onIncoming ( incoming , shouldKeepAlive ); } \u6211\u4eec\u770b\u5230\u89e3\u6790\u5b8cHTTP\u5934\u540e\uff0cNode.js\u4f1a\u521b\u5efa\u4e00\u4e2a\u8868\u793a\u8bf7\u6c42\u7684\u5bf9\u8c61IncomingMessage\uff0c\u7136\u540e\u56de\u8c03onIncoming\u3002 1 2 3 4 5 6 7 8 9 10 function parserOnIncoming ( server , socket , state , req , keepAlive ) { // \u8bf7\u6c42\u662f\u5426\u662fconnect\u6216\u8005upgrade if ( req . upgrade ) { req . upgrade = req . method === 'CONNECT' || server . listenerCount ( 'upgrade' ) > 0 ; if ( req . upgrade ) return 2 ; } // ... } Node.js\u89e3\u6790\u5b8c\u5934\u90e8\u5e76\u4e14\u6267\u884c\u4e86\u54cd\u5e94\u7684\u94a9\u5b50\u51fd\u6570\u540e\uff0c\u4f1a\u6267\u884conParserExecuteCommon\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function onParserExecuteCommon ( server , socket , parser , state , ret , d ) { if ( ret instanceof Error ) { prepareError ( ret , parser , d ); ret . rawPacket = d || parser . getCurrentBuffer (); socketOnError . call ( socket , ret ); } else if ( parser . incoming && parser . incoming . upgrade ) { // \u5904\u7406Upgrade\u6216\u8005CONNECT\u8bf7\u6c42 const req = parser . incoming ; const eventName = req . method === 'CONNECT' ? 'connect' : 'upgrade' ; // \u76d1\u542c\u4e86\u5bf9\u5e94\u7684\u4e8b\u4ef6\u5219\u5904\u7406\uff0c\u5426\u5219\u5173\u95ed\u8fde\u63a5 if ( eventName === 'upgrade' || server . listenerCount ( eventName ) > 0 ) { // \u8fd8\u6ca1\u6709\u89e3\u6790\u7684\u6570\u636e const bodyHead = d . slice ( ret , d . length ); socket . readableFlowing = null ; server . emit ( eventName , req , socket , bodyHead ); } else { socket . destroy (); } } } \u8fd9\u65f6\u5019Node.js\u4f1a\u5224\u65ad\u8bf7\u6c42\u662f\u4e0d\u662fConnect\u6216\u8005\u534f\u8bae\u5347\u7ea7\u7684upgrade\u8bf7\u6c42\uff0c\u662f\u7684\u8bdd\u7ee7\u7eed\u5224\u65ad\u662f\u5426\u6709\u5904\u7406\u8be5\u4e8b\u4ef6\u7684\u51fd\u6570\uff0c\u6ca1\u6709\u5219\u5173\u95ed\u8fde\u63a5\uff0c\u5426\u5219\u89e6\u53d1\u5bf9\u5e94\u7684\u4e8b\u4ef6\u8fdb\u884c\u5904\u7406\u3002\u6240\u4ee5\u8fd9\u65f6\u5019Node.js\u4f1a\u89e6\u53d1Connect\u65b9\u6cd5\u3002Connect\u4e8b\u4ef6\u7684\u5904\u7406\u903b\u8f91\u6b63\u5982\u6211\u4eec\u5f00\u59cb\u7ed9\u51fa\u7684\u4f8b\u5b50\u4e2d\u90a3\u6837\u3002\u6211\u4eec\u9996\u5148\u548c\u771f\u6b63\u7684\u670d\u52a1\u5668\u5efa\u7acbTCP\u8fde\u63a5\uff0c\u7136\u540e\u8fd4\u56de\u54cd\u5e94\u5934\u7ed9\u5ba2\u6237\u7aef\uff0c\u540e\u7eed\u5ba2\u6237\u5c31\u53ef\u4ee5\u548c\u771f\u6b63\u7684\u670d\u52a1\u5668\u771f\u6b63\u8fdb\u884cTLS\u63e1\u624b\u548cHTTPS\u901a\u4fe1\u4e86\u3002\u8fd9\u5c31\u662fNode.js\u4e2dConnect\u7684\u539f\u7406\u548c\u5b9e\u73b0\u3002 \u4e0d\u8fc7\u5728\u4ee3\u7801\u4e2d\u6211\u4eec\u53d1\u73b0\u4e00\u4e2a\u597d\u73a9\u7684\u5730\u65b9\u3002\u90a3\u5c31\u662f\u5728\u89e6\u53d1connect\u4e8b\u4ef6\u7684\u65f6\u5019\uff0cNode.js\u7ed9\u56de\u8c03\u51fd\u6570\u4f20\u5165\u7684\u53c2\u6570\u3002 1 server . emit ( 'connect' , req , socket , bodyHead ); \u7b2c\u4e00\u7b2c\u4e8c\u4e2a\u53c2\u6570\u6ca1\u4ec0\u4e48\u7279\u522b\u7684\uff0c\u4f46\u662f\u7b2c\u4e09\u4e2a\u53c2\u6570\u5c31\u6709\u610f\u601d\u4e86\uff0cbodyHead\u4ee3\u8868\u7684\u662fHTTP Connect\u8bf7\u6c42\u4e2d\u9664\u4e86\u8bf7\u6c42\u884c\u548cHTTP\u5934\u4e4b\u5916\u7684\u6570\u636e\u3002\u56e0\u4e3aNode.js\u89e3\u6790\u5b8cHTTP\u5934\u540e\u5c31\u4e0d\u7ee7\u7eed\u5904\u7406\u4e86\u3002\u628a\u5269\u4e0b\u7684\u6570\u636e\u4ea4\u7ed9\u4e86\u7528\u6237\u3002\u6211\u4eec\u6765\u505a\u4e00\u4e9b\u597d\u73a9\u7684\u4e8b\u60c5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const http = require ( 'http' ); const net = require ( 'net' ); const { URL } = require ( 'url' ); const proxy = http . createServer (( req , res ) => { res . writeHead ( 200 , { 'Content-Type' : 'text/plain' }); res . end ( 'okay' ); }); proxy . on ( 'connect' , ( req , clientSocket , head ) => { const { port , hostname } = new URL ( `http:// ${ req . url } ` ); const serverSocket = net . connect ( port || 80 , hostname , () => { clientSocket . write ( 'HTTP/1.1 200 Connection Established\\r\\n' + 'Proxy-agent: Node.js-Proxy\\r\\n' + '\\r\\n' ); // \u628aconnect\u8bf7\u6c42\u5269\u4e0b\u7684\u6570\u636e\u8f6c\u53d1\u7ed9\u670d\u52a1\u5668 serverSocket . write ( head ); serverSocket . pipe ( clientSocket ); clientSocket . pipe ( serverSocket ); }); }); proxy . listen ( 1337 , '127.0.0.1' , () => { const net = require ( 'net' ); const body = 'GET http://www.baidu.com:80 HTTP/1.1\\r\\n\\r\\n' ; const length = body . length ; const socket = net . connect ({ host : '127.0.0.1' , port : 1337 }); socket . write ( `CONNECT www.baidu.com:80 HTTP/1.1\\r\\n\\r\\n ${ body } ` ); socket . setEncoding ( 'utf-8' ); socket . on ( 'data' , ( chunk ) => { console . log ( chunk ) }); }); \u6211\u4eec\u65b0\u5efa\u4e00\u4e2asocket\uff0c\u7136\u540e\u81ea\u5df1\u6784\u9020HTTP Connect\u62a5\u6587\uff0c\u5e76\u4e14\u5728HTTP\u884c\u540e\u9762\u52a0\u4e00\u4e2a\u989d\u5916\u7684\u5b57\u7b26\u4e32\uff0c\u8fd9\u4e2a\u5b57\u7b26\u4e32\u662f\u4e24\u4e00\u4e2aHTTP\u8bf7\u6c42\u3002\u5f53Node.js\u670d\u52a1\u5668\u6536\u5230Connect\u8bf7\u6c42\u540e\uff0c\u6211\u4eec\u5728connect\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\u4e2d\uff0c\u628aConnect\u8bf7\u6c42\u591a\u4f59\u7684\u90a3\u4e00\u90e8\u5206\u6570\u636e\u4f20\u7ed9\u771f\u6b63\u7684\u670d\u52a1\u5668\u3002\u8fd9\u6837\u5c31\u8282\u7701\u4e86\u53d1\u9001\u4e00\u4e2a\u8bf7\u6c42\u7684\u65f6\u95f4\u3002","title":"18.3.2 HTTP Connect\u65b9\u6cd5\u7684\u539f\u7406\u548c\u5b9e\u73b0"},{"location":"chapter18-HTTP/#1833","text":"\u5728\u89e3\u6790HTTP\u534f\u8bae\u6216\u8005\u652f\u6301\u957f\u8fde\u63a5\u7684\u65f6\u5019\uff0cNode.js\u9700\u8981\u8bbe\u7f6e\u4e00\u4e9b\u8d85\u65f6\u7684\u673a\u5236\uff0c\u5426\u5219\u4f1a\u9020\u6210\u653b\u51fb\u6216\u8005\u8d44\u6e90\u6d6a\u8d39\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bHTTP\u670d\u52a1\u5668\u4e2d\u6d89\u53ca\u5230\u8d85\u65f6\u7684\u4e00\u4e9b\u903b\u8f91\u3002 1 \u89e3\u6790HTTP\u5934\u90e8\u8d85\u65f6 \u5f53\u6536\u5230\u4e00\u4e2aHTTP\u8bf7\u6c42\u62a5\u6587\u65f6\uff0c\u4f1a\u4eceHTTP\u8bf7\u6c42\u884c\uff0cHTTP\u5934\uff0cHTTP body\u7684\u987a\u5e8f\u8fdb\u884c\u89e3\u6790\uff0c\u5982\u679c\u7528\u6237\u6784\u9020\u8bf7\u6c42\uff0c\u53ea\u53d1\u9001HTTP\u5934\u7684\u4e00\u90e8\u5206\u3002\u90a3\u4e48HTTP\u89e3\u6790\u5668\u5c31\u4f1a\u4e00\u76f4\u5728\u7b49\u5f85\u540e\u7eed\u6570\u636e\u7684\u5230\u6765\u3002\u8fd9\u4f1a\u5bfc\u81f4DDOS\u653b\u51fb\uff0c\u6240\u4ee5Node.js\u4e2d\u8bbe\u7f6e\u4e86\u89e3\u6790HTTP\u5934\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u9608\u503c\u662f60\u79d2\u3002\u5982\u679c60\u79d2\u5185\u6ca1\u6709\u89e3\u6790\u5b8cHTTP\u5934\u90e8\uff0c\u5219\u4f1a\u89e6\u53d1timeout\u4e8b\u4ef6\u3002\u5982\u679c\u7528\u6237\u4e0d\u5904\u7406\uff0c\u5219Node.js\u4f1a\u81ea\u52a8\u5173\u95ed\u8fde\u63a5\u3002\u6211\u4eec\u770b\u4e00\u4e0bNode.js\u7684\u5b9e\u73b0\u3002Node.js\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u4f1a\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\u3002 1 2 3 4 5 this . headersTimeout = 60 * 1000 ; // 60 seconds // Node.js\u5728\u5efa\u7acbTCP\u8fde\u63a5\u6210\u529f\u540e\u521d\u59cb\u5316\u89e3\u6790HTTP\u5934\u7684\u5f00\u59cb\u65f6\u95f4\u3002 function connectionListenerInternal ( server , socket ) { parser . parsingHeadersStart = nowDate (); } \u7136\u540e\u5728\u6bcf\u6b21\u6536\u5230\u6570\u636e\u7684\u65f6\u5019\u5224\u65adHTTP\u5934\u90e8\u662f\u5426\u89e3\u6790\u5b8c\u6210\uff0c\u5982\u679c\u6ca1\u6709\u89e3\u6790\u5b8c\u6210\u5e76\u4e14\u8d85\u65f6\u4e86\u5219\u4f1a\u89e6\u53d1timeout\u4e8b\u4ef6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function onParserExecute ( server , socket , parser , state , ret ) { socket . _unrefTimer (); const start = parser . parsingHeadersStart ; // start\u7b49\u4e8e0\uff0c\u8bf4\u660eHTTP\u5934\u5df2\u7ecf\u89e3\u6790\u5b8c\u6bd5\uff0c\u5426\u5219\u8bf4\u660e\u6b63\u5728\u89e3\u6790\u5934\uff0c\u7136\u540e\u518d\u5224\u65ad\u89e3\u6790\u65f6\u95f4\u662f\u5426\u8d85\u65f6\u4e86 if ( start !== 0 && nowDate () - start > server . headersTimeout ) { // \u89e6\u53d1timeout\uff0c\u5982\u679c\u6ca1\u6709\u76d1\u542ctimeout\uff0c\u5219\u9ed8\u8ba4\u4f1a\u9500\u6bc1socket\uff0c\u5373\u5173\u95ed\u8fde\u63a5 const serverTimeout = server . emit ( 'timeout' , socket ); if ( ! serverTimeout ) socket . destroy (); return ; } onParserExecuteCommon ( server , socket , parser , state , ret , undefined ); } \u5982\u679c\u5728\u8d85\u65f6\u4e4b\u524d\u89e3\u6790HTTP\u5934\u5b8c\u6210\uff0c\u5219\u628aparsingHeadersStart\u7f6e\u4e3a0\u8868\u793a\u89e3\u6790\u5b8c\u6210\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function parserOnIncoming ( server , socket , state , req , keepAlive ) { // \u8bbe\u7f6e\u4e86keepAlive\u5219\u54cd\u5e94\u540e\u9700\u8981\u91cd\u7f6e\u4e00\u4e9b\u72b6\u6001 if ( server . keepAliveTimeout > 0 ) { req . on ( 'end' , resetHeadersTimeoutOnReqEnd ); } // \u6807\u8bb0\u5934\u90e8\u89e3\u6790\u5b8c\u6bd5 socket . parser . parsingHeadersStart = 0 ; } function resetHeadersTimeoutOnReqEnd () { if ( parser ) { parser . parsingHeadersStart = nowDate (); } } \u53e6\u5916\u5982\u679c\u652f\u6301\u957f\u8fde\u63a5\uff0c\u5373\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u53ef\u4ee5\u53d1\u9001\u591a\u4e2a\u8bf7\u6c42\u3002\u5219\u5728\u6bcf\u4e2a\u54cd\u5e94\u7ed3\u675f\u4e4b\u540e\uff0c\u9700\u8981\u91cd\u65b0\u521d\u59cb\u5316\u89e3\u6790HTTP\u5934\u7684\u5f00\u59cb\u65f6\u95f4\u3002\u5f53\u4e0b\u4e00\u4e2a\u8bf7\u6c42\u6570\u636e\u5230\u6765\u65f6\u518d\u6b21\u5224\u65ad\u89e3\u6790HTTP\u5934\u90e8\u662f\u5426\u8d85\u65f6\u3002\u8fd9\u91cc\u662f\u54cd\u5e94\u7ed3\u675f\u540e\u5c31\u5f00\u59cb\u8ba1\u7b97\u3002\u800c\u4e0d\u662f\u4e0b\u4e00\u4e2a\u8bf7\u6c42\u5230\u6765\u65f6\u3002 2 \u652f\u6301\u7ba1\u9053\u5316\u7684\u60c5\u51b5\u4e0b\uff0c\u591a\u4e2a\u8bf7\u6c42\u7684\u65f6\u95f4\u95f4\u9694 Node.js\u652f\u6301\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u53d1\u9001\u591a\u4e2aHTTP\u8bf7\u6c42\uff0c\u6240\u4ee5\u9700\u8981\u8bbe\u7f6e\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u5982\u679c\u8d85\u65f6\u90fd\u6ca1\u6709\u65b0\u7684\u8bf7\u6c42\u5230\u6765\uff0c\u5219\u89e6\u53d1\u8d85\u65f6\u4e8b\u4ef6\u3002\u8fd9\u91cc\u6d89\u53ca\u5b9a\u65f6\u5668\u7684\u8bbe\u7f6e\u548c\u91cd\u7f6e\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // \u662f\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\u54cd\u5e94 if ( res . _last ) { // \u662f\u5219\u9500\u6bc1socket if ( typeof socket . destroySoon === 'function' ) { socket . destroySoon (); } else { socket . end (); } } else if ( state . outgoing . length === 0 ) { // \u6ca1\u6709\u5f85\u5904\u7406\u7684\u54cd\u5e94\u4e86\uff0c\u5219\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff0c\u7b49\u5f85\u8bf7\u6c42\u7684\u5230\u6765\uff0c\u4e00\u5b9a\u65f6\u95f4\u5185\u6ca1\u6709\u8bf7\u6c42\u5219\u89e6\u53d1timeout\u4e8b\u4ef6 if ( server . keepAliveTimeout && typeof socket . setTimeout === 'function' ) { socket . setTimeout ( server . keepAliveTimeout ); state . keepAliveTimeoutSet = true ; } } \u6bcf\u6b21\u54cd\u5e94\u7ed3\u675f\u7684\u65f6\u5019\uff0cNode.js\u9996\u5148\u4f1a\u5224\u65ad\u5f53\u524d\u54cd\u5e94\u662f\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\uff0c\u4f8b\u5982\u8bfb\u7aef\u4e0d\u53ef\u8bfb\u4e86\uff0c\u8bf4\u660e\u4e0d\u4f1a\u53c8\u8bf7\u6c42\u5230\u6765\u4e86\uff0c\u4e5f\u4e0d\u4f1a\u6709\u54cd\u5e94\u4e86\uff0c\u90a3\u4e48\u5c31\u4e0d\u9700\u8981\u4fdd\u6301\u8fd9\u4e2aTCP\u8fde\u63a5\u3002\u5982\u679c\u5f53\u524d\u54cd\u5e94\u4e0d\u662f\u6700\u540e\u4e00\u4e2a\uff0c\u5219Node.js\u4f1a\u6839\u636ekeepAliveTimeout\u7684\u503c\u505a\u4e0b\u4e00\u6b65\u5224\u65ad\uff0c\u5982\u679ckeepAliveTimeout \u975e\u7a7a\uff0c\u5219\u8bbe\u7f6e\u5b9a\u65f6\u5668\uff0c\u5982\u679ckeepAliveTimeout \u65f6\u95f4\u5185\u90fd\u6ca1\u6709\u65b0\u7684\u8bf7\u6c42\u5219\u89e6\u53d1timeout\u4e8b\u4ef6\u3002\u90a3\u4e48\u5982\u679c\u6709\u65b0\u8bf7\u6c42\u5230\u6765\uff0c\u5219\u9700\u8981\u91cd\u7f6e\u8fd9\u4e2a\u5b9a\u65f6\u5668\u3002Node.js\u5728\u6536\u5230\u65b0\u8bf7\u6c42\u7684\u7b2c\u4e00\u4e2a\u8bf7\u6c42\u5305\u4e2d\uff0c\u91cd\u7f6e\u8be5\u5b9a\u65f6\u5668\u3002 1 2 3 4 5 6 7 8 9 10 11 function onParserExecuteCommon ( server , socket , parser , state , ret , d ) { resetSocketTimeout ( server , socket , state ); } function resetSocketTimeout ( server , socket , state ) { if ( ! state . keepAliveTimeoutSet ) return ; socket . setTimeout ( server . timeout || 0 ); state . keepAliveTimeoutSet = false ; } onParserExecuteCommon\u4f1a\u5728\u6bcf\u6b21\u6536\u5230\u6570\u636e\u65f6\u6267\u884c\uff0c\u7136\u540eNode.js\u4f1a\u91cd\u7f6e\u5b9a\u65f6\u5668\u4e3aserver.timeout\u7684\u503c\u3002","title":"18.3.3 \u8d85\u65f6\u7ba1\u7406"},{"location":"chapter18-HTTP/#184-agent","text":"\u672c\u8282\u6211\u4eec\u5148\u5206\u6790Agent\u6a21\u5757\u7684\u5b9e\u73b0\uff0cAgent\u5bf9TCP\u8fde\u63a5\u8fdb\u884c\u4e86\u6c60\u5316\u7ba1\u7406\u3002\u7b80\u5355\u7684\u60c5\u51b5\u4e0b\uff0c\u5ba2\u6237\u7aef\u53d1\u9001\u4e00\u4e2aHTTP\u8bf7\u6c42\u4e4b\u524d\uff0c\u9996\u5148\u5efa\u7acb\u4e00\u4e2aTCP\u8fde\u63a5\uff0c\u6536\u5230\u54cd\u5e94\u540e\u4f1a\u7acb\u523b\u5173\u95edTCP\u8fde\u63a5\u3002\u4f46\u662f\u6211\u4eec\u77e5\u9053TCP\u7684\u4e09\u6b21\u63e1\u624b\u662f\u6bd4\u8f83\u8017\u65f6\u7684\u3002\u6240\u4ee5\u5982\u679c\u6211\u4eec\u80fd\u590d\u7528TCP\u8fde\u63a5\uff0c\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u53d1\u9001\u591a\u4e2aHTTP\u8bf7\u6c42\u548c\u63a5\u6536\u591a\u4e2aHTTP\u54cd\u5e94\uff0c\u90a3\u4e48\u5728\u6027\u80fd\u4e0a\u9762\u5c31\u4f1a\u5f97\u5230\u5f88\u5927\u7684\u63d0\u5347\u3002Agent\u7684\u4f5c\u7528\u5c31\u662f\u590d\u7528TCP\u8fde\u63a5\u3002\u4e0d\u8fc7Agent\u7684\u6a21\u5f0f\u662f\u5728\u4e00\u4e2aTCP\u8fde\u63a5\u4e0a\u4e32\u884c\u5730\u53d1\u9001\u8bf7\u6c42\u548c\u63a5\u6536\u54cd\u5e94\uff0c\u4e0d\u652f\u6301HTTP PipeLine\u6a21\u5f0f\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bAgent\u6a21\u5757\u7684\u5177\u4f53\u5b9e\u73b0\u3002\u770b\u5b83\u662f\u5982\u4f55\u5b9e\u73b0TCP\u8fde\u63a5\u590d\u7528\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 function Agent ( options ) { if ( ! ( this instanceof Agent )) return new Agent ( options ); EventEmitter . call ( this ); this . defaultPort = 80 ; this . protocol = 'http:' ; this . options = { ... options }; // path\u5b57\u6bb5\u8868\u793a\u662f\u672c\u673a\u7684\u8fdb\u7a0b\u95f4\u901a\u4fe1\u65f6\u4f7f\u7528\u7684\u8def\u5f84\uff0c\u6bd4\u5982Unix\u57df\u8def\u5f84 this . options . path = null ; // socket\u4e2a\u6570\u8fbe\u5230\u9608\u503c\u540e\uff0c\u7b49\u5f85\u7a7a\u95f2socket\u7684\u8bf7\u6c42 this . requests = {}; // \u6b63\u5728\u4f7f\u7528\u7684socket this . sockets = {}; // \u7a7a\u95f2socket this . freeSockets = {}; // \u7a7a\u95f2socket\u7684\u5b58\u6d3b\u65f6\u95f4 this . keepAliveMsecs = this . options . keepAliveMsecs || 1000 ; /* \u7528\u5b8c\u7684socket\u662f\u5426\u653e\u5230\u7a7a\u95f2\u961f\u5217\uff0c \u5f00\u542fkeepalive\u624d\u4f1a\u653e\u5230\u7a7a\u95f2\u961f\u5217\uff0c \u4e0d\u5f00\u542fkeepalive \u8fd8\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u5219\u590d\u7528socket \u6ca1\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u5219\u76f4\u63a5\u9500\u6bc1socket */ this . keepAlive = this . options . keepAlive || false ; // \u6700\u5927\u7684socket\u4e2a\u6570\uff0c\u5305\u62ec\u6b63\u5728\u4f7f\u7528\u7684\u548c\u7a7a\u95f2\u7684socket this . maxSockets = this . options . maxSockets || Agent . defaultMaxSockets ; // \u6700\u5927\u7684\u7a7a\u95f2socket\u4e2a\u6570 this . maxFreeSockets = this . options . maxFreeSockets || 256 ; } Agent\u7ef4\u62a4\u4e86\u51e0\u4e2a\u6570\u636e\u7ed3\u6784\uff0c\u5206\u522b\u662f\u7b49\u5f85socket\u7684\u8bf7\u6c42\u3001\u6b63\u5728\u4f7f\u7528\u7684socket\u3001\u7a7a\u95f2socket\u3002\u6bcf\u4e00\u4e2a\u6570\u636e\u7ed3\u6784\u662f\u4e00\u4e2a\u5bf9\u8c61\uff0c\u5bf9\u8c61\u7684key\u662f\u6839\u636eHTTP\u8bf7\u6c42\u53c2\u6570\u8ba1\u7b97\u7684\u3002\u5bf9\u8c61\u7684\u503c\u662f\u4e00\u4e2a\u961f\u5217\u3002\u5177\u4f53\u7ed3\u6784\u5982\u56fe18-7\u6240\u793a\u3002 \u56fe18-7 \u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0bAgent\u6a21\u5757\u7684\u5177\u4f53\u5b9e\u73b0\u3002","title":"18.4 Agent"},{"location":"chapter18-HTTP/#1841-key","text":"key\u7684\u8ba1\u7b97\u662f\u6c60\u5316\u7ba1\u7406\u7684\u6838\u5fc3\u3002\u6b63\u786e\u5730\u8bbe\u8ba1key\u7684\u8ba1\u7b97\u89c4\u5219\uff0c\u624d\u80fd\u66f4\u597d\u5730\u5229\u7528\u6c60\u5316\u5e26\u6765\u7684\u597d\u5904\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // \u4e00\u4e2a\u8bf7\u6c42\u5bf9\u5e94\u7684key Agent . prototype . getName = function getName ( options ) { let name = options . host || 'localhost' ; name += ':' ; if ( options . port ) name += options . port ; name += ':' ; if ( options . localAddress ) name += options . localAddress ; if ( options . family === 4 || options . family === 6 ) name += `: ${ options . family } ` ; if ( options . socketPath ) name += `: ${ options . socketPath } ` ; return name ; }; \u6211\u4eec\u770b\u5230key\u7531host\u3001port\u3001\u672c\u5730\u5730\u5740\u3001\u5730\u5740\u7c07\u7c7b\u578b\u3001unix\u8def\u5f84\u8ba1\u7b97\u800c\u6765\u3002\u6240\u4ee5\u4e0d\u540c\u7684\u8bf7\u6c42\u53ea\u6709\u8fd9\u4e9b\u56e0\u5b50\u90fd\u4e00\u6837\u7684\u60c5\u51b5\u4e0b\u624d\u80fd\u590d\u7528\u8fde\u63a5\u3002\u53e6\u5916\u6211\u4eec\u770b\u5230Agent\u652f\u6301Unix\u57df\u3002","title":"18.4.1 key\u7684\u8ba1\u7b97"},{"location":"chapter18-HTTP/#1842-socket","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 function createSocket ( req , options , cb ) { options = { ... options , ... this . options }; // \u8ba1\u7b97key const name = this . getName ( options ); options . _agentKey = name ; options . encoding = null ; let called = false ; // \u521b\u5efasocket\u5b8c\u6bd5\u540e\u6267\u884c\u7684\u56de\u8c03 const oncreate = ( err , s ) => { if ( called ) return ; called = true ; if ( err ) return cb ( err ); if ( ! this . sockets [ name ]) { this . sockets [ name ] = []; } // \u63d2\u5165\u6b63\u5728\u4f7f\u7528\u7684socket\u961f\u5217 this . sockets [ name ]. push ( s ); // \u76d1\u542csocket\u7684\u4e00\u4e9b\u4e8b\u4ef6\uff0c\u7528\u4e8e\u56de\u6536socket installListeners ( this , s , options ); // \u6709\u53ef\u7528socket\uff0c\u901a\u77e5\u8c03\u7528\u65b9 cb ( null , s ); }; // \u521b\u5efa\u4e00\u4e2a\u65b0\u7684socket\uff0c\u4f7f\u7528net.createConnection const newSocket = this . createConnection ( options , oncreate ); if ( newSocket ) oncreate ( null , newSocket ); } function installListeners ( agent , s , options ) { /* socket\u89e6\u53d1\u7a7a\u95f2\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\uff0c\u544a\u8bc9agent\u8be5socket\u7a7a\u95f2\u4e86\uff0c agent\u4f1a\u56de\u6536\u8be5socket\u5230\u7a7a\u95f2\u961f\u5217 */ function onFree () { agent . emit ( 'free' , s , options ); } /* \u76d1\u542csocket\u7a7a\u95f2\u4e8b\u4ef6\uff0c\u8c03\u7528\u65b9\u4f7f\u7528\u5b8csocket\u540e\u89e6\u53d1\uff0c \u901a\u77e5agent socket\u7528\u5b8c\u4e86 */ s . on ( 'free' , onFree ); function onClose ( err ) { agent . removeSocket ( s , options ); } // socket\u5173\u95ed\u5219agent\u4f1a\u4ecesocket\u961f\u5217\u4e2d\u5220\u9664\u5b83 s . on ( 'close' , onClose ); function onRemove () { agent . removeSocket ( s , options ); s . removeListener ( 'close' , onClose ); s . removeListener ( 'free' , onFree ); s . removeListener ( 'agentRemove' , onRemove ); } // agent\u88ab\u79fb\u9664 s . on ( 'agentRemove' , onRemove ); } \u521b\u5efasocket\u7684\u4e3b\u8981\u903b\u8f91\u5982\u4e0b 1 \u8c03\u7528net\u6a21\u5757\u521b\u5efa\u4e00\u4e2asocket\uff08TCP\u6216\u8005Unix\u57df\uff09\uff0c\u7136\u540e\u63d2\u5165\u4f7f\u7528\u4e2d\u7684socket\u961f\u5217\uff0c\u6700\u540e\u901a\u77e5\u8c03\u7528\u65b9socket\u521b\u5efa\u6210\u529f\u3002 2 \u76d1\u542csocket\u7684close\u3001free\u4e8b\u4ef6\u548cagentRemove\u4e8b\u4ef6\uff0c\u89e6\u53d1\u65f6\u4ece\u961f\u5217\u4e2d\u5220\u9664socket\u3002","title":"18.4.2 \u521b\u5efa\u4e00\u4e2asocket"},{"location":"chapter18-HTTP/#1843-socket","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // \u628asocket\u4ece\u6b63\u5728\u4f7f\u7528\u961f\u5217\u6216\u8005\u7a7a\u95f2\u961f\u5217\u4e2d\u79fb\u51fa function removeSocket ( s , options ) { const name = this . getName ( options ); const sets = [ this . sockets ]; /* socket\u4e0d\u53ef\u5199\u4e86\uff0c\u5219\u6709\u53ef\u80fd\u662f\u5b58\u5728\u7a7a\u95f2\u7684\u961f\u5217\u4e2d\uff0c \u6240\u4ee5\u9700\u8981\u904d\u5386\u7a7a\u95f2\u961f\u5217\uff0c\u56e0\u4e3aremoveSocket\u53ea\u4f1a\u5728 \u4f7f\u7528\u5b8csocket\u6216\u8005socket\u5173\u95ed\u7684\u65f6\u5019\u88ab\u8c03\u7528\uff0c\u524d\u8005\u53ea\u6709\u5728 \u53ef\u5199\u72b6\u6001\u65f6\u4f1a\u8c03\u7528\uff0c\u540e\u8005\u662f\u4e0d\u53ef\u5199\u7684 */ if ( ! s . writable ) sets . push ( this . freeSockets ); // \u4ece\u961f\u5217\u4e2d\u5220\u9664\u5bf9\u5e94\u7684socket for ( const sockets of sets ) { if ( sockets [ name ]) { const index = sockets [ name ]. indexOf ( s ); if ( index !== - 1 ) { sockets [ name ]. splice ( index , 1 ); // Don't leak if ( sockets [ name ]. length === 0 ) delete sockets [ name ]; } } } /* \u5982\u679c\u8fd8\u6709\u5728\u7b49\u5f85socekt\u7684\u8bf7\u6c42\uff0c\u5219\u521b\u5efasocket\u53bb\u5904\u7406\u5b83\uff0c \u56e0\u4e3asocket\u6570\u5df2\u7ecf\u51cf\u4e00\u4e86\uff0c\u8bf4\u660esocket\u4e2a\u6570\u8fd8\u6ca1\u6709\u8fbe\u5230\u9608\u503c \u4f46\u662f\u8fd9\u91cc\u5e94\u8be5\u5148\u5224\u65ad\u662f\u5426\u8fd8\u6709\u7a7a\u95f2\u7684socket\uff0c\u6709\u5219\u53ef\u4ee5\u590d\u7528\uff0c \u6ca1\u6709\u5219\u521b\u5efa\u65b0\u7684socket */ if ( this . requests [ name ] && this . requests [ name ]. length ) { const req = this . requests [ name ][ 0 ]; const socketCreationHandler = handleSocketCreation ( this , req , false ); this . createSocket ( req , options , socketCreationHandler ); } }; \u524d\u9762\u5df2\u7ecf\u5206\u6790\u8fc7\uff0cAgent\u7ef4\u62a4\u4e86\u4e24\u4e2asocket\u961f\u5217\uff0c\u5220\u9664socket\u5c31\u662f\u4ece\u8fd9\u4e24\u4e2a\u961f\u5217\u4e2d\u627e\u5230\u5bf9\u5e94\u7684socket\uff0c\u7136\u540e\u79fb\u9664\u5b83\u3002\u79fb\u9664\u540e\u9700\u8981\u5224\u65ad\u4e00\u4e0b\u662f\u5426\u8fd8\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u961f\u5217\uff0c\u6709\u7684\u8bdd\u5c31\u65b0\u5efa\u4e00\u4e2asocket\u53bb\u5904\u7406\u5b83\u3002\u56e0\u4e3a\u79fb\u9664\u4e86\u4e00\u4e2asocket\uff0c\u5c31\u8bf4\u660e\u53ef\u4ee5\u65b0\u589e\u4e00\u4e2asocket\u3002","title":"18.4.3 \u5220\u9664socket"},{"location":"chapter18-HTTP/#1844-socket-keepalive","text":"\u5f53socket\u88ab\u4f7f\u7528\u5b8c\u5e76\u4e14\u88ab\u63d2\u5165\u7a7a\u95f2\u961f\u5217\u540e\uff0c\u9700\u8981\u91cd\u65b0\u8bbe\u7f6esocket\u7684keepalive\u503c\u3002\u7b49\u5230\u8d85\u65f6\u4f1a\u81ea\u52a8\u5173\u95edsocket\u3002\u5728\u4e00\u4e2asocket\u4e0a\u8c03\u7528\u4e00\u6b21setKeepAlive\u5c31\u53ef\u4ee5\u4e86\uff0c\u8fd9\u91cc\u53ef\u80fd\u4f1a\u5bfc\u81f4\u591a\u6b21\u8c03\u7528setKeepAlive\uff0c\u4e0d\u8fc7\u4e5f\u6ca1\u6709\u5f71\u54cd\u3002 1 2 3 4 5 function keepSocketAlive ( socket ) { socket . setKeepAlive ( true , this . keepAliveMsecs ); socket . unref (); return true ; }; \u53e6\u5916\u9700\u8981\u8bbe\u7f6eref\u6807\u8bb0\uff0c\u9632\u6b62\u8be5socket\u963b\u6b62\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\uff0c\u56e0\u4e3a\u8be5socket\u662f\u7a7a\u95f2\u7684\uff0c\u4e0d\u5e94\u8be5\u5f71\u54cd\u4e8b\u4ef6\u5faa\u73af\u7684\u9000\u51fa\u3002","title":"18.4.4 \u8bbe\u7f6esocket keepalive"},{"location":"chapter18-HTTP/#1845-socket","text":"1 2 3 4 function reuseSocket ( socket , req ) { req . reusedSocket = true ; socket . ref (); }; \u91cd\u65b0\u4f7f\u7528\u8be5socket\uff0c\u9700\u8981\u4fee\u6539ref\u6807\u8bb0\uff0c\u963b\u6b62\u4e8b\u4ef6\u5faa\u73af\u9000\u51fa\uff0c\u5e76\u6807\u8bb0\u8bf7\u6c42\u4f7f\u7528\u7684\u662f\u590d\u7528socket\u3002","title":"18.4.5 \u590d\u7528socket"},{"location":"chapter18-HTTP/#1846-agent","text":"1 2 3 4 5 6 7 8 9 function destroy () { for ( const set of [ this . freeSockets , this . sockets ]) { for ( const key of ObjectKeys ( set )) { for ( const setName of set [ key ]) { setName . destroy (); } } } }; \u56e0\u4e3aAgent\u672c\u8d28\u4e0a\u662f\u4e00\u4e2asocket\u6c60\uff0c\u9500\u6bc1Agent\u5373\u9500\u6bc1\u6c60\u91cc\u7ef4\u62a4\u7684\u6240\u6709socket\u3002","title":"18.4.6 \u9500\u6bc1Agent"},{"location":"chapter18-HTTP/#1847","text":"\u6211\u4eec\u770b\u4e00\u4e0b\u5982\u4f55\u4f7f\u7528Agent\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 function addRequest ( req , options , port , localAddress ) { // \u53c2\u6570\u5904\u7406 if ( typeof options === 'string' ) { options = { host : options , port , localAddress }; } options = { ... options , ... this . options }; if ( options . socketPath ) options . path = options . socketPath ; if ( ! options . servername && options . servername !== '' ) options . servername = calculateServerName ( options , req ); // \u62ff\u5230\u8bf7\u6c42\u5bf9\u5e94\u7684key const name = this . getName ( options ); // \u8be5key\u8fd8\u6ca1\u6709\u5728\u4f7f\u7528\u7684socekt\u5219\u521d\u59cb\u5316\u6570\u636e\u7ed3\u6784 if ( ! this . sockets [ name ]) { this . sockets [ name ] = []; } // \u8be5key\u5bf9\u5e94\u7684\u7a7a\u95f2socket\u5217\u8868 const freeLen = this . freeSockets [ name ] ? this . freeSockets [ name ]. length : 0 ; // \u8be5key\u5bf9\u5e94\u7684\u6240\u6709socket\u4e2a\u6570 const sockLen = freeLen + this . sockets [ name ]. length ; // \u8be5key\u6709\u5bf9\u5e94\u7684\u7a7a\u95f2socekt if ( freeLen ) { // \u83b7\u53d6\u4e00\u4e2a\u8be5key\u5bf9\u5e94\u7684\u7a7a\u95f2socket const socket = this . freeSockets [ name ]. shift (); // \u53d6\u5b8c\u4e86\u5220\u9664\uff0c\u9632\u6b62\u5185\u5b58\u6cc4\u6f0f if ( ! this . freeSockets [ name ]. length ) delete this . freeSockets [ name ]; // \u8bbe\u7f6eref\u6807\u8bb0\uff0c\u56e0\u4e3a\u6b63\u5728\u4f7f\u7528\u8be5socket this . reuseSocket ( socket , req ); // \u8bbe\u7f6e\u8bf7\u6c42\u5bf9\u5e94\u7684socket setRequestSocket ( this , req , socket ); // \u63d2\u5165\u6b63\u5728\u4f7f\u7528\u7684socket\u961f\u5217 this . sockets [ name ]. push ( socket ); } else if ( sockLen < this . maxSockets ) { /* \u5982\u679c\u8be5key\u6ca1\u6709\u5bf9\u5e94\u7684\u7a7a\u95f2socket\u5e76\u4e14\u4f7f\u7528\u7684 socket\u4e2a\u6570\u8fd8\u6ca1\u6709\u5f97\u5230\u9608\u503c\uff0c\u5219\u7ee7\u7eed\u521b\u5efa */ this . createSocket ( req , options , handleSocketCreation ( this , req , true )); } else { // \u7b49\u5f85\u8be5key\u4e0b\u6709\u7a7a\u95f2\u7684socket if ( ! this . requests [ name ]) { this . requests [ name ] = []; } this . requests [ name ]. push ( req ); } } \u5f53\u6211\u4eec\u9700\u8981\u53d1\u9001\u4e00\u4e2aHTTP\u8bf7\u6c42\u7684\u65f6\u5019\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7Agent\u7684addRequest\u65b9\u6cd5\u628a\u8bf7\u6c42\u6258\u7ba1\u5230Agent\u4e2d\uff0c\u5f53\u6709\u53ef\u7528\u7684socket\u65f6\uff0cAgent\u4f1a\u901a\u77e5\u6211\u4eec\u3002addRequest\u7684\u4ee3\u7801\u5f88\u957f\uff0c\u4e3b\u8981\u5206\u4e3a\u4e09\u79cd\u60c5\u51b5\u3002 1 \u6709\u7a7a\u95f2socket\uff0c\u5219\u76f4\u63a5\u590d\u7528\uff0c\u5e76\u63d2\u5165\u6b63\u5728\u4f7f\u7528\u7684socket\u961f\u5217\u4e2d \u6211\u4eec\u4e3b\u8981\u770b\u4e00\u4e0bsetRequestSocket\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function setRequestSocket ( agent , req , socket ) { // \u901a\u77e5\u8bf7\u6c42socket\u521b\u5efa\u6210\u529f req . onSocket ( socket ); const agentTimeout = agent . options . timeout || 0 ; if ( req . timeout === undefined || req . timeout === agentTimeout ) { return ; } // \u5f00\u542f\u4e00\u4e2a\u5b9a\u65f6\u5668\uff0c\u8fc7\u671f\u540e\u89e6\u53d1timeout\u4e8b\u4ef6 socket . setTimeout ( req . timeout ); /* \u76d1\u542c\u54cd\u5e94\u4e8b\u4ef6\uff0c\u54cd\u5e94\u7ed3\u675f\u540e\u9700\u8981\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\uff0c \u5f00\u542f\u4e0b\u4e00\u4e2a\u8bf7\u6c42\u7684\u8d85\u65f6\u8ba1\u7b97\uff0c\u5426\u5219\u4f1a\u63d0\u524d\u8fc7\u671f */ req . once ( 'response' , ( res ) => { res . once ( 'end' , () => { if ( socket . timeout !== agentTimeout ) { socket . setTimeout ( agentTimeout ); } }); }); } setRequestSocket\u51fd\u6570\u901a\u8fc7req.onSocket(socket)\u901a\u77e5\u8c03\u7528\u65b9\u6709\u53ef\u7528socket\u3002\u7136\u540e\u5982\u679c\u8bf7\u6c42\u8bbe\u7f6e\u4e86\u8d85\u65f6\u65f6\u95f4\u5219\u8bbe\u7f6esocket\u7684\u8d85\u65f6\u65f6\u95f4\uff0c\u5373\u8bf7\u6c42\u7684\u8d85\u65f6\u65f6\u95f4\u3002\u6700\u540e\u76d1\u542c\u54cd\u5e94\u7ed3\u675f\u4e8b\u4ef6\uff0c\u91cd\u65b0\u8bbe\u7f6e\u8d85\u65f6\u65f6\u95f4\u3002 2 \u6ca1\u6709\u7a7a\u95f2socket\uff0c\u4f46\u662f\u4f7f\u7528\u7684socket\u4e2a\u6570\u8fd8\u6ca1\u6709\u8fbe\u5230\u9608\u503c\uff0c\u5219\u521b\u5efa\u65b0\u7684socket\u3002 \u6211\u4eec\u4e3b\u8981\u5206\u6790\u521b\u5efasocket\u540e\u7684\u56de\u8c03handleSocketCreation\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function handleSocketCreation ( agent , request , informRequest ) { return function handleSocketCreation_Inner ( err , socket ) { if ( err ) { process . nextTick ( emitErrorNT , request , err ); return ; } /* \u662f\u5426\u9700\u8981\u76f4\u63a5\u901a\u77e5\u8bf7\u6c42\u65b9\uff0c\u8fd9\u65f6\u5019request\u4e0d\u662f\u6765\u81ea\u7b49\u5f85 socket\u7684requests\u961f\u5217\uff0c \u800c\u662f\u6765\u81ea\u8c03\u7528\u65b9\uff0c\u89c1addRequest */ if ( informRequest ) setRequestSocket ( agent , request , socket ); else /* \u4e0d\u76f4\u63a5\u901a\u77e5\uff0c\u5148\u544a\u8bc9agent\u6709\u7a7a\u95f2\u7684socket\uff0c agent\u4f1a\u5224\u65ad\u662f\u5426\u6709\u6b63\u5728\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u6709\u5219\u5904\u7406 */ socket . emit ( 'free' ); }; } 3 \u4e0d\u6ee1\u8db31,2\uff0c\u5219\u628a\u8bf7\u6c42\u63d2\u5165\u7b49\u5f85socket\u961f\u5217\u3002 \u63d2\u5165\u7b49\u5f85socket\u961f\u5217\u540e\uff0c\u5f53\u6709socket\u7a7a\u95f2\u65f6\u4f1a\u89e6\u53d1free\u4e8b\u4ef6\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8be5\u4e8b\u4ef6\u7684\u5904\u7406\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // \u76d1\u542csocket\u7a7a\u95f2\u4e8b\u4ef6 this . on ( 'free' , ( socket , options ) => { const name = this . getName ( options ); // socket\u8fd8\u53ef\u5199\u5e76\u4e14\u8fd8\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u5219\u590d\u7528socket if ( socket . writable && this . requests [ name ] && this . requests [ name ]. length ) { // \u62ff\u5230\u4e00\u4e2a\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u7136\u540e\u901a\u77e5\u5b83\u6709socket\u53ef\u7528 const req = this . requests [ name ]. shift (); setRequestSocket ( this , req , socket ); // \u6ca1\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u5219\u5220\u9664\uff0c\u9632\u6b62\u5185\u5b58\u6cc4\u6f0f if ( this . requests [ name ]. length === 0 ) { // don't leak delete this . requests [ name ]; } } else { // socket\u4e0d\u53ef\u7528\u5199\u6216\u8005\u6ca1\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\u4e86 const req = socket . _httpMessage ; // socket\u53ef\u5199\u5e76\u4e14\u8bf7\u6c42\u8bbe\u7f6e\u4e86\u5141\u8bb8\u4f7f\u7528\u590d\u7528\u7684socket if ( req && req . shouldKeepAlive && socket . writable && this . keepAlive ) { let freeSockets = this . freeSockets [ name ]; // \u8be5key\u4e0b\u5f53\u524d\u7684\u7a7a\u95f2socket\u4e2a\u6570 const freeLen = freeSockets ? freeSockets . length : 0 ; let count = freeLen ; // \u6b63\u5728\u4f7f\u7528\u7684socket\u4e2a\u6570 if ( this . sockets [ name ]) count += this . sockets [ name ]. length ; /* \u8be5key\u4f7f\u7528\u7684socket\u4e2a\u6570\u8fbe\u5230\u9608\u503c\u6216\u8005\u7a7a\u95f2socket\u8fbe\u5230\u9608\u503c\uff0c \u5219\u4e0d\u590d\u7528socket\uff0c\u76f4\u63a5\u9500\u6bc1socket */ if ( count > this . maxSockets || freeLen >= this . maxFreeSockets ) { socket . destroy (); } else if ( this . keepSocketAlive ( socket )) { /* \u91cd\u65b0\u8bbe\u7f6esocket\u7684\u5b58\u6d3b\u65f6\u95f4\uff0c\u8bbe\u7f6e\u5931\u8d25\u8bf4\u660e\u65e0\u6cd5\u91cd\u65b0\u8bbe\u7f6e\u5b58\u6d3b\u65f6 \u95f4\uff0c\u5219\u8bf4\u660e\u53ef\u80fd\u4e0d\u652f\u6301\u590d\u7528 */ freeSockets = freeSockets || []; this . freeSockets [ name ] = freeSockets ; socket [ async_id_symbol ] = - 1 ; socket . _httpMessage = null ; // \u628asocket\u4ece\u6b63\u5728\u4f7f\u7528\u961f\u5217\u4e2d\u79fb\u9664 this . removeSocket ( socket , options ); // \u63d2\u5165socket\u7a7a\u95f2\u961f\u5217 freeSockets . push ( socket ); } else { // \u4e0d\u590d\u7528\u5219\u76f4\u63a5\u9500\u6bc1 socket . destroy (); } } else { socket . destroy (); } } }); \u5f53\u6709socket\u7a7a\u95f2\u65f6\uff0c\u5206\u4e3a\u4ee5\u4e0b\u51e0\u79cd\u60c5\u51b5 1 \u5982\u679c\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u5219\u76f4\u63a5\u590d\u7528socket\u3002 2 \u5982\u679c\u6ca1\u6709\u7b49\u5f85socket\u7684\u8bf7\u6c42\uff0c\u5141\u8bb8\u590d\u7528\u5e76\u4e14socket\u4e2a\u6570\u6ca1\u6709\u8fbe\u5230\u9608\u503c\u5219\u63d2\u5165\u7a7a\u95f2\u961f\u5217\u3002 3 \u76f4\u63a5\u9500\u6bc1","title":"18.4.7 \u4f7f\u7528\u8fde\u63a5\u6c60"},{"location":"chapter18-HTTP/#1848","text":"\u5ba2\u6237\u7aef 1 2 3 4 5 6 7 const http = require ( 'http' ); const keepAliveAgent = new http . Agent ({ keepAlive : true , maxSockets : 1 }); const options = { port : 10000 , method : 'GET' , host : '127.0.0.1' ,} options . agent = keepAliveAgent ; http . get ( options , () => {}); http . get ( options , () => {}); console . log ( options . agent . requests ) \u670d\u52a1\u5668 1 2 3 4 5 let i = 0 ; const net = require ( 'net' ); net . createServer (( socket ) => { console . log ( ++ i ); }). listen ( 10000 ); \u5728\u4f8b\u5b50\u4e2d\uff0c\u9996\u5148\u521b\u5efa\u4e86\u4e00\u4e2atcp\u670d\u52a1\u5668\u3002\u7136\u540e\u5728\u5ba2\u6237\u7aef\u4f7f\u7528agent\u3002\u4f46\u662fmaxSocket\u7684\u503c\u4e3a1\uff0c\u4ee3\u8868\u6700\u591a\u53ea\u80fd\u6709\u4e00\u4e2asocket\uff0c\u800c\u8fd9\u65f6\u5019\u5ba2\u6237\u7aef\u53d1\u9001\u4e24\u4e2a\u8bf7\u6c42\uff0c\u6240\u4ee5\u6709\u4e00\u4e2a\u8bf7\u6c42\u5c31\u4f1a\u5728\u6392\u961f\u3002\u670d\u52a1\u5668\u4e5f\u53ea\u6536\u5230\u4e86\u4e00\u4e2a\u8fde\u63a5\u3002","title":"18.4.8 \u6d4b\u8bd5\u4f8b\u5b50"},{"location":"chapter19-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD/","text":"Node.js\u7684\u6a21\u5757\u5206\u4e3a\u7528\u6237JS\u6a21\u5757\u3001Node.js\u539f\u751fJS\u6a21\u5757\u3001Node.js\u5185\u7f6eC++\u6a21\u5757\u3002\u672c\u7ae0\u4ecb\u7ecd\u8fd9\u4e9b\u6a21\u5757\u52a0\u8f7d\u7684\u539f\u7406\u4ee5\u53caNode.js\u4e2d\u6a21\u5757\u52a0\u8f7d\u5668\u7684\u7c7b\u578b\u548c\u539f\u7406\u3002 \u4e0b\u9762\u6211\u4eec\u4ee5\u4e00\u4e2a\u4f8b\u5b50\u4e3a\u5f00\u59cb\uff0c\u5206\u6790Node.js\u4e2d\u6a21\u5757\u52a0\u8f7d\u7684\u539f\u7406\u3002\u5047\u8bbe\u6211\u4eec\u6709\u4e00\u4e2a\u6587\u4ef6demo.js\uff0c\u4ee3\u7801\u5982\u4e0b 1 2 const myjs = require ( \u2018 myjs ); const net = require ( \u2018 net \u2019 ); \u5176\u4e2dmyjs\u7684\u4ee3\u7801\u5982\u4e0b 1 exports . hello = \u2018 world \u2019 ; \u6211\u4eec\u770b\u4e00\u4e0b\u6267\u884cnode demo.js\u7684\u65f6\u5019\uff0c\u8fc7\u7a0b\u662f\u600e\u6837\u7684\u3002\u5728Node.js\u542f\u52a8\u7ae0\u8282\u6211\u4eec\u5206\u6790\u8fc7\uff0cNode.js\u542f\u52a8\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884c\u4ee5\u4e0b\u4ee3\u7801\u3002 require('internal/modules/cjs/loader').Module.runMain(process.argv[1]) \u5176\u4e2drunMain\u51fd\u6570\u5728pre_execution.js\u7684initializeCJSLoader\u4e2d\u6302\u8f7d 1 2 3 4 5 6 function initializeCJSLoader () { const CJSLoader = require ( 'internal/modules/cjs/loader' ); CJSLoader . Module . _initPaths (); CJSLoader . Module . runMain = require ( 'internal/modules/run_main' ). executeUserEntryPoint ; } \u6211\u4eec\u770b\u5230runMain\u662frun_main.js\u5bfc\u51fa\u7684\u51fd\u6570\u3002\u7ee7\u7eed\u5f80\u4e0b\u770b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const CJSLoader = require ( 'internal/modules/cjs/loader' ); const { Module } = CJSLoader ; function executeUserEntryPoint ( main = process . argv [ 1 ]) { const resolvedMain = resolveMainPath ( main ); const useESMLoader = shouldUseESMLoader ( resolvedMain ); if ( useESMLoader ) { runMainESM ( resolvedMain || main ); } else { Module . _load ( main , null , true ); } } module . exports = { executeUserEntryPoint }; process.argv[1]\u5c31\u662f\u6211\u4eec\u8981\u6267\u884c\u7684JS\u6587\u4ef6\u3002\u6700\u540e\u901a\u8fc7cjs/loader.js\u7684Module._load\u52a0\u8f7d\u4e86\u6211\u4eec\u7684JS\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5904\u7406\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Module . _load = function ( request , parent , isMain ) { const filename = Module . _resolveFilename ( request , parent , isMain ); const cachedModule = Module . _cache [ filename ]; // \u6709\u7f13\u5b58\u5219\u76f4\u63a5\u8fd4\u56de if ( cachedModule !== undefined ) { updateChildren ( parent , cachedModule , true ); if ( ! cachedModule . loaded ) return getExportsForCircularRequire ( cachedModule ); return cachedModule . exports ; } // \u662f\u5426\u662f\u53ef\u8bbf\u95ee\u7684\u539f\u751fJS\u6a21\u5757\uff0c\u662f\u5219\u8fd4\u56de const mod = loadNativeModule ( filename , request ); if ( mod && mod . canBeRequiredByUsers ) return mod . exports ; // \u975e\u539f\u751fJS\u6a21\u5757\uff0c\u5219\u65b0\u5efa\u4e00\u4e2aModule\u8868\u793a\u52a0\u8f7d\u7684\u6a21\u5757 const module = new Module ( filename , parent ); // \u7f13\u5b58 Module . _cache [ filename ] = module ; // \u52a0\u8f7d module . load ( filename ); // \u8c03\u7528\u65b9\u62ff\u5230\u7684\u662fmodule.exports\u7684\u503c return module . exports ; }; _load\u51fd\u6570\u4e3b\u8981\u662f\u4e09\u4e2a\u903b\u8f91 1 \u5224\u65ad\u662f\u5426\u6709\u7f13\u5b58\uff0c\u6709\u5219\u8fd4\u56de\u3002 2 \u6ca1\u6709\u7f13\u5b58\uff0c\u5219\u5224\u65ad\u662f\u5426\u662f\u539f\u751fJS\u6a21\u5757\uff0c\u662f\u5219\u4ea4\u7ed9\u539f\u751f\u6a21\u5757\u5904\u7406\u3002 1 \u4e0d\u662f\u539f\u751f\u6a21\u5757\uff0c\u5219\u65b0\u5efa\u4e00\u4e2aModule\u8868\u793a\u7528\u6237\u7684JS\u6a21\u5757\uff0c\u7136\u540e\u6267\u884cload\u51fd\u6570\u52a0\u8f7d\u3002 \u8fd9\u91cc\u6211\u4eec\u53ea\u9700\u8981\u5173\u6ce83\u7684\u903b\u8f91\uff0c\u5728Node.js\u4e2d\uff0c\u7528\u6237\u5b9a\u4e49\u7684\u6a21\u5757\u4f7f\u7528Module\u8868\u793a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function Module ( id = '' , parent ) { // \u6a21\u5757\u5bf9\u5e94\u7684\u6587\u4ef6\u8def\u5f84 this . id = id ; this . path = path . dirname ( id ); // \u5728\u6a21\u5757\u91cc\u4f7f\u7528\u7684exports\u53d8\u91cf this . exports = {}; this . parent = parent ; // \u52a0\u5165\u7236\u6a21\u5757\u7684children\u961f\u5217 updateChildren ( parent , this , false ); this . filename = null ; // \u662f\u5426\u5df2\u7ecf\u52a0\u8f7d this . loaded = false ; this . children = []; } \u63a5\u7740\u770b\u4e00\u4e0bload\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 Module . prototype . load = function ( filename ) { this . filename = filename ; // \u62d3\u5c55\u540d const extension = findLongestRegisteredExtension ( filename ); // \u6839\u636e\u62d3\u5c55\u540d\u4f7f\u7528\u4e0d\u540c\u7684\u52a0\u8f7d\u65b9\u5f0f Module . _extensions [ extension ]( this , filename ); this . loaded = true ; }; Node.js\u4f1a\u6839\u636e\u4e0d\u540c\u7684\u6587\u4ef6\u62d3\u5c55\u540d\u4f7f\u7528\u4e0d\u540c\u7684\u51fd\u6570\u5904\u7406\u3002 19.1 \u52a0\u8f7d\u7528\u6237\u6a21\u5757 \u00b6 \u5728Node.js\u4e2d_extensions\u6709\u4e09\u79cd\uff0c\u5206\u522b\u662fjs\u3001json\u3001node\u3002 19.1.1 \u52a0\u8f7dJSON\u6a21\u5757 \u00b6 \u52a0\u8f7dJSON\u6a21\u5757\u662f\u6bd4\u8f83\u7b80\u5355\u7684 1 2 3 4 5 6 7 8 9 10 Module . _extensions [ '.json' ] = function ( module , filename ) { const content = fs . readFileSync ( filename , 'utf8' ); try { module . exports = JSONParse ( stripBOM ( content )); } catch ( err ) { err . message = filename + ': ' + err . message ; throw err ; } }; \u76f4\u63a5\u8bfb\u53d6JSON\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u7136\u540e\u89e3\u6790\u6210\u5bf9\u8c61\u5c31\u884c\u3002 19.1.2 \u52a0\u8f7dJS\u6a21\u5757 \u00b6 1 2 3 4 Module . _extensions [ '.js' ] = function ( module , filename ) { const content = fs . readFileSync ( filename , 'utf8' ); module . _compile ( content , filename ); }; \u8bfb\u5b8c\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u7136\u540e\u6267\u884c_compile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Module . prototype . _compile = function ( content , filename ) { // \u751f\u6210\u4e00\u4e2a\u51fd\u6570 const compiledWrapper = wrapSafe ( filename , content , this ); const dirname = path . dirname ( filename ); // require\u662f\u5bf9_load\u51fd\u6570\u7684\u5c01\u88c5 const require = ( path ) => { return this . require ( path ); }; let result ; // \u6211\u4eec\u5e73\u65f6\u4f7f\u7528\u7684exports\u53d8\u91cf const exports = this . exports ; const thisValue = exports ; // \u6211\u4eec\u5e73\u65f6\u4f7f\u7528\u7684module\u53d8\u91cf const module = this ; // \u6267\u884c\u51fd\u6570 result = compiledWrapper . call ( thisValue , exports , require , module , filename , dirname ); return result ; } _compile\u91cc\u9762\u5305\u62ec\u4e86\u51e0\u4e2a\u91cd\u8981\u7684\u903b\u8f91 1 wrapSafe\uff1a\u5305\u88f9\u6211\u4eec\u7684\u4ee3\u7801\u5e76\u751f\u6210\u4e00\u4e2a\u51fd\u6570 2 require\uff1a\u652f\u6301\u5728\u6a21\u5757\u5185\u52a0\u8f7d\u5176\u4ed6\u6a21\u5757 3 \u6267\u884c\u6a21\u5757\u4ee3\u7801 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e09\u4e2a\u903b\u8f91\u3002 1 wrapSafe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function wrapSafe ( filename , content , cjsModuleInstance ) { const wrapper = Module . wrap ( content ); return vm . runInThisContext ( wrapper , { filename , lineOffset : 0 , ... }); } const wrapper = [ '(function (exports, require, module, __filename, __dirname) { ' , '\\n});' ]; Module . wrap = function ( script ) { return Module . wrapper [ 0 ] + script + Module . wrapper [ 1 ]; }; vm.runInThisContext\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u201d(function() {})\u201d\u7684\u65f6\u5019\uff0c\u4f1a\u8fd4\u56de\u4e00\u4e2a\u51fd\u6570\u3002\u6240\u4ee5\u6267\u884cModule.wrap\u540e\u4f1a\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u5185\u5bb9\u5982\u4e0b 1 2 3 ( function ( exports , require , module , __filename , __dirname ) { // }); \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0brequire\u51fd\u6570\uff0c\u5373\u6211\u4eec\u5e73\u65f6\u5728\u4ee3\u7801\u4e2d\u4f7f\u7528\u7684require\u3002 2 require 1 2 3 4 5 6 7 8 Module . prototype . require = function ( id ) { requireDepth ++ ; try { return Module . _load ( id , this , /* isMain */ false ); } finally { requireDepth -- ; } }; require\u662f\u5bf9Module._load\u7684\u5c01\u88c5\uff0cModule._load\u4f1a\u628a\u6a21\u5757\u5bfc\u51fa\u7684\u53d8\u91cf\u901a\u8fc7module.exports\u5c5e\u6027\u8fd4\u56de\u7ed9require\u8c03\u7528\u65b9\u3002\u56e0\u4e3aModule._load\u53ea\u4f1a\u4ece\u539f\u751fJS\u6a21\u5757\u548c\u7528\u6237JS\u6a21\u5757\u4e2d\u67e5\u627e\u7528\u6237\u9700\u8981\u52a0\u8f7d\u7684\u6a21\u5757\uff0c\u6240\u4ee5\u662f\u65e0\u6cd5\u8bbf\u95eeC++\u6a21\u5757\u7684\uff0c\u8bbf\u95eeC++\u6a21\u5757\u53ef\u7528process.bindng\u6216internalBinding\u3002 3 \u6267\u884c\u4ee3\u7801 \u6211\u4eec\u56de\u5230_compile\u51fd\u6570\u3002\u770b\u4e00\u4e0b\u6267\u884cvm.runInThisContext\u8fd4\u56de\u7684\u51fd\u6570\u3002 1 2 3 4 5 6 compiledWrapper . call ( exports , exports , require , module , filename , dirname ); \u76f8\u5f53\u4e8e\u6267\u884c\u4ee5\u4e0b\u4ee3\u7801 1 2 3 4 ( function ( exports , require , module , __filename , __dirname ) { const myjs = require ( \u2018 myjs ); const net = require ( \u2018 net \u2019 ); }); \u81f3\u6b64\uff0cNode.js\u5f00\u59cb\u6267\u884c\u7528\u6237\u7684JS\u4ee3\u7801\u3002\u521a\u624d\u6211\u4eec\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7require\u662f\u5bf9Module._load\u7684\u5c01\u88c5\uff0c\u5f53\u6267\u884crequire\u52a0\u8f7d\u7528\u6237\u6a21\u5757\u65f6\uff0c\u53c8\u56de\u5230\u4e86\u6211\u4eec\u6b63\u5728\u5206\u6790\u7684\u8fd9\u4e2a\u8fc7\u7a0b\u3002 19.1.3 \u52a0\u8f7dnode\u6a21\u5757 \u00b6 Node\u62d3\u5c55\u7684\u6a21\u5757\u672c\u8d28\u4e0a\u662f\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u6211\u4eec\u770brequire\u4e00\u4e2a.node\u6a21\u5757\u7684\u65f6\u5019\u7684\u8fc7\u7a0b\u3002\u6211\u4eec\u4ece\u52a0\u8f7d.node\u6a21\u5757\u7684\u6e90\u7801\u5f00\u59cb\u3002 1 2 3 4 Module . _extensions [ '.node' ] = function ( module , filename ) { // ... return process . dlopen ( module , path . toNamespacedPath ( filename )); }; \u76f4\u63a5\u8c03\u4e86process.dlopen\uff0c\u8be5\u51fd\u6570\u5728node.js\u91cc\u5b9a\u4e49\u3002 1 2 const rawMethods = internalBinding ( 'process_methods' ); process . dlopen = rawMethods . dlopen ; \u627e\u5230process_methods\u6a21\u5757\u5bf9\u5e94\u7684\u662fnode_process_methods.cc\u3002 1 env -> SetMethod ( target , \"dlopen\" , binding :: DLOpen ); \u4e4b\u524d\u8bf4\u8fc7\uff0cNode.js\u7684\u62d3\u5c55\u6a21\u5757\u5176\u5b9e\u662f\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u90a3\u4e48\u6211\u4eec\u5148\u770b\u770b\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\u6211\u4eec\u662f\u5982\u4f55\u4f7f\u7528\u7684\u3002\u4ee5\u4e0b\u662f\u793a\u4f8b\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <stdio.h> #include <stdlib.h> #include <dlfcn.h> int main (){ // \u6253\u5f00\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u62ff\u5230\u4e00\u4e2ahandler handler = dlopen ( ' xxx . so ' , RTLD_LAZY ); // \u53d6\u51fa\u52a8\u6001\u94fe\u63a5\u5e93\u91cc\u7684\u51fd\u6570add add = dlsym ( handler , \"add\" ); // \u6267\u884c printf ( \"%d\" , add ( 1 , 1 )); dlclose ( handler ); return 0 ; } \u4e86\u89e3\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u4f7f\u7528\uff0c\u6211\u4eec\u7ee7\u7eed\u5206\u6790\u521a\u624d\u770b\u5230\u7684DLOpen\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void DLOpen ( const FunctionCallbackInfo < Value >& args ) { int32_t flags = DLib :: kDefaultFlags ; node :: Utf8Value filename ( env -> isolate (), args [ 1 ]); // Cast env -> TryLoadAddon ( * filename , flags , [ & ]( DLib * dlib ) { const bool is_opened = dlib -> Open (); node_module * mp = thread_local_modpending ; thread_local_modpending = nullptr ; // \u7701\u7565\u90e8\u5206\u4ee3\u7801 if ( mp -> nm_context_register_func != nullptr ) { mp -> nm_context_register_func ( exports , module , context , mp -> nm_priv ); } else if ( mp -> nm_register_func != nullptr ) { mp -> nm_register_func ( exports , module , mp -> nm_priv ); } return true ; }); } \u6211\u4eec\u770b\u5230\u91cd\u70b9\u662fTryLoadAddon\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u7684\u903b\u8f91\u5c31\u662f\u6267\u884c\u5b83\u7684\u7b2c\u4e09\u4e2a\u53c2\u6570\u3002\u6211\u4eec\u53d1\u73b0\u7b2c\u4e09\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u51fd\u6570\uff0c\u5165\u53c2\u662fDLib\u5bf9\u8c61\u3002\u6240\u4ee5\u6211\u4eec\u5148\u770b\u770b\u8fd9\u4e2a\u7c7b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 class DLib { public : static const int kDefaultFlags = RTLD_LAZY ; DLib ( const char * filename , int flags ); bool Open (); void Close (); const std :: string filename_ ; const int flags_ ; std :: string errmsg_ ; void * handle_ ; uv_lib_t lib_ ; }; \u518d\u770b\u4e00\u4e0b\u5b9e\u73b0\u3002 1 2 3 4 5 6 bool DLib::Open () { handle_ = dlopen ( filename_ . c_str (), flags_ ); if ( handle_ != nullptr ) return true ; errmsg_ = dlerror (); return false ; } DLib\u5c31\u662f\u5bf9\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u4e00\u4e2a\u5c01\u88c5\uff0c\u5b83\u5c01\u88c5\u4e86\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u6587\u4ef6\u540d\u548c\u64cd\u4f5c\u3002TryLoadAddon\u51fd\u6570\u9996\u5148\u6839\u636erequire\u4f20\u5165\u7684\u6587\u4ef6\u540d\uff0c\u6784\u9020\u4e00\u4e2aDLib\uff0c\u7136\u540e\u6267\u884c 1 const bool is_opened = dlib -> Open (); Open\u51fd\u6570\u6253\u5f00\u4e86\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u8981\u5148\u4e86\u89e3\u4e00\u4e0b\u6253\u5f00\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\u7a76\u7adf\u53d1\u751f\u4e86\u4ec0\u4e48\u3002\u9996\u5148\u6211\u4eec\u4e00\u822cC++\u63d2\u4ef6\u6700\u540e\u4e00\u53e5\u4ee3\u7801\u7684\u5b9a\u4e49\u3002 1 NAPI_MODULE ( NODE_GYP_MODULE_NAME , init ) \u8fd9\u662f\u4e2a\u5b8f\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #define NAPI_MODULE(modname, regfunc) \\ NAPI_MODULE_X ( modname , regfunc , NULL , 0 ) #define NAPI_MODULE_X(modname, regfunc, priv, flags) \\ static napi_module _module = \\ { \\ NAPI_MODULE_VERSION , \\ flags , \\ __FILE__ , \\ regfunc , \\ #modname, \\ priv , \\ { 0 }, \\ }; \\ static void _register_modname ( void ) __attribute__ (( constructor )); \\ static void _register_modname ( void ) { \\ napi_module_register ( & _module ); \\ } \u6240\u4ee5\u4e00\u4e2anode\u6269\u5c55\u5c31\u662f\u5b9a\u4e49\u4e86\u4e00\u4e2anapi_module\u6a21\u5757\u548c\u4e00\u4e2aregister_modname\uff08modname\u662f\u6211\u4eec\u5b9a\u4e49\u7684\uff09\u51fd\u6570\u3002__attribute((constructor))\u662f\u4ee3\u8868\u8be5\u51fd\u6570\u4f1a\u5148\u6267\u884c\u7684\u610f\u601d\uff0c\u5177\u4f53\u53ef\u4ee5\u67e5\u9605\u6587\u6863\u3002\u770b\u5230\u8fd9\u91cc\u6211\u4eec\u77e5\u9053\uff0c\u5f53\u6211\u4eec\u6253\u5f00\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884c_register_modname\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u6267\u884c\u7684\u662f 1 napi_module_register ( & _module ); \u6211\u4eec\u7ee7\u7eed\u5c55\u5f00\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Registers a NAPI module. void napi_module_register ( napi_module * mod ) { node :: node_module * nm = new node :: node_module { -1 , mod -> nm_flags | NM_F_DELETEME , nullptr , mod -> nm_filename , nullptr , napi_module_register_cb , mod -> nm_modname , mod , // priv nullptr , }; node :: node_module_register ( nm ); } Node.js\u628anapi\u6a21\u5757\u8f6c\u6210node_module\u3002\u6700\u540e\u8c03\u7528node_module_register\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 extern \"C\" void node_module_register ( void * m ) { struct node_module * mp = reinterpret_cast < struct node_module *> ( m ); if ( mp -> nm_flags & NM_F_INTERNAL ) { mp -> nm_link = modlist_internal ; modlist_internal = mp ; } else if ( ! node_is_initialized ) { mp -> nm_flags = NM_F_LINKED ; mp -> nm_link = modlist_linked ; modlist_linked = mp ; } else { thread_local_modpending = mp ; } } napi\u6a21\u5757\u4e0d\u662fNM_F_INTERNAL\u6a21\u5757\uff0cnode_is_initialized\u662f\u5728Node.js\u521d\u59cb\u5316\u65f6\u8bbe\u7f6e\u7684\u53d8\u91cf\uff0c\u8fd9\u65f6\u5019\u5df2\u7ecf\u662ftrue\u3002\u6240\u4ee5\u6ce8\u518cnapi\u6a21\u5757\u65f6\uff0c\u4f1a\u6267\u884cthread_local_modpending = mp\u3002thread_local_modpending \u7c7b\u4f3c\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf\uff0c\u4fdd\u5b58\u5f53\u524d\u52a0\u8f7d\u7684\u6a21\u5757\u3002\u5206\u6790\u5230\u8fd9\uff0c\u6211\u4eec\u56de\u5230DLOpen\u51fd\u6570\u3002 1 2 node_module * mp = thread_local_modpending ; thread_local_modpending = nullptr ; \u8fd9\u65f6\u5019\u6211\u4eec\u5c31\u77e5\u9053\u521a\u624d\u90a3\u4e2a\u53d8\u91cfthread_local_modpending\u7684\u4f5c\u7528\u4e86\u3002node_module* mp = thread_local_modpending\u540e\u6211\u4eec\u62ff\u5230\u4e86\u6211\u4eec\u521a\u624d\u5b9a\u4e49\u7684napi\u6a21\u5757\u7684\u4fe1\u606f\u3002\u63a5\u7740\u6267\u884cnode_module\u7684\u51fd\u6570nm_register_func\u3002 1 2 3 4 5 6 7 8 if ( mp -> nm_context_register_func != nullptr ) { mp -> nm_context_register_func ( exports , module , context , mp -> nm_priv ); } else if ( mp -> nm_register_func != nullptr ) { mp -> nm_register_func ( exports , module , mp -> nm_priv ); } \u4ece\u521a\u624d\u7684node_module\u5b9a\u4e49\u4e2d\u6211\u4eec\u770b\u5230\u51fd\u6570\u662fnapi_module_register_cb\u3002 1 2 3 4 5 6 7 static void napi_module_register_cb ( v8 :: Local < v8 :: Object > exports , v8 :: Local < v8 :: Value > module , v8 :: Local < v8 :: Context > context , void * priv ) { napi_module_register_by_symbol ( exports , module , context , static_cast < napi_module *> ( priv ) -> nm_register_func ); } \u8be5\u51fd\u6570\u8c03\u7528napi_module_register_by_symbol\u51fd\u6570\uff0c\u5e76\u4f20\u5165napi_module\u7684nm_register_func\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void napi_module_register_by_symbol ( v8 :: Local < v8 :: Object > exports , v8 :: Local < v8 :: Value > module , v8 :: Local < v8 :: Context > context , napi_addon_register_func init ) { // Create a new napi_env for this specific module. napi_env env = v8impl :: NewEnv ( context ); napi_value _exports ; env -> CallIntoModuleThrow ([ & ]( napi_env env ) { _exports = init ( env , v8impl :: JsValueFromV8LocalValue ( exports )); }); if ( _exports != nullptr && _exports != v8impl :: JsValueFromV8LocalValue ( exports )) { napi_value _module = v8impl :: JsValueFromV8LocalValue ( module ); napi_set_named_property ( env , _module , \"exports\" , _exports ); } } init\u5c31\u662f\u6211\u4eec\u5b9a\u4e49\u7684\u51fd\u6570\u3002\u5165\u53c2\u662fenv\u548cexports\uff0c\u53ef\u4ee5\u5bf9\u6bd4\u6211\u4eec\u5b9a\u4e49\u7684\u51fd\u6570\u7684\u5165\u53c2\u3002\u6700\u540e\u6211\u4eec\u4fee\u6539exports\u53d8\u91cf\u3002\u5373\u8bbe\u7f6e\u5bfc\u51fa\u7684\u5185\u5bb9\u3002\u6700\u540e\u5728JS\u91cc\uff0c\u6211\u4eec\u5c31\u62ff\u5230\u4e86C++\u5c42\u5b9a\u4e49\u7684\u5185\u5bb9\u3002 19.2 \u52a0\u8f7d\u539f\u751fJS\u6a21\u5757 \u00b6 \u4e0a\u4e00\u8282\u6211\u4eec\u4e86\u89e3\u4e86Node.js\u6267\u884cnode demo.js\u7684\u8fc7\u7a0b\uff0c\u5176\u4e2d\u6211\u4eec\u5728demo.js\u4e2d\u4f7f\u7528require\u52a0\u8f7dnet\u6a21\u5757\u3002net\u662f\u539f\u751fJS\u6a21\u5757\u3002\u8fd9\u65f6\u5019\u5c31\u4f1a\u8fdb\u5165\u539f\u751f\u6a21\u5757\u7684\u5904\u7406\u903b\u8f91\u3002 \u539f\u751f\u6a21\u5757\u662fNode.js\u5185\u90e8\u5b9e\u73b0\u7684JS\u6a21\u5757\u3002\u4f7f\u7528NativeModule\u6765\u8868\u793a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class NativeModule { // \u539f\u751fJS\u6a21\u5757\u7684map static map = new Map ( moduleIds . map (( id ) => [ id , new NativeModule ( id )])); constructor ( id ) { this . filename = ` ${ id } .js` ; this . id = id ; this . canBeRequiredByUsers = ! id . startsWith ( 'internal/' ); this . exports = {}; this . loaded = false ; this . loading = false ; this . module = undefined ; this . exportKeys = undefined ; } } \u5f53\u6211\u4eec\u6267\u884crequire(\u2018net\u2019)\u65f6\uff0c\u5c31\u4f1a\u8fdb\u5165_load\u51fd\u6570\u3002_load\u51fd\u6570\u5224\u65ad\u8981\u52a0\u8f7d\u7684\u6a21\u5757\u662f\u539f\u751fJS\u6a21\u5757\u540e\uff0c\u4f1a\u901a\u8fc7loadNativeModule\u51fd\u6570\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u3002\u6211\u4eec\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 function loadNativeModule ( filename , request ) { const mod = NativeModule . map . get ( filename ); if ( mod ) { mod . compileForPublicLoader (); return mod ; } } \u5728Node.js\u542f\u52a8\u8fc7\u7a0b\u4e2d\u6211\u4eec\u5206\u6790\u8fc7\uff0cmod\u662f\u4e00\u4e2aNativeModule\u5bf9\u8c61\uff0c\u63a5\u7740\u770bcompileForPublicLoader\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 compileForPublicLoader () { this . compileForInternalLoader (); return this . exports ; } compileForInternalLoader () { if ( this . loaded || this . loading ) { return this . exports ; } // id\u5c31\u662f\u6211\u4eec\u8981\u52a0\u8f7d\u7684\u6a21\u5757\uff0c\u6bd4\u5982net const id = this . id ; this . loading = true ; try { const fn = compileFunction ( id ); fn ( this . exports , // \u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u7684\u52a0\u8f7d\u5668 nativeModuleRequire , this , process , // \u52a0\u8f7dC++\u6a21\u5757\u7684\u52a0\u8f7d\u5668 internalBinding , primordials ); this . loaded = true ; } finally { this . loading = false ; } return this . exports ; } \u6211\u4eec\u91cd\u70b9\u770bcompileFunction\u8fd9\u91cc\u7684\u903b\u8f91\u3002\u8be5\u51fd\u6570\u662fnode_native_module_env.cc\u6a21\u5757\u5bfc\u51fa\u7684\u51fd\u6570\u3002\u5177\u4f53\u7684\u4ee3\u7801\u5c31\u4e0d\u8d34\u4e86\uff0c\u901a\u8fc7\u5c42\u5c42\u67e5\u627e\uff0c\u6700\u540e\u5230node_native_module.cc \u7684NativeModuleLoader::CompileAsModule 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 MaybeLocal < Function > NativeModuleLoader :: CompileAsModule ( Local < Context > context , const char * id , NativeModuleLoader :: Result * result ) { Isolate * isolate = context -> GetIsolate (); // \u51fd\u6570\u7684\u5f62\u53c2 std :: vector < Local < String >> parameters = { FIXED_ONE_BYTE_STRING ( isolate , \"exports\" ), FIXED_ONE_BYTE_STRING ( isolate , \"require\" ), FIXED_ONE_BYTE_STRING ( isolate , \"module\" ), FIXED_ONE_BYTE_STRING ( isolate , \"process\" ), FIXED_ONE_BYTE_STRING ( isolate , \"internalBinding\" ), FIXED_ONE_BYTE_STRING ( isolate , \"primordials\" )}; // \u7f16\u8bd1\u51fa\u4e00\u4e2a\u51fd\u6570 return LookupAndCompile ( context , id , & parameters , result ); } \u6211\u4eec\u7ee7\u7eed\u770bLookupAndCompile\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 MaybeLocal < Function > NativeModuleLoader :: LookupAndCompile ( Local < Context > context , const char * id , std :: vector < Local < String >>* parameters , NativeModuleLoader :: Result * result ) { Isolate * isolate = context -> GetIsolate (); EscapableHandleScope scope ( isolate ); Local < String > source ; // \u627e\u5230\u539f\u751fJS\u6a21\u5757\u5185\u5bb9\u6240\u5728\u7684\u5185\u5b58\u5730\u5740 if ( ! LoadBuiltinModuleSource ( isolate , id ). ToLocal ( & source )) { return {}; } // \u2018net\u2019 + \u2018.js\u2019 std :: string filename_s = id + std :: string ( \".js\" ); Local < String > filename = OneByteString ( isolate , filename_s . c_str (), filename_s . size ()); // \u7701\u7565\u4e00\u4e9b\u53c2\u6570\u5904\u7406 // \u811a\u672c\u6e90\u7801 ScriptCompiler :: Source script_source ( source , origin , cached_data ); // \u7f16\u8bd1\u51fa\u4e00\u4e2a\u51fd\u6570 MaybeLocal < Function > maybe_fun = ScriptCompiler :: CompileFunctionInContext ( context , & script_source , parameters -> size (), parameters -> data (), 0 , nullptr , options ); Local < Function > fun = maybe_fun . ToLocalChecked (); return scope . Escape ( fun ); } LookupAndCompile\u51fd\u6570\u9996\u5148\u627e\u5230\u52a0\u8f7d\u6a21\u5757\u7684\u6e90\u7801\uff0c\u7136\u540e\u7f16\u8bd1\u51fa\u4e00\u4e2a\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0bLoadBuiltinModuleSource\u5982\u4f55\u67e5\u627e\u6a21\u5757\u6e90\u7801\u7684\u3002 1 2 3 4 MaybeLocal < String > NativeModuleLoader :: LoadBuiltinModuleSource ( Isolate * isolate , const char * id ) { const auto source_it = source_ . find ( id ); return source_it -> second . ToStringChecked ( isolate ); } \u8fd9\u91cc\u662fid\u662fnet\uff0c\u901a\u8fc7\u8be5id\u4ece_source\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u6570\u636e\uff0c\u90a3\u4e48_source\u662f\u4ec0\u4e48\u5462\uff1f\u56e0\u4e3aNode.js\u4e3a\u4e86\u63d0\u9ad8\u6548\u7387\uff0c\u628a\u539f\u751fJS\u6a21\u5757\u7684\u6e90\u7801\u5b57\u7b26\u4e32\u76f4\u63a5\u8f6c\u6210ASCII\u7801\u5b58\u5230\u5185\u5b58\u91cc\u3002\u8fd9\u6837\u52a0\u8f7d\u8fd9\u4e9b\u6a21\u5757\u7684\u65f6\u5019\uff0c\u5c31\u4e0d\u9700\u8981\u786c\u76d8IO\u4e86\u3002\u76f4\u63a5\u4ece\u5185\u5b58\u8bfb\u53d6\u5c31\u884c\u3002\u6211\u4eec\u770b\u4e00\u4e0b_source\u7684\u5b9a\u4e49\uff08\u5728\u7f16\u8bd1Node.js\u6e90\u7801\u6216\u8005\u6267\u884cjs2c.py\u751f\u6210\u7684node_javascript.cc\u4e2d\uff09\u3002 1 2 3 source_ . emplace ( \"net\" , UnionBytes { net_raw , 46682 }); source_ . emplace ( \"cyb\" , UnionBytes { cyb_raw , 63 }); source_ . emplace ( \"os\" , UnionBytes { os_raw , 7548 }); cyb\u662f\u6211\u589e\u52a0\u7684\u6d4b\u8bd5\u6a21\u5757\u3002\u6211\u4eec\u53ef\u4ee5\u770b\u4e00\u4e0b\u8be5\u6a21\u5757\u7684\u5185\u5bb9\u3002 1 2 3 4 5 static const uint8_t cyb_raw [] = { 99 , 111 , 110 , 115 , 116 , 32 , 99 , 121 , 98 , 32 , 61 , 32 , 105 , 110 , 116 , 101 , 114 , 110 , 97 , 108 , 66 , 105 , 110 , 100 , 105 , 110 , 103 , 40 , 39 , 99 , 121 , 98 , 95 , 119 , 114 , 97 , 112 , 39 , 41 , 59 , 32 , 10 , 109 , 111 , 100 , 117 , 108 , 101 , 46 , 101 , 120 , 112 , 111 , 114 , 116 , 115 , 32 , 61 , 32 , 99 , 121 , 98 , 59 }; \u6211\u4eec\u8f6c\u6210\u5b57\u7b26\u4e32\u770b\u4e00\u4e0b\u662f\u4ec0\u4e48 1 2 3 Buffer . from ([ 99 , 111 , 110 , 115 , 116 , 32 , 99 , 121 , 98 , 32 , 61 , 32 , 105 , 110 , 116 , 101 , 114 , 110 , 97 , 108 , 66 , 105 , 110 , 100 , 105 , 110 , 103 , 40 , 39 , 99 , 121 , 98 , 95 , 119 , 114 , 97 , 112 , 39 , 41 , 59 , 32 , 10 , 109 , 111 , 100 , 117 , 108 , 101 , 46 , 101 , 120 , 112 , 111 , 114 , 116 , 115 , 32 , 61 , 32 , 99 , 121 , 98 , 59 ]. join ( ',' ). split ( ',' )). toString ( 'utf-8' ) \u8f93\u51fa 1 2 const cyb = internalBinding ( 'cyb_wrap' ); module . exports = cyb ; \u6240\u4ee5\u6211\u4eec\u6267\u884crequire('net')\u65f6\uff0c\u901a\u8fc7NativeModule\u7684compileForInternalLoader\uff0c\u6700\u7ec8\u4f1a\u5728_source\u4e2d\u627e\u5230net\u6a21\u5757\u5bf9\u5e94\u7684\u6e90\u7801\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u7f16\u8bd1\u6210\u4e00\u4e2a\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 const fn = compileFunction ( id ); fn ( this . exports , // \u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u7684\u52a0\u8f7d\u5668 nativeModuleRequire , this , process , // \u52a0\u8f7dC++\u6a21\u5757\u7684\u52a0\u8f7d\u5668 internalBinding , primordials ); \u7531fn\u7684\u5165\u53c2\u53ef\u4ee5\u77e5\u9053\uff0c\u6211\u4eec\u5728net\uff08\u6216\u5176\u5b83\u539f\u751fJS\u6a21\u5757\u4e2d\uff09\u53ea\u80fd\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u548c\u5185\u7f6e\u7684C++\u6a21\u5757\u3002\u5f53fn\u6267\u884c\u5b8c\u6bd5\u540e\uff0c\u539f\u751f\u6a21\u5757\u52a0\u8f7d\u5668\u5c31\u4f1a\u628amod.exports\u7684\u503c\u8fd4\u56de\u7ed9\u8c03\u7528\u65b9\u3002 19.3 \u52a0\u8f7d\u5185\u7f6eC++\u6a21\u5757 \u5728\u539f\u751fJS\u6a21\u5757\u4e2d\u6211\u4eec\u4e00\u822c\u4f1a\u52a0\u8f7d\u4e00\u4e9b\u5185\u7f6e\u7684C++\u6a21\u5757\uff0c\u8fd9\u662fNode.js\u62d3\u5c55JS\u529f\u80fd\u7684\u5173\u952e\u4e4b\u5904\u3002\u6bd4\u5982\u6211\u4eecrequire(\u2018net\u2019)\u7684\u65f6\u5019\uff0cnet\u6a21\u5757\u4f1a\u52a0\u8f7dtcp_wrap\u6a21\u5757\u3002 1 2 3 4 5 const { TCP , TCPConnectWrap , constants : TCPConstants } = internalBinding ( 'tcp_wrap' ) C++\u6a21\u5757\u52a0\u8f7d\u5668\u4e5f\u662f\u5728internal/bootstrap/loaders.js\u4e2d\u5b9a\u4e49\u7684\uff0c\u5206\u4e3a\u4e09\u79cd\u3002 1 internalBinding\uff1a\u4e0d\u66b4\u9732\u7ed9\u7528\u6237\u7684\u8bbf\u95ee\u7684\u63a5\u53e3\uff0c\u53ea\u80fd\u5728Node.js\u4ee3\u7801\u4e2d\u8bbf\u95ee\uff0c\u6bd4\u5982\u539f\u751fJS\u6a21\u5757\uff08flag\u4e3aNM_F_INTERNAL\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 let internalBinding ; { const bindingObj = ObjectCreate ( null ); internalBinding = function internalBinding ( module ) { let mod = bindingObj [ module ]; if ( typeof mod !== 'object' ) { mod = bindingObj [ module ] = getInternalBinding ( module ); moduleLoadList . push ( `Internal Binding ${ module } ` ); } return mod ; }; } internalBinding\u662f\u5728getInternalBinding\u51fd\u6570\u57fa\u7840\u4e0a\u52a0\u4e86\u7f13\u5b58\u529f\u80fd\u3002getInternalBinding\u662fC++\u5c42\u5b9a\u4e49\u7684\u51fd\u6570\u5bf9JS\u66b4\u9732\u7684\u63a5\u53e3\u540d\u3002\u5b83\u7684\u4f5c\u7528\u662f\u4eceC++\u6a21\u5757\u94fe\u8868\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u6a21\u5757\u3002 2 process.binding\uff1a\u66b4\u9732\u7ed9\u7528\u6237\u8c03\u7528C++\u6a21\u5757\u7684\u63a5\u53e3\uff0c\u4f46\u662f\u53ea\u80fd\u8bbf\u95ee\u90e8\u5206C++\u6a21\u5757\uff08flag\u4e3aNM_F_BUILTIN\u7684C++\u6a21\u5757\uff09\u3002 1 2 3 4 5 6 7 process . binding = function binding ( module ) { module = String ( module ); if ( internalBindingWhitelist . has ( module )) { return internalBinding ( module ); } throw new Error ( `No such module: ${ module } ` ); }; binding\u662f\u5728internalBinding\u7684\u57fa\u7840\u4e0a\u52a0\u4e86\u767d\u540d\u5355\u7684\u903b\u8f91\uff0c\u53ea\u5bf9\u5916\u66b4\u9732\u90e8\u5206\u6a21\u5757\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const internalBindingWhitelist = new SafeSet ([ 'async_wrap' , 'buffer' , 'cares_wrap' , 'config' , 'constants' , 'contextify' , 'crypto' , 'fs' , 'fs_event_wrap' , 'http_parser' , 'icu' , 'inspector' , 'js_stream' , 'natives' , 'os' , 'pipe_wrap' , 'process_wrap' , 'signal_wrap' , 'spawn_sync' , 'stream_wrap' , 'tcp_wrap' , 'tls_wrap' , 'tty_wrap' , 'udp_wrap' , 'url' , 'util' , 'uv' , 'v8' , 'zlib' ]); 3 process._linkedBinding: \u66b4\u9732\u7ed9\u7528\u6237\u8bbf\u95eeC++\u6a21\u5757\u7684\u63a5\u53e3\uff0c\u7528\u4e8e\u8bbf\u95ee\u7528\u6237\u81ea\u5df1\u6dfb\u52a0\u7684\u4f46\u662f\u6ca1\u6709\u52a0\u5230\u5185\u7f6e\u6a21\u5757\u7684C++\u6a21\u5757\uff08flag\u4e3aNM_F_LINKED\uff09\u3002 1 2 3 4 5 6 7 8 const bindingObj = ObjectCreate ( null ); process . _linkedBinding = function _linkedBinding ( module ) { module = String ( module ); let mod = bindingObj [ module ]; if ( typeof mod !== 'object' ) mod = bindingObj [ module ] = getLinkedBinding ( module ); return mod ; }; _linkedBinding\u662f\u5728getLinkedBinding\u51fd\u6570\u57fa\u7840\u4e0a\u52a0\u4e86\u7f13\u5b58\u529f\u80fd\uff0cgetLinkedBinding\u662fC++\u5c42\u5b9a\u4e49\u7684\u51fd\u6570\u5bf9\u5916\u66b4\u9732\u7684\u540d\u5b57\u3002getLinkedBinding\u4ece\u53e6\u4e00\u4e2aC++\u6a21\u5757\u94fe\u8868\u4e2d\u67e5\u627e\u5bf9\u5e94\u7684\u6a21\u5757\u3002 \u4e0a\u4e00\u8282\u5df2\u7ecf\u5206\u6790\u8fc7\uff0cinternalBinding\u662f\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u65f6\u4f20\u5165\u7684\u5b9e\u53c2\u3002internalBinding\u662f\u5bf9getInternalBinding\u7684\u5c01\u88c5\u3002getInternalBinding\u5bf9\u5e94\u7684\u662fbinding::GetInternalBinding\uff08node_binding.cc\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // \u6839\u636e\u6a21\u5757\u540d\u67e5\u627e\u5bf9\u5e94\u7684\u6a21\u5757 void GetInternalBinding ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); // \u6a21\u5757\u540d Local < String > module = args [ 0 ]. As < String > (); node :: Utf8Value module_v ( env -> isolate (), module ); Local < Object > exports ; // \u4eceC++\u5185\u90e8\u6a21\u5757\u627e node_module * mod = FindModule ( modlist_internal , * module_v , NM_F_INTERNAL ); // \u627e\u5230\u5219\u521d\u59cb\u5316 if ( mod != nullptr ) { exports = InitModule ( env , mod , module ); } else { // \u7701\u7565 } args . GetReturnValue (). Set ( exports ); } modlist_internal\u662f\u4e00\u6761\u94fe\u8868\uff0c\u5728Node.js\u542f\u52a8\u8fc7\u7a0b\u7684\u65f6\u5019\uff0c\u7531\u5404\u4e2aC++\u6a21\u5757\u8fde\u6210\u7684\u94fe\u8868\u3002\u901a\u8fc7\u6a21\u5757\u540d\u627e\u5230\u5bf9\u5e94\u7684C++\u6a21\u5757\u540e\uff0c\u6267\u884cInitModule\u521d\u59cb\u5316\u6a21\u5757\u3002 1 2 3 4 5 6 7 8 9 // \u521d\u59cb\u5316\u4e00\u4e2a\u6a21\u5757\uff0c\u5373\u6267\u884c\u5b83\u91cc\u9762\u7684\u6ce8\u518c\u51fd\u6570 static Local < Object > InitModule ( Environment * env , node_module * mod , Local < String > module ) { Local < Object > exports = Object :: New ( env -> isolate ()); Local < Value > unused = Undefined ( env -> isolate ()); mod -> nm_context_register_func ( exports , unused , env -> context (), mod -> nm_priv ); return exports ; } \u6267\u884cC++\u6a21\u5757\u7684nm_context_register_func\u6307\u5411\u7684\u51fd\u6570\u3002\u8fd9\u4e2a\u51fd\u6570\u5c31\u662f\u5728C++\u6a21\u5757\u6700\u540e\u4e00\u884c\u5b9a\u4e49\u7684Initialize\u51fd\u6570\u3002Initialize\u4f1a\u8bbe\u7f6e\u5bfc\u51fa\u7684\u5bf9\u8c61\u3002\u6211\u4eec\u4eceJS\u53ef\u4ee5\u8bbf\u95eeInitialize\u5bfc\u51fa\u7684\u5bf9\u8c61\u3002V8\u4e2d\uff0cJS\u8c03\u7528C++\u51fd\u6570\u7684\u89c4\u5219\u662f\u51fd\u6570\u5165\u53c2const FunctionCallbackInfo & args\uff08\u62ff\u5230JS\u4f20\u8fc7\u6765\u7684\u5185\u5bb9\uff09\u548c\u8bbe\u7f6e\u8fd4\u56de\u503cargs.GetReturnValue().Set(\u7ed9JS\u8fd4\u56de\u7684\u5185\u5bb9), GetInternalBinding\u51fd\u6570\u7684\u903b\u8f91\u5c31\u662f\u6267\u884c\u5bf9\u5e94\u6a21\u5757\u7684\u94a9\u5b50\u51fd\u6570\uff0c\u5e76\u4f20\u4e00\u4e2aexports\u53d8\u91cf\u8fdb\u53bb\uff0c\u7136\u540e\u94a9\u5b50\u51fd\u6570\u4f1a\u4fee\u6539exports\u7684\u503c\uff0c\u8be5exports\u7684\u503c\u5c31\u662fJS\u5c42\u80fd\u62ff\u5230\u7684\u503c\u3002","title":"19-\u6a21\u5757\u52a0\u8f7d"},{"location":"chapter19-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD/#191","text":"\u5728Node.js\u4e2d_extensions\u6709\u4e09\u79cd\uff0c\u5206\u522b\u662fjs\u3001json\u3001node\u3002","title":"19.1 \u52a0\u8f7d\u7528\u6237\u6a21\u5757"},{"location":"chapter19-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD/#1911-json","text":"\u52a0\u8f7dJSON\u6a21\u5757\u662f\u6bd4\u8f83\u7b80\u5355\u7684 1 2 3 4 5 6 7 8 9 10 Module . _extensions [ '.json' ] = function ( module , filename ) { const content = fs . readFileSync ( filename , 'utf8' ); try { module . exports = JSONParse ( stripBOM ( content )); } catch ( err ) { err . message = filename + ': ' + err . message ; throw err ; } }; \u76f4\u63a5\u8bfb\u53d6JSON\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u7136\u540e\u89e3\u6790\u6210\u5bf9\u8c61\u5c31\u884c\u3002","title":"19.1.1 \u52a0\u8f7dJSON\u6a21\u5757"},{"location":"chapter19-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD/#1912-js","text":"1 2 3 4 Module . _extensions [ '.js' ] = function ( module , filename ) { const content = fs . readFileSync ( filename , 'utf8' ); module . _compile ( content , filename ); }; \u8bfb\u5b8c\u6587\u4ef6\u7684\u5185\u5bb9\uff0c\u7136\u540e\u6267\u884c_compile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 Module . prototype . _compile = function ( content , filename ) { // \u751f\u6210\u4e00\u4e2a\u51fd\u6570 const compiledWrapper = wrapSafe ( filename , content , this ); const dirname = path . dirname ( filename ); // require\u662f\u5bf9_load\u51fd\u6570\u7684\u5c01\u88c5 const require = ( path ) => { return this . require ( path ); }; let result ; // \u6211\u4eec\u5e73\u65f6\u4f7f\u7528\u7684exports\u53d8\u91cf const exports = this . exports ; const thisValue = exports ; // \u6211\u4eec\u5e73\u65f6\u4f7f\u7528\u7684module\u53d8\u91cf const module = this ; // \u6267\u884c\u51fd\u6570 result = compiledWrapper . call ( thisValue , exports , require , module , filename , dirname ); return result ; } _compile\u91cc\u9762\u5305\u62ec\u4e86\u51e0\u4e2a\u91cd\u8981\u7684\u903b\u8f91 1 wrapSafe\uff1a\u5305\u88f9\u6211\u4eec\u7684\u4ee3\u7801\u5e76\u751f\u6210\u4e00\u4e2a\u51fd\u6570 2 require\uff1a\u652f\u6301\u5728\u6a21\u5757\u5185\u52a0\u8f7d\u5176\u4ed6\u6a21\u5757 3 \u6267\u884c\u6a21\u5757\u4ee3\u7801 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e09\u4e2a\u903b\u8f91\u3002 1 wrapSafe 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function wrapSafe ( filename , content , cjsModuleInstance ) { const wrapper = Module . wrap ( content ); return vm . runInThisContext ( wrapper , { filename , lineOffset : 0 , ... }); } const wrapper = [ '(function (exports, require, module, __filename, __dirname) { ' , '\\n});' ]; Module . wrap = function ( script ) { return Module . wrapper [ 0 ] + script + Module . wrapper [ 1 ]; }; vm.runInThisContext\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\u662f\u201d(function() {})\u201d\u7684\u65f6\u5019\uff0c\u4f1a\u8fd4\u56de\u4e00\u4e2a\u51fd\u6570\u3002\u6240\u4ee5\u6267\u884cModule.wrap\u540e\u4f1a\u8fd4\u56de\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u5185\u5bb9\u5982\u4e0b 1 2 3 ( function ( exports , require , module , __filename , __dirname ) { // }); \u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0brequire\u51fd\u6570\uff0c\u5373\u6211\u4eec\u5e73\u65f6\u5728\u4ee3\u7801\u4e2d\u4f7f\u7528\u7684require\u3002 2 require 1 2 3 4 5 6 7 8 Module . prototype . require = function ( id ) { requireDepth ++ ; try { return Module . _load ( id , this , /* isMain */ false ); } finally { requireDepth -- ; } }; require\u662f\u5bf9Module._load\u7684\u5c01\u88c5\uff0cModule._load\u4f1a\u628a\u6a21\u5757\u5bfc\u51fa\u7684\u53d8\u91cf\u901a\u8fc7module.exports\u5c5e\u6027\u8fd4\u56de\u7ed9require\u8c03\u7528\u65b9\u3002\u56e0\u4e3aModule._load\u53ea\u4f1a\u4ece\u539f\u751fJS\u6a21\u5757\u548c\u7528\u6237JS\u6a21\u5757\u4e2d\u67e5\u627e\u7528\u6237\u9700\u8981\u52a0\u8f7d\u7684\u6a21\u5757\uff0c\u6240\u4ee5\u662f\u65e0\u6cd5\u8bbf\u95eeC++\u6a21\u5757\u7684\uff0c\u8bbf\u95eeC++\u6a21\u5757\u53ef\u7528process.bindng\u6216internalBinding\u3002 3 \u6267\u884c\u4ee3\u7801 \u6211\u4eec\u56de\u5230_compile\u51fd\u6570\u3002\u770b\u4e00\u4e0b\u6267\u884cvm.runInThisContext\u8fd4\u56de\u7684\u51fd\u6570\u3002 1 2 3 4 5 6 compiledWrapper . call ( exports , exports , require , module , filename , dirname ); \u76f8\u5f53\u4e8e\u6267\u884c\u4ee5\u4e0b\u4ee3\u7801 1 2 3 4 ( function ( exports , require , module , __filename , __dirname ) { const myjs = require ( \u2018 myjs ); const net = require ( \u2018 net \u2019 ); }); \u81f3\u6b64\uff0cNode.js\u5f00\u59cb\u6267\u884c\u7528\u6237\u7684JS\u4ee3\u7801\u3002\u521a\u624d\u6211\u4eec\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7require\u662f\u5bf9Module._load\u7684\u5c01\u88c5\uff0c\u5f53\u6267\u884crequire\u52a0\u8f7d\u7528\u6237\u6a21\u5757\u65f6\uff0c\u53c8\u56de\u5230\u4e86\u6211\u4eec\u6b63\u5728\u5206\u6790\u7684\u8fd9\u4e2a\u8fc7\u7a0b\u3002","title":"19.1.2 \u52a0\u8f7dJS\u6a21\u5757"},{"location":"chapter19-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD/#1913-node","text":"Node\u62d3\u5c55\u7684\u6a21\u5757\u672c\u8d28\u4e0a\u662f\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u6211\u4eec\u770brequire\u4e00\u4e2a.node\u6a21\u5757\u7684\u65f6\u5019\u7684\u8fc7\u7a0b\u3002\u6211\u4eec\u4ece\u52a0\u8f7d.node\u6a21\u5757\u7684\u6e90\u7801\u5f00\u59cb\u3002 1 2 3 4 Module . _extensions [ '.node' ] = function ( module , filename ) { // ... return process . dlopen ( module , path . toNamespacedPath ( filename )); }; \u76f4\u63a5\u8c03\u4e86process.dlopen\uff0c\u8be5\u51fd\u6570\u5728node.js\u91cc\u5b9a\u4e49\u3002 1 2 const rawMethods = internalBinding ( 'process_methods' ); process . dlopen = rawMethods . dlopen ; \u627e\u5230process_methods\u6a21\u5757\u5bf9\u5e94\u7684\u662fnode_process_methods.cc\u3002 1 env -> SetMethod ( target , \"dlopen\" , binding :: DLOpen ); \u4e4b\u524d\u8bf4\u8fc7\uff0cNode.js\u7684\u62d3\u5c55\u6a21\u5757\u5176\u5b9e\u662f\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u90a3\u4e48\u6211\u4eec\u5148\u770b\u770b\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\u6211\u4eec\u662f\u5982\u4f55\u4f7f\u7528\u7684\u3002\u4ee5\u4e0b\u662f\u793a\u4f8b\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <stdio.h> #include <stdlib.h> #include <dlfcn.h> int main (){ // \u6253\u5f00\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u62ff\u5230\u4e00\u4e2ahandler handler = dlopen ( ' xxx . so ' , RTLD_LAZY ); // \u53d6\u51fa\u52a8\u6001\u94fe\u63a5\u5e93\u91cc\u7684\u51fd\u6570add add = dlsym ( handler , \"add\" ); // \u6267\u884c printf ( \"%d\" , add ( 1 , 1 )); dlclose ( handler ); return 0 ; } \u4e86\u89e3\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u4f7f\u7528\uff0c\u6211\u4eec\u7ee7\u7eed\u5206\u6790\u521a\u624d\u770b\u5230\u7684DLOpen\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void DLOpen ( const FunctionCallbackInfo < Value >& args ) { int32_t flags = DLib :: kDefaultFlags ; node :: Utf8Value filename ( env -> isolate (), args [ 1 ]); // Cast env -> TryLoadAddon ( * filename , flags , [ & ]( DLib * dlib ) { const bool is_opened = dlib -> Open (); node_module * mp = thread_local_modpending ; thread_local_modpending = nullptr ; // \u7701\u7565\u90e8\u5206\u4ee3\u7801 if ( mp -> nm_context_register_func != nullptr ) { mp -> nm_context_register_func ( exports , module , context , mp -> nm_priv ); } else if ( mp -> nm_register_func != nullptr ) { mp -> nm_register_func ( exports , module , mp -> nm_priv ); } return true ; }); } \u6211\u4eec\u770b\u5230\u91cd\u70b9\u662fTryLoadAddon\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u7684\u903b\u8f91\u5c31\u662f\u6267\u884c\u5b83\u7684\u7b2c\u4e09\u4e2a\u53c2\u6570\u3002\u6211\u4eec\u53d1\u73b0\u7b2c\u4e09\u4e2a\u53c2\u6570\u662f\u4e00\u4e2a\u51fd\u6570\uff0c\u5165\u53c2\u662fDLib\u5bf9\u8c61\u3002\u6240\u4ee5\u6211\u4eec\u5148\u770b\u770b\u8fd9\u4e2a\u7c7b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 class DLib { public : static const int kDefaultFlags = RTLD_LAZY ; DLib ( const char * filename , int flags ); bool Open (); void Close (); const std :: string filename_ ; const int flags_ ; std :: string errmsg_ ; void * handle_ ; uv_lib_t lib_ ; }; \u518d\u770b\u4e00\u4e0b\u5b9e\u73b0\u3002 1 2 3 4 5 6 bool DLib::Open () { handle_ = dlopen ( filename_ . c_str (), flags_ ); if ( handle_ != nullptr ) return true ; errmsg_ = dlerror (); return false ; } DLib\u5c31\u662f\u5bf9\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u4e00\u4e2a\u5c01\u88c5\uff0c\u5b83\u5c01\u88c5\u4e86\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u6587\u4ef6\u540d\u548c\u64cd\u4f5c\u3002TryLoadAddon\u51fd\u6570\u9996\u5148\u6839\u636erequire\u4f20\u5165\u7684\u6587\u4ef6\u540d\uff0c\u6784\u9020\u4e00\u4e2aDLib\uff0c\u7136\u540e\u6267\u884c 1 const bool is_opened = dlib -> Open (); Open\u51fd\u6570\u6253\u5f00\u4e86\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u8981\u5148\u4e86\u89e3\u4e00\u4e0b\u6253\u5f00\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\u7a76\u7adf\u53d1\u751f\u4e86\u4ec0\u4e48\u3002\u9996\u5148\u6211\u4eec\u4e00\u822cC++\u63d2\u4ef6\u6700\u540e\u4e00\u53e5\u4ee3\u7801\u7684\u5b9a\u4e49\u3002 1 NAPI_MODULE ( NODE_GYP_MODULE_NAME , init ) \u8fd9\u662f\u4e2a\u5b8f\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #define NAPI_MODULE(modname, regfunc) \\ NAPI_MODULE_X ( modname , regfunc , NULL , 0 ) #define NAPI_MODULE_X(modname, regfunc, priv, flags) \\ static napi_module _module = \\ { \\ NAPI_MODULE_VERSION , \\ flags , \\ __FILE__ , \\ regfunc , \\ #modname, \\ priv , \\ { 0 }, \\ }; \\ static void _register_modname ( void ) __attribute__ (( constructor )); \\ static void _register_modname ( void ) { \\ napi_module_register ( & _module ); \\ } \u6240\u4ee5\u4e00\u4e2anode\u6269\u5c55\u5c31\u662f\u5b9a\u4e49\u4e86\u4e00\u4e2anapi_module\u6a21\u5757\u548c\u4e00\u4e2aregister_modname\uff08modname\u662f\u6211\u4eec\u5b9a\u4e49\u7684\uff09\u51fd\u6570\u3002__attribute((constructor))\u662f\u4ee3\u8868\u8be5\u51fd\u6570\u4f1a\u5148\u6267\u884c\u7684\u610f\u601d\uff0c\u5177\u4f53\u53ef\u4ee5\u67e5\u9605\u6587\u6863\u3002\u770b\u5230\u8fd9\u91cc\u6211\u4eec\u77e5\u9053\uff0c\u5f53\u6211\u4eec\u6253\u5f00\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\u7684\u65f6\u5019\uff0c\u4f1a\u6267\u884c_register_modname\u51fd\u6570\uff0c\u8be5\u51fd\u6570\u6267\u884c\u7684\u662f 1 napi_module_register ( & _module ); \u6211\u4eec\u7ee7\u7eed\u5c55\u5f00\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Registers a NAPI module. void napi_module_register ( napi_module * mod ) { node :: node_module * nm = new node :: node_module { -1 , mod -> nm_flags | NM_F_DELETEME , nullptr , mod -> nm_filename , nullptr , napi_module_register_cb , mod -> nm_modname , mod , // priv nullptr , }; node :: node_module_register ( nm ); } Node.js\u628anapi\u6a21\u5757\u8f6c\u6210node_module\u3002\u6700\u540e\u8c03\u7528node_module_register\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 extern \"C\" void node_module_register ( void * m ) { struct node_module * mp = reinterpret_cast < struct node_module *> ( m ); if ( mp -> nm_flags & NM_F_INTERNAL ) { mp -> nm_link = modlist_internal ; modlist_internal = mp ; } else if ( ! node_is_initialized ) { mp -> nm_flags = NM_F_LINKED ; mp -> nm_link = modlist_linked ; modlist_linked = mp ; } else { thread_local_modpending = mp ; } } napi\u6a21\u5757\u4e0d\u662fNM_F_INTERNAL\u6a21\u5757\uff0cnode_is_initialized\u662f\u5728Node.js\u521d\u59cb\u5316\u65f6\u8bbe\u7f6e\u7684\u53d8\u91cf\uff0c\u8fd9\u65f6\u5019\u5df2\u7ecf\u662ftrue\u3002\u6240\u4ee5\u6ce8\u518cnapi\u6a21\u5757\u65f6\uff0c\u4f1a\u6267\u884cthread_local_modpending = mp\u3002thread_local_modpending \u7c7b\u4f3c\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf\uff0c\u4fdd\u5b58\u5f53\u524d\u52a0\u8f7d\u7684\u6a21\u5757\u3002\u5206\u6790\u5230\u8fd9\uff0c\u6211\u4eec\u56de\u5230DLOpen\u51fd\u6570\u3002 1 2 node_module * mp = thread_local_modpending ; thread_local_modpending = nullptr ; \u8fd9\u65f6\u5019\u6211\u4eec\u5c31\u77e5\u9053\u521a\u624d\u90a3\u4e2a\u53d8\u91cfthread_local_modpending\u7684\u4f5c\u7528\u4e86\u3002node_module* mp = thread_local_modpending\u540e\u6211\u4eec\u62ff\u5230\u4e86\u6211\u4eec\u521a\u624d\u5b9a\u4e49\u7684napi\u6a21\u5757\u7684\u4fe1\u606f\u3002\u63a5\u7740\u6267\u884cnode_module\u7684\u51fd\u6570nm_register_func\u3002 1 2 3 4 5 6 7 8 if ( mp -> nm_context_register_func != nullptr ) { mp -> nm_context_register_func ( exports , module , context , mp -> nm_priv ); } else if ( mp -> nm_register_func != nullptr ) { mp -> nm_register_func ( exports , module , mp -> nm_priv ); } \u4ece\u521a\u624d\u7684node_module\u5b9a\u4e49\u4e2d\u6211\u4eec\u770b\u5230\u51fd\u6570\u662fnapi_module_register_cb\u3002 1 2 3 4 5 6 7 static void napi_module_register_cb ( v8 :: Local < v8 :: Object > exports , v8 :: Local < v8 :: Value > module , v8 :: Local < v8 :: Context > context , void * priv ) { napi_module_register_by_symbol ( exports , module , context , static_cast < napi_module *> ( priv ) -> nm_register_func ); } \u8be5\u51fd\u6570\u8c03\u7528napi_module_register_by_symbol\u51fd\u6570\uff0c\u5e76\u4f20\u5165napi_module\u7684nm_register_func\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void napi_module_register_by_symbol ( v8 :: Local < v8 :: Object > exports , v8 :: Local < v8 :: Value > module , v8 :: Local < v8 :: Context > context , napi_addon_register_func init ) { // Create a new napi_env for this specific module. napi_env env = v8impl :: NewEnv ( context ); napi_value _exports ; env -> CallIntoModuleThrow ([ & ]( napi_env env ) { _exports = init ( env , v8impl :: JsValueFromV8LocalValue ( exports )); }); if ( _exports != nullptr && _exports != v8impl :: JsValueFromV8LocalValue ( exports )) { napi_value _module = v8impl :: JsValueFromV8LocalValue ( module ); napi_set_named_property ( env , _module , \"exports\" , _exports ); } } init\u5c31\u662f\u6211\u4eec\u5b9a\u4e49\u7684\u51fd\u6570\u3002\u5165\u53c2\u662fenv\u548cexports\uff0c\u53ef\u4ee5\u5bf9\u6bd4\u6211\u4eec\u5b9a\u4e49\u7684\u51fd\u6570\u7684\u5165\u53c2\u3002\u6700\u540e\u6211\u4eec\u4fee\u6539exports\u53d8\u91cf\u3002\u5373\u8bbe\u7f6e\u5bfc\u51fa\u7684\u5185\u5bb9\u3002\u6700\u540e\u5728JS\u91cc\uff0c\u6211\u4eec\u5c31\u62ff\u5230\u4e86C++\u5c42\u5b9a\u4e49\u7684\u5185\u5bb9\u3002","title":"19.1.3 \u52a0\u8f7dnode\u6a21\u5757"},{"location":"chapter19-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD/#192-js","text":"\u4e0a\u4e00\u8282\u6211\u4eec\u4e86\u89e3\u4e86Node.js\u6267\u884cnode demo.js\u7684\u8fc7\u7a0b\uff0c\u5176\u4e2d\u6211\u4eec\u5728demo.js\u4e2d\u4f7f\u7528require\u52a0\u8f7dnet\u6a21\u5757\u3002net\u662f\u539f\u751fJS\u6a21\u5757\u3002\u8fd9\u65f6\u5019\u5c31\u4f1a\u8fdb\u5165\u539f\u751f\u6a21\u5757\u7684\u5904\u7406\u903b\u8f91\u3002 \u539f\u751f\u6a21\u5757\u662fNode.js\u5185\u90e8\u5b9e\u73b0\u7684JS\u6a21\u5757\u3002\u4f7f\u7528NativeModule\u6765\u8868\u793a\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class NativeModule { // \u539f\u751fJS\u6a21\u5757\u7684map static map = new Map ( moduleIds . map (( id ) => [ id , new NativeModule ( id )])); constructor ( id ) { this . filename = ` ${ id } .js` ; this . id = id ; this . canBeRequiredByUsers = ! id . startsWith ( 'internal/' ); this . exports = {}; this . loaded = false ; this . loading = false ; this . module = undefined ; this . exportKeys = undefined ; } } \u5f53\u6211\u4eec\u6267\u884crequire(\u2018net\u2019)\u65f6\uff0c\u5c31\u4f1a\u8fdb\u5165_load\u51fd\u6570\u3002_load\u51fd\u6570\u5224\u65ad\u8981\u52a0\u8f7d\u7684\u6a21\u5757\u662f\u539f\u751fJS\u6a21\u5757\u540e\uff0c\u4f1a\u901a\u8fc7loadNativeModule\u51fd\u6570\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u3002\u6211\u4eec\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 function loadNativeModule ( filename , request ) { const mod = NativeModule . map . get ( filename ); if ( mod ) { mod . compileForPublicLoader (); return mod ; } } \u5728Node.js\u542f\u52a8\u8fc7\u7a0b\u4e2d\u6211\u4eec\u5206\u6790\u8fc7\uff0cmod\u662f\u4e00\u4e2aNativeModule\u5bf9\u8c61\uff0c\u63a5\u7740\u770bcompileForPublicLoader\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 compileForPublicLoader () { this . compileForInternalLoader (); return this . exports ; } compileForInternalLoader () { if ( this . loaded || this . loading ) { return this . exports ; } // id\u5c31\u662f\u6211\u4eec\u8981\u52a0\u8f7d\u7684\u6a21\u5757\uff0c\u6bd4\u5982net const id = this . id ; this . loading = true ; try { const fn = compileFunction ( id ); fn ( this . exports , // \u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u7684\u52a0\u8f7d\u5668 nativeModuleRequire , this , process , // \u52a0\u8f7dC++\u6a21\u5757\u7684\u52a0\u8f7d\u5668 internalBinding , primordials ); this . loaded = true ; } finally { this . loading = false ; } return this . exports ; } \u6211\u4eec\u91cd\u70b9\u770bcompileFunction\u8fd9\u91cc\u7684\u903b\u8f91\u3002\u8be5\u51fd\u6570\u662fnode_native_module_env.cc\u6a21\u5757\u5bfc\u51fa\u7684\u51fd\u6570\u3002\u5177\u4f53\u7684\u4ee3\u7801\u5c31\u4e0d\u8d34\u4e86\uff0c\u901a\u8fc7\u5c42\u5c42\u67e5\u627e\uff0c\u6700\u540e\u5230node_native_module.cc \u7684NativeModuleLoader::CompileAsModule 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 MaybeLocal < Function > NativeModuleLoader :: CompileAsModule ( Local < Context > context , const char * id , NativeModuleLoader :: Result * result ) { Isolate * isolate = context -> GetIsolate (); // \u51fd\u6570\u7684\u5f62\u53c2 std :: vector < Local < String >> parameters = { FIXED_ONE_BYTE_STRING ( isolate , \"exports\" ), FIXED_ONE_BYTE_STRING ( isolate , \"require\" ), FIXED_ONE_BYTE_STRING ( isolate , \"module\" ), FIXED_ONE_BYTE_STRING ( isolate , \"process\" ), FIXED_ONE_BYTE_STRING ( isolate , \"internalBinding\" ), FIXED_ONE_BYTE_STRING ( isolate , \"primordials\" )}; // \u7f16\u8bd1\u51fa\u4e00\u4e2a\u51fd\u6570 return LookupAndCompile ( context , id , & parameters , result ); } \u6211\u4eec\u7ee7\u7eed\u770bLookupAndCompile\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 MaybeLocal < Function > NativeModuleLoader :: LookupAndCompile ( Local < Context > context , const char * id , std :: vector < Local < String >>* parameters , NativeModuleLoader :: Result * result ) { Isolate * isolate = context -> GetIsolate (); EscapableHandleScope scope ( isolate ); Local < String > source ; // \u627e\u5230\u539f\u751fJS\u6a21\u5757\u5185\u5bb9\u6240\u5728\u7684\u5185\u5b58\u5730\u5740 if ( ! LoadBuiltinModuleSource ( isolate , id ). ToLocal ( & source )) { return {}; } // \u2018net\u2019 + \u2018.js\u2019 std :: string filename_s = id + std :: string ( \".js\" ); Local < String > filename = OneByteString ( isolate , filename_s . c_str (), filename_s . size ()); // \u7701\u7565\u4e00\u4e9b\u53c2\u6570\u5904\u7406 // \u811a\u672c\u6e90\u7801 ScriptCompiler :: Source script_source ( source , origin , cached_data ); // \u7f16\u8bd1\u51fa\u4e00\u4e2a\u51fd\u6570 MaybeLocal < Function > maybe_fun = ScriptCompiler :: CompileFunctionInContext ( context , & script_source , parameters -> size (), parameters -> data (), 0 , nullptr , options ); Local < Function > fun = maybe_fun . ToLocalChecked (); return scope . Escape ( fun ); } LookupAndCompile\u51fd\u6570\u9996\u5148\u627e\u5230\u52a0\u8f7d\u6a21\u5757\u7684\u6e90\u7801\uff0c\u7136\u540e\u7f16\u8bd1\u51fa\u4e00\u4e2a\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0bLoadBuiltinModuleSource\u5982\u4f55\u67e5\u627e\u6a21\u5757\u6e90\u7801\u7684\u3002 1 2 3 4 MaybeLocal < String > NativeModuleLoader :: LoadBuiltinModuleSource ( Isolate * isolate , const char * id ) { const auto source_it = source_ . find ( id ); return source_it -> second . ToStringChecked ( isolate ); } \u8fd9\u91cc\u662fid\u662fnet\uff0c\u901a\u8fc7\u8be5id\u4ece_source\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u6570\u636e\uff0c\u90a3\u4e48_source\u662f\u4ec0\u4e48\u5462\uff1f\u56e0\u4e3aNode.js\u4e3a\u4e86\u63d0\u9ad8\u6548\u7387\uff0c\u628a\u539f\u751fJS\u6a21\u5757\u7684\u6e90\u7801\u5b57\u7b26\u4e32\u76f4\u63a5\u8f6c\u6210ASCII\u7801\u5b58\u5230\u5185\u5b58\u91cc\u3002\u8fd9\u6837\u52a0\u8f7d\u8fd9\u4e9b\u6a21\u5757\u7684\u65f6\u5019\uff0c\u5c31\u4e0d\u9700\u8981\u786c\u76d8IO\u4e86\u3002\u76f4\u63a5\u4ece\u5185\u5b58\u8bfb\u53d6\u5c31\u884c\u3002\u6211\u4eec\u770b\u4e00\u4e0b_source\u7684\u5b9a\u4e49\uff08\u5728\u7f16\u8bd1Node.js\u6e90\u7801\u6216\u8005\u6267\u884cjs2c.py\u751f\u6210\u7684node_javascript.cc\u4e2d\uff09\u3002 1 2 3 source_ . emplace ( \"net\" , UnionBytes { net_raw , 46682 }); source_ . emplace ( \"cyb\" , UnionBytes { cyb_raw , 63 }); source_ . emplace ( \"os\" , UnionBytes { os_raw , 7548 }); cyb\u662f\u6211\u589e\u52a0\u7684\u6d4b\u8bd5\u6a21\u5757\u3002\u6211\u4eec\u53ef\u4ee5\u770b\u4e00\u4e0b\u8be5\u6a21\u5757\u7684\u5185\u5bb9\u3002 1 2 3 4 5 static const uint8_t cyb_raw [] = { 99 , 111 , 110 , 115 , 116 , 32 , 99 , 121 , 98 , 32 , 61 , 32 , 105 , 110 , 116 , 101 , 114 , 110 , 97 , 108 , 66 , 105 , 110 , 100 , 105 , 110 , 103 , 40 , 39 , 99 , 121 , 98 , 95 , 119 , 114 , 97 , 112 , 39 , 41 , 59 , 32 , 10 , 109 , 111 , 100 , 117 , 108 , 101 , 46 , 101 , 120 , 112 , 111 , 114 , 116 , 115 , 32 , 61 , 32 , 99 , 121 , 98 , 59 }; \u6211\u4eec\u8f6c\u6210\u5b57\u7b26\u4e32\u770b\u4e00\u4e0b\u662f\u4ec0\u4e48 1 2 3 Buffer . from ([ 99 , 111 , 110 , 115 , 116 , 32 , 99 , 121 , 98 , 32 , 61 , 32 , 105 , 110 , 116 , 101 , 114 , 110 , 97 , 108 , 66 , 105 , 110 , 100 , 105 , 110 , 103 , 40 , 39 , 99 , 121 , 98 , 95 , 119 , 114 , 97 , 112 , 39 , 41 , 59 , 32 , 10 , 109 , 111 , 100 , 117 , 108 , 101 , 46 , 101 , 120 , 112 , 111 , 114 , 116 , 115 , 32 , 61 , 32 , 99 , 121 , 98 , 59 ]. join ( ',' ). split ( ',' )). toString ( 'utf-8' ) \u8f93\u51fa 1 2 const cyb = internalBinding ( 'cyb_wrap' ); module . exports = cyb ; \u6240\u4ee5\u6211\u4eec\u6267\u884crequire('net')\u65f6\uff0c\u901a\u8fc7NativeModule\u7684compileForInternalLoader\uff0c\u6700\u7ec8\u4f1a\u5728_source\u4e2d\u627e\u5230net\u6a21\u5757\u5bf9\u5e94\u7684\u6e90\u7801\u5b57\u7b26\u4e32\uff0c\u7136\u540e\u7f16\u8bd1\u6210\u4e00\u4e2a\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 const fn = compileFunction ( id ); fn ( this . exports , // \u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u7684\u52a0\u8f7d\u5668 nativeModuleRequire , this , process , // \u52a0\u8f7dC++\u6a21\u5757\u7684\u52a0\u8f7d\u5668 internalBinding , primordials ); \u7531fn\u7684\u5165\u53c2\u53ef\u4ee5\u77e5\u9053\uff0c\u6211\u4eec\u5728net\uff08\u6216\u5176\u5b83\u539f\u751fJS\u6a21\u5757\u4e2d\uff09\u53ea\u80fd\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u548c\u5185\u7f6e\u7684C++\u6a21\u5757\u3002\u5f53fn\u6267\u884c\u5b8c\u6bd5\u540e\uff0c\u539f\u751f\u6a21\u5757\u52a0\u8f7d\u5668\u5c31\u4f1a\u628amod.exports\u7684\u503c\u8fd4\u56de\u7ed9\u8c03\u7528\u65b9\u3002 19.3 \u52a0\u8f7d\u5185\u7f6eC++\u6a21\u5757 \u5728\u539f\u751fJS\u6a21\u5757\u4e2d\u6211\u4eec\u4e00\u822c\u4f1a\u52a0\u8f7d\u4e00\u4e9b\u5185\u7f6e\u7684C++\u6a21\u5757\uff0c\u8fd9\u662fNode.js\u62d3\u5c55JS\u529f\u80fd\u7684\u5173\u952e\u4e4b\u5904\u3002\u6bd4\u5982\u6211\u4eecrequire(\u2018net\u2019)\u7684\u65f6\u5019\uff0cnet\u6a21\u5757\u4f1a\u52a0\u8f7dtcp_wrap\u6a21\u5757\u3002 1 2 3 4 5 const { TCP , TCPConnectWrap , constants : TCPConstants } = internalBinding ( 'tcp_wrap' ) C++\u6a21\u5757\u52a0\u8f7d\u5668\u4e5f\u662f\u5728internal/bootstrap/loaders.js\u4e2d\u5b9a\u4e49\u7684\uff0c\u5206\u4e3a\u4e09\u79cd\u3002 1 internalBinding\uff1a\u4e0d\u66b4\u9732\u7ed9\u7528\u6237\u7684\u8bbf\u95ee\u7684\u63a5\u53e3\uff0c\u53ea\u80fd\u5728Node.js\u4ee3\u7801\u4e2d\u8bbf\u95ee\uff0c\u6bd4\u5982\u539f\u751fJS\u6a21\u5757\uff08flag\u4e3aNM_F_INTERNAL\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 let internalBinding ; { const bindingObj = ObjectCreate ( null ); internalBinding = function internalBinding ( module ) { let mod = bindingObj [ module ]; if ( typeof mod !== 'object' ) { mod = bindingObj [ module ] = getInternalBinding ( module ); moduleLoadList . push ( `Internal Binding ${ module } ` ); } return mod ; }; } internalBinding\u662f\u5728getInternalBinding\u51fd\u6570\u57fa\u7840\u4e0a\u52a0\u4e86\u7f13\u5b58\u529f\u80fd\u3002getInternalBinding\u662fC++\u5c42\u5b9a\u4e49\u7684\u51fd\u6570\u5bf9JS\u66b4\u9732\u7684\u63a5\u53e3\u540d\u3002\u5b83\u7684\u4f5c\u7528\u662f\u4eceC++\u6a21\u5757\u94fe\u8868\u4e2d\u627e\u5230\u5bf9\u5e94\u7684\u6a21\u5757\u3002 2 process.binding\uff1a\u66b4\u9732\u7ed9\u7528\u6237\u8c03\u7528C++\u6a21\u5757\u7684\u63a5\u53e3\uff0c\u4f46\u662f\u53ea\u80fd\u8bbf\u95ee\u90e8\u5206C++\u6a21\u5757\uff08flag\u4e3aNM_F_BUILTIN\u7684C++\u6a21\u5757\uff09\u3002 1 2 3 4 5 6 7 process . binding = function binding ( module ) { module = String ( module ); if ( internalBindingWhitelist . has ( module )) { return internalBinding ( module ); } throw new Error ( `No such module: ${ module } ` ); }; binding\u662f\u5728internalBinding\u7684\u57fa\u7840\u4e0a\u52a0\u4e86\u767d\u540d\u5355\u7684\u903b\u8f91\uff0c\u53ea\u5bf9\u5916\u66b4\u9732\u90e8\u5206\u6a21\u5757\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const internalBindingWhitelist = new SafeSet ([ 'async_wrap' , 'buffer' , 'cares_wrap' , 'config' , 'constants' , 'contextify' , 'crypto' , 'fs' , 'fs_event_wrap' , 'http_parser' , 'icu' , 'inspector' , 'js_stream' , 'natives' , 'os' , 'pipe_wrap' , 'process_wrap' , 'signal_wrap' , 'spawn_sync' , 'stream_wrap' , 'tcp_wrap' , 'tls_wrap' , 'tty_wrap' , 'udp_wrap' , 'url' , 'util' , 'uv' , 'v8' , 'zlib' ]); 3 process._linkedBinding: \u66b4\u9732\u7ed9\u7528\u6237\u8bbf\u95eeC++\u6a21\u5757\u7684\u63a5\u53e3\uff0c\u7528\u4e8e\u8bbf\u95ee\u7528\u6237\u81ea\u5df1\u6dfb\u52a0\u7684\u4f46\u662f\u6ca1\u6709\u52a0\u5230\u5185\u7f6e\u6a21\u5757\u7684C++\u6a21\u5757\uff08flag\u4e3aNM_F_LINKED\uff09\u3002 1 2 3 4 5 6 7 8 const bindingObj = ObjectCreate ( null ); process . _linkedBinding = function _linkedBinding ( module ) { module = String ( module ); let mod = bindingObj [ module ]; if ( typeof mod !== 'object' ) mod = bindingObj [ module ] = getLinkedBinding ( module ); return mod ; }; _linkedBinding\u662f\u5728getLinkedBinding\u51fd\u6570\u57fa\u7840\u4e0a\u52a0\u4e86\u7f13\u5b58\u529f\u80fd\uff0cgetLinkedBinding\u662fC++\u5c42\u5b9a\u4e49\u7684\u51fd\u6570\u5bf9\u5916\u66b4\u9732\u7684\u540d\u5b57\u3002getLinkedBinding\u4ece\u53e6\u4e00\u4e2aC++\u6a21\u5757\u94fe\u8868\u4e2d\u67e5\u627e\u5bf9\u5e94\u7684\u6a21\u5757\u3002 \u4e0a\u4e00\u8282\u5df2\u7ecf\u5206\u6790\u8fc7\uff0cinternalBinding\u662f\u52a0\u8f7d\u539f\u751fJS\u6a21\u5757\u65f6\u4f20\u5165\u7684\u5b9e\u53c2\u3002internalBinding\u662f\u5bf9getInternalBinding\u7684\u5c01\u88c5\u3002getInternalBinding\u5bf9\u5e94\u7684\u662fbinding::GetInternalBinding\uff08node_binding.cc\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // \u6839\u636e\u6a21\u5757\u540d\u67e5\u627e\u5bf9\u5e94\u7684\u6a21\u5757 void GetInternalBinding ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); // \u6a21\u5757\u540d Local < String > module = args [ 0 ]. As < String > (); node :: Utf8Value module_v ( env -> isolate (), module ); Local < Object > exports ; // \u4eceC++\u5185\u90e8\u6a21\u5757\u627e node_module * mod = FindModule ( modlist_internal , * module_v , NM_F_INTERNAL ); // \u627e\u5230\u5219\u521d\u59cb\u5316 if ( mod != nullptr ) { exports = InitModule ( env , mod , module ); } else { // \u7701\u7565 } args . GetReturnValue (). Set ( exports ); } modlist_internal\u662f\u4e00\u6761\u94fe\u8868\uff0c\u5728Node.js\u542f\u52a8\u8fc7\u7a0b\u7684\u65f6\u5019\uff0c\u7531\u5404\u4e2aC++\u6a21\u5757\u8fde\u6210\u7684\u94fe\u8868\u3002\u901a\u8fc7\u6a21\u5757\u540d\u627e\u5230\u5bf9\u5e94\u7684C++\u6a21\u5757\u540e\uff0c\u6267\u884cInitModule\u521d\u59cb\u5316\u6a21\u5757\u3002 1 2 3 4 5 6 7 8 9 // \u521d\u59cb\u5316\u4e00\u4e2a\u6a21\u5757\uff0c\u5373\u6267\u884c\u5b83\u91cc\u9762\u7684\u6ce8\u518c\u51fd\u6570 static Local < Object > InitModule ( Environment * env , node_module * mod , Local < String > module ) { Local < Object > exports = Object :: New ( env -> isolate ()); Local < Value > unused = Undefined ( env -> isolate ()); mod -> nm_context_register_func ( exports , unused , env -> context (), mod -> nm_priv ); return exports ; } \u6267\u884cC++\u6a21\u5757\u7684nm_context_register_func\u6307\u5411\u7684\u51fd\u6570\u3002\u8fd9\u4e2a\u51fd\u6570\u5c31\u662f\u5728C++\u6a21\u5757\u6700\u540e\u4e00\u884c\u5b9a\u4e49\u7684Initialize\u51fd\u6570\u3002Initialize\u4f1a\u8bbe\u7f6e\u5bfc\u51fa\u7684\u5bf9\u8c61\u3002\u6211\u4eec\u4eceJS\u53ef\u4ee5\u8bbf\u95eeInitialize\u5bfc\u51fa\u7684\u5bf9\u8c61\u3002V8\u4e2d\uff0cJS\u8c03\u7528C++\u51fd\u6570\u7684\u89c4\u5219\u662f\u51fd\u6570\u5165\u53c2const FunctionCallbackInfo & args\uff08\u62ff\u5230JS\u4f20\u8fc7\u6765\u7684\u5185\u5bb9\uff09\u548c\u8bbe\u7f6e\u8fd4\u56de\u503cargs.GetReturnValue().Set(\u7ed9JS\u8fd4\u56de\u7684\u5185\u5bb9), GetInternalBinding\u51fd\u6570\u7684\u903b\u8f91\u5c31\u662f\u6267\u884c\u5bf9\u5e94\u6a21\u5757\u7684\u94a9\u5b50\u51fd\u6570\uff0c\u5e76\u4f20\u4e00\u4e2aexports\u53d8\u91cf\u8fdb\u53bb\uff0c\u7136\u540e\u94a9\u5b50\u51fd\u6570\u4f1a\u4fee\u6539exports\u7684\u503c\uff0c\u8be5exports\u7684\u503c\u5c31\u662fJS\u5c42\u80fd\u62ff\u5230\u7684\u503c\u3002","title":"19.2 \u52a0\u8f7d\u539f\u751fJS\u6a21\u5757"},{"location":"chapter20-%E6%8B%93%E5%B1%95Node.js/","text":"\u62d3\u5c55Node.js\u4ece\u5b8f\u89c2\u6765\u8bf4\uff0c\u6709\u51e0\u79cd\u65b9\u5f0f\uff0c\u5305\u62ec\u76f4\u63a5\u4fee\u6539Node.js\u5185\u6838\u91cd\u65b0\u7f16\u8bd1\u5206\u53d1\u3001\u63d0\u4f9bnpm\u5305\u3002npm\u5305\u53c8\u53ef\u4ee5\u5206\u4e3aJS\u548cC++\u62d3\u5c55\u3002\u672c\u7ae0\u4e3b\u8981\u662f\u4ecb\u7ecd\u4fee\u6539Node.js\u5185\u6838\u548c\u5199C++\u63d2\u4ef6\u3002 20.1 \u4fee\u6539Node.js\u5185\u6838 \u00b6 \u4fee\u6539Node.js\u5185\u6838\u7684\u65b9\u5f0f\u4e5f\u6709\u5f88\u591a\u79cd\uff0c\u6211\u4eec\u53ef\u4ee5\u4fee\u6539JS\u5c42\u3001C++\u3001C\u8bed\u8a00\u5c42\u7684\u4ee3\u7801\uff0c\u4e5f\u53ef\u4ee5\u65b0\u589e\u4e00\u4e9b\u529f\u80fd\u6216\u6a21\u5757\u3002\u672c\u8282\u5206\u522b\u4ecb\u7ecd\u5982\u4f55\u65b0\u589e\u4e00\u4e2aNode.js\u7684C++\u6a21\u5757\u548c\u4fee\u6539Node.js\u5185\u6838\u3002\u76f8\u6bd4\u4fee\u6539Node.js\u5185\u6838\u4ee3\u7801\uff0c\u65b0\u589e\u4e00\u4e2aNode.js\u5185\u7f6e\u6a21\u5757\u9700\u8981\u4e86\u89e3\u66f4\u591a\u7684\u77e5\u8bc6\u3002 20.1.1 \u65b0\u589e\u4e00\u4e2a\u5185\u7f6eC++\u6a21\u5757 \u00b6 1.\u9996\u5148\u5728src\u6587\u4ef6\u5939\u4e0b\u65b0\u589e\u4e24\u4e2a\u6587\u4ef6\u3002 cyb.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #ifndef SRC_CYB_H_ #define SRC_CYB_H_ #include \"v8.h\" namespace node { class Environment ; class Cyb { public : static void Initialize ( v8 :: Local < v8 :: Object > target , v8 :: Local < v8 :: Value > unused , v8 :: Local < v8 :: Context > context , void * priv ); private : static void Console ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); }; } // namespace node #endif cyb.cc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \"cyb.h\" #include \"env-inl.h\" #include \"util-inl.h\" #include \"node_internals.h\" namespace node { using v8 :: Context ; using v8 :: Function ; using v8 :: FunctionCallbackInfo ; using v8 :: FunctionTemplate ; using v8 :: Local ; using v8 :: Object ; using v8 :: String ; using v8 :: Value ; void Cyb::Initialize ( Local < Object > target , Local < Value > unused , Local < Context > context , void * priv ) { Environment * env = Environment :: GetCurrent ( context ); // \u7533\u8bf7\u4e00\u4e2a\u51fd\u6570\u6a21\u5757\uff0c\u6a21\u677f\u51fd\u6570\u662fConsole Local < FunctionTemplate > t = env -> NewFunctionTemplate ( Console ); // \u7533\u8bf7\u4e00\u4e2a\u5b57\u7b26\u4e32 Local < String > str = FIXED_ONE_BYTE_STRING ( env -> isolate (), \"console\" ); // \u8bbe\u7f6e\u51fd\u6570\u540d t -> SetClassName ( str ); // \u5bfc\u51fa\u51fd\u6570\uff0ctarget\u5373exports target -> Set ( env -> context (), str , t -> GetFunction ( env -> context ()). ToLocalChecke d ()). Check (); } void Cyb::Console ( const FunctionCallbackInfo < Value >& args ) { v8 :: Isolate * isolate = args . GetIsolate (); v8 :: Local < String > str = String :: NewFromUtf8 ( isolate , \"hello world\" ); args . GetReturnValue (). Set ( str ); } } // namespace node // \u58f0\u660e\u8be5\u6a21\u5757 NODE_MODULE_CONTEXT_AWARE_INTERNAL ( cyb_wrap , node :: Cyb :: Initialize ) \u6211\u4eec\u65b0\u5b9a\u4e49\u4e00\u4e2a\u6a21\u5757\uff0c\u662f\u4e0d\u80fd\u81ea\u52a8\u6dfb\u52a0\u5230Node.js\u5185\u6838\u7684\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u989d\u5916\u7684\u64cd\u4f5c\u3002 1 \u9996\u5148\u6211\u4eec\u9700\u8981\u4fee\u6539node.gyp\u6587\u4ef6\u3002\u628a\u6211\u4eec\u65b0\u589e\u7684\u6587\u4ef6\u52a0\u5230\u914d\u7f6e\u91cc\uff0c\u5426\u5219\u7f16\u8bd1\u7684\u65f6\u5019\uff0c\u4e0d\u4f1a\u7f16\u8bd1\u8fd9\u4e2a\u65b0\u589e\u7684\u6a21\u5757\u3002\u6211\u4eec\u53ef\u4ee5\u5728node.gyp\u6587\u4ef6\u4e2d\u627e\u5230src/tcp_wrap.cc,\u7136\u540e\u5728\u5b83\u540e\u9762\u52a0\u5165\u6211\u4eec\u7684\u6587\u4ef6\u5c31\u884c\u3002 1 2 src/cyb_wrap.cc src/cyb_wrap.h \u8fd9\u65f6\u5019Node.js\u4f1a\u7f16\u8bd1\u6211\u4eec\u7684\u4ee3\u7801\u4e86\u3002\u4f46\u662fNode.js\u7684\u5185\u7f6e\u6a21\u5757\u6709\u4e00\u5b9a\u7684\u673a\u5236\uff0c\u6211\u4eec\u7684\u4ee3\u7801\u52a0\u5165\u4e86Node.js\u5185\u6838\uff0c\u4e0d\u4ee3\u8868\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e86\u3002Node.js\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u4f1a\u8c03\u7528RegisterBuiltinModules\u51fd\u6570\u6ce8\u518c\u6240\u6709\u7684\u5185\u7f6eC++\u6a21\u5757\u3002 1 2 3 4 5 void RegisterBuiltinModules () { #define V(modname) _register_##modname(); NODE_BUILTIN_MODULES ( V ) #undef V } \u6211\u4eec\u770b\u5230\u8be5\u51fd\u6570\u53ea\u6709\u4e00\u4e2a\u5b8f\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u5b8f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 void RegisterBuiltinModules () { #define V(modname) _register_##modname(); NODE_BUILTIN_MODULES ( V ) #undef V } #define NODE_BUILTIN_MODULES(V) \\ NODE_BUILTIN_STANDARD_MODULES ( V ) \\ NODE_BUILTIN_OPENSSL_MODULES ( V ) \\ NODE_BUILTIN_ICU_MODULES ( V ) \\ NODE_BUILTIN_REPORT_MODULES ( V ) \\ NODE_BUILTIN_PROFILER_MODULES ( V ) \\ NODE_BUILTIN_DTRACE_MODULES ( V ) \u5b8f\u91cc\u9762\u53c8\u662f\u4e00\u5806\u5b8f\u3002\u6211\u4eec\u8981\u505a\u7684\u5c31\u662f\u4fee\u6539\u8fd9\u4e2a\u5b8f\u3002\u56e0\u4e3a\u6211\u4eec\u662f\u81ea\u5b9a\u4e49\u7684\u5185\u7f6e\u6a21\u5757\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u589e\u52a0\u4e00\u4e2a\u5b8f\u3002 1 2 #define NODE_BUILTIN_EXTEND_MODULES(V) \\ V ( cyb_wrap ) \u7136\u540e\u628a\u8fd9\u4e2a\u5b8f\u8ffd\u52a0\u5230\u90a3\u4e00\u5806\u5b8f\u540e\u9762\u3002 1 2 3 4 5 6 7 8 #define NODE_BUILTIN_MODULES(V) \\ NODE_BUILTIN_STANDARD_MODULES ( V ) \\ NODE_BUILTIN_OPENSSL_MODULES ( V ) \\ NODE_BUILTIN_ICU_MODULES ( V ) \\ NODE_BUILTIN_REPORT_MODULES ( V ) \\ NODE_BUILTIN_PROFILER_MODULES ( V ) \\ NODE_BUILTIN_DTRACE_MODULES ( V ) \\ NODE_BUILTIN_EXTEND_MODULES ( V ) \u8fd9\u65f6\u5019\uff0cNode.js\u4e0d\u4ec5\u53ef\u4ee5\u7f16\u8bd1\u6211\u4eec\u7684\u4ee3\u7801\uff0c\u8fd8\u4f1a\u628a\u6211\u4eec\u4ee3\u7801\u4e2d\u5b9a\u4e49\u7684\u6a21\u5757\u6ce8\u518c\u5230\u5185\u7f6eC++\u6a21\u5757\u91cc\u4e86\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u5982\u4f55\u4f7f\u7528C++\u6a21\u5757\u4e86\u3002 2 \u5728lib\u6587\u4ef6\u5939\u65b0\u5efa\u4e00\u4e2acyb.js\uff0c\u4f5c\u4e3aNode.js\u539f\u751f\u6a21\u5757 1 2 const cyb = internalBinding ( 'cyb_wrap' ); module . exports = cyb ; \u65b0\u589e\u539f\u751f\u6a21\u5757\uff0c\u6211\u4eec\u4e5f\u9700\u8981\u4fee\u6539node.gyp\u6587\u4ef6\uff0c\u5426\u5219\u4ee3\u7801\u4e5f\u4e0d\u4f1a\u88ab\u7f16\u8bd1\u8fdbnode\u5185\u6838\u3002\u6211\u4eec\u627e\u5230node.gyp\u6587\u4ef6\u7684lib/net.js\uff0c\u5728\u540e\u9762\u8ffd\u52a0lib/cyb.js\u3002\u8be5\u914d\u7f6e\u4e0b\u7684\u6587\u4ef6\u662f\u7ed9js2c.py\u4f7f\u7528\u7684\uff0c\u5982\u679c\u4e0d\u4fee\u6539\uff0c\u6211\u4eec\u5728require\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u627e\u4e0d\u5230\u8be5\u6a21\u5757\u3002\u6700\u540e\u6211\u4eec\u5728lib/internal/bootstrap/loader\u6587\u4ef6\u91cc\u627e\u5230internalBindingWhitelist\u53d8\u91cf\uff0c\u5728\u6570\u7ec4\u6700\u540e\u589e\u52a0cyb_wrap\uff0c\u8fd9\u4e2a\u914d\u7f6e\u662f\u7ed9process.binding\u51fd\u6570\u4f7f\u7528\u7684\uff0c\u5982\u679c\u4e0d\u4fee\u6539\u8fd9\u4e2a\u914d\u7f6e\uff0c\u901a\u8fc7process.binding\u5c31\u627e\u4e0d\u5230\u6211\u4eec\u7684\u6a21\u5757\u3002process.binding\u662f\u53ef\u4ee5\u5728\u7528\u6237JS\u91cc\u4f7f\u7528\u7684\u3002\u81f3\u6b64\uff0c\u6211\u4eec\u5b8c\u6210\u4e86\u6240\u6709\u7684\u4fee\u6539\u5de5\u4f5c\uff0c\u91cd\u65b0\u7f16\u8bd1Node.js\u3002\u7136\u540e\u7f16\u5199\u6d4b\u8bd5\u7a0b\u5e8f\u3002 3 \u65b0\u5efa\u4e00\u4e2a\u6d4b\u8bd5\u6587\u4ef6testcyb.js 1 2 3 // const cyb = process.binding('cyb_wrap'); const cyb = require ( 'cyb' ); console . log ( cyb . console ()) \u53ef\u4ee5\u770b\u5230\uff0c\u4f1a\u8f93\u51fahello world\u3002 20.1.2 \u4fee\u6539Node.js\u5185\u6838 \u00b6 \u672c\u8282\u4ecb\u7ecd\u5982\u4f55\u4fee\u6539Node.js\u5185\u6838\u3002\u4fee\u6539\u7684\u90e8\u5206\u4e3b\u8981\u662f\u4e3a\u4e86\u5b8c\u5584Node.js\u7684TCP keepalive\u529f\u80fd\u3002\u76ee\u524dNode.js\u7684keepalive\u53ea\u652f\u6301\u8bbe\u7f6e\u5f00\u5173\u4ee5\u53ca\u7a7a\u95f2\u591a\u4e45\u540e\u53d1\u9001\u63a2\u6d4b\u5305\u3002\u5728\u65b0\u7248Linux\u5185\u6838\u4e2d\uff0cTCP keepalive\u5305\u62ec\u4ee5\u4e0b\u914d\u7f6e\u3002 1 2 3 4 1 \u591a\u4e45\u6ca1\u6709\u901a\u4fe1\u6570\u636e\u5305\uff0c\u5219\u5f00\u59cb\u53d1\u9001\u63a2\u6d4b\u5305\u3002 2 \u6bcf\u9694\u591a\u4e45\uff0c\u518d\u6b21\u53d1\u9001\u63a2\u6d4b\u5305\u3002 3 \u53d1\u9001\u591a\u5c11\u4e2a\u63a2\u6d4b\u5305\u540e\uff0c\u5c31\u8ba4\u4e3a\u8fde\u63a5\u65ad\u5f00\u3002 4 TCP_USER_TIMEOUT\uff0c\u53d1\u9001\u4e86\u6570\u636e\uff0c\u591a\u4e45\u6ca1\u6709\u6536\u5230ack\u540e\uff0c\u8ba4\u4e3a\u8fde\u63a5\u65ad\u5f00\u3002 Node.js\u53ea\u652f\u6301\u7b2c\u4e00\u6761\uff0c\u6240\u4ee5\u6211\u4eec\u7684\u76ee\u7684\u662f\u652f\u63012,3,4\u3002\u56e0\u4e3a\u8fd9\u4e2a\u529f\u80fd\u662f\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\uff0c\u6240\u4ee5\u9996\u5148\u9700\u8981\u4fee\u6539Libuv\u7684\u4ee3\u7801\u3002 1 \u4fee\u6539src/unix/tcp.c \u5728tcp.c\u52a0\u5165\u4ee5\u4e0b\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 int uv_tcp_keepalive_ex ( uv_tcp_t * handle , int on , unsigned int delay , unsigned int interval , unsigned int count ) { int err ; if ( uv__stream_fd ( handle ) != - 1 ) { err = uv__tcp_keepalive_ex ( uv__stream_fd ( handle ), on , delay , interval , count ); if ( err ) return err ; } if ( on ) handle -> flags |= UV_HANDLE_TCP_KEEPALIVE ; else handle -> flags &= ~ UV_HANDLE_TCP_KEEPALIVE ; return 0 ; } int uv_tcp_timeout ( uv_tcp_t * handle , unsigned int timeout ) { # ifdef TCP_USER_TIMEOUT int fd = uv__stream_fd ( handle ); if ( fd != - 1 && setsockopt ( fd , IPPROTO_TCP , TCP_USER_TIMEOUT , & timeout , sizeof ( timeout ))) { return UV__ERR ( errno ); } # endif return 0 ; } int uv__tcp_keepalive_ex ( int fd , int on , unsigned int delay , unsigned int interval , unsigned int count ) { if ( setsockopt ( fd , SOL_SOCKET , SO_KEEPALIVE , & on , sizeof ( on ))) return UV__ERR ( errno ); # ifdef TCP_KEEPIDLE if ( on && delay && setsockopt ( fd , IPPROTO_TCP , TCP_KEEPIDLE , & delay , sizeof ( delay ))) return UV__ERR ( errno ); # endif # ifdef TCP_KEEPINTVL if ( on && interval && setsockopt ( fd , IPPROTO_TCP , TCP_KEEPINTVL , & interval , sizeof ( interval ))) return UV__ERR ( errno ); # endif # ifdef TCP_KEEPCNT if ( on && count && setsockopt ( fd , IPPROTO_TCP , TCP_KEEPCNT , & count , sizeof ( count ))) return UV__ERR ( errno ); # endif /* Solaris/SmartOS, if you don't support keep-alive, * then don't advertise it in your system headers... */ /* FIXME(bnoordhuis) That's possibly because sizeof(delay) should be 1. */ # if defined ( TCP_KEEPALIVE ) && ! defined ( __sun ) if ( on && setsockopt ( fd , IPPROTO_TCP , TCP_KEEPALIVE , & delay , sizeof ( delay ))) return UV__ERR ( errno ); # endif return 0 ; } 2 \u4fee\u6539include/uv.h \u628a\u5728tcp.c\u4e2d\u52a0\u5165\u7684\u63a5\u53e3\u66b4\u9732\u51fa\u6765\u3002 1 2 3 4 5 6 UV_EXTERN int uv_tcp_keepalive_ex ( uv_tcp_t * handle , int enable , unsigned int delay , unsigned int interval , unsigned int count ); UV_EXTERN int uv_tcp_timeout ( uv_tcp_t * handle , unsigned int timeout ); \u81f3\u6b64\uff0c\u6211\u4eec\u5c31\u4fee\u6539\u5b8cLibuv\u7684\u4ee3\u7801\uff0c\u4e5f\u5bf9\u5916\u66b4\u9732\u4e86\u8bbe\u7f6e\u7684\u63a5\u53e3\uff0c\u63a5\u7740\u6211\u4eec\u4fee\u6539\u4e0a\u5c42\u7684C++\u548cJS\u4ee3\u7801\uff0c\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u5728JS\u5c42\u4f7f\u7528\u8be5\u529f\u80fd\u3002 3 \u4fee\u6539src/tcp_wrap.cc \u4fee\u6539TCPWrap::Initialize\u51fd\u6570\u7684\u4ee3\u7801\u3002 1 2 env -> SetProtoMethod ( t , \"setKeepAliveEx\" , SetKeepAliveEx ); env -> SetProtoMethod ( t , \"setKeepAliveTimeout\" , SetKeepAliveTimeout ); \u9996\u5148\u5bf9JS\u5c42\u66b4\u9732\u4e24\u4e2a\u65b0\u7684API\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e24\u4e2aAPI\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void TCPWrap::SetKeepAliveEx ( const FunctionCallbackInfo < Value >& args ) { TCPWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder (), args . GetReturnValue (). Set ( UV_EBADF )); Environment * env = wrap -> env (); int enable ; if ( ! args [ 0 ] -> Int32Value ( env -> context ()). To ( & enable )) return ; unsigned int delay = static_cast < unsigned int > ( args [ 1 ]. As < Uint32 > () -> Value ()); unsigned int detal = static_cast < unsigned int > ( args [ 2 ]. As < Uint32 > () -> Value ()); unsigned int count = static_cast < unsigned int > ( args [ 3 ]. As < Uint32 > () -> Value ()); int err = uv_tcp_keepalive_ex ( & wrap -> handle_ , enable , delay , detal , count ); args . GetReturnValue (). Set ( err ); } void TCPWrap::SetKeepAliveTimeout ( const FunctionCallbackInfo < Value >& args ) { TCPWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder (), args . GetReturnValue (). Set ( UV_EBADF )); unsigned int time = static_cast < unsigned int > ( args [ 0 ]. As < Uint32 > () -> Value ()); int err = uv_tcp_timeout ( & wrap -> handle_ , time ); args . GetReturnValue (). Set ( err ); } \u540c\u65f6\u8fd8\u9700\u8981\u5728src/tcp_wrap.h\u4e2d\u58f0\u660e\u8fd9\u4e24\u4e2a\u51fd\u6570\u3002 1 2 static void SetKeepAliveEx ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static void SetKeepAliveTimeout ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // \u4fee\u6539lib/net.js Socket . prototype . setKeepAliveEx = function ( setting , secs , interval , count ) { if ( ! this . _handle ) { this . once ( 'connect' , () => this . setKeepAliveEx ( setting , secs , interval , count )); return this ; } if ( this . _handle . setKeepAliveEx ) this . _handle . setKeepAliveEx ( setting , ~~ secs > 0 ? ~~ secs : 0 , ~~ interval > 0 ? ~~ interval : 0 , ~~ count > 0 ? ~~ count : 0 ); return this ; }; Socket . prototype . setKeepAliveTimeout = function ( timeout ) { if ( ! this . _handle ) { this . once ( 'connect' , () => this . setKeepAliveTimeout ( timeout )); return this ; } if ( this . _handle . setKeepAliveTimeout ) this . _handle . setKeepAliveTimeout ( ~~ timeout > 0 ? ~~ timeout : 0 ); return this ; }; \u91cd\u65b0\u7f16\u8bd1Node.js\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u4f7f\u7528\u8fd9\u4e24\u4e2a\u65b0\u7684API\u66f4\u7075\u6d3b\u5730\u63a7\u5236TCP\u7684keepalive\u4e86\u3002 1 2 3 4 5 const net = require ( 'net' ); net . createServer (( socket ) => { socket . setKeepAliveEx ( true , 1 , 2 , 3 ); // socket.setKeepAliveTimeout(4); }). listen ( 1101 ); 20.2 \u4f7f\u7528N-API\u7f16\u5199C++\u63d2\u4ef6 \u00b6 \u672c\u5c0f\u8282\u4ecb\u7ecd\u4f7f\u7528N_API\u7f16\u5199C++\u63d2\u4ef6\u77e5\u8bc6\u3002Node.js C++\u63d2\u4ef6\u672c\u8d28\u662f\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u5199\u5b8c\u7f16\u8bd1\u540e\uff0c\u751f\u6210\u4e00\u4e2a.node\u6587\u4ef6\u3002\u6211\u4eec\u5728Node.js\u91cc\u76f4\u63a5require\u4f7f\u7528\uff0cNode.js\u4f1a\u4e3a\u6211\u4eec\u5904\u7406\u4e00\u5207\u3002 \u9996\u5148\u5efa\u7acb\u4e00\u4e2atest.cc\u6587\u4ef6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // hello.cc using N-API #include <node_api.h> namespace demo { napi_value Method ( napi_env env , napi_callback_info args ) { napi_value greeting ; napi_status status ; status = napi_create_string_utf8 ( env , \"world\" , NAPI_AUTO_LENGTH , & greeting ); if ( status != napi_ok ) return nullptr ; return greeting ; } napi_value init ( napi_env env , napi_value exports ) { napi_status status ; napi_value fn ; status = napi_create_function ( env , nullptr , 0 , Method , nullptr , & fn ); if ( status != napi_ok ) return nullptr ; status = napi_set_named_property ( env , exports , \"hello\" , fn ); if ( status != napi_ok ) return nullptr ; return exports ; } NAPI_MODULE ( NODE_GYP_MODULE_NAME , init ) } // namespace demo \u6211\u4eec\u4e0d\u9700\u8981\u5177\u4f53\u4e86\u89e3\u4ee3\u7801\u7684\u610f\u601d\uff0c\u4f46\u662f\u4ece\u4ee3\u7801\u4e2d\u6211\u4eec\u5927\u81f4\u77e5\u9053\u5b83\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002\u5269\u4e0b\u7684\u5c31\u662f\u9605\u8bfbN-API\u7684API\u6587\u6863\u5c31\u53ef\u4ee5\u3002\u63a5\u7740\u6211\u4eec\u65b0\u5efa\u4e00\u4e2abinding.gyp\u6587\u4ef6\u3002gyp\u6587\u4ef6\u662fnode-gyp\u7684\u914d\u7f6e\u6587\u4ef6\u3002node-gyp\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u9488\u5bf9\u4e0d\u540c\u5e73\u53f0\u751f\u4ea7\u4e0d\u540c\u7684\u7f16\u8bd1\u914d\u7f6e\u6587\u4ef6\u3002\u6bd4\u5982Linux\u4e0b\u7684makefile\u3002 1 2 3 4 5 6 7 8 { \"targets\" : [ { \"target_name\" : \"test\" , \"sources\" : [ \"./test.cc\" ] } ] } \u8bed\u6cd5\u548cmakefile\u6709\u70b9\u50cf\uff0c\u5c31\u662f\u5b9a\u4e49\u6211\u4eec\u7f16\u8bd1\u540e\u7684\u76ee\u524d\u6587\u4ef6\u540d\uff0c\u4f9d\u8d56\u54ea\u4e9b\u6e90\u6587\u4ef6\u3002\u7136\u540e\u6211\u4eec\u5b89\u88c5node-gyp\u3002 1 npm install node-gyp -g Node.js\u6e90\u7801\u4e2d\u4e5f\u6709\u4e00\u4e2anode-gyp\uff0c\u5b83\u662f\u5e2e\u52a9npm\u5b89\u88c5\u62d3\u5c55\u6a21\u5757\u65f6\uff0c\u5c31\u5730\u7f16\u8bd1\u7528\u7684\u3002\u6211\u4eec\u5b89\u88c5\u7684node-gyp\u662f\u5e2e\u52a9\u6211\u4eec\u751f\u6210\u914d\u7f6e\u6587\u4ef6\u5e76\u7f16\u8bd1\u7528\u7684\uff0c\u5177\u4f53\u53ef\u4ee5\u53c2\u8003Node.js\u6587\u6863\u3002\u4e00\u5207\u51c6\u5907\u5c31\u7eea\u3002\u6211\u4eec\u5f00\u59cb\u7f16\u8bd1\u3002\u76f4\u63a5\u6267\u884c 1 2 node-gyp configure node-gyp build \u5728\u8def\u5f84./build/Release/\u4e0b\u751f\u6210\u4e86test.node\u6587\u4ef6\u3002\u8fd9\u5c31\u662f\u6211\u4eec\u7684\u62d3\u5c55\u6a21\u5757\u3002\u6211\u4eec\u7f16\u5199\u6d4b\u8bd5\u7a0b\u5e8fapp.js\u3002 1 2 var addon = require ( \"./build/Release/test\" ); console . log ( addon . hello ()); \u6267\u884c \u2003 1 node app.js \u6211\u4eec\u770b\u5230\u8f93\u51faworld\u3002\u6211\u4eec\u5df2\u7ecf\u5b66\u4f1a\u4e86\u5982\u4f55\u7f16\u5199\u4e00\u4e2aNode.js\u7684\u62d3\u5c55\u6a21\u5757\u3002\u5269\u4e0b\u7684\u5c31\u662f\u9605\u8bfbN-API\u6587\u6863\uff0c\u6839\u636e\u81ea\u5df1\u7684\u9700\u6c42\u7f16\u5199\u4e0d\u540c\u7684\u6a21\u5757\u3002","title":"24-\u62d3\u5c55Node.js"},{"location":"chapter20-%E6%8B%93%E5%B1%95Node.js/#201-nodejs","text":"\u4fee\u6539Node.js\u5185\u6838\u7684\u65b9\u5f0f\u4e5f\u6709\u5f88\u591a\u79cd\uff0c\u6211\u4eec\u53ef\u4ee5\u4fee\u6539JS\u5c42\u3001C++\u3001C\u8bed\u8a00\u5c42\u7684\u4ee3\u7801\uff0c\u4e5f\u53ef\u4ee5\u65b0\u589e\u4e00\u4e9b\u529f\u80fd\u6216\u6a21\u5757\u3002\u672c\u8282\u5206\u522b\u4ecb\u7ecd\u5982\u4f55\u65b0\u589e\u4e00\u4e2aNode.js\u7684C++\u6a21\u5757\u548c\u4fee\u6539Node.js\u5185\u6838\u3002\u76f8\u6bd4\u4fee\u6539Node.js\u5185\u6838\u4ee3\u7801\uff0c\u65b0\u589e\u4e00\u4e2aNode.js\u5185\u7f6e\u6a21\u5757\u9700\u8981\u4e86\u89e3\u66f4\u591a\u7684\u77e5\u8bc6\u3002","title":"20.1 \u4fee\u6539Node.js\u5185\u6838"},{"location":"chapter20-%E6%8B%93%E5%B1%95Node.js/#2011-c","text":"1.\u9996\u5148\u5728src\u6587\u4ef6\u5939\u4e0b\u65b0\u589e\u4e24\u4e2a\u6587\u4ef6\u3002 cyb.h 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #ifndef SRC_CYB_H_ #define SRC_CYB_H_ #include \"v8.h\" namespace node { class Environment ; class Cyb { public : static void Initialize ( v8 :: Local < v8 :: Object > target , v8 :: Local < v8 :: Value > unused , v8 :: Local < v8 :: Context > context , void * priv ); private : static void Console ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); }; } // namespace node #endif cyb.cc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \"cyb.h\" #include \"env-inl.h\" #include \"util-inl.h\" #include \"node_internals.h\" namespace node { using v8 :: Context ; using v8 :: Function ; using v8 :: FunctionCallbackInfo ; using v8 :: FunctionTemplate ; using v8 :: Local ; using v8 :: Object ; using v8 :: String ; using v8 :: Value ; void Cyb::Initialize ( Local < Object > target , Local < Value > unused , Local < Context > context , void * priv ) { Environment * env = Environment :: GetCurrent ( context ); // \u7533\u8bf7\u4e00\u4e2a\u51fd\u6570\u6a21\u5757\uff0c\u6a21\u677f\u51fd\u6570\u662fConsole Local < FunctionTemplate > t = env -> NewFunctionTemplate ( Console ); // \u7533\u8bf7\u4e00\u4e2a\u5b57\u7b26\u4e32 Local < String > str = FIXED_ONE_BYTE_STRING ( env -> isolate (), \"console\" ); // \u8bbe\u7f6e\u51fd\u6570\u540d t -> SetClassName ( str ); // \u5bfc\u51fa\u51fd\u6570\uff0ctarget\u5373exports target -> Set ( env -> context (), str , t -> GetFunction ( env -> context ()). ToLocalChecke d ()). Check (); } void Cyb::Console ( const FunctionCallbackInfo < Value >& args ) { v8 :: Isolate * isolate = args . GetIsolate (); v8 :: Local < String > str = String :: NewFromUtf8 ( isolate , \"hello world\" ); args . GetReturnValue (). Set ( str ); } } // namespace node // \u58f0\u660e\u8be5\u6a21\u5757 NODE_MODULE_CONTEXT_AWARE_INTERNAL ( cyb_wrap , node :: Cyb :: Initialize ) \u6211\u4eec\u65b0\u5b9a\u4e49\u4e00\u4e2a\u6a21\u5757\uff0c\u662f\u4e0d\u80fd\u81ea\u52a8\u6dfb\u52a0\u5230Node.js\u5185\u6838\u7684\uff0c\u6211\u4eec\u8fd8\u9700\u8981\u989d\u5916\u7684\u64cd\u4f5c\u3002 1 \u9996\u5148\u6211\u4eec\u9700\u8981\u4fee\u6539node.gyp\u6587\u4ef6\u3002\u628a\u6211\u4eec\u65b0\u589e\u7684\u6587\u4ef6\u52a0\u5230\u914d\u7f6e\u91cc\uff0c\u5426\u5219\u7f16\u8bd1\u7684\u65f6\u5019\uff0c\u4e0d\u4f1a\u7f16\u8bd1\u8fd9\u4e2a\u65b0\u589e\u7684\u6a21\u5757\u3002\u6211\u4eec\u53ef\u4ee5\u5728node.gyp\u6587\u4ef6\u4e2d\u627e\u5230src/tcp_wrap.cc,\u7136\u540e\u5728\u5b83\u540e\u9762\u52a0\u5165\u6211\u4eec\u7684\u6587\u4ef6\u5c31\u884c\u3002 1 2 src/cyb_wrap.cc src/cyb_wrap.h \u8fd9\u65f6\u5019Node.js\u4f1a\u7f16\u8bd1\u6211\u4eec\u7684\u4ee3\u7801\u4e86\u3002\u4f46\u662fNode.js\u7684\u5185\u7f6e\u6a21\u5757\u6709\u4e00\u5b9a\u7684\u673a\u5236\uff0c\u6211\u4eec\u7684\u4ee3\u7801\u52a0\u5165\u4e86Node.js\u5185\u6838\uff0c\u4e0d\u4ee3\u8868\u5c31\u53ef\u4ee5\u4f7f\u7528\u4e86\u3002Node.js\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u4f1a\u8c03\u7528RegisterBuiltinModules\u51fd\u6570\u6ce8\u518c\u6240\u6709\u7684\u5185\u7f6eC++\u6a21\u5757\u3002 1 2 3 4 5 void RegisterBuiltinModules () { #define V(modname) _register_##modname(); NODE_BUILTIN_MODULES ( V ) #undef V } \u6211\u4eec\u770b\u5230\u8be5\u51fd\u6570\u53ea\u6709\u4e00\u4e2a\u5b8f\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u5b8f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 void RegisterBuiltinModules () { #define V(modname) _register_##modname(); NODE_BUILTIN_MODULES ( V ) #undef V } #define NODE_BUILTIN_MODULES(V) \\ NODE_BUILTIN_STANDARD_MODULES ( V ) \\ NODE_BUILTIN_OPENSSL_MODULES ( V ) \\ NODE_BUILTIN_ICU_MODULES ( V ) \\ NODE_BUILTIN_REPORT_MODULES ( V ) \\ NODE_BUILTIN_PROFILER_MODULES ( V ) \\ NODE_BUILTIN_DTRACE_MODULES ( V ) \u5b8f\u91cc\u9762\u53c8\u662f\u4e00\u5806\u5b8f\u3002\u6211\u4eec\u8981\u505a\u7684\u5c31\u662f\u4fee\u6539\u8fd9\u4e2a\u5b8f\u3002\u56e0\u4e3a\u6211\u4eec\u662f\u81ea\u5b9a\u4e49\u7684\u5185\u7f6e\u6a21\u5757\uff0c\u6240\u4ee5\u6211\u4eec\u53ef\u4ee5\u589e\u52a0\u4e00\u4e2a\u5b8f\u3002 1 2 #define NODE_BUILTIN_EXTEND_MODULES(V) \\ V ( cyb_wrap ) \u7136\u540e\u628a\u8fd9\u4e2a\u5b8f\u8ffd\u52a0\u5230\u90a3\u4e00\u5806\u5b8f\u540e\u9762\u3002 1 2 3 4 5 6 7 8 #define NODE_BUILTIN_MODULES(V) \\ NODE_BUILTIN_STANDARD_MODULES ( V ) \\ NODE_BUILTIN_OPENSSL_MODULES ( V ) \\ NODE_BUILTIN_ICU_MODULES ( V ) \\ NODE_BUILTIN_REPORT_MODULES ( V ) \\ NODE_BUILTIN_PROFILER_MODULES ( V ) \\ NODE_BUILTIN_DTRACE_MODULES ( V ) \\ NODE_BUILTIN_EXTEND_MODULES ( V ) \u8fd9\u65f6\u5019\uff0cNode.js\u4e0d\u4ec5\u53ef\u4ee5\u7f16\u8bd1\u6211\u4eec\u7684\u4ee3\u7801\uff0c\u8fd8\u4f1a\u628a\u6211\u4eec\u4ee3\u7801\u4e2d\u5b9a\u4e49\u7684\u6a21\u5757\u6ce8\u518c\u5230\u5185\u7f6eC++\u6a21\u5757\u91cc\u4e86\uff0c\u63a5\u4e0b\u6765\u5c31\u662f\u5982\u4f55\u4f7f\u7528C++\u6a21\u5757\u4e86\u3002 2 \u5728lib\u6587\u4ef6\u5939\u65b0\u5efa\u4e00\u4e2acyb.js\uff0c\u4f5c\u4e3aNode.js\u539f\u751f\u6a21\u5757 1 2 const cyb = internalBinding ( 'cyb_wrap' ); module . exports = cyb ; \u65b0\u589e\u539f\u751f\u6a21\u5757\uff0c\u6211\u4eec\u4e5f\u9700\u8981\u4fee\u6539node.gyp\u6587\u4ef6\uff0c\u5426\u5219\u4ee3\u7801\u4e5f\u4e0d\u4f1a\u88ab\u7f16\u8bd1\u8fdbnode\u5185\u6838\u3002\u6211\u4eec\u627e\u5230node.gyp\u6587\u4ef6\u7684lib/net.js\uff0c\u5728\u540e\u9762\u8ffd\u52a0lib/cyb.js\u3002\u8be5\u914d\u7f6e\u4e0b\u7684\u6587\u4ef6\u662f\u7ed9js2c.py\u4f7f\u7528\u7684\uff0c\u5982\u679c\u4e0d\u4fee\u6539\uff0c\u6211\u4eec\u5728require\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u627e\u4e0d\u5230\u8be5\u6a21\u5757\u3002\u6700\u540e\u6211\u4eec\u5728lib/internal/bootstrap/loader\u6587\u4ef6\u91cc\u627e\u5230internalBindingWhitelist\u53d8\u91cf\uff0c\u5728\u6570\u7ec4\u6700\u540e\u589e\u52a0cyb_wrap\uff0c\u8fd9\u4e2a\u914d\u7f6e\u662f\u7ed9process.binding\u51fd\u6570\u4f7f\u7528\u7684\uff0c\u5982\u679c\u4e0d\u4fee\u6539\u8fd9\u4e2a\u914d\u7f6e\uff0c\u901a\u8fc7process.binding\u5c31\u627e\u4e0d\u5230\u6211\u4eec\u7684\u6a21\u5757\u3002process.binding\u662f\u53ef\u4ee5\u5728\u7528\u6237JS\u91cc\u4f7f\u7528\u7684\u3002\u81f3\u6b64\uff0c\u6211\u4eec\u5b8c\u6210\u4e86\u6240\u6709\u7684\u4fee\u6539\u5de5\u4f5c\uff0c\u91cd\u65b0\u7f16\u8bd1Node.js\u3002\u7136\u540e\u7f16\u5199\u6d4b\u8bd5\u7a0b\u5e8f\u3002 3 \u65b0\u5efa\u4e00\u4e2a\u6d4b\u8bd5\u6587\u4ef6testcyb.js 1 2 3 // const cyb = process.binding('cyb_wrap'); const cyb = require ( 'cyb' ); console . log ( cyb . console ()) \u53ef\u4ee5\u770b\u5230\uff0c\u4f1a\u8f93\u51fahello world\u3002","title":"20.1.1 \u65b0\u589e\u4e00\u4e2a\u5185\u7f6eC++\u6a21\u5757"},{"location":"chapter20-%E6%8B%93%E5%B1%95Node.js/#2012-nodejs","text":"\u672c\u8282\u4ecb\u7ecd\u5982\u4f55\u4fee\u6539Node.js\u5185\u6838\u3002\u4fee\u6539\u7684\u90e8\u5206\u4e3b\u8981\u662f\u4e3a\u4e86\u5b8c\u5584Node.js\u7684TCP keepalive\u529f\u80fd\u3002\u76ee\u524dNode.js\u7684keepalive\u53ea\u652f\u6301\u8bbe\u7f6e\u5f00\u5173\u4ee5\u53ca\u7a7a\u95f2\u591a\u4e45\u540e\u53d1\u9001\u63a2\u6d4b\u5305\u3002\u5728\u65b0\u7248Linux\u5185\u6838\u4e2d\uff0cTCP keepalive\u5305\u62ec\u4ee5\u4e0b\u914d\u7f6e\u3002 1 2 3 4 1 \u591a\u4e45\u6ca1\u6709\u901a\u4fe1\u6570\u636e\u5305\uff0c\u5219\u5f00\u59cb\u53d1\u9001\u63a2\u6d4b\u5305\u3002 2 \u6bcf\u9694\u591a\u4e45\uff0c\u518d\u6b21\u53d1\u9001\u63a2\u6d4b\u5305\u3002 3 \u53d1\u9001\u591a\u5c11\u4e2a\u63a2\u6d4b\u5305\u540e\uff0c\u5c31\u8ba4\u4e3a\u8fde\u63a5\u65ad\u5f00\u3002 4 TCP_USER_TIMEOUT\uff0c\u53d1\u9001\u4e86\u6570\u636e\uff0c\u591a\u4e45\u6ca1\u6709\u6536\u5230ack\u540e\uff0c\u8ba4\u4e3a\u8fde\u63a5\u65ad\u5f00\u3002 Node.js\u53ea\u652f\u6301\u7b2c\u4e00\u6761\uff0c\u6240\u4ee5\u6211\u4eec\u7684\u76ee\u7684\u662f\u652f\u63012,3,4\u3002\u56e0\u4e3a\u8fd9\u4e2a\u529f\u80fd\u662f\u64cd\u4f5c\u7cfb\u7edf\u63d0\u4f9b\u7684\uff0c\u6240\u4ee5\u9996\u5148\u9700\u8981\u4fee\u6539Libuv\u7684\u4ee3\u7801\u3002 1 \u4fee\u6539src/unix/tcp.c \u5728tcp.c\u52a0\u5165\u4ee5\u4e0b\u4ee3\u7801 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 int uv_tcp_keepalive_ex ( uv_tcp_t * handle , int on , unsigned int delay , unsigned int interval , unsigned int count ) { int err ; if ( uv__stream_fd ( handle ) != - 1 ) { err = uv__tcp_keepalive_ex ( uv__stream_fd ( handle ), on , delay , interval , count ); if ( err ) return err ; } if ( on ) handle -> flags |= UV_HANDLE_TCP_KEEPALIVE ; else handle -> flags &= ~ UV_HANDLE_TCP_KEEPALIVE ; return 0 ; } int uv_tcp_timeout ( uv_tcp_t * handle , unsigned int timeout ) { # ifdef TCP_USER_TIMEOUT int fd = uv__stream_fd ( handle ); if ( fd != - 1 && setsockopt ( fd , IPPROTO_TCP , TCP_USER_TIMEOUT , & timeout , sizeof ( timeout ))) { return UV__ERR ( errno ); } # endif return 0 ; } int uv__tcp_keepalive_ex ( int fd , int on , unsigned int delay , unsigned int interval , unsigned int count ) { if ( setsockopt ( fd , SOL_SOCKET , SO_KEEPALIVE , & on , sizeof ( on ))) return UV__ERR ( errno ); # ifdef TCP_KEEPIDLE if ( on && delay && setsockopt ( fd , IPPROTO_TCP , TCP_KEEPIDLE , & delay , sizeof ( delay ))) return UV__ERR ( errno ); # endif # ifdef TCP_KEEPINTVL if ( on && interval && setsockopt ( fd , IPPROTO_TCP , TCP_KEEPINTVL , & interval , sizeof ( interval ))) return UV__ERR ( errno ); # endif # ifdef TCP_KEEPCNT if ( on && count && setsockopt ( fd , IPPROTO_TCP , TCP_KEEPCNT , & count , sizeof ( count ))) return UV__ERR ( errno ); # endif /* Solaris/SmartOS, if you don't support keep-alive, * then don't advertise it in your system headers... */ /* FIXME(bnoordhuis) That's possibly because sizeof(delay) should be 1. */ # if defined ( TCP_KEEPALIVE ) && ! defined ( __sun ) if ( on && setsockopt ( fd , IPPROTO_TCP , TCP_KEEPALIVE , & delay , sizeof ( delay ))) return UV__ERR ( errno ); # endif return 0 ; } 2 \u4fee\u6539include/uv.h \u628a\u5728tcp.c\u4e2d\u52a0\u5165\u7684\u63a5\u53e3\u66b4\u9732\u51fa\u6765\u3002 1 2 3 4 5 6 UV_EXTERN int uv_tcp_keepalive_ex ( uv_tcp_t * handle , int enable , unsigned int delay , unsigned int interval , unsigned int count ); UV_EXTERN int uv_tcp_timeout ( uv_tcp_t * handle , unsigned int timeout ); \u81f3\u6b64\uff0c\u6211\u4eec\u5c31\u4fee\u6539\u5b8cLibuv\u7684\u4ee3\u7801\uff0c\u4e5f\u5bf9\u5916\u66b4\u9732\u4e86\u8bbe\u7f6e\u7684\u63a5\u53e3\uff0c\u63a5\u7740\u6211\u4eec\u4fee\u6539\u4e0a\u5c42\u7684C++\u548cJS\u4ee3\u7801\uff0c\u4f7f\u5f97\u6211\u4eec\u53ef\u4ee5\u5728JS\u5c42\u4f7f\u7528\u8be5\u529f\u80fd\u3002 3 \u4fee\u6539src/tcp_wrap.cc \u4fee\u6539TCPWrap::Initialize\u51fd\u6570\u7684\u4ee3\u7801\u3002 1 2 env -> SetProtoMethod ( t , \"setKeepAliveEx\" , SetKeepAliveEx ); env -> SetProtoMethod ( t , \"setKeepAliveTimeout\" , SetKeepAliveTimeout ); \u9996\u5148\u5bf9JS\u5c42\u66b4\u9732\u4e24\u4e2a\u65b0\u7684API\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e24\u4e2aAPI\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void TCPWrap::SetKeepAliveEx ( const FunctionCallbackInfo < Value >& args ) { TCPWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder (), args . GetReturnValue (). Set ( UV_EBADF )); Environment * env = wrap -> env (); int enable ; if ( ! args [ 0 ] -> Int32Value ( env -> context ()). To ( & enable )) return ; unsigned int delay = static_cast < unsigned int > ( args [ 1 ]. As < Uint32 > () -> Value ()); unsigned int detal = static_cast < unsigned int > ( args [ 2 ]. As < Uint32 > () -> Value ()); unsigned int count = static_cast < unsigned int > ( args [ 3 ]. As < Uint32 > () -> Value ()); int err = uv_tcp_keepalive_ex ( & wrap -> handle_ , enable , delay , detal , count ); args . GetReturnValue (). Set ( err ); } void TCPWrap::SetKeepAliveTimeout ( const FunctionCallbackInfo < Value >& args ) { TCPWrap * wrap ; ASSIGN_OR_RETURN_UNWRAP ( & wrap , args . Holder (), args . GetReturnValue (). Set ( UV_EBADF )); unsigned int time = static_cast < unsigned int > ( args [ 0 ]. As < Uint32 > () -> Value ()); int err = uv_tcp_timeout ( & wrap -> handle_ , time ); args . GetReturnValue (). Set ( err ); } \u540c\u65f6\u8fd8\u9700\u8981\u5728src/tcp_wrap.h\u4e2d\u58f0\u660e\u8fd9\u4e24\u4e2a\u51fd\u6570\u3002 1 2 static void SetKeepAliveEx ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); static void SetKeepAliveTimeout ( const v8 :: FunctionCallbackInfo < v8 :: Value >& args ); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // \u4fee\u6539lib/net.js Socket . prototype . setKeepAliveEx = function ( setting , secs , interval , count ) { if ( ! this . _handle ) { this . once ( 'connect' , () => this . setKeepAliveEx ( setting , secs , interval , count )); return this ; } if ( this . _handle . setKeepAliveEx ) this . _handle . setKeepAliveEx ( setting , ~~ secs > 0 ? ~~ secs : 0 , ~~ interval > 0 ? ~~ interval : 0 , ~~ count > 0 ? ~~ count : 0 ); return this ; }; Socket . prototype . setKeepAliveTimeout = function ( timeout ) { if ( ! this . _handle ) { this . once ( 'connect' , () => this . setKeepAliveTimeout ( timeout )); return this ; } if ( this . _handle . setKeepAliveTimeout ) this . _handle . setKeepAliveTimeout ( ~~ timeout > 0 ? ~~ timeout : 0 ); return this ; }; \u91cd\u65b0\u7f16\u8bd1Node.js\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u4f7f\u7528\u8fd9\u4e24\u4e2a\u65b0\u7684API\u66f4\u7075\u6d3b\u5730\u63a7\u5236TCP\u7684keepalive\u4e86\u3002 1 2 3 4 5 const net = require ( 'net' ); net . createServer (( socket ) => { socket . setKeepAliveEx ( true , 1 , 2 , 3 ); // socket.setKeepAliveTimeout(4); }). listen ( 1101 );","title":"20.1.2 \u4fee\u6539Node.js\u5185\u6838"},{"location":"chapter20-%E6%8B%93%E5%B1%95Node.js/#202-n-apic","text":"\u672c\u5c0f\u8282\u4ecb\u7ecd\u4f7f\u7528N_API\u7f16\u5199C++\u63d2\u4ef6\u77e5\u8bc6\u3002Node.js C++\u63d2\u4ef6\u672c\u8d28\u662f\u4e00\u4e2a\u52a8\u6001\u94fe\u63a5\u5e93\uff0c\u5199\u5b8c\u7f16\u8bd1\u540e\uff0c\u751f\u6210\u4e00\u4e2a.node\u6587\u4ef6\u3002\u6211\u4eec\u5728Node.js\u91cc\u76f4\u63a5require\u4f7f\u7528\uff0cNode.js\u4f1a\u4e3a\u6211\u4eec\u5904\u7406\u4e00\u5207\u3002 \u9996\u5148\u5efa\u7acb\u4e00\u4e2atest.cc\u6587\u4ef6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // hello.cc using N-API #include <node_api.h> namespace demo { napi_value Method ( napi_env env , napi_callback_info args ) { napi_value greeting ; napi_status status ; status = napi_create_string_utf8 ( env , \"world\" , NAPI_AUTO_LENGTH , & greeting ); if ( status != napi_ok ) return nullptr ; return greeting ; } napi_value init ( napi_env env , napi_value exports ) { napi_status status ; napi_value fn ; status = napi_create_function ( env , nullptr , 0 , Method , nullptr , & fn ); if ( status != napi_ok ) return nullptr ; status = napi_set_named_property ( env , exports , \"hello\" , fn ); if ( status != napi_ok ) return nullptr ; return exports ; } NAPI_MODULE ( NODE_GYP_MODULE_NAME , init ) } // namespace demo \u6211\u4eec\u4e0d\u9700\u8981\u5177\u4f53\u4e86\u89e3\u4ee3\u7801\u7684\u610f\u601d\uff0c\u4f46\u662f\u4ece\u4ee3\u7801\u4e2d\u6211\u4eec\u5927\u81f4\u77e5\u9053\u5b83\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002\u5269\u4e0b\u7684\u5c31\u662f\u9605\u8bfbN-API\u7684API\u6587\u6863\u5c31\u53ef\u4ee5\u3002\u63a5\u7740\u6211\u4eec\u65b0\u5efa\u4e00\u4e2abinding.gyp\u6587\u4ef6\u3002gyp\u6587\u4ef6\u662fnode-gyp\u7684\u914d\u7f6e\u6587\u4ef6\u3002node-gyp\u53ef\u4ee5\u5e2e\u52a9\u6211\u4eec\u9488\u5bf9\u4e0d\u540c\u5e73\u53f0\u751f\u4ea7\u4e0d\u540c\u7684\u7f16\u8bd1\u914d\u7f6e\u6587\u4ef6\u3002\u6bd4\u5982Linux\u4e0b\u7684makefile\u3002 1 2 3 4 5 6 7 8 { \"targets\" : [ { \"target_name\" : \"test\" , \"sources\" : [ \"./test.cc\" ] } ] } \u8bed\u6cd5\u548cmakefile\u6709\u70b9\u50cf\uff0c\u5c31\u662f\u5b9a\u4e49\u6211\u4eec\u7f16\u8bd1\u540e\u7684\u76ee\u524d\u6587\u4ef6\u540d\uff0c\u4f9d\u8d56\u54ea\u4e9b\u6e90\u6587\u4ef6\u3002\u7136\u540e\u6211\u4eec\u5b89\u88c5node-gyp\u3002 1 npm install node-gyp -g Node.js\u6e90\u7801\u4e2d\u4e5f\u6709\u4e00\u4e2anode-gyp\uff0c\u5b83\u662f\u5e2e\u52a9npm\u5b89\u88c5\u62d3\u5c55\u6a21\u5757\u65f6\uff0c\u5c31\u5730\u7f16\u8bd1\u7528\u7684\u3002\u6211\u4eec\u5b89\u88c5\u7684node-gyp\u662f\u5e2e\u52a9\u6211\u4eec\u751f\u6210\u914d\u7f6e\u6587\u4ef6\u5e76\u7f16\u8bd1\u7528\u7684\uff0c\u5177\u4f53\u53ef\u4ee5\u53c2\u8003Node.js\u6587\u6863\u3002\u4e00\u5207\u51c6\u5907\u5c31\u7eea\u3002\u6211\u4eec\u5f00\u59cb\u7f16\u8bd1\u3002\u76f4\u63a5\u6267\u884c 1 2 node-gyp configure node-gyp build \u5728\u8def\u5f84./build/Release/\u4e0b\u751f\u6210\u4e86test.node\u6587\u4ef6\u3002\u8fd9\u5c31\u662f\u6211\u4eec\u7684\u62d3\u5c55\u6a21\u5757\u3002\u6211\u4eec\u7f16\u5199\u6d4b\u8bd5\u7a0b\u5e8fapp.js\u3002 1 2 var addon = require ( \"./build/Release/test\" ); console . log ( addon . hello ()); \u6267\u884c \u2003 1 node app.js \u6211\u4eec\u770b\u5230\u8f93\u51faworld\u3002\u6211\u4eec\u5df2\u7ecf\u5b66\u4f1a\u4e86\u5982\u4f55\u7f16\u5199\u4e00\u4e2aNode.js\u7684\u62d3\u5c55\u6a21\u5757\u3002\u5269\u4e0b\u7684\u5c31\u662f\u9605\u8bfbN-API\u6587\u6863\uff0c\u6839\u636e\u81ea\u5df1\u7684\u9700\u6c42\u7f16\u5199\u4e0d\u540c\u7684\u6a21\u5757\u3002","title":"20.2 \u4f7f\u7528N-API\u7f16\u5199C++\u63d2\u4ef6"},{"location":"chapter21-JS%20Stream/","text":"\u6d41\u662f\u5bf9\u751f\u4ea7\u6570\u636e\u548c\u6d88\u8d39\u6570\u636e\u8fc7\u7a0b\u7684\u62bd\u8c61\uff0c\u6d41\u672c\u8eab\u4e0d\u751f\u4ea7\u548c\u6d88\u8d39\u6570\u636e\uff0c\u5b83\u53ea\u662f\u5b9a\u4e49\u4e86\u6570\u636e\u5904\u7406\u7684\u6d41\u7a0b\u3002\u53ef\u8bfb\u6d41\u662f\u5bf9\u6570\u636e\u6e90\u6d41\u5411\u5176\u5b83\u5730\u65b9\u7684\u8fc7\u7a0b\u62bd\u8c61\uff0c\u5c5e\u4e8e\u751f\u4ea7\u8005\uff0c\u53ef\u8bfb\u6d41\u662f\u5bf9\u6570\u636e\u6d41\u5411\u67d0\u4e00\u76ee\u7684\u5730\u7684\u8fc7\u7a0b\u7684\u62bd\u8c61\u3002Node.js\u4e2d\u7684\u6d41\u5206\u4e3a\u53ef\u8bfb\u3001\u53ef\u5199\u3001\u53ef\u8bfb\u5199\u3001\u8f6c\u6362\u6d41\u3002\u4e0b\u9762\u6211\u5148\u770b\u4e00\u4e0b\u6d41\u7684\u57fa\u7c7b\u3002 21.1 \u6d41\u57fa\u7c7b\u548c\u6d41\u901a\u7528\u903b\u8f91 \u00b6 1 2 3 4 5 6 7 8 const EE = require ( 'events' ); const util = require ( 'util' ); // \u6d41\u7684\u57fa\u7c7b function Stream () { EE . call ( this ); } // \u7ee7\u627f\u4e8b\u4ef6\u8ba2\u9605\u5206\u53d1\u7684\u80fd\u529b util . inherits ( Stream , EE ); \u6d41\u7684\u57fa\u7c7b\u53ea\u63d0\u4f9b\u4e86\u4e00\u4e2a\u51fd\u6570\u5c31\u662fpipe\u3002\u7528\u4e8e\u5b9e\u73b0\u7ba1\u9053\u5316\u3002\u7ba1\u9053\u5316\u662f\u5bf9\u6570\u636e\u4ece\u4e00\u4e2a\u5730\u65b9\u6d41\u5411\u53e6\u4e00\u4e2a\u5730\u65b9\u7684\u62bd\u8c61\u3002\u8fd9\u4e2a\u65b9\u6cd5\u4ee3\u7801\u6bd4\u8f83\u591a\uff0c\u5206\u5f00\u8bf4\u3002 21.1.1\u5904\u7406\u6570\u636e\u4e8b\u4ef6 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // \u6570\u636e\u6e90\u5bf9\u8c61 var source = this ; // \u76d1\u542cdata\u4e8b\u4ef6\uff0c\u53ef\u8bfb\u6d41\u6709\u6570\u636e\u7684\u65f6\u5019\uff0c\u4f1a\u89e6\u53d1data\u4e8b\u4ef6 source . on ( 'data' , ondata ); function ondata ( chunk ) { // \u6e90\u6d41\u6709\u6570\u636e\u5230\u8fbe\uff0c\u5e76\u4e14\u76ee\u7684\u6d41\u53ef\u5199 if ( dest . writable ) { /* \u76ee\u7684\u6d41\u8fc7\u8f7d\u5e76\u4e14\u6e90\u6d41\u5b9e\u73b0\u4e86pause\u65b9\u6cd5\uff0c \u90a3\u5c31\u6682\u505c\u53ef\u8bfb\u6d41\u7684\u8bfb\u53d6\u64cd\u4f5c\uff0c\u7b49\u5f85\u76ee\u7684\u6d41\u89e6\u53d1drain\u4e8b\u4ef6 */ if ( false === dest . write ( chunk ) && source . pause ) { source . pause (); } } } // \u76d1\u542cdrain\u4e8b\u4ef6\uff0c\u76ee\u7684\u6d41\u53ef\u4ee5\u6d88\u8d39\u6570\u636e\u4e86\u5c31\u4f1a\u89e6\u53d1\u8be5\u4e8b\u4ef6 dest . on ( 'drain' , ondrain ); function ondrain () { // \u76ee\u7684\u6d41\u53ef\u7ee7\u7eed\u5199\u4e86\uff0c\u5e76\u4e14\u53ef\u8bfb\u6d41\u53ef\u8bfb\uff0c\u5207\u6362\u6210\u81ea\u52a8\u8bfb\u53d6\u6a21\u5f0f if ( source . readable && source . resume ) { source . resume (); } } \u8fd9\u662f\u7ba1\u9053\u5316\u65f6\u6d41\u63a7\u5b9e\u73b0\u7684\u5730\u65b9\uff0c\u4e3b\u8981\u662f\u5229\u7528\u4e86write\u8fd4\u56de\u503c\u548cdrain\u4e8b\u4ef6\u3002 21.1.2\u6d41\u5173\u95ed/\u7ed3\u675f\u5904\u7406 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* 1 dest._isStdio\u662ftrue\u8868\u793a\u76ee\u7684\u6d41\u662f\u6807\u51c6\u8f93\u51fa\u6216\u6807\u51c6\u9519\u8bef\uff08\u89c1 process/stdio.js\uff09\uff0c 2 \u914d\u7f6e\u7684end\u5b57\u6bb5\u4ee3\u8868\u53ef\u8bfb\u6d41\u89e6\u53d1end\u6216close\u4e8b\u4ef6\u65f6\uff0c\u662f\u5426\u81ea\u52a8\u5173\u95ed\u53ef\u5199 \u6d41\uff0c\u9ed8\u8ba4\u662f\u81ea\u52a8\u5173\u95ed\u3002\u5982\u679c\u914d\u7f6e\u4e86end\u662ffalse\uff0c\u5219\u53ef\u8bfb\u6d41\u8fd9\u4e24\u4e2a\u4e8b\u4ef6\u89e6\u53d1 \u65f6\uff0c\u6211\u4eec\u9700\u8981\u81ea\u5df1\u5173\u95ed\u53ef\u5199\u6d41\u3002 3 \u6211\u4eec\u770b\u5230\u53ef\u8bfb\u6d41\u7684error\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u53ef\u5199\u6d41\u662f\u4e0d\u4f1a\u88ab\u81ea\u52a8\u5173\u95ed\u7684\uff0c\u9700\u8981\u6211 \u4eec\u81ea\u5df1\u76d1\u542c\u53ef\u8bfb\u6d41\u7684error\u4e8b\u4ef6\uff0c\u7136\u540e\u624b\u52a8\u5173\u95ed\u53ef\u5199\u6d41\u3002\u6240\u4ee5if\u7684\u5224\u65ad\u610f\u601d \u662f\u4e0d\u662f\u6807\u51c6\u8f93\u51fa\u6216\u6807\u51c6\u9519\u8bef\u6d41\uff0c\u5e76\u4e14\u6ca1\u6709\u914d\u7f6eend\u662ffalse\u7684\u65f6\u5019\uff0c\u4f1a\u81ea\u52a8 \u5173\u95ed\u53ef\u5199\u6d41\u3002\u800c\u6807\u51c6\u8f93\u51fa\u548c\u6807\u51c6\u9519\u8bef\u6d41\u662f\u5728\u8fdb\u7a0b\u9000\u51fa\u7684\u65f6\u5019\u624d\u88ab\u5173\u95ed\u7684\u3002 */ if ( ! dest . _isStdio && ( ! options || options . end !== false )) { // \u6e90\u6d41\u6ca1\u6709\u6570\u636e\u53ef\u8bfb\u4e86\uff0c\u6267\u884cend\u56de\u8c03 source . on ( 'end' , onend ); // \u6e90\u6d41\u5173\u95ed\u4e86\uff0c\u6267\u884cclose\u56de\u8c03 source . on ( 'close' , onclose ); } var didOnEnd = false ; function onend () { if ( didOnEnd ) return ; didOnEnd = true ; // \u6267\u884c\u76ee\u7684\u6d41\u7684end\uff0c\u8bf4\u660e\u5199\u6570\u636e\u5b8c\u6bd5 dest . end (); } function onclose () { if ( didOnEnd ) return ; didOnEnd = true ; // \u9500\u6bc1\u76ee\u7684\u6d41 if ( typeof dest . destroy === 'function' ) dest . destroy (); } \u4e0a\u9762\u662f\u53ef\u8bfb\u6e90\u6d41\u7ed3\u675f\u6216\u5173\u95ed\u540e\uff0c\u5982\u4f55\u5904\u7406\u53ef\u5199\u6d41\u7684\u903b\u8f91\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53ea\u9700\u8981\u76d1\u542c\u53ef\u8bfb\u6d41\u7684error\u4e8b\u4ef6\uff0c\u7136\u540e\u6267\u884c\u53ef\u5199\u6d41\u7684\u5173\u95ed\u64cd\u4f5c\u3002 21.1.3 \u9519\u8bef\u5904\u7406 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // \u53ef\u8bfb\u6d41\u6216\u8005\u53ef\u5199\u6d41\u51fa\u9519\u7684\u65f6\u5019\u90fd\u9700\u8981\u505c\u6b62\u6570\u636e\u7684\u5904\u7406 source . on ( 'error' , onerror ); dest . on ( 'error' , onerror ); // \u53ef\u8bfb\u6d41\u6216\u8005\u53ef\u5199\u6d41\u89e6\u53d1error\u4e8b\u4ef6\u65f6\u7684\u5904\u7406\u903b\u8f91 function onerror ( er ) { // \u51fa\u9519\u4e86\uff0c\u6e05\u9664\u6ce8\u518c\u7684\u4e8b\u4ef6\uff0c\u5305\u62ec\u6b63\u5728\u6267\u884c\u7684onerror\u51fd\u6570 cleanup (); /* \u5982\u679c\u7528\u6237\u6ca1\u6709\u76d1\u542c\u6d41\u7684error\u4e8b\u4ef6\uff0c\u5219\u629b\u51fa\u9519\u8bef\uff0c \u6240\u4ee5\u6211\u4eec\u4e1a\u52a1\u4ee3\u7801\u9700\u8981\u76d1\u542cerror\u4e8b\u4ef6 */ if ( EE . listenerCount ( this , 'error' ) === 0 ) { throw er ; // Unhandled stream error in pipe. } } \u5728error\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\u4e2d\uff0c\u901a\u8fc7cleanup\u51fd\u6570\u6e05\u9664\u4e86Node.js\u672c\u8eab\u6ce8\u518c\u7684error\u4e8b\u4ef6\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\u5982\u679c\u7528\u6237\u6ca1\u6709\u6ce8\u518cerror\u4e8b\u4ef6\uff0c\u5219error\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\u4e2a\u6570\u4e3a0,\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u6ce8\u518cerror\u4e8b\u4ef6\u3002\u4e0b\u9762\u6211\u4eec\u518d\u5206\u6790cleanup\u51fd\u6570\u7684\u903b\u8f91\u3002 21.1.4 \u6e05\u9664\u6ce8\u518c\u7684\u4e8b\u4ef6 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // \u4fdd\u8bc1\u6e90\u6d41\u5173\u95ed\u3001\u6570\u636e\u8bfb\u5b8c\u3001\u76ee\u7684\u6d41\u5173\u95ed\u65f6\u6e05\u9664\u6ce8\u518c\u7684\u4e8b\u4ef6 source . on ( 'end' , cleanup ); source . on ( 'close' , cleanup ); dest . on ( 'close' , cleanup ); // \u6e05\u9664\u6240\u6709\u53ef\u80fd\u4f1a\u7ed1\u5b9a\u7684\u4e8b\u4ef6\uff0c\u5982\u679c\u6ca1\u6709\u7ed1\u5b9a\uff0c\u6267\u884c\u6e05\u9664\u4e5f\u662f\u65e0\u5bb3\u7684 function cleanup () { source . removeListener ( 'data' , ondata ); dest . removeListener ( 'drain' , ondrain ); source . removeListener ( 'end' , onend ); source . removeListener ( 'close' , onclose ); source . removeListener ( 'error' , onerror ); dest . removeListener ( 'error' , onerror ); source . removeListener ( 'end' , cleanup ); source . removeListener ( 'close' , cleanup ); dest . removeListener ( 'close' , cleanup ); } // \u89e6\u53d1\u76ee\u7684\u6d41\u7684pipe\u4e8b\u4ef6 dest . emit ( 'pipe' , source ); // \u652f\u6301\u8fde\u7eed\u7684\u7ba1\u9053\u5316A.pipe(B).pipe(C) return dest ; 21.1.5 \u6d41\u7684\u9608\u503c \u00b6 \u901a\u8fc7 getHighWaterMark\uff08lib\\internal\\streams\\state.js\uff09 \u51fd\u6570\u53ef\u4ee5\u8ba1\u7b97\u51fa\u6d41\u7684\u9608\u503c\uff0c\u9608\u503c\u7528\u4e8e\u63a7\u5236\u7528\u6237\u8bfb\u5199\u6570\u636e\u7684\u901f\u5ea6\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function getHighWaterMark ( state , options , duplexKey , isDuplex ) { // \u7528\u6237\u5b9a\u4e49\u7684\u9608\u503c let hwm = options . highWaterMark ; // \u7528\u6237\u5b9a\u4e49\u4e86\uff0c\u5219\u6821\u9a8c\u662f\u5426\u5408\u6cd5 if ( hwm != null ) { if ( typeof hwm !== 'number' || ! ( hwm >= 0 )) throw new errors . TypeError ( 'ERR_INVALID_OPT_VALUE' , 'highWaterMark' , hwm ); return Math . floor ( hwm ); } else if ( isDuplex ) { // \u7528\u6237\u6ca1\u6709\u5b9a\u4e49\u516c\u5171\u7684\u9608\u503c\uff0c\u5373\u8bfb\u5199\u6d41\u516c\u7528\u7684\u9608\u503c // \u7528\u6237\u662f\u5426\u5b9a\u4e49\u4e86\u6d41\u5355\u72ec\u7684\u9608\u503c\uff0c\u6bd4\u5982\u8bfb\u6d41\u7684\u9608\u503c\u6216\u8005\u5199\u6d41\u7684\u9608\u503c hwm = options [ duplexKey ]; // \u7528\u6237\u6709\u5b9a\u4e49 if ( hwm != null ) { if ( typeof hwm !== 'number' || ! ( hwm >= 0 )) throw new errors . TypeError ( 'ERR_INVALID_OPT_VALUE' , duplexKey , hwm ); return Math . floor ( hwm ); } } // \u9ed8\u8ba4\u503c\uff0c\u5bf9\u8c61\u662f16\u4e2a\uff0cbuffer\u662f16KB return state . objectMode ? 16 : 16 * 1024 ; } getHighWaterMark\u51fd\u6570\u903b\u8f91\u5982\u4e0b 1 \u7528\u6237\u5b9a\u4e49\u4e86\u5408\u6cd5\u7684\u9608\u503c\uff0c\u5219\u53d6\u7528\u6237\u5b9a\u4e49\u7684\uff08\u53ef\u8bfb\u6d41\u3001\u53ef\u5199\u6d41\u3001\u53cc\u5411\u6d41\uff09\u3002 2 \u5982\u679c\u662f\u53cc\u5411\u6d41\uff0c\u5e76\u4e14\u7528\u6237\u6ca1\u6709\u53ef\u8bfb\u6d41\u53ef\u5199\u6d41\u5171\u4eab\u7684\u5b9a\u4e49\u9608\u503c\uff0c\u6839\u636e\u5f53\u524d\u662f\u53ef\u8bfb\u6d41\u8fd8\u662f\u53ef\u5199\u6d41\uff0c\u5224\u65ad\u7528\u6237\u662f\u5426\u8bbe\u7f6e\u5bf9\u5e94\u6d41\u7684\u9608\u503c\u3002\u6709\u5219\u53d6\u7528\u6237\u8bbe\u7f6e\u7684\u503c\u4f5c\u4e3a\u9608\u503c\u3002 3 \u5982\u679c\u4e0d\u6ee1\u8db31,2\uff0c\u5219\u8fd4\u56de\u9ed8\u8ba4\u503c\u3002 21.1.6 \u9500\u6bc1\u6d41 \u00b6 \u901a\u8fc7\u8c03\u7528destroy\u51fd\u6570\u53ef\u4ee5\u9500\u6bc1\u4e00\u4e2a\u6d41\uff0c\u5305\u62ec\u53ef\u8bfb\u6d41\u548c\u53ef\u5199\u6d41\u3002\u5e76\u4e14\u53ef\u4ee5\u5b9e\u73b0_ destroy\u51fd\u6570\u81ea\u5b9a\u4e49\u9500\u6bc1\u7684\u884c\u4e3a\u3002\u6211\u4eec\u770b\u770b\u53ef\u5199\u6d41\u7684destroy\u51fd\u6570\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 function destroy ( err , cb ) { // \u8bfb\u6d41\u3001\u5199\u6d41\u3001\u53cc\u5411\u6d41 const readableDestroyed = this . _readableState && this . _readableState . destroyed ; const writableDestroyed = this . _writableState && this . _writableState . destroyed ; // \u6d41\u662f\u5426\u5df2\u7ecf\u9500\u6bc1\uff0c\u662f\u5219\u76f4\u63a5\u6267\u884c\u56de\u8c03 if ( readableDestroyed || writableDestroyed ) { // \u4f20\u4e86cb\uff0c\u5219\u6267\u884c\uff0c\u53ef\u9009\u5730\u4f20\u5165err\uff0c\u7528\u6237\u5b9a\u4e49\u7684err if ( cb ) { cb ( err ); } else if ( err && ( ! this . _writableState || ! this . _writableState . errorEmitted )) { /* \u4f20\u4e86err\uff0c\u662f\u8bfb\u6d41\u6216\u8005\u6ca1\u6709\u89e6\u53d1\u8fc7error\u4e8b\u4ef6\u7684\u5199\u6d41\uff0c \u5219\u89e6\u53d1error\u4e8b\u4ef6 */ process . nextTick ( emitErrorNT , this , err ); } return this ; } // \u8fd8\u6ca1\u6709\u9500\u6bc1\u5219\u5f00\u59cb\u9500\u6bc1\u6d41\u7a0b if ( this . _readableState ) { this . _readableState . destroyed = true ; } if ( this . _writableState ) { this . _writableState . destroyed = true ; } // \u7528\u6237\u53ef\u4ee5\u81ea\u5b9a\u4e49_destroy\u51fd\u6570 this . _destroy ( err || null , ( err ) => { // \u6ca1\u6709cb\u4f46\u662f\u6709error\uff0c\u5219\u89e6\u53d1error\u4e8b\u4ef6 if ( ! cb && err ) { process . nextTick ( emitErrorNT , this , err ); // \u53ef\u5199\u6d41\u5219\u6807\u8bb0\u5df2\u7ecf\u89e6\u53d1\u8fc7error\u4e8b\u4ef6 if ( this . _writableState ) { this . _writableState . errorEmitted = true ; } } else if ( cb ) { // \u6709cb\u6216\u8005\u6ca1\u6709err cb ( err ); } }); return this ; } destroy\u51fd\u6570\u9500\u6bc1\u6d41\u7684\u901a\u7528\u903b\u8f91\u3002\u5176\u4e2d_destroy\u51fd\u6570\u4e0d\u540c\u7684\u6d41\u4e0d\u4e00\u6837\uff0c\u4e0b\u9762\u5206\u522b\u662f\u53ef\u8bfb\u6d41\u548c\u53ef\u5199\u6d41\u7684\u5b9e\u73b0\u3002 1 \u53ef\u8bfb\u6d41 1 2 3 4 Readable . prototype . _destroy = function ( err , cb ) { this . push ( null ); cb ( err ); }; 2 \u53ef\u5199\u6d41 1 2 3 4 Writable . prototype . _destroy = function ( err , cb ) { this . end (); cb ( err ); }; 21.2 \u53ef\u8bfb\u6d41 \u00b6 Node.js\u4e2d\u53ef\u8bfb\u6d41\u6709\u4e24\u79cd\u5de5\u4f5c\u6a21\u5f0f\uff1a\u6d41\u5f0f\u548c\u6682\u505c\u5f0f\uff0c\u6d41\u5f0f\u5c31\u662f\u6709\u6570\u636e\u7684\u65f6\u5019\u5c31\u4f1a\u89e6\u53d1\u56de\u8c03\uff0c\u5e76\u4e14\u628a\u6570\u636e\u4f20\u7ed9\u56de\u8c03\uff0c\u6682\u505c\u5f0f\u5c31\u662f\u9700\u8981\u7528\u6237\u81ea\u5df1\u624b\u52a8\u6267\u884c\u8bfb\u53d6\u7684\u64cd\u4f5c\u3002\u6211\u4eec\u901a\u8fc7\u6e90\u7801\u53bb\u4e86\u89e3\u4e00\u4e0b\u53ef\u8bfb\u6d41\u5b9e\u73b0\u7684\u4e00\u4e9b\u903b\u8f91\u3002\u56e0\u4e3a\u5b9e\u73b0\u7684\u4ee3\u7801\u6bd4\u8f83\u591a\uff0c\u903b\u8f91\u4e5f\u6bd4\u8f83\u7ed5\uff0c\u672c\u6587\u53ea\u5206\u6790\u4e00\u4e9b\u4e3b\u8981\u7684\u903b\u8f91\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bReadableState\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u662f\u8868\u793a\u53ef\u8bfb\u6d41\u7684\u4e00\u4e9b\u72b6\u6001\u548c\u5c5e\u6027\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 function ReadableState ( options , stream ) { options = options || {}; // \u662f\u5426\u662f\u53cc\u5411\u6d41 var isDuplex = stream instanceof Stream . Duplex ; // \u6570\u636e\u6a21\u5f0f this . objectMode = !! options . objectMode ; // \u53cc\u5411\u6d41\u7684\u65f6\u5019\uff0c\u8bbe\u7f6e\u8bfb\u7aef\u7684\u6a21\u5f0f if ( isDuplex ) this . objectMode = this . objectMode || !! options . readableObjectMode ; // \u8bfb\u5230highWaterMark\u4e2a\u5b57\u8282\u5219\u505c\u6b62\uff0c\u5bf9\u8c61\u6a21\u5f0f\u7684\u8bdd\u5219\u662f16\u4e2a\u5bf9\u8c61 this . highWaterMark = getHighWaterMark ( this , options , 'readableHighWaterMark' , isDuplex ); // \u5b58\u50a8\u6570\u636e\u7684\u7f13\u51b2\u533a this . buffer = new BufferList (); // \u53ef\u8bfb\u6570\u636e\u7684\u957f\u5ea6 this . length = 0 ; // \u7ba1\u9053\u7684\u76ee\u7684\u6e90\u548c\u4e2a\u6570 this . pipes = null ; this . pipesCount = 0 ; // \u5de5\u4f5c\u6a21\u5f0f this . flowing = null ; // \u6d41\u662f\u5426\u5df2\u7ecf\u7ed3\u675f this . ended = false ; // \u662f\u5426\u89e6\u53d1\u8fc7end\u4e8b\u4ef6\u4e86 this . endEmitted = false ; // \u662f\u5426\u6b63\u5728\u8bfb\u53d6\u6570\u636e this . reading = false ; // \u662f\u5426\u540c\u6b65\u6267\u884c\u4e8b\u4ef6 this . sync = true ; // \u662f\u5426\u9700\u8981\u89e6\u53d1readable\u4e8b\u4ef6 this . needReadable = false ; // \u662f\u5426\u89e6\u53d1\u4e86readable\u4e8b\u4ef6 this . emittedReadable = false ; // \u662f\u5426\u76d1\u542c\u4e86readable\u4e8b\u4ef6 this . readableListening = false ; // \u662f\u5426\u6b63\u5728\u6267\u884cresume\u7684\u8fc7\u7a0b this . resumeScheduled = false ; // \u6d41\u662f\u5426\u5df2\u9500\u6bc1 this . destroyed = false ; // \u6570\u636e\u7f16\u7801\u683c\u5f0f this . defaultEncoding = options . defaultEncoding || 'utf8' ; /* \u5728\u7ba1\u9053\u5316\u4e2d\uff0c\u6709\u591a\u5c11\u4e2a\u5199\u8005\u5df2\u7ecf\u8fbe\u5230\u9608\u503c\uff0c \u9700\u8981\u7b49\u5f85\u89e6\u53d1drain\u4e8b\u4ef6,awaitDrain\u8bb0\u5f55\u8fbe\u5230\u9608\u503c\u7684\u5199\u8005\u4e2a\u6570 */ this . awaitDrain = 0 ; // \u6267\u884cmaybeReadMore\u51fd\u6570\u7684\u65f6\u5019\uff0c\u8bbe\u7f6e\u4e3atrue this . readingMore = false ; this . decoder = null ; this . encoding = null ; // \u7f16\u7801\u89e3\u7801\u5668 if ( options . encoding ) { if ( ! StringDecoder ) StringDecoder = require ( 'string_decoder' ). StringDecoder ; this . decoder = new StringDecoder ( options . encoding ); this . encoding = options . encoding ; } } ReadableState\u91cc\u5305\u542b\u4e86\u4e00\u5927\u5806\u5b57\u6bb5\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u4e0d\u7ba1\u5b83\uff0c\u7b49\u5f85\u7528\u5230\u7684\u65f6\u5019\uff0c\u518d\u56de\u5934\u770b\u3002\u63a5\u7740\u6211\u4eec\u5f00\u59cb\u770b\u53ef\u8bfb\u6d41\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function Readable ( options ) { if ( ! ( this instanceof Readable )) return new Readable ( options ); this . _readableState = new ReadableState ( options , this ); // \u53ef\u8bfb this . readable = true ; // \u7528\u6237\u5b9e\u73b0\u7684\u4e24\u4e2a\u51fd\u6570 if ( options ) { if ( typeof options . read === 'function' ) this . _read = options . read ; if ( typeof options . destroy === 'function' ) this . _destroy = options . destroy ; } // \u521d\u59cb\u5316\u7236\u7c7b Stream . call ( this ); } \u4e0a\u9762\u7684\u903b\u8f91\u4e0d\u591a\uff0c\u9700\u8981\u5173\u6ce8\u7684\u662fread\u548cdestroy\u8fd9\u4e24\u4e2a\u51fd\u6570\uff0c\u5982\u679c\u6211\u4eec\u662f\u76f4\u63a5\u4f7f\u7528Readable\u4f7f\u7528\u53ef\u8bfb\u6d41\uff0c\u90a3\u5728options\u91cc\u662f\u5fc5\u987b\u4f20read\u51fd\u6570\u7684\uff0cdestroy\u662f\u53ef\u9009\u7684\u3002\u5982\u679c\u6211\u4eec\u662f\u4ee5\u7ee7\u627f\u7684\u65b9\u5f0f\u4f7f\u7528Readable\uff0c\u90a3\u5fc5\u987b\u5b9e\u73b0_read\u51fd\u6570\u3002Node.js\u53ea\u662f\u62bd\u8c61\u4e86\u6d41\u7684\u903b\u8f91\uff0c\u5177\u4f53\u7684\u64cd\u4f5c\uff08\u6bd4\u5982\u53ef\u8bfb\u6d41\u5c31\u662f\u8bfb\u53d6\u6570\u636e\uff09\u662f\u7531\u7528\u6237\u81ea\u5df1\u5b9e\u73b0\u7684\uff0c\u56e0\u4e3a\u8bfb\u53d6\u64cd\u4f5c\u662f\u4e1a\u52a1\u76f8\u5173\u7684\u3002\u4e0b\u9762\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u53ef\u8bfb\u6d41\u7684\u64cd\u4f5c\u3002 21.2.1 \u53ef\u8bfb\u6d41\u4ece\u5e95\u5c42\u8d44\u6e90\u83b7\u53d6\u6570\u636e \u00b6 \u5bf9\u7528\u6237\u6765\u8bf4\uff0c\u53ef\u8bfb\u6d41\u662f\u7528\u6237\u83b7\u53d6\u6570\u636e\u7684\u5730\u65b9\uff0c\u4f46\u662f\u5bf9\u53ef\u8bfb\u6d41\u6765\u8bf4\uff0c\u5b83\u63d0\u4f9b\u6570\u636e\u7ed9\u7528\u6237\u7684\u524d\u63d0\u662f\u5b83\u81ea\u5df1\u6709\u6570\u636e\uff0c\u6240\u4ee5\u53ef\u8bfb\u6d41\u9996\u5148\u9700\u8981\u751f\u4ea7\u6570\u636e\u3002\u751f\u4ea7\u6570\u636e\u7684\u903b\u8f91\u7531_read\u51fd\u6570\u5b9e\u73b0\u3002_read\u51fd\u6570\u7684\u903b\u8f91\u5927\u6982\u662f 1 2 const data = getSomeData (); readableStream . push ( data ); \u901a\u8fc7push\u51fd\u6570\uff0c\u5f80\u53ef\u8bfb\u6d41\u91cc\u5199\u5165\u6570\u636e\uff0c\u7136\u540e\u5c31\u53ef\u4ee5\u4e3a\u7528\u6237\u63d0\u4f9b\u6570\u636e\uff0c\u6211\u4eec\u770b\u770bpush\u7684\u5b9e\u73b0\uff0c\u53ea\u5217\u51fa\u4e3b\u8981\u903b\u8f91\u3002 Read 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 able . prototype . push = function ( chunk , encoding ) { // \u7701\u7565\u4e86\u7f16\u7801\u5904\u7406\u7684\u4ee3\u7801 return readableAddChunk ( this , chunk , encoding , false , skipChunkCheck ); }; function readableAddChunk ( stream , chunk , encoding , addToFront , skipChunkCheck ) { var state = stream . _readableState ; // push null\u4ee3\u8868\u6d41\u7ed3\u675f if ( chunk === null ) { state . reading = false ; onEofChunk ( stream , state ); } else { addChunk ( stream , state , chunk , false ); } // \u8fd4\u56de\u662f\u5426\u8fd8\u53ef\u4ee5\u8bfb\u53d6\u66f4\u591a\u6570\u636e return needMoreData ( state ); } function addChunk ( stream , state , chunk , addToFront ) { // \u662f\u6d41\u6a21\u5f0f\u5e76\u4e14\u6ca1\u6709\u7f13\u5b58\u7684\u6570\u636e\uff0c\u5219\u76f4\u63a5\u89e6\u53d1data\u4e8b\u4ef6 if ( state . flowing && state . length === 0 && ! state . sync ) { stream . emit ( 'data' , chunk ); } else { // \u5426\u5219\u5148\u628a\u6570\u636e\u7f13\u5b58\u8d77\u6765 state . length += state . objectMode ? 1 : chunk . length ; if ( addToFront ) state . buffer . unshift ( chunk ); else state . buffer . push ( chunk ); // \u76d1\u542c\u4e86readable\u4e8b\u4ef6\u5219\u89e6\u53d1readable\u4e8b\u4ef6\uff0c\u901a\u8fc7read\u4e3b\u52a8\u8bfb\u53d6 if ( state . needReadable ) emitReadable ( stream ); } // \u7ee7\u7eed\u8bfb\u53d6\u6570\u636e\uff0c\u5982\u679c\u53ef\u4ee5\u7684\u8bdd maybeReadMore ( stream , state ); } \u603b\u7684\u6765\u8bf4\uff0c\u53ef\u8bfb\u6d41\u9996\u5148\u8981\u4ece\u67d0\u4e2a\u5730\u65b9\u83b7\u53d6\u6570\u636e\uff0c\u6839\u636e\u5f53\u524d\u7684\u5de5\u4f5c\u6a21\u5f0f\uff0c\u76f4\u63a5\u4ea4\u4ed8\u7ed9\u7528\u6237\uff0c\u6216\u8005\u5148\u7f13\u5b58\u8d77\u6765\u3002\u53ef\u4ee5\u7684\u60c5\u51b5\u4e0b\uff0c\u7ee7\u7eed\u83b7\u53d6\u6570\u636e\u3002 21.2.2 \u7528\u6237\u4ece\u53ef\u8bfb\u6d41\u83b7\u53d6\u6570\u636e \u00b6 \u7528\u6237\u53ef\u4ee5\u901a\u8fc7read\u51fd\u6570\u6216\u8005\u76d1\u542cdata\u4e8b\u4ef6\u6765\u4ece\u53ef\u8bfb\u6d41\u4e2d\u83b7\u53d6\u6570\u636e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Readable . prototype . read = function ( n ) { n = parseInt ( n , 10 ); var state = this . _readableState ; // \u8ba1\u7b97\u53ef\u8bfb\u7684\u5927\u5c0f n = howMuchToRead ( n , state ); var ret ; // \u9700\u8981\u8bfb\u53d6\u7684\u5927\u4e8e0\uff0c\u5219\u53d6\u8bfb\u53d6\u6570\u636e\u5230ret\u8fd4\u56de if ( n > 0 ) ret = fromList ( n , state ); else ret = null ; // \u51cf\u53bb\u521a\u8bfb\u53d6\u7684\u957f\u5ea6 state . length -= n ; /* \u5982\u679c\u7f13\u5b58\u91cc\u6ca1\u6709\u6570\u636e\u6216\u8005\u8bfb\u5b8c\u540e\u5c0f\u4e8e\u9608\u503c\u4e86\uff0c \u5219\u53ef\u8bfb\u6d41\u53ef\u4ee5\u7ee7\u7eed\u4ece\u5e95\u5c42\u8d44\u6e90\u91cc\u83b7\u53d6\u6570\u636e */ if ( state . length === 0 || state . length - n < state . highWaterMark ) { this . _read ( state . highWaterMark ); } // \u89e6\u53d1data\u4e8b\u4ef6 if ( ret !== null ) this . emit ( 'data' , ret ); return ret ; }; \u8bfb\u53d6\u6570\u636e\u7684\u64cd\u4f5c\u5c31\u662f\u8ba1\u7b97\u7f13\u5b58\u91cc\u6709\u591a\u5c11\u6570\u636e\u53ef\u4ee5\u8bfb\uff0c\u548c\u7528\u6237\u9700\u8981\u7684\u6570\u636e\u5927\u5c0f\uff0c\u53d6\u5c0f\u7684\uff0c\u7136\u540e\u8fd4\u56de\u7ed9\u7528\u6237\uff0c\u5e76\u89e6\u53d1data\u4e8b\u4ef6\u3002\u5982\u679c\u6570\u636e\u8fd8\u6ca1\u6709\u8fbe\u5230\u9608\u503c\uff0c\u5219\u89e6\u53d1\u53ef\u8bfb\u6d41\u4ece\u5e95\u5c42\u8d44\u6e90\u4e2d\u83b7\u53d6\u6570\u636e\u3002\u4ece\u800c\u6e90\u6e90\u4e0d\u65ad\u5730\u751f\u6210\u6570\u636e\u3002 21.3 \u53ef\u5199\u6d41 \u00b6 \u53ef\u5199\u6d41\u662f\u5bf9\u6570\u636e\u6d41\u5411\u7684\u62bd\u8c61\uff0c\u7528\u6237\u8c03\u7528\u53ef\u5199\u6d41\u7684\u63a5\u53e3\uff0c\u53ef\u5199\u6d41\u8d1f\u8d23\u63a7\u5236\u6570\u636e\u7684\u5199\u5165\u3002\u6d41\u7a0b\u5982\u56fe21-1\u6240\u793a\u3002 \u56fe21-1 \u4e0b\u9762\u662f\u53ef\u5199\u6d41\u7684\u4ee3\u7801\u903b\u8f91\u56fe\u5982\u56fe21-2\u6240\u793a\u3002 \u56fe21-2 \u6211\u4eec\u770b\u4e00\u4e0b\u53ef\u5199\u6d41\u7684\u5b9e\u73b0\u3002 21.3.1 WritableState \u00b6 WritableState\u662f\u7ba1\u7406\u53ef\u5199\u6d41\u914d\u7f6e\u7684\u7c7b\u3002\u91cc\u9762\u5305\u542b\u4e86\u975e\u5e38\u7684\u5b57\u6bb5\uff0c\u5177\u4f53\u542b\u4e49\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u5206\u6790\u7684\u65f6\u5019\u8bb2\u89e3\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 function WritableState ( options , stream ) { options = options || {}; // \u662f\u4e0d\u662f\u53cc\u5411\u6d41 var isDuplex = stream instanceof Stream . Duplex ; // \u6570\u636e\u6a21\u5f0f this . objectMode = !! options . objectMode ; /* \u53cc\u5411\u6d41\u7684\u6d41\u9ed8\u8ba4\u5171\u4eabobjectMode\u914d\u7f6e\uff0c \u7528\u6237\u53ef\u4ee5\u81ea\u5df1\u914d\u7f6e\u6210\u975e\u5171\u4eab\uff0c\u5373\u8bfb\u6d41\u548c\u5199\u6d41\u7684\u6570\u636e\u6a21\u5f0f\u72ec\u7acb */ if ( isDuplex ) this . objectMode = this . objectMode || !! options . writableObjectMode ; /* \u9608\u503c\uff0c\u8d85\u8fc7\u540e\u8bf4\u660e\u9700\u8981\u6682\u505c\u8c03\u7528write\uff0c0\u4ee3\u8868\u6bcf\u6b21\u8c03\u7528write \u7684\u65f6\u5019\u90fd\u8fd4\u56defalse\uff0c\u7528\u6237\u7b49\u5f85drain\u4e8b\u4ef6\u89e6\u53d1\u540e\u518d\u6267\u884cwrite */ this . highWaterMark = getHighWaterMark ( this , options , 'writableHighWaterMark' , isDuplex ); // \u662f\u5426\u8c03\u7528\u4e86_final\u51fd\u6570 this . finalCalled = false ; // \u662f\u5426\u9700\u8981\u89e6\u53d1drain\u4e8b\u4ef6\uff0c\u91cd\u65b0\u9a71\u52a8\u751f\u4ea7\u8005 this . needDrain = false ; // \u6b63\u5728\u6267\u884cend\u6d41\u7a0b this . ending = false ; // \u662f\u5426\u6267\u884c\u8fc7end\u51fd\u6570 this . ended = false ; // \u662f\u5426\u89e6\u53d1\u4e86finish\u4e8b\u4ef6 this . finished = false ; // \u6d41\u662f\u5426\u88ab\u9500\u6bc1\u4e86 this . destroyed = false ; var noDecode = options . decodeStrings === false ; // \u662f\u5426\u9700\u8981decode\u6d41\u6570\u636e\u540e\u5728\u6267\u884c\u5199\uff08\u8c03\u7528\u7528\u6237\u5b9a\u4e49\u7684_write\uff09 this . decodeStrings = ! noDecode ; // \u7f16\u7801\u7c7b\u578b this . defaultEncoding = options . defaultEncoding || 'utf8' ; // \u5f85\u5199\u5165\u7684\u6570\u636e\u957f\u5ea6\u6216\u5bf9\u8c61\u6570 this . length = 0 ; // \u6b63\u5728\u5f80\u5e95\u5c42\u5199 this . writing = false ; // \u52a0\u585e\uff0c\u7f13\u5b58\u751f\u4ea7\u8005\u7684\u6570\u636e\uff0c\u505c\u6b62\u5f80\u5e95\u5c42\u5199\u5165 this . corked = 0 ; // \u7528\u6237\u5b9a\u4e49\u7684_write\u6216\u8005_writev\u662f\u540c\u6b65\u8fd8\u662f\u5f02\u6b65\u8c03\u7528\u53ef\u5199\u6d41\u7684\u56de\u8c03\u51fd\u6570onwrite this . sync = true ; // \u662f\u5426\u6b63\u5728\u5904\u7406\u7f13\u5b58\u7684\u6570\u636e this . bufferProcessing = false ; // \u7528\u6237\u5b9e\u73b0\u7684\u94a9\u5b50_write\u51fd\u6570\u91cc\u9700\u8981\u6267\u884c\u7684\u56de\u8c03\uff0c\u544a\u8bc9\u5199\u6d41\u5199\u5b8c\u6210\u4e86 this . onwrite = onwrite . bind ( undefined , stream ); // \u5f53\u524d\u5199\u64cd\u4f5c\u5bf9\u5e94\u7684\u56de\u8c03 this . writecb = null ; // \u5f53\u524d\u5199\u64cd\u4f5c\u7684\u6570\u636e\u957f\u5ea6\u6216\u5bf9\u8c61\u6570 this . writelen = 0 ; // \u7f13\u5b58\u7684\u6570\u636e\u94fe\u8868\u5934\u6307\u9488 this . bufferedRequest = null ; // \u6307\u5411\u7f13\u5b58\u7684\u6570\u636e\u94fe\u8868\u6700\u540e\u4e00\u4e2a\u8282\u70b9 this . lastBufferedRequest = null ; // \u5f85\u6267\u884c\u7684\u56de\u8c03\u51fd\u6570\u4e2a\u6570 this . pendingcb = 0 ; // \u662f\u5426\u5df2\u7ecf\u89e6\u53d1\u8fc7prefinished\u4e8b\u4ef6 this . prefinished = false ; // \u662f\u5426\u5df2\u7ecf\u89e6\u53d1\u8fc7error\u4e8b\u4ef6 this . errorEmitted = false ; // count buffered requests // \u7f13\u5b58\u7684buffer\u6570 this . bufferedRequestCount = 0 ; /* \u7a7a\u95f2\u7684\u8282\u70b9\u94fe\u8868\uff0c\u5f53\u628a\u7f13\u5b58\u6570\u636e\u5199\u5165\u5e95\u5c42\u65f6\uff0ccorkReq\u4fdd\u6570\u636e\u7684\u4e0a\u4e0b\u6587\uff08\u5982 \u7528\u6237\u56de\u8c03\uff09\uff0c\u56e0\u4e3a\u8fd9\u65f6\u5019\uff0c\u7f13\u5b58\u94fe\u8868\u5df2\u7ecf\u88ab\u6e05\u7a7a\uff0c this.corkedRequestsFree\u59cb\u7ec8\u7ef4\u62a4\u4e00\u4e2a\u7a7a\u95f2\u8282\u70b9\uff0c\u6700\u591a\u4e24\u4e2a */ var corkReq = { next : null , entry : null , finish : undefined }; corkReq . finish = onCorkedFinish . bind ( undefined , corkReq , this ); this . corkedRequestsFree = corkReq ; } 21.3.2 Writable \u00b6 Writable\u662f\u53ef\u5199\u6d41\u7684\u5177\u4f53\u5b9e\u73b0\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528Writable\u4f5c\u4e3a\u53ef\u5199\u6d41\u6765\u4f7f\u7528\uff0c\u4e5f\u53ef\u4ee5\u7ee7\u627fWritable\u5b9e\u73b0\u81ea\u5df1\u7684\u53ef\u5199\u6d41\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function Writable ( options ) { this . _writableState = new WritableState ( options , this ); // \u53ef\u5199 this . writable = true ; // \u652f\u6301\u7528\u6237\u81ea\u5b9a\u4e49\u7684\u94a9\u5b50 if ( options ) { if ( typeof options . write === 'function' ) this . _write = options . write ; if ( typeof options . writev === 'function' ) this . _writev = options . writev ; if ( typeof options . destroy === 'function' ) this . _destroy = options . destroy ; if ( typeof options . final === 'function' ) this . _final = options . final ; } Stream . call ( this ); } \u53ef\u5199\u6d41\u7ee7\u627f\u4e8e\u6d41\u57fa\u7c7b\uff0c\u63d0\u4f9b\u51e0\u4e2a\u94a9\u5b50\u51fd\u6570\uff0c\u7528\u6237\u53ef\u4ee5\u81ea\u5b9a\u4e49\u94a9\u5b50\u51fd\u6570\u5b9e\u73b0\u81ea\u5df1\u7684\u903b\u8f91\u3002\u5982\u679c\u7528\u6237\u662f\u76f4\u63a5\u4f7f\u7528Writable\u7c7b\u4f5c\u4e3a\u53ef\u5199\u6d41\uff0c\u5219options.write\u51fd\u6570\u662f\u5fc5\u987b\u4f20\u7684\uff0coptions.wirte\u51fd\u6570\u63a7\u5236\u6570\u636e\u5f80\u54ea\u91cc\u5199\uff0c\u5e76\u4e14\u901a\u77e5\u53ef\u5199\u6d41\u662f\u5426\u5199\u5b8c\u6210\u4e86\u3002\u5982\u679c\u7528\u6237\u662f\u4ee5\u7ee7\u627fWritable\u7c7b\u7684\u5f62\u5f0f\u4f7f\u7528\u53ef\u5199\u6d41\uff0c\u5219_write\u51fd\u6570\u662f\u5fc5\u987b\u5b9e\u73b0\u7684\uff0c_write\u51fd\u6570\u548coptions.write\u51fd\u6570\u7684\u4f5c\u7528\u662f\u4e00\u6837\u7684\u3002 21.3.3 \u6570\u636e\u5199\u5165 \u00b6 \u53ef\u5199\u6d41\u63d0\u4f9bwrite\u51fd\u6570\u7ed9\u7528\u6237\u5b9e\u73b0\u6570\u636e\u7684\u5199\u5165\uff0c\u5199\u5165\u6709\u4e24\u79cd\u65b9\u5f0f\u3002\u4e00\u4e2a\u662f\u9010\u4e2a\u5199\uff0c\u4e00\u4e2a\u662f\u6279\u91cf\u5199\uff0c\u6279\u91cf\u5199\u662f\u53ef\u9009\u7684\uff0c\u53d6\u51b3\u4e8e\u7528\u6237\u7684\u5b9e\u73b0\uff0c\u5982\u679c\u7528\u6237\u76f4\u63a5\u4f7f\u7528Writable\u5219\u9700\u8981\u4f20\u5165writev\uff0c\u5982\u679c\u662f\u7ee7\u627f\u65b9\u5f0f\u4f7f\u7528Writable\u5219\u5b9e\u73b0_writev\u51fd\u6570\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bwrite\u51fd\u6570\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Writable . prototype . write = function ( chunk , encoding , cb ) { var state = this . _writableState ; // \u544a\u8bc9\u7528\u6237\u662f\u5426\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u8c03\u7528write var ret = false ; // \u6570\u636e\u683c\u5f0f var isBuf = ! state . objectMode && Stream . _isUint8Array ( chunk ); // \u662f\u5426\u9700\u8981\u8f6c\u6210buffer\u683c\u5f0f if ( isBuf && Object . getPrototypeOf ( chunk ) !== Buffer . prototype ) { chunk = Stream . _uint8ArrayToBuffer ( chunk ); } // \u53c2\u6570\u5904\u7406\uff0c\u4f20\u4e86\u6570\u636e\u548c\u56de\u8c03\uff0c\u6ca1\u6709\u4f20\u7f16\u7801\u7c7b\u578b if ( typeof encoding === 'function' ) { cb = encoding ; encoding = null ; } // \u662fbuffer\u7c7b\u578b\u5219\u8bbe\u7f6e\u6210buffer\uff0c\u5426\u5219\u5982\u679c\u6ca1\u4f20\u5219\u53d6\u9ed8\u8ba4\u7f16\u7801 if ( isBuf ) encoding = 'buffer' ; else if ( ! encoding ) encoding = state . defaultEncoding ; if ( typeof cb !== 'function' ) cb = nop ; // \u6b63\u5728\u6267\u884cend\uff0c\u518d\u6267\u884cwrite\uff0c\u62a5\u9519 if ( state . ending ) writeAfterEnd ( this , cb ); else if ( isBuf || validChunk ( this , state , chunk , cb )) { // \u5f85\u6267\u884c\u7684\u56de\u8c03\u6570\u52a0\u4e00\uff0c\u5373cb state . pendingcb ++ ; // \u5199\u5165\u6216\u7f13\u5b58\uff0c\u89c1\u8be5\u51fd\u6570 ret = writeOrBuffer ( this , state , isBuf , chunk , encoding , cb ); } /// \u8fd8\u80fd\u4e0d\u80fd\u7ee7\u7eed\u5199 return ret ; }; write\u51fd\u6570\u9996\u5148\u505a\u4e86\u4e00\u4e9b\u53c2\u6570\u5904\u7406\u548c\u6570\u636e\u8f6c\u6362\uff0c\u7136\u540e\u5224\u65ad\u6d41\u662f\u5426\u5df2\u7ecf\u7ed3\u675f\u4e86\uff0c\u5982\u679c\u6d41\u7ed3\u675f\u518d\u6267\u884c\u5199\u5165\uff0c\u5219\u4f1a\u62a5\u9519\u3002\u5982\u679c\u6d41\u6ca1\u6709\u7ed3\u675f\u5219\u6267\u884c\u5199\u5165\u6216\u8005\u7f13\u5b58\u5904\u7406\u3002\u6700\u540e\u901a\u77e5\u7528\u6237\u662f\u5426\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u8c03\u7528write\u5199\u5165\u6570\u636e\uff08\u6211\u4eec\u770b\u5230\u5982\u679c\u5199\u5165\u7684\u6570\u636e\u6bd4\u9608\u503c\u5927\uff0c\u53ef\u5199\u6d41\u8fd8\u662f\u4f1a\u6267\u884c\u5199\u5165\u64cd\u4f5c\uff0c\u4f46\u662f\u4f1a\u8fd4\u56defalse\u544a\u8bc9\u7528\u6237\u4e9b\u4e0d\u8981\u5199\u5165\u4e86\uff0c\u5982\u679c\u8c03\u7528\u65b9\u7ee7\u7eed\u5199\u5165\u7684\u8bdd\uff0c\u4e5f\u662f\u6ca1\u4f1a\u7ee7\u7eed\u5199\u5165\u7684\uff0c\u4f46\u662f\u53ef\u80fd\u4f1a\u5bfc\u81f4\u5199\u5165\u7aef\u538b\u529b\u8fc7\u5927\uff09\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bwriteAfterEnd\u7684\u903b\u8f91\u3002\u7136\u540e\u518d\u770bwriteOrBuffer\u3002 1 2 3 4 5 function writeAfterEnd ( stream , cb ) { var er = new errors . Error ( 'ERR_STREAM_WRITE_AFTER_END' ); stream . emit ( 'error' , er ); process . nextTick ( cb , er ); } writeAfterEnd\u51fd\u6570\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u9996\u5148\u89e6\u53d1\u53ef\u5199\u6d41\u7684error\u4e8b\u4ef6\uff0c\u7136\u540e\u4e0b\u4e00\u4e2atick\u7684\u65f6\u5019\u6267\u884c\u7528\u6237\u5728\u8c03\u7528write\u65f6\u4f20\u5165\u7684\u56de\u8c03\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bwriteOrBuffer\u3002writeOrBuffer\u51fd\u6570\u4f1a\u5bf9\u6570\u636e\u8fdb\u884c\u7f13\u5b58\u6216\u8005\u76f4\u63a5\u5199\u5165\u76ee\u7684\u5730\uff08\u76ee\u7684\u5730\u53ef\u4ee5\u662f\u6587\u4ef6\u3001socket\u3001\u5185\u5b58\uff0c\u53d6\u51b3\u4e8e\u7528\u6237\u7684\u5b9e\u73b0\uff09\uff0c\u53d6\u51b3\u4e8e\u5f53\u524d\u53ef\u5199\u6d41\u7684\u72b6\u6001\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 function writeOrBuffer ( stream , state , isBuf , chunk , encoding , cb ) { // \u6570\u636e\u5904\u7406 if ( ! isBuf ) { var newChunk = decodeChunk ( state , chunk , encoding ); if ( chunk !== newChunk ) { isBuf = true ; encoding = 'buffer' ; chunk = newChunk ; } } // \u5bf9\u8c61\u6a21\u5f0f\u7684\u7b97\u4e00\u4e2a var len = state . objectMode ? 1 : chunk . length ; // \u66f4\u65b0\u5f85\u5199\u5165\u6570\u636e\u957f\u5ea6\u6216\u5bf9\u8c61\u4e2a\u6570 state . length += len ; // \u5f85\u5199\u5165\u7684\u957f\u5ea6\u662f\u5426\u8d85\u8fc7\u4e86\u9608\u503c var ret = state . length < state . highWaterMark ; /* \u8d85\u8fc7\u4e86\u9608\u503c\uff0c\u5219\u8bbe\u7f6e\u9700\u8981\u7b49\u5f85drain\u4e8b\u4ef6\u6807\u8bb0\uff0c \u8fd9\u65f6\u5019\u7528\u6237\u4e0d\u5e94\u8be5\u518d\u6267\u884cwrite\uff0c\u800c\u662f\u7b49\u5f85drain\u4e8b\u4ef6\u89e6\u53d1 */ if ( ! ret ) state . needDrain = true ; // \u5982\u679c\u6b63\u5728\u5199\u6216\u8005\u8bbe\u7f6e\u4e86\u963b\u585e\u5219\u5148\u7f13\u5b58\u6570\u636e\uff0c\u5426\u5219\u76f4\u63a5\u5199\u5165 if ( state . writing || state . corked ) { // \u6307\u5411\u5f53\u524d\u7684\u5c3e\u8282\u70b9 var last = state . lastBufferedRequest ; // \u63d2\u5165\u65b0\u7684\u5c3e\u7ed3\u70b9 state . lastBufferedRequest = { chunk , encoding , isBuf , callback : cb , next : null }; /* \u4e4b\u524d\u8fd8\u6709\u8282\u70b9\u7684\u8bdd\uff0c\u65e7\u7684\u5c3e\u8282\u70b9\u7684next\u6307\u9488\u6307\u5411\u65b0\u7684\u5c3e\u8282\u70b9\uff0c \u5f62\u6210\u94fe\u8868 */ if ( last ) { last . next = state . lastBufferedRequest ; } else { /* \u6307\u5411buffer\u94fe\u8868\uff0cbufferedRequest\u76f8\u7b49\u4e8e\u5934\u6307\u9488\uff0c \u63d2\u5165\u7b2c\u4e00\u4e2abuffer\u8282\u70b9\u7684\u65f6\u5019\u6267\u884c\u5230\u8fd9 */ state . bufferedRequest = state . lastBufferedRequest ; } // \u7f13\u5b58\u7684buffer\u4e2a\u6570\u52a0\u4e00 state . bufferedRequestCount += 1 ; } else { // \u76f4\u63a5\u5199\u5165 doWrite ( stream , state , false , len , chunk , encoding , cb ); } // \u8fd4\u56de\u662f\u5426\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u6267\u884cwirte\uff0c\u5982\u679c\u6ca1\u6709\u8fbe\u5230\u9608\u503c\u5219\u53ef\u4ee5\u7ee7\u7eed\u5199 return ret ; } writeOrBuffer\u51fd\u6570\u4e3b\u8981\u7684\u903b\u8f91\u5982\u4e0b 1 \u66f4\u65b0\u5f85\u5199\u5165\u6570\u636e\u7684\u957f\u5ea6\uff0c\u5224\u65ad\u662f\u5426\u8fbe\u5230\u9608\u503c\uff0c\u7136\u540e\u901a\u77e5\u7528\u6237\u662f\u5426\u8fd8\u53ef\u4ee5\u6267\u884cwrite\u7ee7\u7eed\u5199\u5165\u3002 2 \u5224\u65ad\u5f53\u524d\u662f\u5426\u6b63\u5728\u5199\u5165\u6216\u8005\u5904\u4e8ecork\u6a21\u5f0f\u3002\u662f\u7684\u8bdd\u628a\u6570\u636e\u7f13\u5b58\u8d77\u6765\uff0c\u5426\u5219\u6267\u884c\u5199\u64cd\u4f5c\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u7f13\u5b58\u7684\u903b\u8f91\u548c\u5f62\u6210\u7684\u6570\u636e\u7ed3\u6784\u3002 \u7f13\u5b58\u7b2c\u4e00\u4e2a\u8282\u70b9\u65f6\uff0c\u5982\u56fe21-3\u6240\u793a\u3002 \u56fe21-3 \u7f13\u5b58\u7b2c\u4e8c\u4e2a\u8282\u70b9\u65f6\uff0c\u5982\u56fe21-4\u6240\u793a\u3002 \u56fe21-4 \u7f13\u5b58\u7b2c\u4e09\u4e2a\u8282\u70b9\u65f6\uff0c\u5982\u56fe21-5 \u56fe21-5 \u6211\u4eec\u770b\u5230\uff0c\u51fd\u6570\u7684\u6570\u636e\u662f\u4ee5\u94fe\u8868\u7684\u5f62\u5f0f\u7ba1\u7406\u7684\uff0c\u5176\u4e2dbufferedRequest\u662f\u94fe\u8868\u5934\u7ed3\u70b9\uff0clastBufferedRequest\u6307\u5411\u5c3e\u8282\u70b9\u3002\u5047\u8bbe\u5f53\u524d\u53ef\u5199\u6d41\u4e0d\u5904\u4e8e\u5199\u5165\u6216\u8005cork\u72b6\u6001\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5199\u5165\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function doWrite ( stream , state , writev , len , chunk , encoding , cb ) { // \u672c\u6b21\u5199\u5165\u7684\u6570\u636e\u957f\u5ea6 state . writelen = len ; // \u672c\u6b21\u5199\u5b8c\u6210\u540e\u6267\u884c\u7684\u56de\u8c03 state . writecb = cb ; // \u6b63\u5728\u5199\u5165 state . writing = true ; // \u5047\u8bbe\u7528\u6237\u5b9a\u4e49\u7684_writev\u6216\u8005_write\u51fd\u6570\u662f\u540c\u6b65\u56de\u8c03onwrite state . sync = true ; if ( writev ) // chunk\u4e3a\u7f13\u5b58\u5f85\u5199\u5165\u7684buffer\u8282\u70b9\u6570\u7ec4 stream . _writev ( chunk , state . onwrite ); else // \u6267\u884c\u7528\u6237\u5b9a\u4e49\u7684\u5199\u51fd\u6570\uff0conwrite\u662fNode.js\u5b9a\u4e49\u7684\uff0c\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u4e86\u8be5\u51fd\u6570 stream . _write ( chunk , encoding , state . onwrite ); /* \u5982\u679c\u7528\u6237\u662f\u540c\u6b65\u56de\u8c03onwrite\uff0c\u5219\u8fd9\u53e5\u4ee3\u7801\u6ca1\u6709\u610f\u4e49\uff0c \u5982\u679c\u662f\u5f02\u6b65\u56de\u8c03onwrite\uff0c\u8fd9\u53e5\u4ee3\u7801\u4f1a\u5728onwrite\u4e4b\u524d\u6267\u884c\uff0c \u5b83\u6807\u8bb0\u7528\u6237\u662f\u5f02\u6b65\u56de\u8c03\u6a21\u5f0f\uff0c\u5728onwrite\u4e2d\u9700\u8981\u5224\u65ad\u56de\u8c03\u6a21\u5f0f\uff0c\u5373sync\u7684\u503c */ state . sync = false ; } doWrite\u51fd\u6570\u8bb0\u5f55\u4e86\u672c\u6b21\u5199\u5165\u7684\u4e0a\u4e0b\u6587\uff0c\u6bd4\u5982\u957f\u5ea6\uff0c\u56de\u8c03\uff0c\u7136\u540e\u8bbe\u7f6e\u6b63\u5728\u5199\u6807\u8bb0\u3002\u6700\u540e\u6267\u884c\u5199\u5165\u3002\u5982\u679c\u5f53\u524d\u5f85\u5199\u5165\u7684\u6570\u636e\u662f\u7f13\u5b58\u7684\u6570\u636e\u5e76\u4e14\u7528\u6237\u5b9e\u73b0\u4e86_writev\u51fd\u6570\uff0c\u5219\u8c03\u7528_writev\u3002\u5426\u5219\u8c03\u7528_write\u3002\u4e0b\u9762\u6211\u4eec\u5b9e\u73b0\u4e00\u4e2a\u53ef\u5199\u6d41\u7684\u4f8b\u5b50\uff0c\u628a\u8fd9\u91cc\u7684\u903b\u8f91\u4e32\u8d77\u6765\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 const { Writable } = require ( 'stream' ); class DemoWritable extends Writable { constructor () { super (); this . data = null ; } _write ( chunk , encoding , cb ) { // \u4fdd\u5b58\u6570\u636e this . data = this . data ? Buffer . concat ([ this . data , chunk ]) : chunk ; // \u6267\u884c\u56de\u8c03\u544a\u8bc9\u53ef\u5199\u6d41\u5199\u5b8c\u6210\u4e86\uff0cfalse\u4ee3\u8868\u5199\u6210\u529f\uff0ctrue\u4ee3\u8868\u5199\u5931\u8d25 cb ( null ); } } DemoWritable\u5b9a\u4e49\u4e86\u6570\u636e\u6d41\u5411\u7684\u76ee\u7684\u5730\uff0c\u5728\u7528\u6237\u8c03\u7528write\u7684\u65f6\u5019\uff0c\u53ef\u5199\u6d41\u4f1a\u6267\u884c\u7528\u6237\u5b9a\u4e49\u7684_write\uff0c_write\u4fdd\u5b58\u4e86\u6570\u636e\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03\u5e76\u4f20\u5165\u53c2\u6570\uff0c\u901a\u77e5\u53ef\u5199\u6d41\u6570\u636e\u5199\u5b8c\u6210\u4e86\uff0c\u5e76\u901a\u8fc7\u53c2\u6570\u6807\u8bb0\u5199\u6210\u529f\u8fd8\u662f\u5931\u8d25\u3002\u8fd9\u65f6\u5019\u56de\u5230\u53ef\u5199\u6d41\u4fa7\u3002\u6211\u4eec\u770b\u5230\u53ef\u5199\u6d41\u8bbe\u7f6e\u7684\u56de\u8c03\u662fonwrite\uff0conwrite\u662f\u5728\u521d\u59cb\u5316\u53ef\u5199\u6d41\u7684\u65f6\u5019\u8bbe\u7f6e\u7684\u3002 1 this . onwrite = onwrite . bind ( undefined , stream ); \u6211\u4eec\u63a5\u7740\u770bonwrite\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 function onwrite ( stream , er ) { var state = stream . _writableState ; var sync = state . sync ; // \u672c\u6b21\u5199\u5b8c\u65f6\u6267\u884c\u7684\u56de\u8c03 var cb = state . writecb ; // \u91cd\u7f6e\u5185\u90e8\u5b57\u6bb5\u7684\u503c // \u5199\u5b8c\u4e86\uff0c\u91cd\u7f6e\u56de\u8c03\uff0c\u8fd8\u6709\u591a\u5c11\u5355\u4f4d\u7684\u6570\u636e\u6ca1\u6709\u5199\u5165\uff0c\u6570\u636e\u5199\u5b8c\uff0c\u91cd\u7f6e\u672c\u6b21\u5f85\u5199\u5165\u7684\u6570\u636e\u6570\u4e3a0 state . writing = false ; state . writecb = null ; state . length -= state . writelen ; state . writelen = 0 ; // \u5199\u51fa\u9519 if ( er ) onwriteError ( stream , state , sync , er , cb ); else { // Check if we're actually ready to finish, but don't emit yet // \u662f\u5426\u5df2\u7ecf\u6267\u884c\u4e86end\uff0c\u5e76\u4e14\u6570\u636e\u4e5f\u5199\u5b8c\u4e86\uff08\u63d0\u4ea4\u5199\u64cd\u4f5c\u548c\u6700\u540e\u771f\u6b63\u6267\u884c\u4e2d\u95f4\u53ef\u80fd\u6267\u884c\u4e86end\uff09 var finished = needFinish ( state ); // \u8fd8\u6ca1\u7ed3\u675f\uff0c\u5e76\u4e14\u6ca1\u6709\u8bbe\u7f6e\u963b\u585e\u6807\u8bb0\uff0c\u4e5f\u4e0d\u5728\u5904\u7406buffer\uff0c\u5e76\u4e14\u6709\u5f85\u5904\u7406\u7684\u7f13\u5b58\u6570\u636e\uff0c\u5219\u8fdb\u884c\u5199\u5165 if ( ! finished && ! state . corked && ! state . bufferProcessing && state . bufferedRequest ) { clearBuffer ( stream , state ); } // \u7528\u6237\u540c\u6b65\u56de\u8c03onwrite\u5219Node.js\u5f02\u6b65\u6267\u884c\u7528\u6237\u56de\u8c03 if ( sync ) { process . nextTick ( afterWrite , stream , state , finished , cb ); } else { afterWrite ( stream , state , finished , cb ); } } } onwrite\u7684\u903b\u8f91\u5982\u4e0b 1 \u66f4\u65b0\u53ef\u5199\u6d41\u7684\u72b6\u6001\u548c\u6570\u636e 2 \u5199\u51fa\u9519\u5219\u89e6\u53d1error\u4e8b\u4ef6\u548c\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u5199\u6210\u529f\u5219\u5224\u65ad\u662f\u5426\u6ee1\u8db3\u7ee7\u7eed\u6267\u884c\u5199\u64cd\u4f5c\uff0c\u662f\u7684\u8bdd\u5219\u7ee7\u7eed\u5199\uff0c\u5426\u5219\u6267\u884c\u7528\u6237\u56de\u8c03\u3002 \u6211\u4eec\u770b\u4e00\u4e0bclearBuffer\u51fd\u6570\u7684\u903b\u8f91\uff0c\u8be5\u903b\u8f91\u4e3b\u8981\u662f\u628a\u7f13\u5b58\u7684\u6570\u636e\u5199\u5230\u76ee\u7684\u5730\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 function clearBuffer ( stream , state ) { // \u6b63\u5728\u5904\u7406buffer state . bufferProcessing = true ; // \u6307\u5411\u5934\u7ed3\u70b9 var entry = state . bufferedRequest ; // \u5b9e\u73b0\u4e86_writev\u5e76\u4e14\u6709\u4e24\u4e2a\u4ee5\u4e0a\u7684\u6570\u636e\u5757\uff0c\u5219\u6279\u91cf\u5199\u5165\uff0c\u5373\u4e00\u6b21\u628a\u6240\u6709\u7f13\u5b58\u7684buffer\u90fd\u5199\u5165 if ( stream . _writev && entry && entry . next ) { // Fast case, write everything using _writev() var l = state . bufferedRequestCount ; var buffer = new Array ( l ); var holder = state . corkedRequestsFree ; // \u6307\u5411\u5f85\u5199\u5165\u6570\u636e\u7684\u94fe\u8868 holder . entry = entry ; var count = 0 ; // \u6570\u636e\u662f\u5426\u5168\u90e8\u90fd\u662fbuffer\u683c\u5f0f var allBuffers = true ; // \u628a\u7f13\u5b58\u7684\u8282\u70b9\u653e\u5230buffer\u6570\u7ec4\u4e2d while ( entry ) { buffer [ count ] = entry ; if ( ! entry . isBuf ) allBuffers = false ; entry = entry . next ; count += 1 ; } buffer . allBuffers = allBuffers ; doWrite ( stream , state , true , state . length , buffer , '' , holder . finish ); // \u5f85\u6267\u884c\u7684cb\u52a0\u4e00\uff0c\u5373holder.finish state . pendingcb ++ ; // \u6e05\u7a7a\u7f13\u5b58\u961f\u5217 state . lastBufferedRequest = null ; // \u8fd8\u6709\u4e0b\u4e00\u4e2a\u8282\u70b9\u5219\u66f4\u65b0\u6307\u9488,\u4e0b\u6b21\u4f7f\u7528 if ( holder . next ) { state . corkedRequestsFree = holder . next ; holder . next = null ; } else { // \u6ca1\u6709\u4e0b\u4e00\u4e2a\u8282\u70b9\u5219\u6062\u590d\u503c\uff0c\u89c1\u521d\u59cb\u5316\u65f6\u7684\u8bbe\u7f6e var corkReq = { next : null , entry : null , finish : undefined }; corkReq . finish = onCorkedFinish . bind ( undefined , corkReq , state ); state . corkedRequestsFree = corkReq ; } state . bufferedRequestCount = 0 ; } else { // \u6162\u6162\u5199\uff0c\u5373\u4e00\u4e2a\u4e2abuffer\u5199\uff0c\u5199\u5b8c\u540e\u7b49\u9700\u8981\u6267\u884c\u7528\u6237\u7684cb\uff0c\u9a71\u52a8\u4e0b\u4e00\u4e2a\u5199 // Slow case, write chunks one-by-one while ( entry ) { var chunk = entry . chunk ; var encoding = entry . encoding ; var cb = entry . callback ; var len = state . objectMode ? 1 : chunk . length ; // \u6267\u884c\u5199\u5165 doWrite ( stream , state , false , len , chunk , encoding , cb ); entry = entry . next ; // \u5904\u7406\u5b8c\u4e00\u4e2a\uff0c\u51cf\u4e00 state . bufferedRequestCount -- ; /* \u5728onwrite\u91cc\u6e05\u9664\u8fd9\u4e2a\u6807\u8bb0\uff0conwrite\u4f9d\u8d56\u4e8e\u7528\u6237\u6267\u884c\uff0c\u5982\u679c\u7528\u6237\u6ca1\u8c03\uff0c \u6216\u8005\u4e0d\u662f\u540c\u6b65\u8c03\uff0c\u5219\u9000\u51fa\uff0c\u7b49\u5f85\u6267\u884conwrite\u7684\u65f6\u5019\u518d\u7ee7\u7eed\u5199 */ if ( state . writing ) { break ; } } // \u5199\u5b8c\u4e86\u7f13\u5b58\u7684\u6570\u636e\uff0c\u5219\u66f4\u65b0\u6307\u9488 if ( entry === null ) state . lastBufferedRequest = null ; } /* \u66f4\u65b0\u7f13\u5b58\u6570\u636e\u94fe\u8868\u7684\u5934\u7ed3\u70b9\u6307\u5411\uff0c 1 \u5982\u679c\u662f\u6279\u91cf\u5199\u5219entry\u4e3anull 2 \u5982\u679c\u5355\u4e2a\u5199\uff0c\u5219\u53ef\u80fd\u8fd8\u6709\u503c\uff08\u5982\u679c\u7528\u6237\u662f\u5f02\u6b65\u8c03\u7528onwrite\u7684\u8bdd\uff09 */ state . bufferedRequest = entry ; // \u672c\u8f6e\u5904\u7406\u5b8c\u6bd5\uff08\u5904\u7406\u5b8c\u4e00\u4e2a\u6216\u5168\u90e8\uff09 state . bufferProcessing = false ; } clearBuffer\u7684\u903b\u8f91\u770b\u8d77\u6765\u975e\u5e38\u591a\uff0c\u4f46\u662f\u903b\u8f91\u5e76\u4e0d\u7b97\u5f88\u590d\u6742\u3002\u4e3b\u8981\u5206\u4e3a\u4e24\u4e2a\u5206\u652f\u3002 1 \u7528\u6237\u5b9e\u73b0\u4e86\u6279\u91cf\u5199\u51fd\u6570\uff0c\u5219\u4e00\u6b21\u628a\u7f13\u5b58\u7684\u65f6\u5019\u5199\u5165\u76ee\u7684\u5730\u3002\u9996\u5148\u628a\u7f13\u5b58\u7684\u6570\u636e\uff08\u94fe\u8868\uff09\u5168\u90e8\u6536\u96c6\u8d77\u6765\uff0c\u7136\u540e\u6267\u884c\u6267\u884c\u5199\u5165\uff0c\u5e76\u8bbe\u7f6e\u56de\u8c03\u662ffinish\u51fd\u6570\u3002corkedRequestsFree\u5b57\u6bb5\u6307\u5411\u4e00\u4e2a\u8282\u70b9\u6570\u6700\u5c11\u4e3a\u4e00\uff0c\u6700\u591a\u4e3a\u4e8c\u7684\u94fe\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u6279\u91cf\u5199\u7684\u6570\u636e\u7684\u4e0a\u4e0b\u6587\u3002\u6279\u91cf\u5199\u65f6\u7684\u6570\u636e\u7ed3\u6784\u56fe\u5982\u56fe21-6\u548c21-7\u6240\u793a\uff08\u4e24\u79cd\u573a\u666f\uff09\u3002 \u56fe21-6 \u56fe21-7 corkedRequestsFree\u4fdd\u8bc1\u6700\u5c11\u6709\u4e00\u4e2a\u8282\u70b9\uff0c\u7528\u4e8e\u4e00\u6b21\u6279\u91cf\u5199\uff0c\u5f53\u4f7f\u7528\u5b8c\u7684\u65f6\u5019\uff0c\u4f1a\u6700\u591a\u4fdd\u5b58\u4e24\u4e2a\u7a7a\u95f2\u8282\u70b9\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u6279\u91cf\u5199\u6210\u529f\u540e\uff0c\u56de\u8c03\u51fd\u6570onCorkedFinish\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function onCorkedFinish ( corkReq , state , err ) { // corkReq.entry\u6307\u5411\u5f53\u524d\u5904\u7406\u7684buffer\u94fe\u8868\u5934\u7ed3\u70b9 var entry = corkReq . entry ; corkReq . entry = null ; // \u904d\u5386\u6267\u884c\u7528\u6237\u4f20\u5165\u7684\u56de\u8c03\u56de\u8c03 while ( entry ) { var cb = entry . callback ; state . pendingcb -- ; cb ( err ); entry = entry . next ; } // \u56de\u6536corkReq\uff0cstate.corkedRequestsFree\u8fd9\u65f6\u5019\u5df2\u7ecf\u7b49\u4e8e\u65b0\u7684corkReq\uff0c\u6307\u5411\u521a\u7528\u5b8c\u7684\u8fd9\u4e2acorkReq\uff0c\u5171\u4fdd\u5b58\u4e24\u4e2a state . corkedRequestsFree . next = corkReq ; } onCorkedFinish\u9996\u5148\u4ece\u672c\u6b21\u6279\u91cf\u5199\u7684\u6570\u636e\u4e0a\u4e0b\u6587\u53d6\u51fa\u56de\u8c03\uff0c\u7136\u540e\u9010\u4e2a\u6267\u884c\u3002\u6700\u540e\u56de\u6536\u8282\u70b9\u3002corkedRequestsFree\u603b\u662f\u6307\u5411\u4e00\u4e2a\u7a7a\u95f2\u8282\u70b9\uff0c\u6240\u4ee5\u5982\u679c\u8282\u70b9\u8d85\u8fc7\u4e24\u4e2a\u65f6\uff0c\u6bcf\u6b21\u4f1a\u628a\u5c3e\u8282\u70b9\u4e22\u5f03\uff0c\u5982\u56fe21-8\u6240\u793a\u3002 \u56fe21-8 2 \u63a5\u7740\u6211\u4eec\u770b\u5355\u4e2a\u5199\u7684\u573a\u666f \u5355\u4e2a\u5199\u7684\u65f6\u5019\uff0c\u5c31\u662f\u901a\u8fc7doWrite\u628a\u6570\u636e\u9010\u4e2a\u5199\u5230\u76ee\u7684\u5730\uff0c\u4f46\u662f\u6709\u4e00\u4e2a\u5730\u65b9\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u7528\u6237\u662f\u5f02\u6b65\u6267\u884c\u53ef\u5199\u6d41\u7684\u56de\u8c03onwrite\uff08\u901a\u8fc7writing\u5b57\u6bb5\uff0c\u56e0\u4e3aonwrite\u4f1a\u7f6ewriting\u4e3atrue\uff0c\u5982\u679c\u6267\u884c\u5b8cdoWrite\uff0cwriting\u4e3afalse\u8bf4\u660e\u662f\u5f02\u6b65\u56de\u8c03\uff09\uff0c\u5219\u5199\u5165\u4e00\u4e2a\u6570\u636e\u540e\u5c31\u4e0d\u518d\u6267\u884cdoWrite\u8fdb\u884c\u5199\uff0c\u800c\u662f\u9700\u8981\u7b49\u5230onwrite\u56de\u8c03\u88ab\u5f02\u6b65\u6267\u884c\u65f6\uff0c\u518d\u6267\u884c\u4e0b\u4e00\u6b21\u5199\uff0c\u56e0\u4e3a\u53ef\u5199\u6d41\u662f\u4e32\u884c\u5730\u6267\u884c\u5199\u64cd\u4f5c\u3002 \u4e0b\u9762\u8bb2\u4e00\u4e0bsync\u5b57\u6bb5\u7684\u4f5c\u7528\u3002sync\u5b57\u6bb5\u662f\u7528\u4e8e\u6807\u8bb0\u6267\u884c\u7528\u6237\u81ea\u5b9a\u4e49\u7684write\u51fd\u6570\u65f6\uff0cwrite\u51fd\u6570\u662f\u540c\u6b65\u8fd8\u662f\u5f02\u6b65\u6267\u884c\u53ef\u5199\u6d41\u7684\u56de\u8c03onwrite\u3002\u4e3b\u8981\u7528\u4e8e\u63a7\u5236\u662f\u540c\u6b65\u8fd8\u662f\u5f02\u6b65\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002\u5e76\u4e14\u9700\u8981\u4fdd\u8bc1\u56de\u8c03\u8981\u6309\u7167\u5b9a\u4e49\u7684\u987a\u5e8f\u6267\u884c\u3002\u6709\u4e24\u4e2a\u5730\u65b9\u6d89\u53ca\u4e86\u8fd9\u4e2a\u903b\u8f91\uff0c\u7b2c\u4e00\u4e2a\u662fwirte\u7684\u65f6\u5019\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u51fd\u6570\u7684\u8c03\u7528\u5173\u7cfb\uff0c\u5982\u56fe21-9\u6240\u793a\u3002 \u56fe21-9 \u5982\u679c\u7528\u6237\u662f\u540c\u6b65\u6267\u884conwrite\uff0c\u5219\u6570\u636e\u4f1a\u88ab\u5b9e\u65f6\u5730\u6d88\u8d39\uff0c\u4e0d\u5b58\u5728\u7f13\u5b58\u6570\u636e\u7684\u60c5\u51b5\uff0c\u8fd9\u65f6\u5019Node.js\u5f02\u6b65\u5e76\u4e14\u6709\u5e8f\u5730\u6267\u884c\u7528\u6237\u56de\u8c03\u3002\u5982\u679c\u7528\u6237\u8fde\u7eed\u4e24\u6b21\u8c03\u7528\u4e86write\u5199\u5165\u6570\u636e\uff0c\u5e76\u4e14\u662f\u4ee5\u5f02\u6b65\u6267\u884c\u56de\u8c03onwrite\uff0c\u5219\u7b2c\u4e00\u6b21\u6267\u884conwrite\u7684\u65f6\u5019\uff0c\u4f1a\u5b58\u5728\u7f13\u5b58\u7684\u6570\u636e\uff0c\u8fd9\u65f6\u5019\u8fd8\u6ca1\u6765\u5f97\u53ca\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u5c31\u4f1a\u5148\u53d1\u751f\u7b2c\u4e8c\u6b21\u5199\u5165\u64cd\u4f5c\uff0c\u540c\u6837\uff0c\u7b2c\u4e8c\u6b21\u5199\u64cd\u4f5c\u4e5f\u662f\u5f02\u6b65\u56de\u8c03onwrite\uff0c\u6240\u4ee5\u63a5\u4e0b\u6765\u5c31\u4f1a\u540c\u6b65\u6267\u884c\u7684\u7528\u6237\u56de\u8c03\u3002\u8fd9\u6837\u5c31\u4fdd\u8bc1\u4e86\u7528\u6237\u56de\u8c03\u7684\u987a\u5e8f\u6267\u884c\u3002\u7b2c\u4e8c\u79cd\u573a\u666f\u662funcork\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u51fd\u6570\u5173\u7cfb\u56fe\uff0c\u5982\u56fe21-10\u6240\u793a\u3002 \u56fe21-10 \u5728uncork\u7684\u6267\u884c\u6d41\u7a0b\u4e2d\uff0c\u5982\u679conwrite\u662f\u88ab\u540c\u6b65\u56de\u8c03\uff0c\u5219\u5728onwrite\u4e2d\u4e0d\u4f1a\u518d\u6b21\u8c03\u7528clearBuffer\uff0c\u56e0\u4e3a\u8fd9\u65f6\u5019\u7684bufferProcessing\u4e3atrue\u3002\u8fd9\u65f6\u5019\u4f1a\u5148\u628a\u7528\u6237\u7684\u56de\u8c03\u5165\u961f\uff0c\u7136\u540e\u518d\u6b21\u6267\u884cdoWrite\u53d1\u8d77\u4e0b\u4e00\u6b21\u5199\u64cd\u4f5c\u3002\u5982\u679conwrite\u662f\u88ab\u5f02\u6b65\u6267\u884c\uff0c\u5728\u6267\u884cclearBuffer\u4e2d\uff0c\u7b2c\u4e00\u6b21\u6267\u884cdoWrite\u5b8c\u6bd5\u540e\uff0cclearBuffer\u5c31\u4f1a\u9000\u51fa\uff0c\u5e76\u4e14\u8fd9\u65f6\u5019bufferProcessing\u4e3afalse\u3002\u7b49\u5230onwrite\u88ab\u56de\u8c03\u7684\u65f6\u5019\uff0c\u518d\u6b21\u6267\u884cclearBuffer\uff0c\u540c\u6837\u6267\u884c\u5b8cdoWrite\u7684\u65f6\u5019\u9000\u51fa\uff0c\u7b49\u5f85\u5f02\u6b65\u56de\u8c03\uff0c\u8fd9\u65f6\u5019\u7528\u6237\u56de\u8c03\u88ab\u6267\u884c\u3002 \u6211\u4eec\u7ee7\u7eed\u5206\u6790onwrite\u7684\u4ee3\u7801\uff0conwrite\u6700\u540e\u4f1a\u8c03\u7528afterWrite\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function afterWrite ( stream , state , finished , cb ) { // \u8fd8\u6ca1\u7ed3\u675f\uff0c\u770b\u662f\u5426\u9700\u8981\u89e6\u53d1drain\u4e8b\u4ef6 if ( ! finished ) onwriteDrain ( stream , state ); // \u51c6\u5907\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u5f85\u6267\u884c\u7684\u56de\u8c03\u51cf\u4e00 state . pendingcb -- ; cb (); finishMaybe ( stream , state ); } function onwriteDrain ( stream , state ) { // \u6ca1\u6709\u6570\u636e\u9700\u8981\u5199\u4e86\uff0c\u5e76\u4e14\u6d41\u5728\u963b\u585e\u4e2d\u7b49\u5f85drain\u4e8b\u4ef6 if ( state . length === 0 && state . needDrain ) { // \u89e6\u53d1drain\u4e8b\u4ef6\u7136\u540e\u6e05\u7a7a\u6807\u8bb0 state . needDrain = false ; stream . emit ( 'drain' ); } } afterWrite\u4e3b\u8981\u662f\u5224\u65ad\u662f\u5426\u9700\u8981\u89e6\u53d1drain\u4e8b\u4ef6\uff0c\u7136\u540e\u6267\u884c\u7528\u6237\u56de\u8c03\u3002\u6700\u540e\u5224\u65ad\u6d41\u662f\u5426\u5df2\u7ecf\u7ed3\u675f\uff08\u5728\u5f02\u6b65\u56de\u8c03onwrite\u7684\u60c5\u51b5\u4e0b\uff0c\u7528\u6237\u8c03\u7528\u56de\u8c03\u4e4b\u524d\uff0c\u53ef\u80fd\u6267\u884c\u4e86end\uff09\u3002\u6d41\u7ed3\u675f\u7684\u903b\u8f91\u6211\u4eec\u540e\u9762\u7ae0\u8282\u5355\u72ec\u5206\u6790\u3002 21.3.4 cork\u548cuncork \u00b6 cork\u548cuncork\u7c7b\u4f3ctcp\u4e2d\u7684negal\u7b97\u6cd5\uff0c\u4e3b\u8981\u7528\u4e8e\u7d2f\u79ef\u6570\u636e\u540e\u4e00\u6b21\u6027\u5199\u5165\u76ee\u7684\u5730\u3002\u800c\u4e0d\u662f\u6709\u4e00\u5757\u5c31\u5b9e\u65f6\u5199\u5165\u3002\u6bd4\u5982\u5728tcp\u4e2d\uff0c\u6bcf\u6b21\u53d1\u9001\u4e00\u4e2a\u5b57\u8282\uff0c\u800c\u534f\u8bae\u5934\u8fdc\u8fdc\u5927\u4e8e\u4e00\u5b57\u8282\uff0c\u6709\u6548\u6570\u636e\u5360\u6bd4\u975e\u5e38\u4f4e\u3002\u4f7f\u7528cork\u7684\u65f6\u5019\u6700\u597d\u540c\u65f6\u63d0\u4f9bwritev\u5b9e\u73b0\uff0c\u5426\u5219\u6700\u540ecork\u5c31\u6ca1\u6709\u610f\u4e49\uff0c\u56e0\u4e3a\u6700\u7ec8\u8fd8\u662f\u9700\u8981\u4e00\u5757\u5757\u7684\u6570\u636e\u8fdb\u884c\u5199\u5165\u3002\u6211\u4eec\u770b\u770bcork\u7684\u4ee3\u7801\u3002 1 2 3 4 Writable . prototype . cork = function () { var state = this . _writableState ; state . corked ++ ; }; cork\u7684\u4ee3\u7801\u975e\u5e38\u7b80\u5355\uff0c\u8fd9\u91cc\u4f7f\u7528\u4e00\u4e2a\u6574\u6570\u800c\u4e0d\u662f\u6807\u8bb0\u4f4d\uff0c\u6240\u4ee5cork\u548cuncork\u9700\u8981\u914d\u5bf9\u4f7f\u7528\u3002\u6211\u4eec\u770b\u770buncork\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Writable . prototype . uncork = function () { var state = this . _writableState ; if ( state . corked ) { state . corked -- ; /* \u6ca1\u6709\u5728\u8fdb\u884c\u5199\u64cd\u4f5c\uff08\u5982\u679c\u8fdb\u884c\u5199\u64cd\u4f5c\u5219\u5728\u5199\u64cd\u4f5c\u5b8c\u6210\u7684\u56de\u8c03\u91cc\u4f1a\u6267\u884cclearBuffer\uff09\uff0c corked=0\uff0c \u6ca1\u6709\u5728\u5904\u7406\u7f13\u5b58\u6570\u636e\uff08writing\u4e3afalse\u5df2\u7ecf\u8bf4\u660e\uff09\uff0c \u6709\u7f13\u5b58\u7684\u6570\u636e\u5f85\u5904\u7406 */ if ( ! state . writing && ! state . corked && ! state . bufferProcessing && state . bufferedRequest ) clearBuffer ( this , state ); } }; 21.3.5 \u6d41\u7ed3\u675f \u00b6 \u6d41\u7ed3\u675f\u9996\u5148\u4f1a\u628a\u5f53\u524d\u7f13\u5b58\u7684\u6570\u636e\u5199\u5165\u76ee\u7684\u5730\uff0c\u5e76\u4e14\u5141\u8bb8\u518d\u6267\u884c\u989d\u5916\u7684\u4e00\u6b21\u5199\u64cd\u4f5c\uff0c\u7136\u540e\u628a\u53ef\u5199\u6d41\u7f6e\u4e3a\u4e0d\u53ef\u5199\u548c\u7ed3\u675f\u72b6\u6001\uff0c\u5e76\u4e14\u89e6\u53d1\u4e00\u7cfb\u5217\u4e8b\u4ef6\u3002\u4e0b\u9762\u662f\u7ed3\u675f\u4e00\u4e2a\u53ef\u5199\u6d41\u7684\u51fd\u6570\u5173\u7cfb\u56fe\u3002\u5982\u56fe21-11\u6240\u793a\u3002 \u56fe21-11 \u901a\u8fc7end\u51fd\u6570\u53ef\u4ee5\u7ed3\u675f\u53ef\u5199\u6d41\uff0c\u6211\u4eec\u770b\u770b\u8be5\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Writable . prototype . end = function ( chunk , encoding , cb ) { var state = this . _writableState ; if ( typeof chunk === 'function' ) { cb = chunk ; chunk = null ; encoding = null ; } else if ( typeof encoding === 'function' ) { cb = encoding ; encoding = null ; } // \u6700\u540e\u4e00\u6b21\u5199\u5165\u7684\u673a\u4f1a\uff0c\u53ef\u80fd\u76f4\u63a5\u5199\u5165\uff0c\u4e5f\u53ef\u4ee5\u4f1a\u88ab\u7f13\u5b58\uff08\u6b63\u5728\u5199\u62a4\u7740\u5904\u4e8ecorked\u72b6\u6001\uff09 if ( chunk !== null && chunk !== undefined ) this . write ( chunk , encoding ); // \u5982\u679c\u5904\u4e8ecorked\u72b6\u6001\uff0c\u5219\u4e0a\u9762\u7684\u5199\u64cd\u4f5c\u4f1a\u88ab\u7f13\u5b58\uff0cuncork\u548cwrite\u4fdd\u5b58\u53ef\u4ee5\u5bf9\u5269\u4f59\u6570\u636e\u6267\u884c\u5199\u64cd\u4f5c if ( state . corked ) { // \u7f6e1\uff0c\u4e3a\u4e86uncork\u80fd\u6b63\u786e\u6267\u884c,\u53ef\u4ee5\u6709\u673a\u4f1a\u5199\u5165\u7f13\u5b58\u7684\u6570\u636e state . corked = 1 ; this . uncork (); } if ( ! state . ending ) endWritable ( this , state , cb ); }; \u6211\u4eec\u63a5\u7740\u770bendWritable\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function endWritable ( stream , state , cb ) { // \u6b63\u5728\u6267\u884cend\u51fd\u6570 state . ending = true ; // \u5224\u65ad\u6d41\u662f\u5426\u53ef\u4ee5\u7ed3\u675f\u4e86 finishMaybe ( stream , state ); if ( cb ) { // \u5df2\u7ecf\u89e6\u53d1\u4e86finish\u4e8b\u4ef6\u5219\u4e0b\u4e00\u4e2atick\u76f4\u63a5\u6267\u884ccb\uff0c\u5426\u5219\u7b49\u5f85finish\u4e8b\u4ef6 if ( state . finished ) process . nextTick ( cb ); else stream . once ( 'finish' , cb ); } // \u6d41\u7ed3\u675f\uff0c\u6d41\u4e0d\u53ef\u5199 state . ended = true ; stream . writable = false ; } endWritable\u51fd\u6570\u6807\u8bb0\u6d41\u4e0d\u53ef\u5199\u5e76\u4e14\u5904\u4e8e\u7ed3\u675f\u72b6\u6001\u3002\u4f46\u662f\u53ea\u662f\u4ee3\u8868\u4e0d\u80fd\u518d\u8c03\u7528write\u5199\u6570\u636e\u4e86\uff0c\u4e4b\u524d\u7f13\u5b58\u7684\u6570\u636e\u9700\u8981\u88ab\u5199\u5b8c\u540e\u624d\u80fd\u771f\u6b63\u5730\u7ed3\u675f\u6d41\u3002\u6211\u4eec\u770bfinishMaybe\u51fd\u6570\u7684\u903b\u8f91\u3002\u8be5\u51fd\u6570\u7528\u4e8e\u5224\u65ad\u6d41\u662f\u5426\u53ef\u4ee5\u7ed3\u675f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function needFinish ( state ) { /* \u6267\u884c\u4e86end\u51fd\u6570\u5219\u8bbe\u7f6eending=true\uff0c \u5f53\u524d\u6ca1\u6709\u6570\u636e\u9700\u8981\u5199\u5165\u4e86\uff0c \u4e5f\u6ca1\u6709\u7f13\u5b58\u7684\u6570\u636e\uff0c \u8fd8\u6ca1\u6709\u89e6\u53d1finish\u4e8b\u4ef6\uff0c \u6ca1\u6709\u6b63\u5728\u8fdb\u884c\u5199\u5165 */ return ( state . ending && state . length === 0 && state . bufferedRequest === null && ! state . finished && ! state . writing ); } // \u6bcf\u6b21\u5199\u5b8c\u6210\u7684\u65f6\u5019\u4e5f\u4f1a\u8c03\u7528\u8be5\u51fd\u6570 function finishMaybe ( stream , state ) { // \u6d41\u662f\u5426\u53ef\u4ee5\u7ed3\u675f var need = needFinish ( state ); // \u662f\u5219\u5148\u5904\u7406prefinish\u4e8b\u4ef6\uff0c\u5426\u5219\u5148\u4e0d\u7ba1\uff0c\u7b49\u5f85\u5199\u5b8c\u6210\u518d\u8c03\u7528\u8be5\u51fd\u6570 if ( need ) { prefinish ( stream , state ); // \u5982\u679c\u6ca1\u6709\u5f85\u6267\u884c\u7684\u56de\u8c03\uff0c\u5219\u89e6\u53d1finish\u4e8b\u4ef6 if ( state . pendingcb === 0 ) { state . finished = true ; stream . emit ( 'finish' ); } } return need ; } \u5f53\u53ef\u5199\u6d41\u4e2d\u6240\u6709\u6570\u636e\u548c\u56de\u8c03\u90fd\u6267\u884c\u4e86\u624d\u80fd\u7ed3\u675f\u6d41\uff0c\u5728\u7ed3\u675f\u6d41\u4e4b\u524d\u4f1a\u5148\u5904\u7406prefinish\u4e8b\u4ef6\u3002 1. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function callFinal ( stream , state ) { // \u6267\u884c\u7528\u6237\u7684final\u51fd\u6570 stream . _final (( err ) => { // \u6267\u884c\u4e86callFinal\u51fd\u6570\uff0ccb\u51cf\u4e00 state . pendingcb -- ; if ( err ) { stream . emit ( 'error' , err ); } // \u6267\u884cprefinish state . prefinished = true ; stream . emit ( 'prefinish' ); // \u662f\u5426\u53ef\u4ee5\u89e6\u53d1finish\u4e8b\u4ef6 finishMaybe ( stream , state ); }); } function prefinish ( stream , state ) { // \u8fd8\u6ca1\u89e6\u53d1prefinish\u5e76\u4e14\u6ca1\u6709\u6267\u884cfinalcall if ( ! state . prefinished && ! state . finalCalled ) { // \u7528\u6237\u4f20\u4e86final\u51fd\u6570\u5219\uff0c\u5f85\u6267\u884c\u56de\u8c03\u6570\u52a0\u4e00\uff0c\u5373callFinal\uff0c\u5426\u5219\u76f4\u63a5\u89e6\u53d1prefinish if ( typeof stream . _final === 'function' ) { state . pendingcb ++ ; state . finalCalled = true ; process . nextTick ( callFinal , stream , state ); } else { state . prefinished = true ; stream . emit ( 'prefinish' ); } } } \u5982\u679c\u7528\u6237\u5b9a\u4e49\u4e86_final\u51fd\u6570\uff0c\u5219\u5148\u6267\u884c\u8be5\u51fd\u6570\uff08\u8fd9\u65f6\u5019\u4f1a\u963b\u6b62finish\u4e8b\u4ef6\u7684\u89e6\u53d1\uff09\uff0c\u6267\u884c\u5b8c\u540e\u89e6\u53d1prefinish\uff0c\u518d\u89e6\u53d1finish\u3002\u5982\u679c\u6ca1\u6709\u5b9a\u4e49_final\uff0c\u5219\u76f4\u63a5\u89e6\u53d1prefinish\u4e8b\u4ef6\u3002\u6700\u540e\u89e6\u53d1finish\u4e8b\u4ef6\u3002 21.4 \u53cc\u5411\u6d41 \u00b6 \u53cc\u5411\u6d41\u662f\u7ee7\u627f\u53ef\u8bfb\u3001\u53ef\u5199\u7684\u6d41\u3002 1 2 3 4 5 6 7 8 9 10 11 util . inherits ( Duplex , Readable ); { // \u628a\u53ef\u5199\u6d41\u4e2d\u5b58\u5728\uff0c\u5e76\u4e14\u5728\u53ef\u8bfb\u6d41\u548cDuplex\u91cc\u90fd\u4e0d\u5b58\u5728\u7684\u65b9\u6cd5\u52a0\u5165\u5230Duplex const keys = Object . keys ( Writable . prototype ); for ( var v = 0 ; v < keys . length ; v ++ ) { const method = keys [ v ]; if ( ! Duplex . prototype [ method ]) Duplex . prototype [ method ] = Writable . prototype [ method ]; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function Duplex ( options ) { if ( ! ( this instanceof Duplex )) return new Duplex ( options ); Readable . call ( this , options ); Writable . call ( this , options ); // \u53cc\u5411\u6d41\u9ed8\u8ba4\u53ef\u8bfb if ( options && options . readable === false ) this . readable = false ; // \u53cc\u5411\u6d41\u9ed8\u8ba4\u53ef\u5199 if ( options && options . writable === false ) this . writable = false ; // \u9ed8\u8ba4\u5141\u8bb8\u534a\u5f00\u5173 this . allowHalfOpen = true ; if ( options && options . allowHalfOpen === false ) this . allowHalfOpen = false ; this . once ( 'end' , onend ); } \u53cc\u5411\u6d41\u7ee7\u627f\u4e86\u53ef\u8bfb\u6d41\u548c\u53ef\u5199\u6d41\u7684\u80fd\u529b\u3002\u53cc\u5411\u6d41\u5b9e\u73b0\u4e86\u4ee5\u4e0b\u529f\u80fd 21.4.1 \u9500\u6bc1 \u00b6 \u5982\u679c\u8bfb\u5199\u4e24\u7aef\u90fd\u9500\u6bc1\uff0c\u5219\u53cc\u5411\u6d41\u9500\u6bc1\u3002 1 2 3 4 5 6 7 8 9 10 Object . defineProperty ( Duplex . prototype , 'destroyed' , { enumerable : false , get () { if ( this . _readableState === undefined || this . _writableState === undefined ) { return false ; } return this . _readableState . destroyed && this . _writableState . destroyed ; } } \u6211\u4eec\u770b\u5982\u4f55\u9500\u6bc1\u4e00\u4e2a\u53cc\u5411\u6d41\u3002 1 2 3 4 5 6 7 8 Duplex . prototype . _destroy = function ( err , cb ) { // \u5173\u95ed\u8bfb\u7aef this . push ( null ); // \u5173\u95ed\u5199\u7aef this . end (); // \u6267\u884c\u56de\u8c03 process . nextTick ( cb , err ); }; \u53cc\u5411\u6d41\u8fd8\u6709\u4e00\u4e2a\u7279\u6027\u662f\u662f\u5426\u5141\u8bb8\u534a\u5f00\u5173\uff0c\u5373\u53ef\u8bfb\u6216\u53ef\u5199\u3002onend\u662f\u8bfb\u7aef\u5173\u95ed\u65f6\u6267\u884c\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u770b\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 // \u5173\u95ed\u5199\u6d41 function onend () { // \u5141\u8bb8\u534a\u5f00\u5173\u6216\u5199\u6d41\u5df2\u7ecf\u7ed3\u675f\u5219\u8fd4\u56de if ( this . allowHalfOpen || this . _writableState . ended ) return ; // \u4e0b\u4e00\u4e2atick\u518d\u5173\u95ed\u5199\u6d41\uff0c\u6267\u884c\u5b8c\u8fd9\u6bb5\u4ee3\u7801\uff0c\u7528\u6237\u8fd8\u53ef\u4ee5\u5199 process . nextTick ( onEndNT , this ); } function onEndNT ( self ) { // \u8c03\u7528\u5199\u7aef\u7684end\u51fd\u6570 self . end (); } \u5f53\u53cc\u5411\u6d41\u5141\u8bb8\u534a\u5f00\u5173\u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u8bfb\u6d41\u5173\u95ed\u65f6\uff0c\u53ef\u5199\u6d41\u53ef\u4ee5\u4e0d\u5173\u95ed\u3002","title":"20-JS Stream"},{"location":"chapter21-JS%20Stream/#211","text":"1 2 3 4 5 6 7 8 const EE = require ( 'events' ); const util = require ( 'util' ); // \u6d41\u7684\u57fa\u7c7b function Stream () { EE . call ( this ); } // \u7ee7\u627f\u4e8b\u4ef6\u8ba2\u9605\u5206\u53d1\u7684\u80fd\u529b util . inherits ( Stream , EE ); \u6d41\u7684\u57fa\u7c7b\u53ea\u63d0\u4f9b\u4e86\u4e00\u4e2a\u51fd\u6570\u5c31\u662fpipe\u3002\u7528\u4e8e\u5b9e\u73b0\u7ba1\u9053\u5316\u3002\u7ba1\u9053\u5316\u662f\u5bf9\u6570\u636e\u4ece\u4e00\u4e2a\u5730\u65b9\u6d41\u5411\u53e6\u4e00\u4e2a\u5730\u65b9\u7684\u62bd\u8c61\u3002\u8fd9\u4e2a\u65b9\u6cd5\u4ee3\u7801\u6bd4\u8f83\u591a\uff0c\u5206\u5f00\u8bf4\u3002","title":"21.1 \u6d41\u57fa\u7c7b\u548c\u6d41\u901a\u7528\u903b\u8f91"},{"location":"chapter21-JS%20Stream/#2111","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // \u6570\u636e\u6e90\u5bf9\u8c61 var source = this ; // \u76d1\u542cdata\u4e8b\u4ef6\uff0c\u53ef\u8bfb\u6d41\u6709\u6570\u636e\u7684\u65f6\u5019\uff0c\u4f1a\u89e6\u53d1data\u4e8b\u4ef6 source . on ( 'data' , ondata ); function ondata ( chunk ) { // \u6e90\u6d41\u6709\u6570\u636e\u5230\u8fbe\uff0c\u5e76\u4e14\u76ee\u7684\u6d41\u53ef\u5199 if ( dest . writable ) { /* \u76ee\u7684\u6d41\u8fc7\u8f7d\u5e76\u4e14\u6e90\u6d41\u5b9e\u73b0\u4e86pause\u65b9\u6cd5\uff0c \u90a3\u5c31\u6682\u505c\u53ef\u8bfb\u6d41\u7684\u8bfb\u53d6\u64cd\u4f5c\uff0c\u7b49\u5f85\u76ee\u7684\u6d41\u89e6\u53d1drain\u4e8b\u4ef6 */ if ( false === dest . write ( chunk ) && source . pause ) { source . pause (); } } } // \u76d1\u542cdrain\u4e8b\u4ef6\uff0c\u76ee\u7684\u6d41\u53ef\u4ee5\u6d88\u8d39\u6570\u636e\u4e86\u5c31\u4f1a\u89e6\u53d1\u8be5\u4e8b\u4ef6 dest . on ( 'drain' , ondrain ); function ondrain () { // \u76ee\u7684\u6d41\u53ef\u7ee7\u7eed\u5199\u4e86\uff0c\u5e76\u4e14\u53ef\u8bfb\u6d41\u53ef\u8bfb\uff0c\u5207\u6362\u6210\u81ea\u52a8\u8bfb\u53d6\u6a21\u5f0f if ( source . readable && source . resume ) { source . resume (); } } \u8fd9\u662f\u7ba1\u9053\u5316\u65f6\u6d41\u63a7\u5b9e\u73b0\u7684\u5730\u65b9\uff0c\u4e3b\u8981\u662f\u5229\u7528\u4e86write\u8fd4\u56de\u503c\u548cdrain\u4e8b\u4ef6\u3002","title":"21.1.1\u5904\u7406\u6570\u636e\u4e8b\u4ef6"},{"location":"chapter21-JS%20Stream/#2112","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /* 1 dest._isStdio\u662ftrue\u8868\u793a\u76ee\u7684\u6d41\u662f\u6807\u51c6\u8f93\u51fa\u6216\u6807\u51c6\u9519\u8bef\uff08\u89c1 process/stdio.js\uff09\uff0c 2 \u914d\u7f6e\u7684end\u5b57\u6bb5\u4ee3\u8868\u53ef\u8bfb\u6d41\u89e6\u53d1end\u6216close\u4e8b\u4ef6\u65f6\uff0c\u662f\u5426\u81ea\u52a8\u5173\u95ed\u53ef\u5199 \u6d41\uff0c\u9ed8\u8ba4\u662f\u81ea\u52a8\u5173\u95ed\u3002\u5982\u679c\u914d\u7f6e\u4e86end\u662ffalse\uff0c\u5219\u53ef\u8bfb\u6d41\u8fd9\u4e24\u4e2a\u4e8b\u4ef6\u89e6\u53d1 \u65f6\uff0c\u6211\u4eec\u9700\u8981\u81ea\u5df1\u5173\u95ed\u53ef\u5199\u6d41\u3002 3 \u6211\u4eec\u770b\u5230\u53ef\u8bfb\u6d41\u7684error\u4e8b\u4ef6\u89e6\u53d1\u65f6\uff0c\u53ef\u5199\u6d41\u662f\u4e0d\u4f1a\u88ab\u81ea\u52a8\u5173\u95ed\u7684\uff0c\u9700\u8981\u6211 \u4eec\u81ea\u5df1\u76d1\u542c\u53ef\u8bfb\u6d41\u7684error\u4e8b\u4ef6\uff0c\u7136\u540e\u624b\u52a8\u5173\u95ed\u53ef\u5199\u6d41\u3002\u6240\u4ee5if\u7684\u5224\u65ad\u610f\u601d \u662f\u4e0d\u662f\u6807\u51c6\u8f93\u51fa\u6216\u6807\u51c6\u9519\u8bef\u6d41\uff0c\u5e76\u4e14\u6ca1\u6709\u914d\u7f6eend\u662ffalse\u7684\u65f6\u5019\uff0c\u4f1a\u81ea\u52a8 \u5173\u95ed\u53ef\u5199\u6d41\u3002\u800c\u6807\u51c6\u8f93\u51fa\u548c\u6807\u51c6\u9519\u8bef\u6d41\u662f\u5728\u8fdb\u7a0b\u9000\u51fa\u7684\u65f6\u5019\u624d\u88ab\u5173\u95ed\u7684\u3002 */ if ( ! dest . _isStdio && ( ! options || options . end !== false )) { // \u6e90\u6d41\u6ca1\u6709\u6570\u636e\u53ef\u8bfb\u4e86\uff0c\u6267\u884cend\u56de\u8c03 source . on ( 'end' , onend ); // \u6e90\u6d41\u5173\u95ed\u4e86\uff0c\u6267\u884cclose\u56de\u8c03 source . on ( 'close' , onclose ); } var didOnEnd = false ; function onend () { if ( didOnEnd ) return ; didOnEnd = true ; // \u6267\u884c\u76ee\u7684\u6d41\u7684end\uff0c\u8bf4\u660e\u5199\u6570\u636e\u5b8c\u6bd5 dest . end (); } function onclose () { if ( didOnEnd ) return ; didOnEnd = true ; // \u9500\u6bc1\u76ee\u7684\u6d41 if ( typeof dest . destroy === 'function' ) dest . destroy (); } \u4e0a\u9762\u662f\u53ef\u8bfb\u6e90\u6d41\u7ed3\u675f\u6216\u5173\u95ed\u540e\uff0c\u5982\u4f55\u5904\u7406\u53ef\u5199\u6d41\u7684\u903b\u8f91\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u53ea\u9700\u8981\u76d1\u542c\u53ef\u8bfb\u6d41\u7684error\u4e8b\u4ef6\uff0c\u7136\u540e\u6267\u884c\u53ef\u5199\u6d41\u7684\u5173\u95ed\u64cd\u4f5c\u3002","title":"21.1.2\u6d41\u5173\u95ed/\u7ed3\u675f\u5904\u7406"},{"location":"chapter21-JS%20Stream/#2113","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // \u53ef\u8bfb\u6d41\u6216\u8005\u53ef\u5199\u6d41\u51fa\u9519\u7684\u65f6\u5019\u90fd\u9700\u8981\u505c\u6b62\u6570\u636e\u7684\u5904\u7406 source . on ( 'error' , onerror ); dest . on ( 'error' , onerror ); // \u53ef\u8bfb\u6d41\u6216\u8005\u53ef\u5199\u6d41\u89e6\u53d1error\u4e8b\u4ef6\u65f6\u7684\u5904\u7406\u903b\u8f91 function onerror ( er ) { // \u51fa\u9519\u4e86\uff0c\u6e05\u9664\u6ce8\u518c\u7684\u4e8b\u4ef6\uff0c\u5305\u62ec\u6b63\u5728\u6267\u884c\u7684onerror\u51fd\u6570 cleanup (); /* \u5982\u679c\u7528\u6237\u6ca1\u6709\u76d1\u542c\u6d41\u7684error\u4e8b\u4ef6\uff0c\u5219\u629b\u51fa\u9519\u8bef\uff0c \u6240\u4ee5\u6211\u4eec\u4e1a\u52a1\u4ee3\u7801\u9700\u8981\u76d1\u542cerror\u4e8b\u4ef6 */ if ( EE . listenerCount ( this , 'error' ) === 0 ) { throw er ; // Unhandled stream error in pipe. } } \u5728error\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\u4e2d\uff0c\u901a\u8fc7cleanup\u51fd\u6570\u6e05\u9664\u4e86Node.js\u672c\u8eab\u6ce8\u518c\u7684error\u4e8b\u4ef6\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\u5982\u679c\u7528\u6237\u6ca1\u6709\u6ce8\u518cerror\u4e8b\u4ef6\uff0c\u5219error\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\u4e2a\u6570\u4e3a0,\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u6ce8\u518cerror\u4e8b\u4ef6\u3002\u4e0b\u9762\u6211\u4eec\u518d\u5206\u6790cleanup\u51fd\u6570\u7684\u903b\u8f91\u3002","title":"21.1.3 \u9519\u8bef\u5904\u7406"},{"location":"chapter21-JS%20Stream/#2114","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // \u4fdd\u8bc1\u6e90\u6d41\u5173\u95ed\u3001\u6570\u636e\u8bfb\u5b8c\u3001\u76ee\u7684\u6d41\u5173\u95ed\u65f6\u6e05\u9664\u6ce8\u518c\u7684\u4e8b\u4ef6 source . on ( 'end' , cleanup ); source . on ( 'close' , cleanup ); dest . on ( 'close' , cleanup ); // \u6e05\u9664\u6240\u6709\u53ef\u80fd\u4f1a\u7ed1\u5b9a\u7684\u4e8b\u4ef6\uff0c\u5982\u679c\u6ca1\u6709\u7ed1\u5b9a\uff0c\u6267\u884c\u6e05\u9664\u4e5f\u662f\u65e0\u5bb3\u7684 function cleanup () { source . removeListener ( 'data' , ondata ); dest . removeListener ( 'drain' , ondrain ); source . removeListener ( 'end' , onend ); source . removeListener ( 'close' , onclose ); source . removeListener ( 'error' , onerror ); dest . removeListener ( 'error' , onerror ); source . removeListener ( 'end' , cleanup ); source . removeListener ( 'close' , cleanup ); dest . removeListener ( 'close' , cleanup ); } // \u89e6\u53d1\u76ee\u7684\u6d41\u7684pipe\u4e8b\u4ef6 dest . emit ( 'pipe' , source ); // \u652f\u6301\u8fde\u7eed\u7684\u7ba1\u9053\u5316A.pipe(B).pipe(C) return dest ;","title":"21.1.4 \u6e05\u9664\u6ce8\u518c\u7684\u4e8b\u4ef6"},{"location":"chapter21-JS%20Stream/#2115","text":"\u901a\u8fc7 getHighWaterMark\uff08lib\\internal\\streams\\state.js\uff09 \u51fd\u6570\u53ef\u4ee5\u8ba1\u7b97\u51fa\u6d41\u7684\u9608\u503c\uff0c\u9608\u503c\u7528\u4e8e\u63a7\u5236\u7528\u6237\u8bfb\u5199\u6570\u636e\u7684\u901f\u5ea6\u3002\u6211\u4eec\u770b\u770b\u8fd9\u4e2a\u51fd\u6570\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 function getHighWaterMark ( state , options , duplexKey , isDuplex ) { // \u7528\u6237\u5b9a\u4e49\u7684\u9608\u503c let hwm = options . highWaterMark ; // \u7528\u6237\u5b9a\u4e49\u4e86\uff0c\u5219\u6821\u9a8c\u662f\u5426\u5408\u6cd5 if ( hwm != null ) { if ( typeof hwm !== 'number' || ! ( hwm >= 0 )) throw new errors . TypeError ( 'ERR_INVALID_OPT_VALUE' , 'highWaterMark' , hwm ); return Math . floor ( hwm ); } else if ( isDuplex ) { // \u7528\u6237\u6ca1\u6709\u5b9a\u4e49\u516c\u5171\u7684\u9608\u503c\uff0c\u5373\u8bfb\u5199\u6d41\u516c\u7528\u7684\u9608\u503c // \u7528\u6237\u662f\u5426\u5b9a\u4e49\u4e86\u6d41\u5355\u72ec\u7684\u9608\u503c\uff0c\u6bd4\u5982\u8bfb\u6d41\u7684\u9608\u503c\u6216\u8005\u5199\u6d41\u7684\u9608\u503c hwm = options [ duplexKey ]; // \u7528\u6237\u6709\u5b9a\u4e49 if ( hwm != null ) { if ( typeof hwm !== 'number' || ! ( hwm >= 0 )) throw new errors . TypeError ( 'ERR_INVALID_OPT_VALUE' , duplexKey , hwm ); return Math . floor ( hwm ); } } // \u9ed8\u8ba4\u503c\uff0c\u5bf9\u8c61\u662f16\u4e2a\uff0cbuffer\u662f16KB return state . objectMode ? 16 : 16 * 1024 ; } getHighWaterMark\u51fd\u6570\u903b\u8f91\u5982\u4e0b 1 \u7528\u6237\u5b9a\u4e49\u4e86\u5408\u6cd5\u7684\u9608\u503c\uff0c\u5219\u53d6\u7528\u6237\u5b9a\u4e49\u7684\uff08\u53ef\u8bfb\u6d41\u3001\u53ef\u5199\u6d41\u3001\u53cc\u5411\u6d41\uff09\u3002 2 \u5982\u679c\u662f\u53cc\u5411\u6d41\uff0c\u5e76\u4e14\u7528\u6237\u6ca1\u6709\u53ef\u8bfb\u6d41\u53ef\u5199\u6d41\u5171\u4eab\u7684\u5b9a\u4e49\u9608\u503c\uff0c\u6839\u636e\u5f53\u524d\u662f\u53ef\u8bfb\u6d41\u8fd8\u662f\u53ef\u5199\u6d41\uff0c\u5224\u65ad\u7528\u6237\u662f\u5426\u8bbe\u7f6e\u5bf9\u5e94\u6d41\u7684\u9608\u503c\u3002\u6709\u5219\u53d6\u7528\u6237\u8bbe\u7f6e\u7684\u503c\u4f5c\u4e3a\u9608\u503c\u3002 3 \u5982\u679c\u4e0d\u6ee1\u8db31,2\uff0c\u5219\u8fd4\u56de\u9ed8\u8ba4\u503c\u3002","title":"21.1.5 \u6d41\u7684\u9608\u503c"},{"location":"chapter21-JS%20Stream/#2116","text":"\u901a\u8fc7\u8c03\u7528destroy\u51fd\u6570\u53ef\u4ee5\u9500\u6bc1\u4e00\u4e2a\u6d41\uff0c\u5305\u62ec\u53ef\u8bfb\u6d41\u548c\u53ef\u5199\u6d41\u3002\u5e76\u4e14\u53ef\u4ee5\u5b9e\u73b0_ destroy\u51fd\u6570\u81ea\u5b9a\u4e49\u9500\u6bc1\u7684\u884c\u4e3a\u3002\u6211\u4eec\u770b\u770b\u53ef\u5199\u6d41\u7684destroy\u51fd\u6570\u5b9a\u4e49\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 function destroy ( err , cb ) { // \u8bfb\u6d41\u3001\u5199\u6d41\u3001\u53cc\u5411\u6d41 const readableDestroyed = this . _readableState && this . _readableState . destroyed ; const writableDestroyed = this . _writableState && this . _writableState . destroyed ; // \u6d41\u662f\u5426\u5df2\u7ecf\u9500\u6bc1\uff0c\u662f\u5219\u76f4\u63a5\u6267\u884c\u56de\u8c03 if ( readableDestroyed || writableDestroyed ) { // \u4f20\u4e86cb\uff0c\u5219\u6267\u884c\uff0c\u53ef\u9009\u5730\u4f20\u5165err\uff0c\u7528\u6237\u5b9a\u4e49\u7684err if ( cb ) { cb ( err ); } else if ( err && ( ! this . _writableState || ! this . _writableState . errorEmitted )) { /* \u4f20\u4e86err\uff0c\u662f\u8bfb\u6d41\u6216\u8005\u6ca1\u6709\u89e6\u53d1\u8fc7error\u4e8b\u4ef6\u7684\u5199\u6d41\uff0c \u5219\u89e6\u53d1error\u4e8b\u4ef6 */ process . nextTick ( emitErrorNT , this , err ); } return this ; } // \u8fd8\u6ca1\u6709\u9500\u6bc1\u5219\u5f00\u59cb\u9500\u6bc1\u6d41\u7a0b if ( this . _readableState ) { this . _readableState . destroyed = true ; } if ( this . _writableState ) { this . _writableState . destroyed = true ; } // \u7528\u6237\u53ef\u4ee5\u81ea\u5b9a\u4e49_destroy\u51fd\u6570 this . _destroy ( err || null , ( err ) => { // \u6ca1\u6709cb\u4f46\u662f\u6709error\uff0c\u5219\u89e6\u53d1error\u4e8b\u4ef6 if ( ! cb && err ) { process . nextTick ( emitErrorNT , this , err ); // \u53ef\u5199\u6d41\u5219\u6807\u8bb0\u5df2\u7ecf\u89e6\u53d1\u8fc7error\u4e8b\u4ef6 if ( this . _writableState ) { this . _writableState . errorEmitted = true ; } } else if ( cb ) { // \u6709cb\u6216\u8005\u6ca1\u6709err cb ( err ); } }); return this ; } destroy\u51fd\u6570\u9500\u6bc1\u6d41\u7684\u901a\u7528\u903b\u8f91\u3002\u5176\u4e2d_destroy\u51fd\u6570\u4e0d\u540c\u7684\u6d41\u4e0d\u4e00\u6837\uff0c\u4e0b\u9762\u5206\u522b\u662f\u53ef\u8bfb\u6d41\u548c\u53ef\u5199\u6d41\u7684\u5b9e\u73b0\u3002 1 \u53ef\u8bfb\u6d41 1 2 3 4 Readable . prototype . _destroy = function ( err , cb ) { this . push ( null ); cb ( err ); }; 2 \u53ef\u5199\u6d41 1 2 3 4 Writable . prototype . _destroy = function ( err , cb ) { this . end (); cb ( err ); };","title":"21.1.6 \u9500\u6bc1\u6d41"},{"location":"chapter21-JS%20Stream/#212","text":"Node.js\u4e2d\u53ef\u8bfb\u6d41\u6709\u4e24\u79cd\u5de5\u4f5c\u6a21\u5f0f\uff1a\u6d41\u5f0f\u548c\u6682\u505c\u5f0f\uff0c\u6d41\u5f0f\u5c31\u662f\u6709\u6570\u636e\u7684\u65f6\u5019\u5c31\u4f1a\u89e6\u53d1\u56de\u8c03\uff0c\u5e76\u4e14\u628a\u6570\u636e\u4f20\u7ed9\u56de\u8c03\uff0c\u6682\u505c\u5f0f\u5c31\u662f\u9700\u8981\u7528\u6237\u81ea\u5df1\u624b\u52a8\u6267\u884c\u8bfb\u53d6\u7684\u64cd\u4f5c\u3002\u6211\u4eec\u901a\u8fc7\u6e90\u7801\u53bb\u4e86\u89e3\u4e00\u4e0b\u53ef\u8bfb\u6d41\u5b9e\u73b0\u7684\u4e00\u4e9b\u903b\u8f91\u3002\u56e0\u4e3a\u5b9e\u73b0\u7684\u4ee3\u7801\u6bd4\u8f83\u591a\uff0c\u903b\u8f91\u4e5f\u6bd4\u8f83\u7ed5\uff0c\u672c\u6587\u53ea\u5206\u6790\u4e00\u4e9b\u4e3b\u8981\u7684\u903b\u8f91\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bReadableState\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u662f\u8868\u793a\u53ef\u8bfb\u6d41\u7684\u4e00\u4e9b\u72b6\u6001\u548c\u5c5e\u6027\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 function ReadableState ( options , stream ) { options = options || {}; // \u662f\u5426\u662f\u53cc\u5411\u6d41 var isDuplex = stream instanceof Stream . Duplex ; // \u6570\u636e\u6a21\u5f0f this . objectMode = !! options . objectMode ; // \u53cc\u5411\u6d41\u7684\u65f6\u5019\uff0c\u8bbe\u7f6e\u8bfb\u7aef\u7684\u6a21\u5f0f if ( isDuplex ) this . objectMode = this . objectMode || !! options . readableObjectMode ; // \u8bfb\u5230highWaterMark\u4e2a\u5b57\u8282\u5219\u505c\u6b62\uff0c\u5bf9\u8c61\u6a21\u5f0f\u7684\u8bdd\u5219\u662f16\u4e2a\u5bf9\u8c61 this . highWaterMark = getHighWaterMark ( this , options , 'readableHighWaterMark' , isDuplex ); // \u5b58\u50a8\u6570\u636e\u7684\u7f13\u51b2\u533a this . buffer = new BufferList (); // \u53ef\u8bfb\u6570\u636e\u7684\u957f\u5ea6 this . length = 0 ; // \u7ba1\u9053\u7684\u76ee\u7684\u6e90\u548c\u4e2a\u6570 this . pipes = null ; this . pipesCount = 0 ; // \u5de5\u4f5c\u6a21\u5f0f this . flowing = null ; // \u6d41\u662f\u5426\u5df2\u7ecf\u7ed3\u675f this . ended = false ; // \u662f\u5426\u89e6\u53d1\u8fc7end\u4e8b\u4ef6\u4e86 this . endEmitted = false ; // \u662f\u5426\u6b63\u5728\u8bfb\u53d6\u6570\u636e this . reading = false ; // \u662f\u5426\u540c\u6b65\u6267\u884c\u4e8b\u4ef6 this . sync = true ; // \u662f\u5426\u9700\u8981\u89e6\u53d1readable\u4e8b\u4ef6 this . needReadable = false ; // \u662f\u5426\u89e6\u53d1\u4e86readable\u4e8b\u4ef6 this . emittedReadable = false ; // \u662f\u5426\u76d1\u542c\u4e86readable\u4e8b\u4ef6 this . readableListening = false ; // \u662f\u5426\u6b63\u5728\u6267\u884cresume\u7684\u8fc7\u7a0b this . resumeScheduled = false ; // \u6d41\u662f\u5426\u5df2\u9500\u6bc1 this . destroyed = false ; // \u6570\u636e\u7f16\u7801\u683c\u5f0f this . defaultEncoding = options . defaultEncoding || 'utf8' ; /* \u5728\u7ba1\u9053\u5316\u4e2d\uff0c\u6709\u591a\u5c11\u4e2a\u5199\u8005\u5df2\u7ecf\u8fbe\u5230\u9608\u503c\uff0c \u9700\u8981\u7b49\u5f85\u89e6\u53d1drain\u4e8b\u4ef6,awaitDrain\u8bb0\u5f55\u8fbe\u5230\u9608\u503c\u7684\u5199\u8005\u4e2a\u6570 */ this . awaitDrain = 0 ; // \u6267\u884cmaybeReadMore\u51fd\u6570\u7684\u65f6\u5019\uff0c\u8bbe\u7f6e\u4e3atrue this . readingMore = false ; this . decoder = null ; this . encoding = null ; // \u7f16\u7801\u89e3\u7801\u5668 if ( options . encoding ) { if ( ! StringDecoder ) StringDecoder = require ( 'string_decoder' ). StringDecoder ; this . decoder = new StringDecoder ( options . encoding ); this . encoding = options . encoding ; } } ReadableState\u91cc\u5305\u542b\u4e86\u4e00\u5927\u5806\u5b57\u6bb5\uff0c\u6211\u4eec\u53ef\u4ee5\u5148\u4e0d\u7ba1\u5b83\uff0c\u7b49\u5f85\u7528\u5230\u7684\u65f6\u5019\uff0c\u518d\u56de\u5934\u770b\u3002\u63a5\u7740\u6211\u4eec\u5f00\u59cb\u770b\u53ef\u8bfb\u6d41\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function Readable ( options ) { if ( ! ( this instanceof Readable )) return new Readable ( options ); this . _readableState = new ReadableState ( options , this ); // \u53ef\u8bfb this . readable = true ; // \u7528\u6237\u5b9e\u73b0\u7684\u4e24\u4e2a\u51fd\u6570 if ( options ) { if ( typeof options . read === 'function' ) this . _read = options . read ; if ( typeof options . destroy === 'function' ) this . _destroy = options . destroy ; } // \u521d\u59cb\u5316\u7236\u7c7b Stream . call ( this ); } \u4e0a\u9762\u7684\u903b\u8f91\u4e0d\u591a\uff0c\u9700\u8981\u5173\u6ce8\u7684\u662fread\u548cdestroy\u8fd9\u4e24\u4e2a\u51fd\u6570\uff0c\u5982\u679c\u6211\u4eec\u662f\u76f4\u63a5\u4f7f\u7528Readable\u4f7f\u7528\u53ef\u8bfb\u6d41\uff0c\u90a3\u5728options\u91cc\u662f\u5fc5\u987b\u4f20read\u51fd\u6570\u7684\uff0cdestroy\u662f\u53ef\u9009\u7684\u3002\u5982\u679c\u6211\u4eec\u662f\u4ee5\u7ee7\u627f\u7684\u65b9\u5f0f\u4f7f\u7528Readable\uff0c\u90a3\u5fc5\u987b\u5b9e\u73b0_read\u51fd\u6570\u3002Node.js\u53ea\u662f\u62bd\u8c61\u4e86\u6d41\u7684\u903b\u8f91\uff0c\u5177\u4f53\u7684\u64cd\u4f5c\uff08\u6bd4\u5982\u53ef\u8bfb\u6d41\u5c31\u662f\u8bfb\u53d6\u6570\u636e\uff09\u662f\u7531\u7528\u6237\u81ea\u5df1\u5b9e\u73b0\u7684\uff0c\u56e0\u4e3a\u8bfb\u53d6\u64cd\u4f5c\u662f\u4e1a\u52a1\u76f8\u5173\u7684\u3002\u4e0b\u9762\u6211\u4eec\u5206\u6790\u4e00\u4e0b\u53ef\u8bfb\u6d41\u7684\u64cd\u4f5c\u3002","title":"21.2 \u53ef\u8bfb\u6d41"},{"location":"chapter21-JS%20Stream/#2121","text":"\u5bf9\u7528\u6237\u6765\u8bf4\uff0c\u53ef\u8bfb\u6d41\u662f\u7528\u6237\u83b7\u53d6\u6570\u636e\u7684\u5730\u65b9\uff0c\u4f46\u662f\u5bf9\u53ef\u8bfb\u6d41\u6765\u8bf4\uff0c\u5b83\u63d0\u4f9b\u6570\u636e\u7ed9\u7528\u6237\u7684\u524d\u63d0\u662f\u5b83\u81ea\u5df1\u6709\u6570\u636e\uff0c\u6240\u4ee5\u53ef\u8bfb\u6d41\u9996\u5148\u9700\u8981\u751f\u4ea7\u6570\u636e\u3002\u751f\u4ea7\u6570\u636e\u7684\u903b\u8f91\u7531_read\u51fd\u6570\u5b9e\u73b0\u3002_read\u51fd\u6570\u7684\u903b\u8f91\u5927\u6982\u662f 1 2 const data = getSomeData (); readableStream . push ( data ); \u901a\u8fc7push\u51fd\u6570\uff0c\u5f80\u53ef\u8bfb\u6d41\u91cc\u5199\u5165\u6570\u636e\uff0c\u7136\u540e\u5c31\u53ef\u4ee5\u4e3a\u7528\u6237\u63d0\u4f9b\u6570\u636e\uff0c\u6211\u4eec\u770b\u770bpush\u7684\u5b9e\u73b0\uff0c\u53ea\u5217\u51fa\u4e3b\u8981\u903b\u8f91\u3002 Read 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 able . prototype . push = function ( chunk , encoding ) { // \u7701\u7565\u4e86\u7f16\u7801\u5904\u7406\u7684\u4ee3\u7801 return readableAddChunk ( this , chunk , encoding , false , skipChunkCheck ); }; function readableAddChunk ( stream , chunk , encoding , addToFront , skipChunkCheck ) { var state = stream . _readableState ; // push null\u4ee3\u8868\u6d41\u7ed3\u675f if ( chunk === null ) { state . reading = false ; onEofChunk ( stream , state ); } else { addChunk ( stream , state , chunk , false ); } // \u8fd4\u56de\u662f\u5426\u8fd8\u53ef\u4ee5\u8bfb\u53d6\u66f4\u591a\u6570\u636e return needMoreData ( state ); } function addChunk ( stream , state , chunk , addToFront ) { // \u662f\u6d41\u6a21\u5f0f\u5e76\u4e14\u6ca1\u6709\u7f13\u5b58\u7684\u6570\u636e\uff0c\u5219\u76f4\u63a5\u89e6\u53d1data\u4e8b\u4ef6 if ( state . flowing && state . length === 0 && ! state . sync ) { stream . emit ( 'data' , chunk ); } else { // \u5426\u5219\u5148\u628a\u6570\u636e\u7f13\u5b58\u8d77\u6765 state . length += state . objectMode ? 1 : chunk . length ; if ( addToFront ) state . buffer . unshift ( chunk ); else state . buffer . push ( chunk ); // \u76d1\u542c\u4e86readable\u4e8b\u4ef6\u5219\u89e6\u53d1readable\u4e8b\u4ef6\uff0c\u901a\u8fc7read\u4e3b\u52a8\u8bfb\u53d6 if ( state . needReadable ) emitReadable ( stream ); } // \u7ee7\u7eed\u8bfb\u53d6\u6570\u636e\uff0c\u5982\u679c\u53ef\u4ee5\u7684\u8bdd maybeReadMore ( stream , state ); } \u603b\u7684\u6765\u8bf4\uff0c\u53ef\u8bfb\u6d41\u9996\u5148\u8981\u4ece\u67d0\u4e2a\u5730\u65b9\u83b7\u53d6\u6570\u636e\uff0c\u6839\u636e\u5f53\u524d\u7684\u5de5\u4f5c\u6a21\u5f0f\uff0c\u76f4\u63a5\u4ea4\u4ed8\u7ed9\u7528\u6237\uff0c\u6216\u8005\u5148\u7f13\u5b58\u8d77\u6765\u3002\u53ef\u4ee5\u7684\u60c5\u51b5\u4e0b\uff0c\u7ee7\u7eed\u83b7\u53d6\u6570\u636e\u3002","title":"21.2.1 \u53ef\u8bfb\u6d41\u4ece\u5e95\u5c42\u8d44\u6e90\u83b7\u53d6\u6570\u636e"},{"location":"chapter21-JS%20Stream/#2122","text":"\u7528\u6237\u53ef\u4ee5\u901a\u8fc7read\u51fd\u6570\u6216\u8005\u76d1\u542cdata\u4e8b\u4ef6\u6765\u4ece\u53ef\u8bfb\u6d41\u4e2d\u83b7\u53d6\u6570\u636e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Readable . prototype . read = function ( n ) { n = parseInt ( n , 10 ); var state = this . _readableState ; // \u8ba1\u7b97\u53ef\u8bfb\u7684\u5927\u5c0f n = howMuchToRead ( n , state ); var ret ; // \u9700\u8981\u8bfb\u53d6\u7684\u5927\u4e8e0\uff0c\u5219\u53d6\u8bfb\u53d6\u6570\u636e\u5230ret\u8fd4\u56de if ( n > 0 ) ret = fromList ( n , state ); else ret = null ; // \u51cf\u53bb\u521a\u8bfb\u53d6\u7684\u957f\u5ea6 state . length -= n ; /* \u5982\u679c\u7f13\u5b58\u91cc\u6ca1\u6709\u6570\u636e\u6216\u8005\u8bfb\u5b8c\u540e\u5c0f\u4e8e\u9608\u503c\u4e86\uff0c \u5219\u53ef\u8bfb\u6d41\u53ef\u4ee5\u7ee7\u7eed\u4ece\u5e95\u5c42\u8d44\u6e90\u91cc\u83b7\u53d6\u6570\u636e */ if ( state . length === 0 || state . length - n < state . highWaterMark ) { this . _read ( state . highWaterMark ); } // \u89e6\u53d1data\u4e8b\u4ef6 if ( ret !== null ) this . emit ( 'data' , ret ); return ret ; }; \u8bfb\u53d6\u6570\u636e\u7684\u64cd\u4f5c\u5c31\u662f\u8ba1\u7b97\u7f13\u5b58\u91cc\u6709\u591a\u5c11\u6570\u636e\u53ef\u4ee5\u8bfb\uff0c\u548c\u7528\u6237\u9700\u8981\u7684\u6570\u636e\u5927\u5c0f\uff0c\u53d6\u5c0f\u7684\uff0c\u7136\u540e\u8fd4\u56de\u7ed9\u7528\u6237\uff0c\u5e76\u89e6\u53d1data\u4e8b\u4ef6\u3002\u5982\u679c\u6570\u636e\u8fd8\u6ca1\u6709\u8fbe\u5230\u9608\u503c\uff0c\u5219\u89e6\u53d1\u53ef\u8bfb\u6d41\u4ece\u5e95\u5c42\u8d44\u6e90\u4e2d\u83b7\u53d6\u6570\u636e\u3002\u4ece\u800c\u6e90\u6e90\u4e0d\u65ad\u5730\u751f\u6210\u6570\u636e\u3002","title":"21.2.2 \u7528\u6237\u4ece\u53ef\u8bfb\u6d41\u83b7\u53d6\u6570\u636e"},{"location":"chapter21-JS%20Stream/#213","text":"\u53ef\u5199\u6d41\u662f\u5bf9\u6570\u636e\u6d41\u5411\u7684\u62bd\u8c61\uff0c\u7528\u6237\u8c03\u7528\u53ef\u5199\u6d41\u7684\u63a5\u53e3\uff0c\u53ef\u5199\u6d41\u8d1f\u8d23\u63a7\u5236\u6570\u636e\u7684\u5199\u5165\u3002\u6d41\u7a0b\u5982\u56fe21-1\u6240\u793a\u3002 \u56fe21-1 \u4e0b\u9762\u662f\u53ef\u5199\u6d41\u7684\u4ee3\u7801\u903b\u8f91\u56fe\u5982\u56fe21-2\u6240\u793a\u3002 \u56fe21-2 \u6211\u4eec\u770b\u4e00\u4e0b\u53ef\u5199\u6d41\u7684\u5b9e\u73b0\u3002","title":"21.3 \u53ef\u5199\u6d41"},{"location":"chapter21-JS%20Stream/#2131-writablestate","text":"WritableState\u662f\u7ba1\u7406\u53ef\u5199\u6d41\u914d\u7f6e\u7684\u7c7b\u3002\u91cc\u9762\u5305\u542b\u4e86\u975e\u5e38\u7684\u5b57\u6bb5\uff0c\u5177\u4f53\u542b\u4e49\u6211\u4eec\u4f1a\u5728\u540e\u7eed\u5206\u6790\u7684\u65f6\u5019\u8bb2\u89e3\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 function WritableState ( options , stream ) { options = options || {}; // \u662f\u4e0d\u662f\u53cc\u5411\u6d41 var isDuplex = stream instanceof Stream . Duplex ; // \u6570\u636e\u6a21\u5f0f this . objectMode = !! options . objectMode ; /* \u53cc\u5411\u6d41\u7684\u6d41\u9ed8\u8ba4\u5171\u4eabobjectMode\u914d\u7f6e\uff0c \u7528\u6237\u53ef\u4ee5\u81ea\u5df1\u914d\u7f6e\u6210\u975e\u5171\u4eab\uff0c\u5373\u8bfb\u6d41\u548c\u5199\u6d41\u7684\u6570\u636e\u6a21\u5f0f\u72ec\u7acb */ if ( isDuplex ) this . objectMode = this . objectMode || !! options . writableObjectMode ; /* \u9608\u503c\uff0c\u8d85\u8fc7\u540e\u8bf4\u660e\u9700\u8981\u6682\u505c\u8c03\u7528write\uff0c0\u4ee3\u8868\u6bcf\u6b21\u8c03\u7528write \u7684\u65f6\u5019\u90fd\u8fd4\u56defalse\uff0c\u7528\u6237\u7b49\u5f85drain\u4e8b\u4ef6\u89e6\u53d1\u540e\u518d\u6267\u884cwrite */ this . highWaterMark = getHighWaterMark ( this , options , 'writableHighWaterMark' , isDuplex ); // \u662f\u5426\u8c03\u7528\u4e86_final\u51fd\u6570 this . finalCalled = false ; // \u662f\u5426\u9700\u8981\u89e6\u53d1drain\u4e8b\u4ef6\uff0c\u91cd\u65b0\u9a71\u52a8\u751f\u4ea7\u8005 this . needDrain = false ; // \u6b63\u5728\u6267\u884cend\u6d41\u7a0b this . ending = false ; // \u662f\u5426\u6267\u884c\u8fc7end\u51fd\u6570 this . ended = false ; // \u662f\u5426\u89e6\u53d1\u4e86finish\u4e8b\u4ef6 this . finished = false ; // \u6d41\u662f\u5426\u88ab\u9500\u6bc1\u4e86 this . destroyed = false ; var noDecode = options . decodeStrings === false ; // \u662f\u5426\u9700\u8981decode\u6d41\u6570\u636e\u540e\u5728\u6267\u884c\u5199\uff08\u8c03\u7528\u7528\u6237\u5b9a\u4e49\u7684_write\uff09 this . decodeStrings = ! noDecode ; // \u7f16\u7801\u7c7b\u578b this . defaultEncoding = options . defaultEncoding || 'utf8' ; // \u5f85\u5199\u5165\u7684\u6570\u636e\u957f\u5ea6\u6216\u5bf9\u8c61\u6570 this . length = 0 ; // \u6b63\u5728\u5f80\u5e95\u5c42\u5199 this . writing = false ; // \u52a0\u585e\uff0c\u7f13\u5b58\u751f\u4ea7\u8005\u7684\u6570\u636e\uff0c\u505c\u6b62\u5f80\u5e95\u5c42\u5199\u5165 this . corked = 0 ; // \u7528\u6237\u5b9a\u4e49\u7684_write\u6216\u8005_writev\u662f\u540c\u6b65\u8fd8\u662f\u5f02\u6b65\u8c03\u7528\u53ef\u5199\u6d41\u7684\u56de\u8c03\u51fd\u6570onwrite this . sync = true ; // \u662f\u5426\u6b63\u5728\u5904\u7406\u7f13\u5b58\u7684\u6570\u636e this . bufferProcessing = false ; // \u7528\u6237\u5b9e\u73b0\u7684\u94a9\u5b50_write\u51fd\u6570\u91cc\u9700\u8981\u6267\u884c\u7684\u56de\u8c03\uff0c\u544a\u8bc9\u5199\u6d41\u5199\u5b8c\u6210\u4e86 this . onwrite = onwrite . bind ( undefined , stream ); // \u5f53\u524d\u5199\u64cd\u4f5c\u5bf9\u5e94\u7684\u56de\u8c03 this . writecb = null ; // \u5f53\u524d\u5199\u64cd\u4f5c\u7684\u6570\u636e\u957f\u5ea6\u6216\u5bf9\u8c61\u6570 this . writelen = 0 ; // \u7f13\u5b58\u7684\u6570\u636e\u94fe\u8868\u5934\u6307\u9488 this . bufferedRequest = null ; // \u6307\u5411\u7f13\u5b58\u7684\u6570\u636e\u94fe\u8868\u6700\u540e\u4e00\u4e2a\u8282\u70b9 this . lastBufferedRequest = null ; // \u5f85\u6267\u884c\u7684\u56de\u8c03\u51fd\u6570\u4e2a\u6570 this . pendingcb = 0 ; // \u662f\u5426\u5df2\u7ecf\u89e6\u53d1\u8fc7prefinished\u4e8b\u4ef6 this . prefinished = false ; // \u662f\u5426\u5df2\u7ecf\u89e6\u53d1\u8fc7error\u4e8b\u4ef6 this . errorEmitted = false ; // count buffered requests // \u7f13\u5b58\u7684buffer\u6570 this . bufferedRequestCount = 0 ; /* \u7a7a\u95f2\u7684\u8282\u70b9\u94fe\u8868\uff0c\u5f53\u628a\u7f13\u5b58\u6570\u636e\u5199\u5165\u5e95\u5c42\u65f6\uff0ccorkReq\u4fdd\u6570\u636e\u7684\u4e0a\u4e0b\u6587\uff08\u5982 \u7528\u6237\u56de\u8c03\uff09\uff0c\u56e0\u4e3a\u8fd9\u65f6\u5019\uff0c\u7f13\u5b58\u94fe\u8868\u5df2\u7ecf\u88ab\u6e05\u7a7a\uff0c this.corkedRequestsFree\u59cb\u7ec8\u7ef4\u62a4\u4e00\u4e2a\u7a7a\u95f2\u8282\u70b9\uff0c\u6700\u591a\u4e24\u4e2a */ var corkReq = { next : null , entry : null , finish : undefined }; corkReq . finish = onCorkedFinish . bind ( undefined , corkReq , this ); this . corkedRequestsFree = corkReq ; }","title":"21.3.1 WritableState"},{"location":"chapter21-JS%20Stream/#2132-writable","text":"Writable\u662f\u53ef\u5199\u6d41\u7684\u5177\u4f53\u5b9e\u73b0\uff0c\u6211\u4eec\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528Writable\u4f5c\u4e3a\u53ef\u5199\u6d41\u6765\u4f7f\u7528\uff0c\u4e5f\u53ef\u4ee5\u7ee7\u627fWritable\u5b9e\u73b0\u81ea\u5df1\u7684\u53ef\u5199\u6d41\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function Writable ( options ) { this . _writableState = new WritableState ( options , this ); // \u53ef\u5199 this . writable = true ; // \u652f\u6301\u7528\u6237\u81ea\u5b9a\u4e49\u7684\u94a9\u5b50 if ( options ) { if ( typeof options . write === 'function' ) this . _write = options . write ; if ( typeof options . writev === 'function' ) this . _writev = options . writev ; if ( typeof options . destroy === 'function' ) this . _destroy = options . destroy ; if ( typeof options . final === 'function' ) this . _final = options . final ; } Stream . call ( this ); } \u53ef\u5199\u6d41\u7ee7\u627f\u4e8e\u6d41\u57fa\u7c7b\uff0c\u63d0\u4f9b\u51e0\u4e2a\u94a9\u5b50\u51fd\u6570\uff0c\u7528\u6237\u53ef\u4ee5\u81ea\u5b9a\u4e49\u94a9\u5b50\u51fd\u6570\u5b9e\u73b0\u81ea\u5df1\u7684\u903b\u8f91\u3002\u5982\u679c\u7528\u6237\u662f\u76f4\u63a5\u4f7f\u7528Writable\u7c7b\u4f5c\u4e3a\u53ef\u5199\u6d41\uff0c\u5219options.write\u51fd\u6570\u662f\u5fc5\u987b\u4f20\u7684\uff0coptions.wirte\u51fd\u6570\u63a7\u5236\u6570\u636e\u5f80\u54ea\u91cc\u5199\uff0c\u5e76\u4e14\u901a\u77e5\u53ef\u5199\u6d41\u662f\u5426\u5199\u5b8c\u6210\u4e86\u3002\u5982\u679c\u7528\u6237\u662f\u4ee5\u7ee7\u627fWritable\u7c7b\u7684\u5f62\u5f0f\u4f7f\u7528\u53ef\u5199\u6d41\uff0c\u5219_write\u51fd\u6570\u662f\u5fc5\u987b\u5b9e\u73b0\u7684\uff0c_write\u51fd\u6570\u548coptions.write\u51fd\u6570\u7684\u4f5c\u7528\u662f\u4e00\u6837\u7684\u3002","title":"21.3.2 Writable"},{"location":"chapter21-JS%20Stream/#2133","text":"\u53ef\u5199\u6d41\u63d0\u4f9bwrite\u51fd\u6570\u7ed9\u7528\u6237\u5b9e\u73b0\u6570\u636e\u7684\u5199\u5165\uff0c\u5199\u5165\u6709\u4e24\u79cd\u65b9\u5f0f\u3002\u4e00\u4e2a\u662f\u9010\u4e2a\u5199\uff0c\u4e00\u4e2a\u662f\u6279\u91cf\u5199\uff0c\u6279\u91cf\u5199\u662f\u53ef\u9009\u7684\uff0c\u53d6\u51b3\u4e8e\u7528\u6237\u7684\u5b9e\u73b0\uff0c\u5982\u679c\u7528\u6237\u76f4\u63a5\u4f7f\u7528Writable\u5219\u9700\u8981\u4f20\u5165writev\uff0c\u5982\u679c\u662f\u7ee7\u627f\u65b9\u5f0f\u4f7f\u7528Writable\u5219\u5b9e\u73b0_writev\u51fd\u6570\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bwrite\u51fd\u6570\u7684\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 Writable . prototype . write = function ( chunk , encoding , cb ) { var state = this . _writableState ; // \u544a\u8bc9\u7528\u6237\u662f\u5426\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u8c03\u7528write var ret = false ; // \u6570\u636e\u683c\u5f0f var isBuf = ! state . objectMode && Stream . _isUint8Array ( chunk ); // \u662f\u5426\u9700\u8981\u8f6c\u6210buffer\u683c\u5f0f if ( isBuf && Object . getPrototypeOf ( chunk ) !== Buffer . prototype ) { chunk = Stream . _uint8ArrayToBuffer ( chunk ); } // \u53c2\u6570\u5904\u7406\uff0c\u4f20\u4e86\u6570\u636e\u548c\u56de\u8c03\uff0c\u6ca1\u6709\u4f20\u7f16\u7801\u7c7b\u578b if ( typeof encoding === 'function' ) { cb = encoding ; encoding = null ; } // \u662fbuffer\u7c7b\u578b\u5219\u8bbe\u7f6e\u6210buffer\uff0c\u5426\u5219\u5982\u679c\u6ca1\u4f20\u5219\u53d6\u9ed8\u8ba4\u7f16\u7801 if ( isBuf ) encoding = 'buffer' ; else if ( ! encoding ) encoding = state . defaultEncoding ; if ( typeof cb !== 'function' ) cb = nop ; // \u6b63\u5728\u6267\u884cend\uff0c\u518d\u6267\u884cwrite\uff0c\u62a5\u9519 if ( state . ending ) writeAfterEnd ( this , cb ); else if ( isBuf || validChunk ( this , state , chunk , cb )) { // \u5f85\u6267\u884c\u7684\u56de\u8c03\u6570\u52a0\u4e00\uff0c\u5373cb state . pendingcb ++ ; // \u5199\u5165\u6216\u7f13\u5b58\uff0c\u89c1\u8be5\u51fd\u6570 ret = writeOrBuffer ( this , state , isBuf , chunk , encoding , cb ); } /// \u8fd8\u80fd\u4e0d\u80fd\u7ee7\u7eed\u5199 return ret ; }; write\u51fd\u6570\u9996\u5148\u505a\u4e86\u4e00\u4e9b\u53c2\u6570\u5904\u7406\u548c\u6570\u636e\u8f6c\u6362\uff0c\u7136\u540e\u5224\u65ad\u6d41\u662f\u5426\u5df2\u7ecf\u7ed3\u675f\u4e86\uff0c\u5982\u679c\u6d41\u7ed3\u675f\u518d\u6267\u884c\u5199\u5165\uff0c\u5219\u4f1a\u62a5\u9519\u3002\u5982\u679c\u6d41\u6ca1\u6709\u7ed3\u675f\u5219\u6267\u884c\u5199\u5165\u6216\u8005\u7f13\u5b58\u5904\u7406\u3002\u6700\u540e\u901a\u77e5\u7528\u6237\u662f\u5426\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u8c03\u7528write\u5199\u5165\u6570\u636e\uff08\u6211\u4eec\u770b\u5230\u5982\u679c\u5199\u5165\u7684\u6570\u636e\u6bd4\u9608\u503c\u5927\uff0c\u53ef\u5199\u6d41\u8fd8\u662f\u4f1a\u6267\u884c\u5199\u5165\u64cd\u4f5c\uff0c\u4f46\u662f\u4f1a\u8fd4\u56defalse\u544a\u8bc9\u7528\u6237\u4e9b\u4e0d\u8981\u5199\u5165\u4e86\uff0c\u5982\u679c\u8c03\u7528\u65b9\u7ee7\u7eed\u5199\u5165\u7684\u8bdd\uff0c\u4e5f\u662f\u6ca1\u4f1a\u7ee7\u7eed\u5199\u5165\u7684\uff0c\u4f46\u662f\u53ef\u80fd\u4f1a\u5bfc\u81f4\u5199\u5165\u7aef\u538b\u529b\u8fc7\u5927\uff09\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bwriteAfterEnd\u7684\u903b\u8f91\u3002\u7136\u540e\u518d\u770bwriteOrBuffer\u3002 1 2 3 4 5 function writeAfterEnd ( stream , cb ) { var er = new errors . Error ( 'ERR_STREAM_WRITE_AFTER_END' ); stream . emit ( 'error' , er ); process . nextTick ( cb , er ); } writeAfterEnd\u51fd\u6570\u7684\u903b\u8f91\u6bd4\u8f83\u7b80\u5355\uff0c\u9996\u5148\u89e6\u53d1\u53ef\u5199\u6d41\u7684error\u4e8b\u4ef6\uff0c\u7136\u540e\u4e0b\u4e00\u4e2atick\u7684\u65f6\u5019\u6267\u884c\u7528\u6237\u5728\u8c03\u7528write\u65f6\u4f20\u5165\u7684\u56de\u8c03\u3002\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0bwriteOrBuffer\u3002writeOrBuffer\u51fd\u6570\u4f1a\u5bf9\u6570\u636e\u8fdb\u884c\u7f13\u5b58\u6216\u8005\u76f4\u63a5\u5199\u5165\u76ee\u7684\u5730\uff08\u76ee\u7684\u5730\u53ef\u4ee5\u662f\u6587\u4ef6\u3001socket\u3001\u5185\u5b58\uff0c\u53d6\u51b3\u4e8e\u7528\u6237\u7684\u5b9e\u73b0\uff09\uff0c\u53d6\u51b3\u4e8e\u5f53\u524d\u53ef\u5199\u6d41\u7684\u72b6\u6001\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 function writeOrBuffer ( stream , state , isBuf , chunk , encoding , cb ) { // \u6570\u636e\u5904\u7406 if ( ! isBuf ) { var newChunk = decodeChunk ( state , chunk , encoding ); if ( chunk !== newChunk ) { isBuf = true ; encoding = 'buffer' ; chunk = newChunk ; } } // \u5bf9\u8c61\u6a21\u5f0f\u7684\u7b97\u4e00\u4e2a var len = state . objectMode ? 1 : chunk . length ; // \u66f4\u65b0\u5f85\u5199\u5165\u6570\u636e\u957f\u5ea6\u6216\u5bf9\u8c61\u4e2a\u6570 state . length += len ; // \u5f85\u5199\u5165\u7684\u957f\u5ea6\u662f\u5426\u8d85\u8fc7\u4e86\u9608\u503c var ret = state . length < state . highWaterMark ; /* \u8d85\u8fc7\u4e86\u9608\u503c\uff0c\u5219\u8bbe\u7f6e\u9700\u8981\u7b49\u5f85drain\u4e8b\u4ef6\u6807\u8bb0\uff0c \u8fd9\u65f6\u5019\u7528\u6237\u4e0d\u5e94\u8be5\u518d\u6267\u884cwrite\uff0c\u800c\u662f\u7b49\u5f85drain\u4e8b\u4ef6\u89e6\u53d1 */ if ( ! ret ) state . needDrain = true ; // \u5982\u679c\u6b63\u5728\u5199\u6216\u8005\u8bbe\u7f6e\u4e86\u963b\u585e\u5219\u5148\u7f13\u5b58\u6570\u636e\uff0c\u5426\u5219\u76f4\u63a5\u5199\u5165 if ( state . writing || state . corked ) { // \u6307\u5411\u5f53\u524d\u7684\u5c3e\u8282\u70b9 var last = state . lastBufferedRequest ; // \u63d2\u5165\u65b0\u7684\u5c3e\u7ed3\u70b9 state . lastBufferedRequest = { chunk , encoding , isBuf , callback : cb , next : null }; /* \u4e4b\u524d\u8fd8\u6709\u8282\u70b9\u7684\u8bdd\uff0c\u65e7\u7684\u5c3e\u8282\u70b9\u7684next\u6307\u9488\u6307\u5411\u65b0\u7684\u5c3e\u8282\u70b9\uff0c \u5f62\u6210\u94fe\u8868 */ if ( last ) { last . next = state . lastBufferedRequest ; } else { /* \u6307\u5411buffer\u94fe\u8868\uff0cbufferedRequest\u76f8\u7b49\u4e8e\u5934\u6307\u9488\uff0c \u63d2\u5165\u7b2c\u4e00\u4e2abuffer\u8282\u70b9\u7684\u65f6\u5019\u6267\u884c\u5230\u8fd9 */ state . bufferedRequest = state . lastBufferedRequest ; } // \u7f13\u5b58\u7684buffer\u4e2a\u6570\u52a0\u4e00 state . bufferedRequestCount += 1 ; } else { // \u76f4\u63a5\u5199\u5165 doWrite ( stream , state , false , len , chunk , encoding , cb ); } // \u8fd4\u56de\u662f\u5426\u8fd8\u53ef\u4ee5\u7ee7\u7eed\u6267\u884cwirte\uff0c\u5982\u679c\u6ca1\u6709\u8fbe\u5230\u9608\u503c\u5219\u53ef\u4ee5\u7ee7\u7eed\u5199 return ret ; } writeOrBuffer\u51fd\u6570\u4e3b\u8981\u7684\u903b\u8f91\u5982\u4e0b 1 \u66f4\u65b0\u5f85\u5199\u5165\u6570\u636e\u7684\u957f\u5ea6\uff0c\u5224\u65ad\u662f\u5426\u8fbe\u5230\u9608\u503c\uff0c\u7136\u540e\u901a\u77e5\u7528\u6237\u662f\u5426\u8fd8\u53ef\u4ee5\u6267\u884cwrite\u7ee7\u7eed\u5199\u5165\u3002 2 \u5224\u65ad\u5f53\u524d\u662f\u5426\u6b63\u5728\u5199\u5165\u6216\u8005\u5904\u4e8ecork\u6a21\u5f0f\u3002\u662f\u7684\u8bdd\u628a\u6570\u636e\u7f13\u5b58\u8d77\u6765\uff0c\u5426\u5219\u6267\u884c\u5199\u64cd\u4f5c\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u7f13\u5b58\u7684\u903b\u8f91\u548c\u5f62\u6210\u7684\u6570\u636e\u7ed3\u6784\u3002 \u7f13\u5b58\u7b2c\u4e00\u4e2a\u8282\u70b9\u65f6\uff0c\u5982\u56fe21-3\u6240\u793a\u3002 \u56fe21-3 \u7f13\u5b58\u7b2c\u4e8c\u4e2a\u8282\u70b9\u65f6\uff0c\u5982\u56fe21-4\u6240\u793a\u3002 \u56fe21-4 \u7f13\u5b58\u7b2c\u4e09\u4e2a\u8282\u70b9\u65f6\uff0c\u5982\u56fe21-5 \u56fe21-5 \u6211\u4eec\u770b\u5230\uff0c\u51fd\u6570\u7684\u6570\u636e\u662f\u4ee5\u94fe\u8868\u7684\u5f62\u5f0f\u7ba1\u7406\u7684\uff0c\u5176\u4e2dbufferedRequest\u662f\u94fe\u8868\u5934\u7ed3\u70b9\uff0clastBufferedRequest\u6307\u5411\u5c3e\u8282\u70b9\u3002\u5047\u8bbe\u5f53\u524d\u53ef\u5199\u6d41\u4e0d\u5904\u4e8e\u5199\u5165\u6216\u8005cork\u72b6\u6001\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5199\u5165\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 function doWrite ( stream , state , writev , len , chunk , encoding , cb ) { // \u672c\u6b21\u5199\u5165\u7684\u6570\u636e\u957f\u5ea6 state . writelen = len ; // \u672c\u6b21\u5199\u5b8c\u6210\u540e\u6267\u884c\u7684\u56de\u8c03 state . writecb = cb ; // \u6b63\u5728\u5199\u5165 state . writing = true ; // \u5047\u8bbe\u7528\u6237\u5b9a\u4e49\u7684_writev\u6216\u8005_write\u51fd\u6570\u662f\u540c\u6b65\u56de\u8c03onwrite state . sync = true ; if ( writev ) // chunk\u4e3a\u7f13\u5b58\u5f85\u5199\u5165\u7684buffer\u8282\u70b9\u6570\u7ec4 stream . _writev ( chunk , state . onwrite ); else // \u6267\u884c\u7528\u6237\u5b9a\u4e49\u7684\u5199\u51fd\u6570\uff0conwrite\u662fNode.js\u5b9a\u4e49\u7684\uff0c\u5728\u521d\u59cb\u5316\u7684\u65f6\u5019\u8bbe\u7f6e\u4e86\u8be5\u51fd\u6570 stream . _write ( chunk , encoding , state . onwrite ); /* \u5982\u679c\u7528\u6237\u662f\u540c\u6b65\u56de\u8c03onwrite\uff0c\u5219\u8fd9\u53e5\u4ee3\u7801\u6ca1\u6709\u610f\u4e49\uff0c \u5982\u679c\u662f\u5f02\u6b65\u56de\u8c03onwrite\uff0c\u8fd9\u53e5\u4ee3\u7801\u4f1a\u5728onwrite\u4e4b\u524d\u6267\u884c\uff0c \u5b83\u6807\u8bb0\u7528\u6237\u662f\u5f02\u6b65\u56de\u8c03\u6a21\u5f0f\uff0c\u5728onwrite\u4e2d\u9700\u8981\u5224\u65ad\u56de\u8c03\u6a21\u5f0f\uff0c\u5373sync\u7684\u503c */ state . sync = false ; } doWrite\u51fd\u6570\u8bb0\u5f55\u4e86\u672c\u6b21\u5199\u5165\u7684\u4e0a\u4e0b\u6587\uff0c\u6bd4\u5982\u957f\u5ea6\uff0c\u56de\u8c03\uff0c\u7136\u540e\u8bbe\u7f6e\u6b63\u5728\u5199\u6807\u8bb0\u3002\u6700\u540e\u6267\u884c\u5199\u5165\u3002\u5982\u679c\u5f53\u524d\u5f85\u5199\u5165\u7684\u6570\u636e\u662f\u7f13\u5b58\u7684\u6570\u636e\u5e76\u4e14\u7528\u6237\u5b9e\u73b0\u4e86_writev\u51fd\u6570\uff0c\u5219\u8c03\u7528_writev\u3002\u5426\u5219\u8c03\u7528_write\u3002\u4e0b\u9762\u6211\u4eec\u5b9e\u73b0\u4e00\u4e2a\u53ef\u5199\u6d41\u7684\u4f8b\u5b50\uff0c\u628a\u8fd9\u91cc\u7684\u903b\u8f91\u4e32\u8d77\u6765\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 const { Writable } = require ( 'stream' ); class DemoWritable extends Writable { constructor () { super (); this . data = null ; } _write ( chunk , encoding , cb ) { // \u4fdd\u5b58\u6570\u636e this . data = this . data ? Buffer . concat ([ this . data , chunk ]) : chunk ; // \u6267\u884c\u56de\u8c03\u544a\u8bc9\u53ef\u5199\u6d41\u5199\u5b8c\u6210\u4e86\uff0cfalse\u4ee3\u8868\u5199\u6210\u529f\uff0ctrue\u4ee3\u8868\u5199\u5931\u8d25 cb ( null ); } } DemoWritable\u5b9a\u4e49\u4e86\u6570\u636e\u6d41\u5411\u7684\u76ee\u7684\u5730\uff0c\u5728\u7528\u6237\u8c03\u7528write\u7684\u65f6\u5019\uff0c\u53ef\u5199\u6d41\u4f1a\u6267\u884c\u7528\u6237\u5b9a\u4e49\u7684_write\uff0c_write\u4fdd\u5b58\u4e86\u6570\u636e\uff0c\u7136\u540e\u6267\u884c\u56de\u8c03\u5e76\u4f20\u5165\u53c2\u6570\uff0c\u901a\u77e5\u53ef\u5199\u6d41\u6570\u636e\u5199\u5b8c\u6210\u4e86\uff0c\u5e76\u901a\u8fc7\u53c2\u6570\u6807\u8bb0\u5199\u6210\u529f\u8fd8\u662f\u5931\u8d25\u3002\u8fd9\u65f6\u5019\u56de\u5230\u53ef\u5199\u6d41\u4fa7\u3002\u6211\u4eec\u770b\u5230\u53ef\u5199\u6d41\u8bbe\u7f6e\u7684\u56de\u8c03\u662fonwrite\uff0conwrite\u662f\u5728\u521d\u59cb\u5316\u53ef\u5199\u6d41\u7684\u65f6\u5019\u8bbe\u7f6e\u7684\u3002 1 this . onwrite = onwrite . bind ( undefined , stream ); \u6211\u4eec\u63a5\u7740\u770bonwrite\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 function onwrite ( stream , er ) { var state = stream . _writableState ; var sync = state . sync ; // \u672c\u6b21\u5199\u5b8c\u65f6\u6267\u884c\u7684\u56de\u8c03 var cb = state . writecb ; // \u91cd\u7f6e\u5185\u90e8\u5b57\u6bb5\u7684\u503c // \u5199\u5b8c\u4e86\uff0c\u91cd\u7f6e\u56de\u8c03\uff0c\u8fd8\u6709\u591a\u5c11\u5355\u4f4d\u7684\u6570\u636e\u6ca1\u6709\u5199\u5165\uff0c\u6570\u636e\u5199\u5b8c\uff0c\u91cd\u7f6e\u672c\u6b21\u5f85\u5199\u5165\u7684\u6570\u636e\u6570\u4e3a0 state . writing = false ; state . writecb = null ; state . length -= state . writelen ; state . writelen = 0 ; // \u5199\u51fa\u9519 if ( er ) onwriteError ( stream , state , sync , er , cb ); else { // Check if we're actually ready to finish, but don't emit yet // \u662f\u5426\u5df2\u7ecf\u6267\u884c\u4e86end\uff0c\u5e76\u4e14\u6570\u636e\u4e5f\u5199\u5b8c\u4e86\uff08\u63d0\u4ea4\u5199\u64cd\u4f5c\u548c\u6700\u540e\u771f\u6b63\u6267\u884c\u4e2d\u95f4\u53ef\u80fd\u6267\u884c\u4e86end\uff09 var finished = needFinish ( state ); // \u8fd8\u6ca1\u7ed3\u675f\uff0c\u5e76\u4e14\u6ca1\u6709\u8bbe\u7f6e\u963b\u585e\u6807\u8bb0\uff0c\u4e5f\u4e0d\u5728\u5904\u7406buffer\uff0c\u5e76\u4e14\u6709\u5f85\u5904\u7406\u7684\u7f13\u5b58\u6570\u636e\uff0c\u5219\u8fdb\u884c\u5199\u5165 if ( ! finished && ! state . corked && ! state . bufferProcessing && state . bufferedRequest ) { clearBuffer ( stream , state ); } // \u7528\u6237\u540c\u6b65\u56de\u8c03onwrite\u5219Node.js\u5f02\u6b65\u6267\u884c\u7528\u6237\u56de\u8c03 if ( sync ) { process . nextTick ( afterWrite , stream , state , finished , cb ); } else { afterWrite ( stream , state , finished , cb ); } } } onwrite\u7684\u903b\u8f91\u5982\u4e0b 1 \u66f4\u65b0\u53ef\u5199\u6d41\u7684\u72b6\u6001\u548c\u6570\u636e 2 \u5199\u51fa\u9519\u5219\u89e6\u53d1error\u4e8b\u4ef6\u548c\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u5199\u6210\u529f\u5219\u5224\u65ad\u662f\u5426\u6ee1\u8db3\u7ee7\u7eed\u6267\u884c\u5199\u64cd\u4f5c\uff0c\u662f\u7684\u8bdd\u5219\u7ee7\u7eed\u5199\uff0c\u5426\u5219\u6267\u884c\u7528\u6237\u56de\u8c03\u3002 \u6211\u4eec\u770b\u4e00\u4e0bclearBuffer\u51fd\u6570\u7684\u903b\u8f91\uff0c\u8be5\u903b\u8f91\u4e3b\u8981\u662f\u628a\u7f13\u5b58\u7684\u6570\u636e\u5199\u5230\u76ee\u7684\u5730\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 function clearBuffer ( stream , state ) { // \u6b63\u5728\u5904\u7406buffer state . bufferProcessing = true ; // \u6307\u5411\u5934\u7ed3\u70b9 var entry = state . bufferedRequest ; // \u5b9e\u73b0\u4e86_writev\u5e76\u4e14\u6709\u4e24\u4e2a\u4ee5\u4e0a\u7684\u6570\u636e\u5757\uff0c\u5219\u6279\u91cf\u5199\u5165\uff0c\u5373\u4e00\u6b21\u628a\u6240\u6709\u7f13\u5b58\u7684buffer\u90fd\u5199\u5165 if ( stream . _writev && entry && entry . next ) { // Fast case, write everything using _writev() var l = state . bufferedRequestCount ; var buffer = new Array ( l ); var holder = state . corkedRequestsFree ; // \u6307\u5411\u5f85\u5199\u5165\u6570\u636e\u7684\u94fe\u8868 holder . entry = entry ; var count = 0 ; // \u6570\u636e\u662f\u5426\u5168\u90e8\u90fd\u662fbuffer\u683c\u5f0f var allBuffers = true ; // \u628a\u7f13\u5b58\u7684\u8282\u70b9\u653e\u5230buffer\u6570\u7ec4\u4e2d while ( entry ) { buffer [ count ] = entry ; if ( ! entry . isBuf ) allBuffers = false ; entry = entry . next ; count += 1 ; } buffer . allBuffers = allBuffers ; doWrite ( stream , state , true , state . length , buffer , '' , holder . finish ); // \u5f85\u6267\u884c\u7684cb\u52a0\u4e00\uff0c\u5373holder.finish state . pendingcb ++ ; // \u6e05\u7a7a\u7f13\u5b58\u961f\u5217 state . lastBufferedRequest = null ; // \u8fd8\u6709\u4e0b\u4e00\u4e2a\u8282\u70b9\u5219\u66f4\u65b0\u6307\u9488,\u4e0b\u6b21\u4f7f\u7528 if ( holder . next ) { state . corkedRequestsFree = holder . next ; holder . next = null ; } else { // \u6ca1\u6709\u4e0b\u4e00\u4e2a\u8282\u70b9\u5219\u6062\u590d\u503c\uff0c\u89c1\u521d\u59cb\u5316\u65f6\u7684\u8bbe\u7f6e var corkReq = { next : null , entry : null , finish : undefined }; corkReq . finish = onCorkedFinish . bind ( undefined , corkReq , state ); state . corkedRequestsFree = corkReq ; } state . bufferedRequestCount = 0 ; } else { // \u6162\u6162\u5199\uff0c\u5373\u4e00\u4e2a\u4e2abuffer\u5199\uff0c\u5199\u5b8c\u540e\u7b49\u9700\u8981\u6267\u884c\u7528\u6237\u7684cb\uff0c\u9a71\u52a8\u4e0b\u4e00\u4e2a\u5199 // Slow case, write chunks one-by-one while ( entry ) { var chunk = entry . chunk ; var encoding = entry . encoding ; var cb = entry . callback ; var len = state . objectMode ? 1 : chunk . length ; // \u6267\u884c\u5199\u5165 doWrite ( stream , state , false , len , chunk , encoding , cb ); entry = entry . next ; // \u5904\u7406\u5b8c\u4e00\u4e2a\uff0c\u51cf\u4e00 state . bufferedRequestCount -- ; /* \u5728onwrite\u91cc\u6e05\u9664\u8fd9\u4e2a\u6807\u8bb0\uff0conwrite\u4f9d\u8d56\u4e8e\u7528\u6237\u6267\u884c\uff0c\u5982\u679c\u7528\u6237\u6ca1\u8c03\uff0c \u6216\u8005\u4e0d\u662f\u540c\u6b65\u8c03\uff0c\u5219\u9000\u51fa\uff0c\u7b49\u5f85\u6267\u884conwrite\u7684\u65f6\u5019\u518d\u7ee7\u7eed\u5199 */ if ( state . writing ) { break ; } } // \u5199\u5b8c\u4e86\u7f13\u5b58\u7684\u6570\u636e\uff0c\u5219\u66f4\u65b0\u6307\u9488 if ( entry === null ) state . lastBufferedRequest = null ; } /* \u66f4\u65b0\u7f13\u5b58\u6570\u636e\u94fe\u8868\u7684\u5934\u7ed3\u70b9\u6307\u5411\uff0c 1 \u5982\u679c\u662f\u6279\u91cf\u5199\u5219entry\u4e3anull 2 \u5982\u679c\u5355\u4e2a\u5199\uff0c\u5219\u53ef\u80fd\u8fd8\u6709\u503c\uff08\u5982\u679c\u7528\u6237\u662f\u5f02\u6b65\u8c03\u7528onwrite\u7684\u8bdd\uff09 */ state . bufferedRequest = entry ; // \u672c\u8f6e\u5904\u7406\u5b8c\u6bd5\uff08\u5904\u7406\u5b8c\u4e00\u4e2a\u6216\u5168\u90e8\uff09 state . bufferProcessing = false ; } clearBuffer\u7684\u903b\u8f91\u770b\u8d77\u6765\u975e\u5e38\u591a\uff0c\u4f46\u662f\u903b\u8f91\u5e76\u4e0d\u7b97\u5f88\u590d\u6742\u3002\u4e3b\u8981\u5206\u4e3a\u4e24\u4e2a\u5206\u652f\u3002 1 \u7528\u6237\u5b9e\u73b0\u4e86\u6279\u91cf\u5199\u51fd\u6570\uff0c\u5219\u4e00\u6b21\u628a\u7f13\u5b58\u7684\u65f6\u5019\u5199\u5165\u76ee\u7684\u5730\u3002\u9996\u5148\u628a\u7f13\u5b58\u7684\u6570\u636e\uff08\u94fe\u8868\uff09\u5168\u90e8\u6536\u96c6\u8d77\u6765\uff0c\u7136\u540e\u6267\u884c\u6267\u884c\u5199\u5165\uff0c\u5e76\u8bbe\u7f6e\u56de\u8c03\u662ffinish\u51fd\u6570\u3002corkedRequestsFree\u5b57\u6bb5\u6307\u5411\u4e00\u4e2a\u8282\u70b9\u6570\u6700\u5c11\u4e3a\u4e00\uff0c\u6700\u591a\u4e3a\u4e8c\u7684\u94fe\u8868\uff0c\u7528\u4e8e\u4fdd\u5b58\u6279\u91cf\u5199\u7684\u6570\u636e\u7684\u4e0a\u4e0b\u6587\u3002\u6279\u91cf\u5199\u65f6\u7684\u6570\u636e\u7ed3\u6784\u56fe\u5982\u56fe21-6\u548c21-7\u6240\u793a\uff08\u4e24\u79cd\u573a\u666f\uff09\u3002 \u56fe21-6 \u56fe21-7 corkedRequestsFree\u4fdd\u8bc1\u6700\u5c11\u6709\u4e00\u4e2a\u8282\u70b9\uff0c\u7528\u4e8e\u4e00\u6b21\u6279\u91cf\u5199\uff0c\u5f53\u4f7f\u7528\u5b8c\u7684\u65f6\u5019\uff0c\u4f1a\u6700\u591a\u4fdd\u5b58\u4e24\u4e2a\u7a7a\u95f2\u8282\u70b9\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u6279\u91cf\u5199\u6210\u529f\u540e\uff0c\u56de\u8c03\u51fd\u6570onCorkedFinish\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function onCorkedFinish ( corkReq , state , err ) { // corkReq.entry\u6307\u5411\u5f53\u524d\u5904\u7406\u7684buffer\u94fe\u8868\u5934\u7ed3\u70b9 var entry = corkReq . entry ; corkReq . entry = null ; // \u904d\u5386\u6267\u884c\u7528\u6237\u4f20\u5165\u7684\u56de\u8c03\u56de\u8c03 while ( entry ) { var cb = entry . callback ; state . pendingcb -- ; cb ( err ); entry = entry . next ; } // \u56de\u6536corkReq\uff0cstate.corkedRequestsFree\u8fd9\u65f6\u5019\u5df2\u7ecf\u7b49\u4e8e\u65b0\u7684corkReq\uff0c\u6307\u5411\u521a\u7528\u5b8c\u7684\u8fd9\u4e2acorkReq\uff0c\u5171\u4fdd\u5b58\u4e24\u4e2a state . corkedRequestsFree . next = corkReq ; } onCorkedFinish\u9996\u5148\u4ece\u672c\u6b21\u6279\u91cf\u5199\u7684\u6570\u636e\u4e0a\u4e0b\u6587\u53d6\u51fa\u56de\u8c03\uff0c\u7136\u540e\u9010\u4e2a\u6267\u884c\u3002\u6700\u540e\u56de\u6536\u8282\u70b9\u3002corkedRequestsFree\u603b\u662f\u6307\u5411\u4e00\u4e2a\u7a7a\u95f2\u8282\u70b9\uff0c\u6240\u4ee5\u5982\u679c\u8282\u70b9\u8d85\u8fc7\u4e24\u4e2a\u65f6\uff0c\u6bcf\u6b21\u4f1a\u628a\u5c3e\u8282\u70b9\u4e22\u5f03\uff0c\u5982\u56fe21-8\u6240\u793a\u3002 \u56fe21-8 2 \u63a5\u7740\u6211\u4eec\u770b\u5355\u4e2a\u5199\u7684\u573a\u666f \u5355\u4e2a\u5199\u7684\u65f6\u5019\uff0c\u5c31\u662f\u901a\u8fc7doWrite\u628a\u6570\u636e\u9010\u4e2a\u5199\u5230\u76ee\u7684\u5730\uff0c\u4f46\u662f\u6709\u4e00\u4e2a\u5730\u65b9\u9700\u8981\u6ce8\u610f\u7684\u662f\uff0c\u5982\u679c\u7528\u6237\u662f\u5f02\u6b65\u6267\u884c\u53ef\u5199\u6d41\u7684\u56de\u8c03onwrite\uff08\u901a\u8fc7writing\u5b57\u6bb5\uff0c\u56e0\u4e3aonwrite\u4f1a\u7f6ewriting\u4e3atrue\uff0c\u5982\u679c\u6267\u884c\u5b8cdoWrite\uff0cwriting\u4e3afalse\u8bf4\u660e\u662f\u5f02\u6b65\u56de\u8c03\uff09\uff0c\u5219\u5199\u5165\u4e00\u4e2a\u6570\u636e\u540e\u5c31\u4e0d\u518d\u6267\u884cdoWrite\u8fdb\u884c\u5199\uff0c\u800c\u662f\u9700\u8981\u7b49\u5230onwrite\u56de\u8c03\u88ab\u5f02\u6b65\u6267\u884c\u65f6\uff0c\u518d\u6267\u884c\u4e0b\u4e00\u6b21\u5199\uff0c\u56e0\u4e3a\u53ef\u5199\u6d41\u662f\u4e32\u884c\u5730\u6267\u884c\u5199\u64cd\u4f5c\u3002 \u4e0b\u9762\u8bb2\u4e00\u4e0bsync\u5b57\u6bb5\u7684\u4f5c\u7528\u3002sync\u5b57\u6bb5\u662f\u7528\u4e8e\u6807\u8bb0\u6267\u884c\u7528\u6237\u81ea\u5b9a\u4e49\u7684write\u51fd\u6570\u65f6\uff0cwrite\u51fd\u6570\u662f\u540c\u6b65\u8fd8\u662f\u5f02\u6b65\u6267\u884c\u53ef\u5199\u6d41\u7684\u56de\u8c03onwrite\u3002\u4e3b\u8981\u7528\u4e8e\u63a7\u5236\u662f\u540c\u6b65\u8fd8\u662f\u5f02\u6b65\u6267\u884c\u7528\u6237\u7684\u56de\u8c03\u3002\u5e76\u4e14\u9700\u8981\u4fdd\u8bc1\u56de\u8c03\u8981\u6309\u7167\u5b9a\u4e49\u7684\u987a\u5e8f\u6267\u884c\u3002\u6709\u4e24\u4e2a\u5730\u65b9\u6d89\u53ca\u4e86\u8fd9\u4e2a\u903b\u8f91\uff0c\u7b2c\u4e00\u4e2a\u662fwirte\u7684\u65f6\u5019\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u51fd\u6570\u7684\u8c03\u7528\u5173\u7cfb\uff0c\u5982\u56fe21-9\u6240\u793a\u3002 \u56fe21-9 \u5982\u679c\u7528\u6237\u662f\u540c\u6b65\u6267\u884conwrite\uff0c\u5219\u6570\u636e\u4f1a\u88ab\u5b9e\u65f6\u5730\u6d88\u8d39\uff0c\u4e0d\u5b58\u5728\u7f13\u5b58\u6570\u636e\u7684\u60c5\u51b5\uff0c\u8fd9\u65f6\u5019Node.js\u5f02\u6b65\u5e76\u4e14\u6709\u5e8f\u5730\u6267\u884c\u7528\u6237\u56de\u8c03\u3002\u5982\u679c\u7528\u6237\u8fde\u7eed\u4e24\u6b21\u8c03\u7528\u4e86write\u5199\u5165\u6570\u636e\uff0c\u5e76\u4e14\u662f\u4ee5\u5f02\u6b65\u6267\u884c\u56de\u8c03onwrite\uff0c\u5219\u7b2c\u4e00\u6b21\u6267\u884conwrite\u7684\u65f6\u5019\uff0c\u4f1a\u5b58\u5728\u7f13\u5b58\u7684\u6570\u636e\uff0c\u8fd9\u65f6\u5019\u8fd8\u6ca1\u6765\u5f97\u53ca\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u5c31\u4f1a\u5148\u53d1\u751f\u7b2c\u4e8c\u6b21\u5199\u5165\u64cd\u4f5c\uff0c\u540c\u6837\uff0c\u7b2c\u4e8c\u6b21\u5199\u64cd\u4f5c\u4e5f\u662f\u5f02\u6b65\u56de\u8c03onwrite\uff0c\u6240\u4ee5\u63a5\u4e0b\u6765\u5c31\u4f1a\u540c\u6b65\u6267\u884c\u7684\u7528\u6237\u56de\u8c03\u3002\u8fd9\u6837\u5c31\u4fdd\u8bc1\u4e86\u7528\u6237\u56de\u8c03\u7684\u987a\u5e8f\u6267\u884c\u3002\u7b2c\u4e8c\u79cd\u573a\u666f\u662funcork\u51fd\u6570\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u51fd\u6570\u5173\u7cfb\u56fe\uff0c\u5982\u56fe21-10\u6240\u793a\u3002 \u56fe21-10 \u5728uncork\u7684\u6267\u884c\u6d41\u7a0b\u4e2d\uff0c\u5982\u679conwrite\u662f\u88ab\u540c\u6b65\u56de\u8c03\uff0c\u5219\u5728onwrite\u4e2d\u4e0d\u4f1a\u518d\u6b21\u8c03\u7528clearBuffer\uff0c\u56e0\u4e3a\u8fd9\u65f6\u5019\u7684bufferProcessing\u4e3atrue\u3002\u8fd9\u65f6\u5019\u4f1a\u5148\u628a\u7528\u6237\u7684\u56de\u8c03\u5165\u961f\uff0c\u7136\u540e\u518d\u6b21\u6267\u884cdoWrite\u53d1\u8d77\u4e0b\u4e00\u6b21\u5199\u64cd\u4f5c\u3002\u5982\u679conwrite\u662f\u88ab\u5f02\u6b65\u6267\u884c\uff0c\u5728\u6267\u884cclearBuffer\u4e2d\uff0c\u7b2c\u4e00\u6b21\u6267\u884cdoWrite\u5b8c\u6bd5\u540e\uff0cclearBuffer\u5c31\u4f1a\u9000\u51fa\uff0c\u5e76\u4e14\u8fd9\u65f6\u5019bufferProcessing\u4e3afalse\u3002\u7b49\u5230onwrite\u88ab\u56de\u8c03\u7684\u65f6\u5019\uff0c\u518d\u6b21\u6267\u884cclearBuffer\uff0c\u540c\u6837\u6267\u884c\u5b8cdoWrite\u7684\u65f6\u5019\u9000\u51fa\uff0c\u7b49\u5f85\u5f02\u6b65\u56de\u8c03\uff0c\u8fd9\u65f6\u5019\u7528\u6237\u56de\u8c03\u88ab\u6267\u884c\u3002 \u6211\u4eec\u7ee7\u7eed\u5206\u6790onwrite\u7684\u4ee3\u7801\uff0conwrite\u6700\u540e\u4f1a\u8c03\u7528afterWrite\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function afterWrite ( stream , state , finished , cb ) { // \u8fd8\u6ca1\u7ed3\u675f\uff0c\u770b\u662f\u5426\u9700\u8981\u89e6\u53d1drain\u4e8b\u4ef6 if ( ! finished ) onwriteDrain ( stream , state ); // \u51c6\u5907\u6267\u884c\u7528\u6237\u56de\u8c03\uff0c\u5f85\u6267\u884c\u7684\u56de\u8c03\u51cf\u4e00 state . pendingcb -- ; cb (); finishMaybe ( stream , state ); } function onwriteDrain ( stream , state ) { // \u6ca1\u6709\u6570\u636e\u9700\u8981\u5199\u4e86\uff0c\u5e76\u4e14\u6d41\u5728\u963b\u585e\u4e2d\u7b49\u5f85drain\u4e8b\u4ef6 if ( state . length === 0 && state . needDrain ) { // \u89e6\u53d1drain\u4e8b\u4ef6\u7136\u540e\u6e05\u7a7a\u6807\u8bb0 state . needDrain = false ; stream . emit ( 'drain' ); } } afterWrite\u4e3b\u8981\u662f\u5224\u65ad\u662f\u5426\u9700\u8981\u89e6\u53d1drain\u4e8b\u4ef6\uff0c\u7136\u540e\u6267\u884c\u7528\u6237\u56de\u8c03\u3002\u6700\u540e\u5224\u65ad\u6d41\u662f\u5426\u5df2\u7ecf\u7ed3\u675f\uff08\u5728\u5f02\u6b65\u56de\u8c03onwrite\u7684\u60c5\u51b5\u4e0b\uff0c\u7528\u6237\u8c03\u7528\u56de\u8c03\u4e4b\u524d\uff0c\u53ef\u80fd\u6267\u884c\u4e86end\uff09\u3002\u6d41\u7ed3\u675f\u7684\u903b\u8f91\u6211\u4eec\u540e\u9762\u7ae0\u8282\u5355\u72ec\u5206\u6790\u3002","title":"21.3.3 \u6570\u636e\u5199\u5165"},{"location":"chapter21-JS%20Stream/#2134-corkuncork","text":"cork\u548cuncork\u7c7b\u4f3ctcp\u4e2d\u7684negal\u7b97\u6cd5\uff0c\u4e3b\u8981\u7528\u4e8e\u7d2f\u79ef\u6570\u636e\u540e\u4e00\u6b21\u6027\u5199\u5165\u76ee\u7684\u5730\u3002\u800c\u4e0d\u662f\u6709\u4e00\u5757\u5c31\u5b9e\u65f6\u5199\u5165\u3002\u6bd4\u5982\u5728tcp\u4e2d\uff0c\u6bcf\u6b21\u53d1\u9001\u4e00\u4e2a\u5b57\u8282\uff0c\u800c\u534f\u8bae\u5934\u8fdc\u8fdc\u5927\u4e8e\u4e00\u5b57\u8282\uff0c\u6709\u6548\u6570\u636e\u5360\u6bd4\u975e\u5e38\u4f4e\u3002\u4f7f\u7528cork\u7684\u65f6\u5019\u6700\u597d\u540c\u65f6\u63d0\u4f9bwritev\u5b9e\u73b0\uff0c\u5426\u5219\u6700\u540ecork\u5c31\u6ca1\u6709\u610f\u4e49\uff0c\u56e0\u4e3a\u6700\u7ec8\u8fd8\u662f\u9700\u8981\u4e00\u5757\u5757\u7684\u6570\u636e\u8fdb\u884c\u5199\u5165\u3002\u6211\u4eec\u770b\u770bcork\u7684\u4ee3\u7801\u3002 1 2 3 4 Writable . prototype . cork = function () { var state = this . _writableState ; state . corked ++ ; }; cork\u7684\u4ee3\u7801\u975e\u5e38\u7b80\u5355\uff0c\u8fd9\u91cc\u4f7f\u7528\u4e00\u4e2a\u6574\u6570\u800c\u4e0d\u662f\u6807\u8bb0\u4f4d\uff0c\u6240\u4ee5cork\u548cuncork\u9700\u8981\u914d\u5bf9\u4f7f\u7528\u3002\u6211\u4eec\u770b\u770buncork\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 Writable . prototype . uncork = function () { var state = this . _writableState ; if ( state . corked ) { state . corked -- ; /* \u6ca1\u6709\u5728\u8fdb\u884c\u5199\u64cd\u4f5c\uff08\u5982\u679c\u8fdb\u884c\u5199\u64cd\u4f5c\u5219\u5728\u5199\u64cd\u4f5c\u5b8c\u6210\u7684\u56de\u8c03\u91cc\u4f1a\u6267\u884cclearBuffer\uff09\uff0c corked=0\uff0c \u6ca1\u6709\u5728\u5904\u7406\u7f13\u5b58\u6570\u636e\uff08writing\u4e3afalse\u5df2\u7ecf\u8bf4\u660e\uff09\uff0c \u6709\u7f13\u5b58\u7684\u6570\u636e\u5f85\u5904\u7406 */ if ( ! state . writing && ! state . corked && ! state . bufferProcessing && state . bufferedRequest ) clearBuffer ( this , state ); } };","title":"21.3.4 cork\u548cuncork"},{"location":"chapter21-JS%20Stream/#2135","text":"\u6d41\u7ed3\u675f\u9996\u5148\u4f1a\u628a\u5f53\u524d\u7f13\u5b58\u7684\u6570\u636e\u5199\u5165\u76ee\u7684\u5730\uff0c\u5e76\u4e14\u5141\u8bb8\u518d\u6267\u884c\u989d\u5916\u7684\u4e00\u6b21\u5199\u64cd\u4f5c\uff0c\u7136\u540e\u628a\u53ef\u5199\u6d41\u7f6e\u4e3a\u4e0d\u53ef\u5199\u548c\u7ed3\u675f\u72b6\u6001\uff0c\u5e76\u4e14\u89e6\u53d1\u4e00\u7cfb\u5217\u4e8b\u4ef6\u3002\u4e0b\u9762\u662f\u7ed3\u675f\u4e00\u4e2a\u53ef\u5199\u6d41\u7684\u51fd\u6570\u5173\u7cfb\u56fe\u3002\u5982\u56fe21-11\u6240\u793a\u3002 \u56fe21-11 \u901a\u8fc7end\u51fd\u6570\u53ef\u4ee5\u7ed3\u675f\u53ef\u5199\u6d41\uff0c\u6211\u4eec\u770b\u770b\u8be5\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Writable . prototype . end = function ( chunk , encoding , cb ) { var state = this . _writableState ; if ( typeof chunk === 'function' ) { cb = chunk ; chunk = null ; encoding = null ; } else if ( typeof encoding === 'function' ) { cb = encoding ; encoding = null ; } // \u6700\u540e\u4e00\u6b21\u5199\u5165\u7684\u673a\u4f1a\uff0c\u53ef\u80fd\u76f4\u63a5\u5199\u5165\uff0c\u4e5f\u53ef\u4ee5\u4f1a\u88ab\u7f13\u5b58\uff08\u6b63\u5728\u5199\u62a4\u7740\u5904\u4e8ecorked\u72b6\u6001\uff09 if ( chunk !== null && chunk !== undefined ) this . write ( chunk , encoding ); // \u5982\u679c\u5904\u4e8ecorked\u72b6\u6001\uff0c\u5219\u4e0a\u9762\u7684\u5199\u64cd\u4f5c\u4f1a\u88ab\u7f13\u5b58\uff0cuncork\u548cwrite\u4fdd\u5b58\u53ef\u4ee5\u5bf9\u5269\u4f59\u6570\u636e\u6267\u884c\u5199\u64cd\u4f5c if ( state . corked ) { // \u7f6e1\uff0c\u4e3a\u4e86uncork\u80fd\u6b63\u786e\u6267\u884c,\u53ef\u4ee5\u6709\u673a\u4f1a\u5199\u5165\u7f13\u5b58\u7684\u6570\u636e state . corked = 1 ; this . uncork (); } if ( ! state . ending ) endWritable ( this , state , cb ); }; \u6211\u4eec\u63a5\u7740\u770bendWritable\u51fd\u6570 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function endWritable ( stream , state , cb ) { // \u6b63\u5728\u6267\u884cend\u51fd\u6570 state . ending = true ; // \u5224\u65ad\u6d41\u662f\u5426\u53ef\u4ee5\u7ed3\u675f\u4e86 finishMaybe ( stream , state ); if ( cb ) { // \u5df2\u7ecf\u89e6\u53d1\u4e86finish\u4e8b\u4ef6\u5219\u4e0b\u4e00\u4e2atick\u76f4\u63a5\u6267\u884ccb\uff0c\u5426\u5219\u7b49\u5f85finish\u4e8b\u4ef6 if ( state . finished ) process . nextTick ( cb ); else stream . once ( 'finish' , cb ); } // \u6d41\u7ed3\u675f\uff0c\u6d41\u4e0d\u53ef\u5199 state . ended = true ; stream . writable = false ; } endWritable\u51fd\u6570\u6807\u8bb0\u6d41\u4e0d\u53ef\u5199\u5e76\u4e14\u5904\u4e8e\u7ed3\u675f\u72b6\u6001\u3002\u4f46\u662f\u53ea\u662f\u4ee3\u8868\u4e0d\u80fd\u518d\u8c03\u7528write\u5199\u6570\u636e\u4e86\uff0c\u4e4b\u524d\u7f13\u5b58\u7684\u6570\u636e\u9700\u8981\u88ab\u5199\u5b8c\u540e\u624d\u80fd\u771f\u6b63\u5730\u7ed3\u675f\u6d41\u3002\u6211\u4eec\u770bfinishMaybe\u51fd\u6570\u7684\u903b\u8f91\u3002\u8be5\u51fd\u6570\u7528\u4e8e\u5224\u65ad\u6d41\u662f\u5426\u53ef\u4ee5\u7ed3\u675f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function needFinish ( state ) { /* \u6267\u884c\u4e86end\u51fd\u6570\u5219\u8bbe\u7f6eending=true\uff0c \u5f53\u524d\u6ca1\u6709\u6570\u636e\u9700\u8981\u5199\u5165\u4e86\uff0c \u4e5f\u6ca1\u6709\u7f13\u5b58\u7684\u6570\u636e\uff0c \u8fd8\u6ca1\u6709\u89e6\u53d1finish\u4e8b\u4ef6\uff0c \u6ca1\u6709\u6b63\u5728\u8fdb\u884c\u5199\u5165 */ return ( state . ending && state . length === 0 && state . bufferedRequest === null && ! state . finished && ! state . writing ); } // \u6bcf\u6b21\u5199\u5b8c\u6210\u7684\u65f6\u5019\u4e5f\u4f1a\u8c03\u7528\u8be5\u51fd\u6570 function finishMaybe ( stream , state ) { // \u6d41\u662f\u5426\u53ef\u4ee5\u7ed3\u675f var need = needFinish ( state ); // \u662f\u5219\u5148\u5904\u7406prefinish\u4e8b\u4ef6\uff0c\u5426\u5219\u5148\u4e0d\u7ba1\uff0c\u7b49\u5f85\u5199\u5b8c\u6210\u518d\u8c03\u7528\u8be5\u51fd\u6570 if ( need ) { prefinish ( stream , state ); // \u5982\u679c\u6ca1\u6709\u5f85\u6267\u884c\u7684\u56de\u8c03\uff0c\u5219\u89e6\u53d1finish\u4e8b\u4ef6 if ( state . pendingcb === 0 ) { state . finished = true ; stream . emit ( 'finish' ); } } return need ; } \u5f53\u53ef\u5199\u6d41\u4e2d\u6240\u6709\u6570\u636e\u548c\u56de\u8c03\u90fd\u6267\u884c\u4e86\u624d\u80fd\u7ed3\u675f\u6d41\uff0c\u5728\u7ed3\u675f\u6d41\u4e4b\u524d\u4f1a\u5148\u5904\u7406prefinish\u4e8b\u4ef6\u3002 1. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function callFinal ( stream , state ) { // \u6267\u884c\u7528\u6237\u7684final\u51fd\u6570 stream . _final (( err ) => { // \u6267\u884c\u4e86callFinal\u51fd\u6570\uff0ccb\u51cf\u4e00 state . pendingcb -- ; if ( err ) { stream . emit ( 'error' , err ); } // \u6267\u884cprefinish state . prefinished = true ; stream . emit ( 'prefinish' ); // \u662f\u5426\u53ef\u4ee5\u89e6\u53d1finish\u4e8b\u4ef6 finishMaybe ( stream , state ); }); } function prefinish ( stream , state ) { // \u8fd8\u6ca1\u89e6\u53d1prefinish\u5e76\u4e14\u6ca1\u6709\u6267\u884cfinalcall if ( ! state . prefinished && ! state . finalCalled ) { // \u7528\u6237\u4f20\u4e86final\u51fd\u6570\u5219\uff0c\u5f85\u6267\u884c\u56de\u8c03\u6570\u52a0\u4e00\uff0c\u5373callFinal\uff0c\u5426\u5219\u76f4\u63a5\u89e6\u53d1prefinish if ( typeof stream . _final === 'function' ) { state . pendingcb ++ ; state . finalCalled = true ; process . nextTick ( callFinal , stream , state ); } else { state . prefinished = true ; stream . emit ( 'prefinish' ); } } } \u5982\u679c\u7528\u6237\u5b9a\u4e49\u4e86_final\u51fd\u6570\uff0c\u5219\u5148\u6267\u884c\u8be5\u51fd\u6570\uff08\u8fd9\u65f6\u5019\u4f1a\u963b\u6b62finish\u4e8b\u4ef6\u7684\u89e6\u53d1\uff09\uff0c\u6267\u884c\u5b8c\u540e\u89e6\u53d1prefinish\uff0c\u518d\u89e6\u53d1finish\u3002\u5982\u679c\u6ca1\u6709\u5b9a\u4e49_final\uff0c\u5219\u76f4\u63a5\u89e6\u53d1prefinish\u4e8b\u4ef6\u3002\u6700\u540e\u89e6\u53d1finish\u4e8b\u4ef6\u3002","title":"21.3.5 \u6d41\u7ed3\u675f"},{"location":"chapter21-JS%20Stream/#214","text":"\u53cc\u5411\u6d41\u662f\u7ee7\u627f\u53ef\u8bfb\u3001\u53ef\u5199\u7684\u6d41\u3002 1 2 3 4 5 6 7 8 9 10 11 util . inherits ( Duplex , Readable ); { // \u628a\u53ef\u5199\u6d41\u4e2d\u5b58\u5728\uff0c\u5e76\u4e14\u5728\u53ef\u8bfb\u6d41\u548cDuplex\u91cc\u90fd\u4e0d\u5b58\u5728\u7684\u65b9\u6cd5\u52a0\u5165\u5230Duplex const keys = Object . keys ( Writable . prototype ); for ( var v = 0 ; v < keys . length ; v ++ ) { const method = keys [ v ]; if ( ! Duplex . prototype [ method ]) Duplex . prototype [ method ] = Writable . prototype [ method ]; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function Duplex ( options ) { if ( ! ( this instanceof Duplex )) return new Duplex ( options ); Readable . call ( this , options ); Writable . call ( this , options ); // \u53cc\u5411\u6d41\u9ed8\u8ba4\u53ef\u8bfb if ( options && options . readable === false ) this . readable = false ; // \u53cc\u5411\u6d41\u9ed8\u8ba4\u53ef\u5199 if ( options && options . writable === false ) this . writable = false ; // \u9ed8\u8ba4\u5141\u8bb8\u534a\u5f00\u5173 this . allowHalfOpen = true ; if ( options && options . allowHalfOpen === false ) this . allowHalfOpen = false ; this . once ( 'end' , onend ); } \u53cc\u5411\u6d41\u7ee7\u627f\u4e86\u53ef\u8bfb\u6d41\u548c\u53ef\u5199\u6d41\u7684\u80fd\u529b\u3002\u53cc\u5411\u6d41\u5b9e\u73b0\u4e86\u4ee5\u4e0b\u529f\u80fd","title":"21.4 \u53cc\u5411\u6d41"},{"location":"chapter21-JS%20Stream/#2141","text":"\u5982\u679c\u8bfb\u5199\u4e24\u7aef\u90fd\u9500\u6bc1\uff0c\u5219\u53cc\u5411\u6d41\u9500\u6bc1\u3002 1 2 3 4 5 6 7 8 9 10 Object . defineProperty ( Duplex . prototype , 'destroyed' , { enumerable : false , get () { if ( this . _readableState === undefined || this . _writableState === undefined ) { return false ; } return this . _readableState . destroyed && this . _writableState . destroyed ; } } \u6211\u4eec\u770b\u5982\u4f55\u9500\u6bc1\u4e00\u4e2a\u53cc\u5411\u6d41\u3002 1 2 3 4 5 6 7 8 Duplex . prototype . _destroy = function ( err , cb ) { // \u5173\u95ed\u8bfb\u7aef this . push ( null ); // \u5173\u95ed\u5199\u7aef this . end (); // \u6267\u884c\u56de\u8c03 process . nextTick ( cb , err ); }; \u53cc\u5411\u6d41\u8fd8\u6709\u4e00\u4e2a\u7279\u6027\u662f\u662f\u5426\u5141\u8bb8\u534a\u5f00\u5173\uff0c\u5373\u53ef\u8bfb\u6216\u53ef\u5199\u3002onend\u662f\u8bfb\u7aef\u5173\u95ed\u65f6\u6267\u884c\u7684\u51fd\u6570\u3002\u6211\u4eec\u770b\u770b\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 // \u5173\u95ed\u5199\u6d41 function onend () { // \u5141\u8bb8\u534a\u5f00\u5173\u6216\u5199\u6d41\u5df2\u7ecf\u7ed3\u675f\u5219\u8fd4\u56de if ( this . allowHalfOpen || this . _writableState . ended ) return ; // \u4e0b\u4e00\u4e2atick\u518d\u5173\u95ed\u5199\u6d41\uff0c\u6267\u884c\u5b8c\u8fd9\u6bb5\u4ee3\u7801\uff0c\u7528\u6237\u8fd8\u53ef\u4ee5\u5199 process . nextTick ( onEndNT , this ); } function onEndNT ( self ) { // \u8c03\u7528\u5199\u7aef\u7684end\u51fd\u6570 self . end (); } \u5f53\u53cc\u5411\u6d41\u5141\u8bb8\u534a\u5f00\u5173\u7684\u60c5\u51b5\u4e0b\uff0c\u53ef\u8bfb\u6d41\u5173\u95ed\u65f6\uff0c\u53ef\u5199\u6d41\u53ef\u4ee5\u4e0d\u5173\u95ed\u3002","title":"21.4.1 \u9500\u6bc1"},{"location":"chapter22-events%E6%A8%A1%E5%9D%97/","text":"events\u6a21\u5757\u662fNode.js\u4e2d\u6bd4\u8f83\u7b80\u5355\u4f46\u662f\u5374\u975e\u5e38\u6838\u5fc3\u7684\u6a21\u5757\uff0cNode.js\u4e2d\uff0c\u5f88\u591a\u6a21\u5757\u90fd\u7ee7\u627f\u4e8eevents\u6a21\u5757\uff0cevents\u6a21\u5757\u662f\u53d1\u5e03\u3001\u8ba2\u9605\u6a21\u5f0f\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e2a\u5982\u679c\u4f7f\u7528events\u6a21\u5757\u3002 1 2 3 4 5 6 7 const { EventEmitter } = require ( 'events' ); class Events extends EventEmitter {} const events = new Events (); events . on ( 'demo' , () => { console . log ( 'emit demo event' ); }); events . emit ( 'demo' ); \u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0bevents\u6a21\u5757\u7684\u5177\u4f53\u5b9e\u73b0\u3002 22.1 \u521d\u59cb\u5316 \u00b6 \u5f53new\u4e00\u4e2aEventEmitter\u6216\u8005\u4ed6\u7684\u5b50\u7c7b\u65f6\uff0c\u5c31\u4f1a\u8fdb\u5165EventEmitter\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function EventEmitter ( opts ) { EventEmitter . init . call ( this , opts ); } EventEmitter . init = function ( opts ) { // \u5982\u679c\u662f\u672a\u521d\u59cb\u5316\u6216\u8005\u6ca1\u6709\u81ea\u5b9a\u4e49_events\uff0c\u5219\u521d\u59cb\u5316 if ( this . _events === undefined || this . _events === ObjectGetPrototypeOf ( this ). _events ) { this . _events = ObjectCreate ( null ); this . _eventsCount = 0 ; } // \u521d\u59cb\u5316\u5904\u7406\u51fd\u6570\u4e2a\u6570\u7684\u9608\u503c this . _maxListeners = this . _maxListeners || undefined ; // \u662f\u5426\u5f00\u542f\u6355\u83b7promise reject,\u9ed8\u8ba4false if ( opts && opts . captureRejections ) { this [ kCapture ] = Boolean ( opts . captureRejections ); } else { this [ kCapture ] = EventEmitter . prototype [ kCapture ]; } }; EventEmitter\u7684\u521d\u59cb\u5316\u4e3b\u8981\u662f\u521d\u59cb\u5316\u4e86\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u548c\u5c5e\u6027\u3002\u552f\u4e00\u652f\u6301\u7684\u4e00\u4e2a\u53c2\u6570\u5c31\u662fcaptureRejections\uff0ccaptureRejections\u8868\u793a\u5f53\u89e6\u53d1\u4e8b\u4ef6\uff0c\u6267\u884c\u5904\u7406\u51fd\u6570\u65f6\uff0cEventEmitter\u662f\u5426\u6355\u83b7\u5904\u7406\u51fd\u6570\u4e2d\u7684\u5f02\u5e38\u3002\u540e\u9762\u6211\u4eec\u4f1a\u8be6\u7ec6\u8bb2\u89e3\u3002 22.2 \u8ba2\u9605\u4e8b\u4ef6 \u00b6 \u521d\u59cb\u5316\u5b8cEventEmitter\u4e4b\u540e\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5f00\u59cb\u4f7f\u7528\u8ba2\u9605\u3001\u53d1\u5e03\u7684\u529f\u80fd\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7addListener\u3001prependListener\u3001on\u3001once\u8ba2\u9605\u4e8b\u4ef6\u3002addListener\u548con\u662f\u7b49\u4ef7\u7684\uff0cprependListener\u7684\u533a\u522b\u5728\u4e8e\u5904\u7406\u51fd\u6570\u4f1a\u88ab\u63d2\u5165\u5230\u961f\u9996\uff0c\u800c\u9ed8\u8ba4\u662f\u8ffd\u52a0\u5230\u961f\u5c3e\u3002once\u6ce8\u518c\u7684\u5904\u7406\u51fd\u6570\uff0c\u6700\u591a\u88ab\u6267\u884c\u4e00\u6b21\u3002\u56db\u4e2aAPI\u90fd\u662f\u901a\u8fc7_addListener\u51fd\u6570\u5b9e\u73b0\u7684\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 function _addListener ( target , type , listener , prepend ) { let m ; let events ; let existing ; events = target . _events ; // \u8fd8\u6ca1\u6709\u521d\u59cb\u5316_events\u5219\u521d\u59cb\u5316 if ( events === undefined ) { events = target . _events = ObjectCreate ( null ); target . _eventsCount = 0 ; } else { /* \u662f\u5426\u5b9a\u4e49\u4e86newListener\u4e8b\u4ef6\uff0c\u662f\u7684\u8bdd\u5148\u89e6\u53d1,\u5982\u679c\u76d1\u542c\u4e86newListener\u4e8b\u4ef6\uff0c \u6bcf\u6b21\u6ce8\u518c\u5176\u4ed6\u4e8b\u4ef6\u65f6\u90fd\u4f1a\u89e6\u53d1newListener\uff0c\u76f8\u5f53\u4e8e\u94a9\u5b50 */ if ( events . newListener !== undefined ) { target . emit ( 'newListener' , type , listener . listener ? listener . listener : listener ); // \u53ef\u80fd\u4f1a\u4fee\u6539_events\uff0c\u8fd9\u91cc\u91cd\u65b0\u8d4b\u503c events = target . _events ; } // \u5224\u65ad\u662f\u5426\u5df2\u7ecf\u5b58\u5728\u5904\u7406\u51fd\u6570 existing = events [ type ]; } // \u4e0d\u5b58\u5728\u5219\u4ee5\u51fd\u6570\u7684\u5f62\u5f0f\u5b58\u50a8\uff0c\u5426\u5219\u662f\u6570\u7ec4 if ( existing === undefined ) { events [ type ] = listener ; ++ target . _eventsCount ; } else { if ( typeof existing === 'function' ) { existing = events [ type ] = prepend ? [ listener , existing ] : [ existing , listener ]; } else if ( prepend ) { existing . unshift ( listener ); } else { existing . push ( listener ); } // \u5904\u7406\u544a\u8b66\uff0c\u5904\u7406\u51fd\u6570\u8fc7\u591a\u53ef\u80fd\u662f\u56e0\u4e3a\u4e4b\u524d\u7684\u6ca1\u6709\u5220\u9664\uff0c\u9020\u6210\u5185\u5b58\u6cc4\u6f0f m = _getMaxListeners ( target ); if ( m > 0 && existing . length > m && ! existing . warned ) { existing . warned = true ; const w = new Error ( 'Possible EventEmitter memory leak detected. ' + ` ${ existing . length } ${ String ( type ) } listeners ` + `added to ${ inspect ( target , { depth : - 1 } )}. Use ` + 'emitter.setMaxListeners() to increase limit' ); w . name = 'MaxListenersExceededWarning' ; w . emitter = target ; w . type = type ; w . count = existing . length ; process . emitWarning ( w ); } } return target ; } \u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0bonce\u7684\u5b9e\u73b0\uff0c\u5bf9\u6bd4\u5176\u4ed6\u51e0\u79cdapi\uff0conce\u7684\u5b9e\u73b0\u76f8\u5bf9\u6bd4\u8f83\u96be\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u63a7\u5236\u5904\u7406\u51fd\u6570\u6700\u591a\u6267\u884c\u4e00\u6b21\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u575a\u6301\u7528\u6237\u5b9a\u4e49\u7684\u51fd\u6570\uff0c\u4fdd\u8bc1\u5728\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u6267\u884c\u7528\u6237\u5b9a\u4e49\u51fd\u6570\u7684\u540c\u65f6\uff0c\u8fd8\u9700\u8981\u5220\u9664\u6ce8\u518c\u7684\u4e8b\u4ef6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 EventEmitter . prototype . once = function once ( type , listener ) { this . on ( type , _onceWrap ( this , type , listener )); return this ; }; function onceWrapper () { // \u8fd8\u6ca1\u6709\u89e6\u53d1\u8fc7 if ( ! this . fired ) { // \u5220\u9664\u4ed6 this . target . removeListener ( this . type , this . wrapFn ); // \u89e6\u53d1\u4e86 this . fired = true ; // \u6267\u884c if ( arguments . length === 0 ) return this . listener . call ( this . target ); return this . listener . apply ( this . target , arguments ); } } // \u652f\u6301once api function _onceWrap ( target , type , listener ) { // fired\u662f\u5426\u5df2\u6267\u884c\u5904\u7406\u51fd\u6570\uff0cwrapFn\u5305\u88f9listener\u7684\u51fd\u6570 const state = { fired : false , wrapFn : undefined , target , type , listener }; // \u751f\u6210\u4e00\u4e2a\u5305\u88f9listener\u7684\u51fd\u6570 const wrapped = onceWrapper . bind ( state ); // \u628a\u539f\u51fd\u6570listener\u4e5f\u6302\u5230\u5305\u88f9\u51fd\u6570\u4e2d\uff0c\u7528\u4e8e\u4e8b\u4ef6\u6ca1\u6709\u89e6\u53d1\u524d\uff0c\u7528\u6237\u4e3b\u52a8\u5220\u9664\uff0c\u89c1removeListener wrapped . listener = listener ; // \u4fdd\u5b58\u5305\u88f9\u51fd\u6570\uff0c\u7528\u4e8e\u6267\u884c\u5b8c\u540e\u5220\u9664\uff0c\u89c1onceWrapper state . wrapFn = wrapped ; return wrapped ; } 22.3 \u89e6\u53d1\u4e8b\u4ef6 \u00b6 \u5206\u6790\u5b8c\u4e8b\u4ef6\u7684\u8ba2\u9605\uff0c\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u4e8b\u4ef6\u7684\u89e6\u53d1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 EventEmitter . prototype . emit = function emit ( type , ... args ) { // \u89e6\u53d1\u7684\u4e8b\u4ef6\u662f\u5426\u662ferror\uff0cerror\u4e8b\u4ef6\u9700\u8981\u7279\u6b8a\u5904\u7406 let doError = ( type === 'error' ); const events = this . _events ; // \u5b9a\u4e49\u4e86\u5904\u7406\u51fd\u6570\uff08\u4e0d\u4e00\u5b9a\u662ftype\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\uff09 if ( events !== undefined ) { // \u5982\u679c\u89e6\u53d1\u7684\u4e8b\u4ef6\u662ferror\uff0c\u5e76\u4e14\u76d1\u542c\u4e86kErrorMonitor\u4e8b\u4ef6\u5219\u89e6\u53d1kErrorMonitor\u4e8b\u4ef6 if ( doError && events [ kErrorMonitor ] !== undefined ) this . emit ( kErrorMonitor , ... args ); // \u89e6\u53d1\u7684\u662ferror\u4e8b\u4ef6\u4f46\u662f\u6ca1\u6709\u5b9a\u4e49\u5904\u7406\u51fd\u6570 doError = ( doError && events . error === undefined ); } else if ( ! doError ) // \u6ca1\u6709\u5b9a\u4e49\u5904\u7406\u51fd\u6570\u5e76\u4e14\u89e6\u53d1\u7684\u4e0d\u662ferror\u4e8b\u4ef6\u5219\u4e0d\u9700\u8981\u5904\u7406\uff0c return false ; // If there is no 'error' event listener then throw. // \u89e6\u53d1\u7684\u662ferror\u4e8b\u4ef6\uff0c\u4f46\u662f\u6ca1\u6709\u5b9a\u4e49\u5904\u7406error\u4e8b\u4ef6\u7684\u51fd\u6570\uff0c\u5219\u62a5\u9519 if ( doError ) { let er ; if ( args . length > 0 ) er = args [ 0 ]; // \u7b2c\u4e00\u4e2a\u5165\u53c2\u662fError\u7684\u5b9e\u4f8b if ( er instanceof Error ) { try { const capture = {}; /* \u7ed9capture\u5bf9\u8c61\u6ce8\u5165stack\u5c5e\u6027\uff0cstack\u7684\u503c\u662f\u6267\u884cError.captureStackTrace \u8bed\u53e5\u7684\u5f53\u524d\u6808\u4fe1\u606f\uff0c\u4f46\u662f\u4e0d\u5305\u62ecemit\u7684\u90e8\u5206 */ Error . captureStackTrace ( capture , EventEmitter . prototype . emit ); ObjectDefineProperty ( er , kEnhanceStackBeforeInspector , { value : enhanceStackTrace . bind ( this , er , capture ), configurable : true }); } catch {} throw er ; // Unhandled 'error' event } let stringifiedEr ; const { inspect } = require ( 'internal/util/inspect' ); try { stringifiedEr = inspect ( er ); } catch { stringifiedEr = er ; } const err = new ERR_UNHANDLED_ERROR ( stringifiedEr ); err . context = er ; throw err ; // Unhandled 'error' event } // \u83b7\u53d6type\u4e8b\u4ef6\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570 const handler = events [ type ]; // \u6ca1\u6709\u5219\u4e0d\u5904\u7406 if ( handler === undefined ) return false ; // \u7b49\u4e8e\u51fd\u6570\u8bf4\u660e\u53ea\u6709\u4e00\u4e2a if ( typeof handler === 'function' ) { // \u76f4\u63a5\u6267\u884c const result = ReflectApply ( handler , this , args ); // \u975e\u7a7a\u5224\u65ad\u662f\u4e0d\u662fpromise\u5e76\u4e14\u662f\u5426\u9700\u8981\u5904\u7406\uff0c\u89c1addCatch if ( result !== undefined && result !== null ) { addCatch ( this , result , type , args ); } } else { // \u591a\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u540c\u4e0a const len = handler . length ; const listeners = arrayClone ( handler , len ); for ( let i = 0 ; i < len ; ++ i ) { const result = ReflectApply ( listeners [ i ], this , args ); if ( result !== undefined && result !== null ) { addCatch ( this , result , type , args ); } } } return true ; } \u6211\u4eec\u770b\u5230\u5728Node.js\u4e2d\uff0c\u5bf9\u4e8eerror\u4e8b\u4ef6\u662f\u7279\u6b8a\u5904\u7406\u7684\uff0c\u5982\u679c\u7528\u6237\u6ca1\u6709\u6ce8\u518cerror\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u7a0b\u5e8f\u6302\u6389\uff0c\u53e6\u5916\u6211\u4eec\u770b\u5230\u6709\u4e00\u4e2aaddCatch\u7684\u903b\u8f91\uff0caddCatch\u662f\u4e3a\u4e86\u652f\u6301\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u4e3a\u5f02\u6b65\u6a21\u5f0f\u7684\u60c5\u51b5\uff0c\u6bd4\u5982async\u51fd\u6570\u6216\u8005\u8fd4\u56dePromise\u7684\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 function addCatch ( that , promise , type , args ) { // \u6ca1\u6709\u5f00\u542f\u6355\u83b7\u5219\u4e0d\u9700\u8981\u5904\u7406 if ( ! that [ kCapture ]) { return ; } // that throws on second use. try { const then = promise . then ; if ( typeof then === 'function' ) { // \u6ce8\u518creject\u7684\u5904\u7406\u51fd\u6570 then . call ( promise , undefined , function ( err ) { process . nextTick ( emitUnhandledRejectionOrErr , that , err , type , args ); }); } } catch ( err ) { that . emit ( 'error' , err ); } } function emitUnhandledRejectionOrErr ( ee , err , type , args ) { // \u7528\u6237\u5b9e\u73b0\u4e86kRejection\u5219\u6267\u884c if ( typeof ee [ kRejection ] === 'function' ) { ee [ kRejection ]( err , type , ... args ); } else { // \u4fdd\u5b58\u5f53\u524d\u503c const prev = ee [ kCapture ]; try { /* \u5173\u95ed\u7136\u540e\u89e6\u53d1error\u4e8b\u4ef6\uff0c\u610f\u4e49 1 \u9632\u6b62error\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u4e5f\u629b\u51faerror\uff0c\u5bfc\u81f4\u6b7b\u5faa\u73af 2 \u5982\u679c\u7528\u6237\u5904\u7406\u4e86error\uff0c\u5219\u8fdb\u7a0b\u4e0d\u4f1a\u9000\u51fa\uff0c\u6240\u4ee5\u9700\u8981\u6062\u590dkCapture\u7684\u503c \u5982\u679c\u7528\u6237\u6ca1\u6709\u5904\u7406error\uff0c\u5219nodejs\u4f1a\u89e6\u53d1uncaughtException\uff0c\u5982\u679c\u7528\u6237 \u5904\u7406\u4e86uncaughtException\u5219\u9700\u8981\u7070\u5ea6kCapture\u7684\u503c */ ee [ kCapture ] = false ; ee . emit ( 'error' , err ); } finally { ee [ kCapture ] = prev ; } } } 22.4 \u53d6\u6d88\u8ba2\u9605 \u00b6 \u6211\u4eec\u63a5\u7740\u770b\u4e00\u4e0b\u5220\u9664\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 function removeAllListeners ( type ) { const events = this . _events ; if ( events === undefined ) return this ; // \u6ca1\u6709\u6ce8\u518cremoveListener\u4e8b\u4ef6\uff0c\u5219\u53ea\u9700\u8981\u5220\u9664\u6570\u636e\uff0c\u5426\u5219\u8fd8\u9700\u8981\u89e6\u53d1removeListener\u4e8b\u4ef6 if ( events . removeListener === undefined ) { // \u7b49\u4e8e0\u8bf4\u660e\u662f\u5220\u9664\u5168\u90e8 if ( arguments . length === 0 ) { this . _events = ObjectCreate ( null ); this . _eventsCount = 0 ; } else if ( events [ type ] !== undefined ) { // \u5426\u5219\u662f\u5220\u9664\u67d0\u4e2a\u7c7b\u578b\u7684\u4e8b\u4ef6\uff0c // \u662f\u552f\u4e00\u4e00\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u5219\u91cd\u7f6e_events\uff0c\u5426\u5219\u5220\u9664\u5bf9\u5e94\u7684\u4e8b\u4ef6\u7c7b\u578b if ( -- this . _eventsCount === 0 ) this . _events = ObjectCreate ( null ); else delete events [ type ]; } return this ; } // \u8bf4\u660e\u6ce8\u518c\u4e86removeListener\u4e8b\u4ef6\uff0carguments.length === 0\u8bf4\u660e\u5220\u9664\u6240\u6709\u7c7b\u578b\u7684\u4e8b\u4ef6 if ( arguments . length === 0 ) { // \u9010\u4e2a\u5220\u9664\uff0c\u9664\u4e86removeListener\u4e8b\u4ef6\uff0c\u8fd9\u91cc\u5220\u9664\u4e86\u975eremoveListener\u4e8b\u4ef6 for ( const key of ObjectKeys ( events )) { if ( key === 'removeListener' ) continue ; this . removeAllListeners ( key ); } // \u8fd9\u91cc\u5220\u9664removeListener\u4e8b\u4ef6\uff0c\u89c1\u4e0b\u9762\u7684\u903b\u8f91 this . removeAllListeners ( 'removeListener' ); // \u91cd\u7f6e\u6570\u636e\u7ed3\u6784 this . _events = ObjectCreate ( null ); this . _eventsCount = 0 ; return this ; } // \u5220\u9664\u67d0\u7c7b\u578b\u4e8b\u4ef6 const listeners = events [ type ]; if ( typeof listeners === 'function' ) { this . removeListener ( type , listeners ); } else if ( listeners !== undefined ) { // LIFO order for ( let i = listeners . length - 1 ; i >= 0 ; i -- ) { this . removeListener ( type , listeners [ i ]); } } return this ; } removeAllListeners\u51fd\u6570\u4e3b\u8981\u7684\u903b\u8f91\u6709\u4e24\u70b9\uff0c\u7b2c\u4e00\u4e2a\u662fremoveListener\u4e8b\u4ef6\u9700\u8981\u7279\u6b8a\u5904\u7406\uff0c\u8fd9\u7c7b\u4f3c\u4e00\u4e2a\u94a9\u5b50\uff0c\u6bcf\u6b21\u7528\u6237\u5220\u9664\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u7684\u65f6\u5019\u90fd\u4f1a\u89e6\u53d1\u8be5\u4e8b\u4ef6\u3002\u7b2c\u4e8c\u662fremoveListener\u51fd\u6570\u3002removeListener\u662f\u771f\u6b63\u5220\u9664\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u7684\u5b9e\u73b0\u3002removeAllListeners\u662f\u5c01\u88c5\u4e86removeListener\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 function removeListener ( type , listener ) { let originalListener ; const events = this . _events ; // \u6ca1\u6709\u4e1c\u897f\u53ef\u5220\u9664 if ( events === undefined ) return this ; const list = events [ type ]; // \u540c\u4e0a if ( list === undefined ) return this ; // list\u662f\u51fd\u6570\u8bf4\u660e\u53ea\u6709\u4e00\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u5426\u5219\u662f\u6570\u7ec4,\u5982\u679clist.listener === listener\u8bf4\u660e\u662fonce\u6ce8\u518c\u7684 if ( list === listener || list . listener === listener ) { // type\u7c7b\u578b\u7684\u5904\u7406\u51fd\u6570\u5c31\u4e00\u4e2a\uff0c\u5e76\u4e14\u4e5f\u6ca1\u6709\u6ce8\u518c\u5176\u4ed6\u7c7b\u578b\u7684\u4e8b\u4ef6\uff0c\u5219\u521d\u59cb\u5316_events if ( -- this . _eventsCount === 0 ) this . _events = ObjectCreate ( null ); else { // \u5c31\u4e00\u4e2a\u6267\u884c\u5b8c\u5220\u9664type\u5bf9\u5e94\u7684\u5c5e\u6027 delete events [ type ]; // \u6ce8\u518c\u4e86removeListener\u4e8b\u4ef6\uff0c\u5219\u5148\u6ce8\u518cremoveListener\u4e8b\u4ef6 if ( events . removeListener ) this . emit ( 'removeListener' , type , list . listener || listener ); } } else if ( typeof list !== 'function' ) { // \u591a\u4e2a\u5904\u7406\u51fd\u6570 let position = - 1 ; // \u627e\u51fa\u9700\u8981\u5220\u9664\u7684\u51fd\u6570 for ( let i = list . length - 1 ; i >= 0 ; i -- ) { if ( list [ i ] === listener || list [ i ]. listener === listener ) { // \u4fdd\u5b58\u539f\u5904\u7406\u51fd\u6570\uff0c\u5982\u679c\u6709\u7684\u8bdd originalListener = list [ i ]. listener ; position = i ; break ; } } if ( position < 0 ) return this ; // \u7b2c\u4e00\u4e2a\u5219\u51fa\u961f\uff0c\u5426\u5219\u5220\u9664\u4e00\u4e2a if ( position === 0 ) list . shift (); else { if ( spliceOne === undefined ) spliceOne = require ( 'internal/util' ). spliceOne ; spliceOne ( list , position ); } // \u5982\u679c\u53ea\u5269\u4e0b\u4e00\u4e2a\uff0c\u5219\u503c\u6539\u6210\u51fd\u6570\u7c7b\u578b if ( list . length === 1 ) events [ type ] = list [ 0 ]; // \u89e6\u53d1removeListener if ( events . removeListener !== undefined ) this . emit ( 'removeListener' , type , originalListener || listener ); } return this ; }; \u4ee5\u4e0a\u5c31\u662fevents\u6a21\u5757\u7684\u6838\u5fc3\u903b\u8f91\uff0c\u53e6\u5916\u8fd8\u6709\u4e00\u4e9b\u5de5\u5177\u51fd\u6570\u5c31\u4e0d\u4e00\u4e00\u5206\u6790\u3002","title":"21-events\u6a21\u5757"},{"location":"chapter22-events%E6%A8%A1%E5%9D%97/#221","text":"\u5f53new\u4e00\u4e2aEventEmitter\u6216\u8005\u4ed6\u7684\u5b50\u7c7b\u65f6\uff0c\u5c31\u4f1a\u8fdb\u5165EventEmitter\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 function EventEmitter ( opts ) { EventEmitter . init . call ( this , opts ); } EventEmitter . init = function ( opts ) { // \u5982\u679c\u662f\u672a\u521d\u59cb\u5316\u6216\u8005\u6ca1\u6709\u81ea\u5b9a\u4e49_events\uff0c\u5219\u521d\u59cb\u5316 if ( this . _events === undefined || this . _events === ObjectGetPrototypeOf ( this ). _events ) { this . _events = ObjectCreate ( null ); this . _eventsCount = 0 ; } // \u521d\u59cb\u5316\u5904\u7406\u51fd\u6570\u4e2a\u6570\u7684\u9608\u503c this . _maxListeners = this . _maxListeners || undefined ; // \u662f\u5426\u5f00\u542f\u6355\u83b7promise reject,\u9ed8\u8ba4false if ( opts && opts . captureRejections ) { this [ kCapture ] = Boolean ( opts . captureRejections ); } else { this [ kCapture ] = EventEmitter . prototype [ kCapture ]; } }; EventEmitter\u7684\u521d\u59cb\u5316\u4e3b\u8981\u662f\u521d\u59cb\u5316\u4e86\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u548c\u5c5e\u6027\u3002\u552f\u4e00\u652f\u6301\u7684\u4e00\u4e2a\u53c2\u6570\u5c31\u662fcaptureRejections\uff0ccaptureRejections\u8868\u793a\u5f53\u89e6\u53d1\u4e8b\u4ef6\uff0c\u6267\u884c\u5904\u7406\u51fd\u6570\u65f6\uff0cEventEmitter\u662f\u5426\u6355\u83b7\u5904\u7406\u51fd\u6570\u4e2d\u7684\u5f02\u5e38\u3002\u540e\u9762\u6211\u4eec\u4f1a\u8be6\u7ec6\u8bb2\u89e3\u3002","title":"22.1 \u521d\u59cb\u5316"},{"location":"chapter22-events%E6%A8%A1%E5%9D%97/#222","text":"\u521d\u59cb\u5316\u5b8cEventEmitter\u4e4b\u540e\uff0c\u6211\u4eec\u5c31\u53ef\u4ee5\u5f00\u59cb\u4f7f\u7528\u8ba2\u9605\u3001\u53d1\u5e03\u7684\u529f\u80fd\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7addListener\u3001prependListener\u3001on\u3001once\u8ba2\u9605\u4e8b\u4ef6\u3002addListener\u548con\u662f\u7b49\u4ef7\u7684\uff0cprependListener\u7684\u533a\u522b\u5728\u4e8e\u5904\u7406\u51fd\u6570\u4f1a\u88ab\u63d2\u5165\u5230\u961f\u9996\uff0c\u800c\u9ed8\u8ba4\u662f\u8ffd\u52a0\u5230\u961f\u5c3e\u3002once\u6ce8\u518c\u7684\u5904\u7406\u51fd\u6570\uff0c\u6700\u591a\u88ab\u6267\u884c\u4e00\u6b21\u3002\u56db\u4e2aAPI\u90fd\u662f\u901a\u8fc7_addListener\u51fd\u6570\u5b9e\u73b0\u7684\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 function _addListener ( target , type , listener , prepend ) { let m ; let events ; let existing ; events = target . _events ; // \u8fd8\u6ca1\u6709\u521d\u59cb\u5316_events\u5219\u521d\u59cb\u5316 if ( events === undefined ) { events = target . _events = ObjectCreate ( null ); target . _eventsCount = 0 ; } else { /* \u662f\u5426\u5b9a\u4e49\u4e86newListener\u4e8b\u4ef6\uff0c\u662f\u7684\u8bdd\u5148\u89e6\u53d1,\u5982\u679c\u76d1\u542c\u4e86newListener\u4e8b\u4ef6\uff0c \u6bcf\u6b21\u6ce8\u518c\u5176\u4ed6\u4e8b\u4ef6\u65f6\u90fd\u4f1a\u89e6\u53d1newListener\uff0c\u76f8\u5f53\u4e8e\u94a9\u5b50 */ if ( events . newListener !== undefined ) { target . emit ( 'newListener' , type , listener . listener ? listener . listener : listener ); // \u53ef\u80fd\u4f1a\u4fee\u6539_events\uff0c\u8fd9\u91cc\u91cd\u65b0\u8d4b\u503c events = target . _events ; } // \u5224\u65ad\u662f\u5426\u5df2\u7ecf\u5b58\u5728\u5904\u7406\u51fd\u6570 existing = events [ type ]; } // \u4e0d\u5b58\u5728\u5219\u4ee5\u51fd\u6570\u7684\u5f62\u5f0f\u5b58\u50a8\uff0c\u5426\u5219\u662f\u6570\u7ec4 if ( existing === undefined ) { events [ type ] = listener ; ++ target . _eventsCount ; } else { if ( typeof existing === 'function' ) { existing = events [ type ] = prepend ? [ listener , existing ] : [ existing , listener ]; } else if ( prepend ) { existing . unshift ( listener ); } else { existing . push ( listener ); } // \u5904\u7406\u544a\u8b66\uff0c\u5904\u7406\u51fd\u6570\u8fc7\u591a\u53ef\u80fd\u662f\u56e0\u4e3a\u4e4b\u524d\u7684\u6ca1\u6709\u5220\u9664\uff0c\u9020\u6210\u5185\u5b58\u6cc4\u6f0f m = _getMaxListeners ( target ); if ( m > 0 && existing . length > m && ! existing . warned ) { existing . warned = true ; const w = new Error ( 'Possible EventEmitter memory leak detected. ' + ` ${ existing . length } ${ String ( type ) } listeners ` + `added to ${ inspect ( target , { depth : - 1 } )}. Use ` + 'emitter.setMaxListeners() to increase limit' ); w . name = 'MaxListenersExceededWarning' ; w . emitter = target ; w . type = type ; w . count = existing . length ; process . emitWarning ( w ); } } return target ; } \u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0bonce\u7684\u5b9e\u73b0\uff0c\u5bf9\u6bd4\u5176\u4ed6\u51e0\u79cdapi\uff0conce\u7684\u5b9e\u73b0\u76f8\u5bf9\u6bd4\u8f83\u96be\uff0c\u56e0\u4e3a\u6211\u4eec\u8981\u63a7\u5236\u5904\u7406\u51fd\u6570\u6700\u591a\u6267\u884c\u4e00\u6b21\uff0c\u6240\u4ee5\u6211\u4eec\u9700\u8981\u575a\u6301\u7528\u6237\u5b9a\u4e49\u7684\u51fd\u6570\uff0c\u4fdd\u8bc1\u5728\u4e8b\u4ef6\u89e6\u53d1\u7684\u65f6\u5019\uff0c\u6267\u884c\u7528\u6237\u5b9a\u4e49\u51fd\u6570\u7684\u540c\u65f6\uff0c\u8fd8\u9700\u8981\u5220\u9664\u6ce8\u518c\u7684\u4e8b\u4ef6\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 EventEmitter . prototype . once = function once ( type , listener ) { this . on ( type , _onceWrap ( this , type , listener )); return this ; }; function onceWrapper () { // \u8fd8\u6ca1\u6709\u89e6\u53d1\u8fc7 if ( ! this . fired ) { // \u5220\u9664\u4ed6 this . target . removeListener ( this . type , this . wrapFn ); // \u89e6\u53d1\u4e86 this . fired = true ; // \u6267\u884c if ( arguments . length === 0 ) return this . listener . call ( this . target ); return this . listener . apply ( this . target , arguments ); } } // \u652f\u6301once api function _onceWrap ( target , type , listener ) { // fired\u662f\u5426\u5df2\u6267\u884c\u5904\u7406\u51fd\u6570\uff0cwrapFn\u5305\u88f9listener\u7684\u51fd\u6570 const state = { fired : false , wrapFn : undefined , target , type , listener }; // \u751f\u6210\u4e00\u4e2a\u5305\u88f9listener\u7684\u51fd\u6570 const wrapped = onceWrapper . bind ( state ); // \u628a\u539f\u51fd\u6570listener\u4e5f\u6302\u5230\u5305\u88f9\u51fd\u6570\u4e2d\uff0c\u7528\u4e8e\u4e8b\u4ef6\u6ca1\u6709\u89e6\u53d1\u524d\uff0c\u7528\u6237\u4e3b\u52a8\u5220\u9664\uff0c\u89c1removeListener wrapped . listener = listener ; // \u4fdd\u5b58\u5305\u88f9\u51fd\u6570\uff0c\u7528\u4e8e\u6267\u884c\u5b8c\u540e\u5220\u9664\uff0c\u89c1onceWrapper state . wrapFn = wrapped ; return wrapped ; }","title":"22.2 \u8ba2\u9605\u4e8b\u4ef6"},{"location":"chapter22-events%E6%A8%A1%E5%9D%97/#223","text":"\u5206\u6790\u5b8c\u4e8b\u4ef6\u7684\u8ba2\u9605\uff0c\u63a5\u7740\u6211\u4eec\u770b\u4e00\u4e0b\u4e8b\u4ef6\u7684\u89e6\u53d1\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 EventEmitter . prototype . emit = function emit ( type , ... args ) { // \u89e6\u53d1\u7684\u4e8b\u4ef6\u662f\u5426\u662ferror\uff0cerror\u4e8b\u4ef6\u9700\u8981\u7279\u6b8a\u5904\u7406 let doError = ( type === 'error' ); const events = this . _events ; // \u5b9a\u4e49\u4e86\u5904\u7406\u51fd\u6570\uff08\u4e0d\u4e00\u5b9a\u662ftype\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\uff09 if ( events !== undefined ) { // \u5982\u679c\u89e6\u53d1\u7684\u4e8b\u4ef6\u662ferror\uff0c\u5e76\u4e14\u76d1\u542c\u4e86kErrorMonitor\u4e8b\u4ef6\u5219\u89e6\u53d1kErrorMonitor\u4e8b\u4ef6 if ( doError && events [ kErrorMonitor ] !== undefined ) this . emit ( kErrorMonitor , ... args ); // \u89e6\u53d1\u7684\u662ferror\u4e8b\u4ef6\u4f46\u662f\u6ca1\u6709\u5b9a\u4e49\u5904\u7406\u51fd\u6570 doError = ( doError && events . error === undefined ); } else if ( ! doError ) // \u6ca1\u6709\u5b9a\u4e49\u5904\u7406\u51fd\u6570\u5e76\u4e14\u89e6\u53d1\u7684\u4e0d\u662ferror\u4e8b\u4ef6\u5219\u4e0d\u9700\u8981\u5904\u7406\uff0c return false ; // If there is no 'error' event listener then throw. // \u89e6\u53d1\u7684\u662ferror\u4e8b\u4ef6\uff0c\u4f46\u662f\u6ca1\u6709\u5b9a\u4e49\u5904\u7406error\u4e8b\u4ef6\u7684\u51fd\u6570\uff0c\u5219\u62a5\u9519 if ( doError ) { let er ; if ( args . length > 0 ) er = args [ 0 ]; // \u7b2c\u4e00\u4e2a\u5165\u53c2\u662fError\u7684\u5b9e\u4f8b if ( er instanceof Error ) { try { const capture = {}; /* \u7ed9capture\u5bf9\u8c61\u6ce8\u5165stack\u5c5e\u6027\uff0cstack\u7684\u503c\u662f\u6267\u884cError.captureStackTrace \u8bed\u53e5\u7684\u5f53\u524d\u6808\u4fe1\u606f\uff0c\u4f46\u662f\u4e0d\u5305\u62ecemit\u7684\u90e8\u5206 */ Error . captureStackTrace ( capture , EventEmitter . prototype . emit ); ObjectDefineProperty ( er , kEnhanceStackBeforeInspector , { value : enhanceStackTrace . bind ( this , er , capture ), configurable : true }); } catch {} throw er ; // Unhandled 'error' event } let stringifiedEr ; const { inspect } = require ( 'internal/util/inspect' ); try { stringifiedEr = inspect ( er ); } catch { stringifiedEr = er ; } const err = new ERR_UNHANDLED_ERROR ( stringifiedEr ); err . context = er ; throw err ; // Unhandled 'error' event } // \u83b7\u53d6type\u4e8b\u4ef6\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570 const handler = events [ type ]; // \u6ca1\u6709\u5219\u4e0d\u5904\u7406 if ( handler === undefined ) return false ; // \u7b49\u4e8e\u51fd\u6570\u8bf4\u660e\u53ea\u6709\u4e00\u4e2a if ( typeof handler === 'function' ) { // \u76f4\u63a5\u6267\u884c const result = ReflectApply ( handler , this , args ); // \u975e\u7a7a\u5224\u65ad\u662f\u4e0d\u662fpromise\u5e76\u4e14\u662f\u5426\u9700\u8981\u5904\u7406\uff0c\u89c1addCatch if ( result !== undefined && result !== null ) { addCatch ( this , result , type , args ); } } else { // \u591a\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u540c\u4e0a const len = handler . length ; const listeners = arrayClone ( handler , len ); for ( let i = 0 ; i < len ; ++ i ) { const result = ReflectApply ( listeners [ i ], this , args ); if ( result !== undefined && result !== null ) { addCatch ( this , result , type , args ); } } } return true ; } \u6211\u4eec\u770b\u5230\u5728Node.js\u4e2d\uff0c\u5bf9\u4e8eerror\u4e8b\u4ef6\u662f\u7279\u6b8a\u5904\u7406\u7684\uff0c\u5982\u679c\u7528\u6237\u6ca1\u6709\u6ce8\u518cerror\u4e8b\u4ef6\u7684\u5904\u7406\u51fd\u6570\uff0c\u53ef\u80fd\u4f1a\u5bfc\u81f4\u7a0b\u5e8f\u6302\u6389\uff0c\u53e6\u5916\u6211\u4eec\u770b\u5230\u6709\u4e00\u4e2aaddCatch\u7684\u903b\u8f91\uff0caddCatch\u662f\u4e3a\u4e86\u652f\u6301\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u4e3a\u5f02\u6b65\u6a21\u5f0f\u7684\u60c5\u51b5\uff0c\u6bd4\u5982async\u51fd\u6570\u6216\u8005\u8fd4\u56dePromise\u7684\u51fd\u6570\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 function addCatch ( that , promise , type , args ) { // \u6ca1\u6709\u5f00\u542f\u6355\u83b7\u5219\u4e0d\u9700\u8981\u5904\u7406 if ( ! that [ kCapture ]) { return ; } // that throws on second use. try { const then = promise . then ; if ( typeof then === 'function' ) { // \u6ce8\u518creject\u7684\u5904\u7406\u51fd\u6570 then . call ( promise , undefined , function ( err ) { process . nextTick ( emitUnhandledRejectionOrErr , that , err , type , args ); }); } } catch ( err ) { that . emit ( 'error' , err ); } } function emitUnhandledRejectionOrErr ( ee , err , type , args ) { // \u7528\u6237\u5b9e\u73b0\u4e86kRejection\u5219\u6267\u884c if ( typeof ee [ kRejection ] === 'function' ) { ee [ kRejection ]( err , type , ... args ); } else { // \u4fdd\u5b58\u5f53\u524d\u503c const prev = ee [ kCapture ]; try { /* \u5173\u95ed\u7136\u540e\u89e6\u53d1error\u4e8b\u4ef6\uff0c\u610f\u4e49 1 \u9632\u6b62error\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u4e5f\u629b\u51faerror\uff0c\u5bfc\u81f4\u6b7b\u5faa\u73af 2 \u5982\u679c\u7528\u6237\u5904\u7406\u4e86error\uff0c\u5219\u8fdb\u7a0b\u4e0d\u4f1a\u9000\u51fa\uff0c\u6240\u4ee5\u9700\u8981\u6062\u590dkCapture\u7684\u503c \u5982\u679c\u7528\u6237\u6ca1\u6709\u5904\u7406error\uff0c\u5219nodejs\u4f1a\u89e6\u53d1uncaughtException\uff0c\u5982\u679c\u7528\u6237 \u5904\u7406\u4e86uncaughtException\u5219\u9700\u8981\u7070\u5ea6kCapture\u7684\u503c */ ee [ kCapture ] = false ; ee . emit ( 'error' , err ); } finally { ee [ kCapture ] = prev ; } } }","title":"22.3 \u89e6\u53d1\u4e8b\u4ef6"},{"location":"chapter22-events%E6%A8%A1%E5%9D%97/#224","text":"\u6211\u4eec\u63a5\u7740\u770b\u4e00\u4e0b\u5220\u9664\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 function removeAllListeners ( type ) { const events = this . _events ; if ( events === undefined ) return this ; // \u6ca1\u6709\u6ce8\u518cremoveListener\u4e8b\u4ef6\uff0c\u5219\u53ea\u9700\u8981\u5220\u9664\u6570\u636e\uff0c\u5426\u5219\u8fd8\u9700\u8981\u89e6\u53d1removeListener\u4e8b\u4ef6 if ( events . removeListener === undefined ) { // \u7b49\u4e8e0\u8bf4\u660e\u662f\u5220\u9664\u5168\u90e8 if ( arguments . length === 0 ) { this . _events = ObjectCreate ( null ); this . _eventsCount = 0 ; } else if ( events [ type ] !== undefined ) { // \u5426\u5219\u662f\u5220\u9664\u67d0\u4e2a\u7c7b\u578b\u7684\u4e8b\u4ef6\uff0c // \u662f\u552f\u4e00\u4e00\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u5219\u91cd\u7f6e_events\uff0c\u5426\u5219\u5220\u9664\u5bf9\u5e94\u7684\u4e8b\u4ef6\u7c7b\u578b if ( -- this . _eventsCount === 0 ) this . _events = ObjectCreate ( null ); else delete events [ type ]; } return this ; } // \u8bf4\u660e\u6ce8\u518c\u4e86removeListener\u4e8b\u4ef6\uff0carguments.length === 0\u8bf4\u660e\u5220\u9664\u6240\u6709\u7c7b\u578b\u7684\u4e8b\u4ef6 if ( arguments . length === 0 ) { // \u9010\u4e2a\u5220\u9664\uff0c\u9664\u4e86removeListener\u4e8b\u4ef6\uff0c\u8fd9\u91cc\u5220\u9664\u4e86\u975eremoveListener\u4e8b\u4ef6 for ( const key of ObjectKeys ( events )) { if ( key === 'removeListener' ) continue ; this . removeAllListeners ( key ); } // \u8fd9\u91cc\u5220\u9664removeListener\u4e8b\u4ef6\uff0c\u89c1\u4e0b\u9762\u7684\u903b\u8f91 this . removeAllListeners ( 'removeListener' ); // \u91cd\u7f6e\u6570\u636e\u7ed3\u6784 this . _events = ObjectCreate ( null ); this . _eventsCount = 0 ; return this ; } // \u5220\u9664\u67d0\u7c7b\u578b\u4e8b\u4ef6 const listeners = events [ type ]; if ( typeof listeners === 'function' ) { this . removeListener ( type , listeners ); } else if ( listeners !== undefined ) { // LIFO order for ( let i = listeners . length - 1 ; i >= 0 ; i -- ) { this . removeListener ( type , listeners [ i ]); } } return this ; } removeAllListeners\u51fd\u6570\u4e3b\u8981\u7684\u903b\u8f91\u6709\u4e24\u70b9\uff0c\u7b2c\u4e00\u4e2a\u662fremoveListener\u4e8b\u4ef6\u9700\u8981\u7279\u6b8a\u5904\u7406\uff0c\u8fd9\u7c7b\u4f3c\u4e00\u4e2a\u94a9\u5b50\uff0c\u6bcf\u6b21\u7528\u6237\u5220\u9664\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u7684\u65f6\u5019\u90fd\u4f1a\u89e6\u53d1\u8be5\u4e8b\u4ef6\u3002\u7b2c\u4e8c\u662fremoveListener\u51fd\u6570\u3002removeListener\u662f\u771f\u6b63\u5220\u9664\u4e8b\u4ef6\u5904\u7406\u51fd\u6570\u7684\u5b9e\u73b0\u3002removeAllListeners\u662f\u5c01\u88c5\u4e86removeListener\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 function removeListener ( type , listener ) { let originalListener ; const events = this . _events ; // \u6ca1\u6709\u4e1c\u897f\u53ef\u5220\u9664 if ( events === undefined ) return this ; const list = events [ type ]; // \u540c\u4e0a if ( list === undefined ) return this ; // list\u662f\u51fd\u6570\u8bf4\u660e\u53ea\u6709\u4e00\u4e2a\u5904\u7406\u51fd\u6570\uff0c\u5426\u5219\u662f\u6570\u7ec4,\u5982\u679clist.listener === listener\u8bf4\u660e\u662fonce\u6ce8\u518c\u7684 if ( list === listener || list . listener === listener ) { // type\u7c7b\u578b\u7684\u5904\u7406\u51fd\u6570\u5c31\u4e00\u4e2a\uff0c\u5e76\u4e14\u4e5f\u6ca1\u6709\u6ce8\u518c\u5176\u4ed6\u7c7b\u578b\u7684\u4e8b\u4ef6\uff0c\u5219\u521d\u59cb\u5316_events if ( -- this . _eventsCount === 0 ) this . _events = ObjectCreate ( null ); else { // \u5c31\u4e00\u4e2a\u6267\u884c\u5b8c\u5220\u9664type\u5bf9\u5e94\u7684\u5c5e\u6027 delete events [ type ]; // \u6ce8\u518c\u4e86removeListener\u4e8b\u4ef6\uff0c\u5219\u5148\u6ce8\u518cremoveListener\u4e8b\u4ef6 if ( events . removeListener ) this . emit ( 'removeListener' , type , list . listener || listener ); } } else if ( typeof list !== 'function' ) { // \u591a\u4e2a\u5904\u7406\u51fd\u6570 let position = - 1 ; // \u627e\u51fa\u9700\u8981\u5220\u9664\u7684\u51fd\u6570 for ( let i = list . length - 1 ; i >= 0 ; i -- ) { if ( list [ i ] === listener || list [ i ]. listener === listener ) { // \u4fdd\u5b58\u539f\u5904\u7406\u51fd\u6570\uff0c\u5982\u679c\u6709\u7684\u8bdd originalListener = list [ i ]. listener ; position = i ; break ; } } if ( position < 0 ) return this ; // \u7b2c\u4e00\u4e2a\u5219\u51fa\u961f\uff0c\u5426\u5219\u5220\u9664\u4e00\u4e2a if ( position === 0 ) list . shift (); else { if ( spliceOne === undefined ) spliceOne = require ( 'internal/util' ). spliceOne ; spliceOne ( list , position ); } // \u5982\u679c\u53ea\u5269\u4e0b\u4e00\u4e2a\uff0c\u5219\u503c\u6539\u6210\u51fd\u6570\u7c7b\u578b if ( list . length === 1 ) events [ type ] = list [ 0 ]; // \u89e6\u53d1removeListener if ( events . removeListener !== undefined ) this . emit ( 'removeListener' , type , originalListener || listener ); } return this ; }; \u4ee5\u4e0a\u5c31\u662fevents\u6a21\u5757\u7684\u6838\u5fc3\u903b\u8f91\uff0c\u53e6\u5916\u8fd8\u6709\u4e00\u4e9b\u5de5\u5177\u51fd\u6570\u5c31\u4e0d\u4e00\u4e00\u5206\u6790\u3002","title":"22.4 \u53d6\u6d88\u8ba2\u9605"},{"location":"chapter23-Async%20hooks/","text":"\u524d\u8a00\uff1a\u867d\u7136Async hooks\u81f3\u6b64\u8fd8\u662f\u5b9e\u9a8c\u6027API\uff0c\u4f46\u662f\u4ed6\u7684\u786e\u53ef\u4ee5\u89e3\u51b3\u5e94\u7528\u4e2d\u7684\u4e00\u4e9b\u95ee\u9898\uff0c\u6bd4\u5982\u65e5\u5fd7\u548c\u8c03\u7528\u6808\u8ddf\u8e2a\u3002\u672c\u6587\u4ece\u5e94\u7528\u548c\u539f\u7406\u65b9\u4fbf\u4ecb\u7ecd\u4e00\u4e0bNode.js\u7684Async hooks\u3002 1 env\u4e2d\u7684AsyncHooks \u00b6 \u5728Node.js\u7684env\u5bf9\u8c61\u4e2d\u6709\u4e00\u4e2aAsyncHooks\u5bf9\u8c61\uff0c\u8d1f\u8d23Node.js\u8fdb\u7a0b\u4e2dasync_hooks\u7684\u7ba1\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b9a\u4e49\u3002 1.1 \u7c7b\u5b9a\u4e49 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class AsyncHooks : public MemoryRetainer { public : enum Fields { // \u4e94\u79cd\u94a9\u5b50 kInit , kBefore , kAfter , kDestroy , kPromiseResolve , // \u94a9\u5b50\u603b\u6570 kTotals , // async_hooks\u5f00\u542f\u7684\u4e2a\u6570 kCheck , // \u8bb0\u5f55\u6808\u7684top\u6307\u9488 kStackLength , // \u6570\u7ec4\u5927\u5c0f kFieldsCount , }; enum UidFields { kExecutionAsyncId , kTriggerAsyncId , // \u5f53\u524dasync id\u7684\u503c kAsyncIdCounter , kDefaultTriggerAsyncId , kUidFieldsCount , }; private : inline AsyncHooks (); // \u5f02\u6b65\u8d44\u6e90\u7684\u7c7b\u578b std :: array < v8 :: Eternal < v8 :: String > , AsyncWrap :: PROVIDERS_LENGTH > providers_ ; // \u6808 AliasedFloat64Array async_ids_stack_ ; // \u6574\u5f62\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5143\u7d20\u503c\u7684\u610f\u4e49\u548cFields\u5bf9\u5e94 AliasedUint32Array fields_ ; // \u6574\u5f62\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5143\u7d20\u503c\u7684\u610f\u4e49\u548cUidFields\u5bf9\u5e94 AliasedFloat64Array async_id_fields_ ; }; \u7ed3\u6784\u56fe\u5982\u4e0b \u63a5\u4e0b\u6765\u770b\u4e00\u4e0benv\u7684AsyncHooks\u5bf9\u8c61\u63d0\u4f9b\u4e86\u54ea\u4e9bAPI\uff0c\u8fd9\u4e9bAPI\u662f\u4e0a\u5c42\u7684\u57fa\u7840\u3002 1.2 \u8bfbAPI \u00b6 \u6211\u4eec\u770b\u4e00\u4e0benv\u5bf9\u8c61\u4e2d\u83b7\u53d6AsyncHooks\u5bf9\u8c61\u5bf9\u5e94\u5b57\u6bb5\u7684API\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // \u83b7\u53d6\u5bf9\u5e94\u7684\u5b57\u6bb5 inline AliasedUint32Array & AsyncHooks::fields () { return fields_ ; } inline AliasedFloat64Array & AsyncHooks::async_id_fields () { return async_id_fields_ ; } inline AliasedFloat64Array & AsyncHooks::async_ids_stack () { return async_ids_stack_ ; } // \u83b7\u53d6\u8d44\u6e90\u7c7b\u578b inline v8 :: Local < v8 :: String > AsyncHooks :: provider_string ( int idx ) { return providers_ [ idx ]. Get ( env () -> isolate ()); } // \u65b0\u5efa\u8d44\u6e90\u7684\u65f6\u5019\uff0c\u83b7\u53d6\u65b0\u7684async id inline double Environment :: new_async_id () { async_hooks () -> async_id_fields ()[ AsyncHooks :: kAsyncIdCounter ] += 1 ; return async_hooks () -> async_id_fields ()[ AsyncHooks :: kAsyncIdCounter ]; } // \u83b7\u53d6\u5f53\u524dasync id inline double Environment :: execution_async_id () { return async_hooks () -> async_id_fields ()[ AsyncHooks :: kExecutionAsyncId ]; } // \u83b7\u53d6\u5f53\u524dtrigger async id inline double Environment :: trigger_async_id () { return async_hooks () -> async_id_fields ()[ AsyncHooks :: kTriggerAsyncId ]; } // \u83b7\u53d6\u9ed8\u8ba4\u7684trigger async id\uff0c\u5982\u679c\u6ca1\u6709\u8bbe\u7f6e\uff0c\u5219\u83b7\u53d6\u5f53\u524d\u7684async id inline double Environment :: get_default_trigger_async_id () { double default_trigger_async_id = async_hooks () -> async_id_fields ()[ AsyncHooks :: kDefaultTriggerAsyncId ]; // If defaultTriggerAsyncId isn't set, use the executionAsyncId if ( default_trigger_async_id < 0 ) default_trigger_async_id = execution_async_id (); return default_trigger_async_id ; } 1.3 \u5199API \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 inline void AsyncHooks::push_async_ids ( double async_id , double trigger_async_id ) { // \u83b7\u53d6\u5f53\u524d\u6808\u9876\u6307\u9488 uint32_t offset = fields_ [ kStackLength ]; // \u4e0d\u591f\u5219\u6269\u5bb9 if ( offset * 2 >= async_ids_stack_ . Length ()) grow_async_ids_stack (); // \u628a\u65e7\u7684\u4e0a\u4e0b\u6587\u538b\u6808 async_ids_stack_ [ 2 * offset ] = async_id_fields_ [ kExecutionAsyncId ]; async_ids_stack_ [ 2 * offset + 1 ] = async_id_fields_ [ kTriggerAsyncId ]; // \u6808\u6307\u9488\u52a0\u4e00 fields_ [ kStackLength ] += 1 ; // \u8bb0\u5f55\u5f53\u524d\u4e0a\u4e0b\u6587 async_id_fields_ [ kExecutionAsyncId ] = async_id ; async_id_fields_ [ kTriggerAsyncId ] = trigger_async_id ; } // \u548c\u4e0a\u9762\u7684\u903b\u8f91\u76f8\u53cd inline bool AsyncHooks::pop_async_id ( double async_id ) { if ( fields_ [ kStackLength ] == 0 ) return false ; uint32_t offset = fields_ [ kStackLength ] - 1 ; async_id_fields_ [ kExecutionAsyncId ] = async_ids_stack_ [ 2 * offset ]; async_id_fields_ [ kTriggerAsyncId ] = async_ids_stack_ [ 2 * offset + 1 ]; fields_ [ kStackLength ] = offset ; return fields_ [ kStackLength ] > 0 ; } 2 \u5e95\u5c42\u8d44\u6e90\u5c01\u88c5\u7c7b - AsyncWrap \u00b6 \u63a5\u7740\u770b\u4e00\u4e0b\u5f02\u6b65\u8d44\u6e90\u7684\u57fa\u7c7bAsyncWrap\u3002\u6240\u6709\u4f9d\u8d56\u4e8eC\u3001C++\u5c42\u5b9e\u73b0\u7684\u8d44\u6e90\uff08\u6bd4\u5982TCP\u3001UDP\uff09\u90fd\u4f1a\u7ee7\u627fAsyncWrap\u3002\u770b\u770b\u8be5\u7c7b\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 class AsyncWrap : public BaseObject { private : ProviderType provider_type_ = PROVIDER_NONE ; double async_id_ = kInvalidAsyncId ; double trigger_async_id_ ; }; \u6211\u4eec\u770b\u5230\u6bcf\u4e2aAsyncWrap\u5bf9\u8c61\u90fd\u6709async_id_\u3001trigger_async_id_\u548cprovider_type_\u5c5e\u6027\uff0c\u8fd9\u6b63\u662f\u5728init\u56de\u8c03\u91cc\u62ff\u5230\u7684\u6570\u636e\u3002\u6211\u4eec\u770b\u770bAsyncWrap\u7684\u6784\u9020\u51fd\u6570\u3002\u63a5\u4e0b\u6765\u770b\u4e00\u4e0b\u65b0\u5efa\u4e00\u4e2a\u8d44\u6e90\uff08AsyncWrap\uff09\u65f6\u7684\u903b\u8f91\u3002 2.1 \u8d44\u6e90\u521d\u59cb\u5316 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 AsyncWrap :: AsyncWrap ( Environment * env , Local < Object > object , ProviderType provider , double execution_async_id , bool silent ) : AsyncWrap ( env , object ) { // \u8d44\u6e90\u7c7b\u578b provider_type_ = provider ; AsyncReset ( execution_async_id , silent ); } void AsyncWrap :: AsyncReset ( Local < Object > resource , double execution_async_id , bool silent ) { // \u83b7\u53d6\u4e00\u4e2a\u65b0\u7684async id\uff0cexecution_async_id\u9ed8\u8ba4\u662fkInvalidAsyncId async_id_ = execution_async_id == kInvalidAsyncId ? env () -> new_async_id () : execution_async_id ; // \u83b7\u53d6trigger async id trigger_async_id_ = env () -> get_default_trigger_async_id (); // \u6267\u884cinit\u94a9\u5b50 EmitAsyncInit ( env (), resource , env () -> async_hooks () -> provider_string ( provider_type ()), async_id_ , trigger_async_id_ ); } \u63a5\u7740\u770bEmitAsyncInit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void AsyncWrap::EmitAsyncInit ( Environment * env , Local < Object > object , Local < String > type , double async_id , double trigger_async_id ) { AsyncHooks * async_hooks = env -> async_hooks (); HandleScope scope ( env -> isolate ()); Local < Function > init_fn = env -> async_hooks_init_function (); Local < Value > argv [] = { Number :: New ( env -> isolate (), async_id ), type , Number :: New ( env -> isolate (), trigger_async_id ), object , }; TryCatchScope try_catch ( env , TryCatchScope :: CatchMode :: kFatal ); // \u6267\u884cinit\u56de\u8c03 USE ( init_fn -> Call ( env -> context (), object , arraysize ( argv ), argv )); } \u90a3\u4e48env->async_hooks_init_function()\u7684\u503c\u662f\u4ec0\u4e48\u5462\uff1f\u8fd9\u662f\u5728Node.js\u521d\u59cb\u5316\u65f6\u8bbe\u7f6e\u7684\u3002 1 2 const { nativeHooks } = require ( 'internal/async_hooks' ); internalBinding ( 'async_wrap' ). setupHooks ( nativeHooks ); SetupHooks\u7684\u5b9e\u73b0\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 static void SetupHooks ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); Local < Object > fn_obj = args [ 0 ]. As < Object > (); #define SET_HOOK_FN(name) \\ do { \\ Local<Value> v = \\ fn_obj->Get(env->context(), \\ FIXED_ONE_BYTE_STRING(env->isolate(), #name)) \\ .ToLocalChecked(); \\ CHECK(v->IsFunction()); \\ env->set_async_hooks_##name##_function(v.As<Function>()); \\ } while (0) // \u4fdd\u5b58\u5230env\u4e2d SET_HOOK_FN ( init ); SET_HOOK_FN ( before ); SET_HOOK_FN ( after ); SET_HOOK_FN ( destroy ); SET_HOOK_FN ( promise_resolve ); #undef SET_HOOK_FN } nativeHooks\u7684\u5b9e\u73b0\u5982\u4e0b 1 2 3 4 5 6 7 nativeHooks : { init : emitInitNative , before : emitBeforeNative , after : emitAfterNative , destroy : emitDestroyNative , promise_resolve : emitPromiseResolveNative } \u8fd9\u4e9bHooks\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\uff0c\u6bd4\u5982emitInitNative 1 2 3 4 5 6 7 8 9 10 function emitInitNative ( asyncId , type , triggerAsyncId , resource ) { for ( var i = 0 ; i < active_hooks . array . length ; i ++ ) { if ( typeof active_hooks . array [ i ][ init_symbol ] === 'function' ) { active_hooks . array [ i ][ init_symbol ]( asyncId , type , triggerAsyncId , resource ); } } } active_hooks.array\u7684\u503c\u5c31\u662f\u6211\u4eec\u5728\u4e1a\u52a1\u4ee3\u7801\u91cc\u8bbe\u7f6e\u7684\u94a9\u5b50\uff0c\u6bcf\u6b21\u8c03\u7814createHooks\u7684\u65f6\u5019\u5c31\u5bf9\u5e94\u6570\u7ec4\u7684\u4e00\u4e2a\u5143\u7d20\u3002 2.2 \u6267\u884c\u8d44\u6e90\u56de\u8c03 \u00b6 \u5f53\u4e1a\u52a1\u4ee3\u7801\u5f02\u6b65\u8bf7\u6c42\u5e95\u5c42API\uff0c\u5e76\u4e14\u5e95\u5c42\u6ee1\u8db3\u6761\u4ef6\u65f6\uff0c\u5c31\u4f1a\u6267\u884c\u4e0a\u5c42\u7684\u56de\u8c03\uff0c\u6bd4\u5982\u76d1\u542c\u4e00\u4e2asocket\u65f6\uff0c\u6709\u8fde\u63a5\u5230\u6765\u3002Node.js\u5c31\u4f1a\u8c03\u7528MakeCallback\u51fd\u6570\u6267\u884c\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 MaybeLocal < Value > AsyncWrap :: MakeCallback ( const Local < Function > cb , int argc , Local < Value >* argv ) { // \u5f53\u524dAsyncWrap\u5bf9\u8c61\u5bf9\u5e94\u7684\u6267\u884c\u4e0a\u4e0b\u6587 ProviderType provider = provider_type (); async_context context { get_async_id (), get_trigger_async_id () }; MaybeLocal < Value > ret = InternalMakeCallback ( env (), object (), cb , argc , argv , context ); return ret ; } MakeCallback\u4e2d\u4f1a\u8c03\u7528InternalMakeCallback\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 MaybeLocal < Value > InternalMakeCallback ( Environment * env , Local < Object > recv , const Local < Function > callback , int argc , Local < Value > argv [], async_context asyncContext ) { // \u65b0\u5efa\u4e00\u4e2ascope InternalCallbackScope scope ( env , recv , asyncContext ); // \u6267\u884c\u56de\u8c03 callback -> Call ( env -> context (), recv , argc , argv ); // \u5173\u95edscope scope . Close (); } \u6211\u4eec\u770b\u770b\u65b0\u5efa\u548c\u5173\u95edscope\u90fd\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 InternalCallbackScope :: InternalCallbackScope ( Environment * env , Local < Object > object , const async_context & asyncContext , int flags ) : env_ ( env ), async_context_ ( asyncContext ), object_ ( object ), skip_hooks_ ( flags & kSkipAsyncHooks ), skip_task_queues_ ( flags & kSkipTaskQueues ) { // v14\u7248\u672c\u4e2d\uff0c\u662f\u5148\u89e6\u53d1before\u518dpush\u4e0a\u4e0b\u6587\uff0c\u987a\u5e8f\u662f\u4e0d\u5bf9\u7684\uff0cv16\u5df2\u7ecf\u6539\u8fc7\u6765\u3002 // \u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5165\u6808 env -> async_hooks () -> push_async_ids ( async_context_ . async_id , async_context_ . trigger_async_id ); // \u89e6\u53d1before\u94a9\u5b50 if ( asyncContext . async_id != 0 && ! skip_hooks_ ) { AsyncWrap :: EmitBefore ( env , asyncContext . async_id ); } pushed_ids_ = true ; } \u5728scope\u91cc\u4f1a\u628a\u5f53\u524dAsyncWrap\u5bf9\u8c61\u7684\u6267\u884c\u4e0a\u4e0b\u6587\u4f5c\u4e3a\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\uff0c\u5e76\u4e14\u89e6\u53d1before\u94a9\u5b50\uff0c\u7136\u540e\u6267\u884c\u4e1a\u52a1\u56de\u8c03\uff0c\u6240\u4ee5\u6211\u4eec\u5728\u56de\u8c03\u91cc\u83b7\u53d6\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u65f6\u5c31\u62ff\u5230\u4e86AsyncWrap\u5bf9\u5e94\u7684\u503c\uff08 \u8c03\u7528executionAsyncId\uff09\uff0c\u63a5\u7740\u770bClose 1 2 3 4 5 6 7 8 9 void InternalCallbackScope::Close () { // \u6267\u884c if ( pushed_ids_ ) env_ -> async_hooks () -> pop_async_id ( async_context_ . async_id ); if ( async_context_ . async_id != 0 && ! skip_hooks_ ) { AsyncWrap :: EmitAfter ( env_ , async_context_ . async_id ); } } Close\u5728\u6267\u884c\u56de\u8c03\u540e\u88ab\u8c03\u7528\uff0c\u4e3b\u8981\u662f\u6062\u590d\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5e76\u4e14\u89e6\u53d1after\u94a9\u5b50\u3002 3 \u4e0a\u5c42\u8d44\u6e90\u7684\u5c01\u88c5 - Timeout\u3001TickObjecd\u7b49 \u00b6 \u5e76\u4e0d\u662f\u6240\u6709\u7684\u5f02\u6b65\u8d44\u6e90\u90fd\u662f\u5e95\u5c42\u5b9e\u73b0\u7684\uff0c\u6bd4\u5982\u5b9a\u65f6\u5668\uff0ctick\u4e5f\u88ab\u5b9a\u4e49\u4e3a\u5f02\u6b65\u8d44\u6e90\uff0c\u56e0\u4e3a\u4ed6\u4eec\u90fd\u662f\u548c\u56de\u8c03\u76f8\u5173\u3002\u8fd9\u79cd\u5f02\u6b65\u8d44\u6e90\u662f\u5728JS\u5c42\u5b9e\u73b0\u7684\uff0c\u8fd9\u91cc\u53ea\u5206\u6790Timeout\u3002 3.1 \u521b\u5efa\u8d44\u6e90 \u00b6 \u6211\u4eec\u770b\u4e00\u4e0b\u6267\u884csetTimeout\u65f6\u7684\u6838\u5fc3\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function setTimeout ( callback , after , arg1 , arg2 , arg3 ) { const timeout = new Timeout ( callback , after , args , false , true ); return timeout ; } function Timeout ( callback , after , args , isRepeat , isRefed ) { initAsyncResource ( this , 'Timeout' ); } function initAsyncResource ( resource , type ) { // \u83b7\u53d6\u65b0\u7684async id const asyncId = resource [ async_id_symbol ] = newAsyncId (); const triggerAsyncId = resource [ trigger_async_id_symbol ] = getDefaultTriggerAsyncId (); // \u662f\u5426\u8bbe\u7f6e\u4e86init\u94a9\u5b50\uff0c\u662f\u5219\u89e6\u53d1\u56de\u8c03 if ( initHooksExist ()) emitInit ( asyncId , type , triggerAsyncId , resource ); } \u6267\u884csetTimeout\u65f6\uff0cNode.js\u4f1a\u521b\u5efa\u4e00\u4e2aTimeout\u5bf9\u8c61\uff0c\u8bbe\u7f6easync_hooks\u76f8\u5173\u7684\u4e0a\u4e0b\u6587\u5e76\u8bb0\u5f55\u5230Timeout\u5bf9\u8c61\u4e2d\u3002\u7136\u540e\u89e6\u53d1init\u94a9\u5b50\u3002 1 2 3 function emitInitScript ( asyncId , type , triggerAsyncId , resource ) { emitInitNative ( asyncId , type , triggerAsyncId , resource ); } \u4ee5\u4e0a\u4ee3\u7801\u4f1a\u6267\u884c\u6bcf\u4e2aasync_hooks\u5bf9\u8c61\u7684init\u56de\u8c03(\u901a\u5e38\u6211\u4eec\u53ea\u6709\u4e00\u4e2aasync_hooks\u5bf9\u8c61)\u3002 3.1 \u6267\u884c\u56de\u8c03 \u00b6 \u5f53\u5b9a\u65f6\u5668\u5230\u671f\u65f6\uff0c\u4f1a\u6267\u884c\u56de\u8c03\uff0c\u6211\u4eec\u770b\u770b\u76f8\u5173\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 // \u89e6\u53d1before\u94a9\u5b50 emitBefore ( asyncId , timer [ trigger_async_id_symbol ]); // \u6267\u884c\u56de\u8c03 timer . _onTimeout (); // \u89e6\u53d1after\u56de\u8c03 emitAfter ( asyncId ); \u6211\u4eec\u770b\u5230\u6267\u884c\u8d85\u65f6\u56de\u8c03\u7684\u524d\u540e\u4f1a\u89e6\u53d1\u5bf9\u5e94\u7684\u94a9\u5b50\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function emitBeforeScript ( asyncId , triggerAsyncId ) { // \u548c\u5e95\u5c42\u7684push_async_ids\u903b\u8f91\u4e00\u6837 pushAsyncIds ( asyncId , triggerAsyncId ); // \u5982\u679c\u6709\u56de\u8c03\u5219\u6267\u884c if ( async_hook_fields [ kBefore ] > 0 ) emitBeforeNative ( asyncId ); } function emitAfterScript ( asyncId ) { // \u8bbe\u7f6e\u4e86after\u56de\u8c03\u5219emit if ( async_hook_fields [ kAfter ] > 0 ) emitAfterNative ( asyncId ); // \u548c\u5e95\u5c42\u7684pop_async_ids\u903b\u8f91\u4e00\u6837 popAsyncIds ( asyncId ); } JS\u5c42\u7684\u5b9e\u73b0\u548c\u5e95\u5c42\u662f\u4fdd\u6301\u4e00\u81f4\u7684\u3002\u5982\u679c\u6211\u4eec\u5728setTimeout\u56de\u8c03\u91cc\u65b0\u5efa\u4e00\u4e2a\u8d44\u6e90\uff0c\u6bd4\u5982\u518d\u6b21\u6267\u884csetTimeout\uff0c\u8fd9\u65f6\u5019trigger async id\u5c31\u662f\u7b2c\u4e00\u4e2asetTimeout\u5bf9\u5e94\u7684async id\uff0c\u6240\u4ee5\u5c31\u8fde\u8d77\u6765\u4e86\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u770b\u5230\u5177\u4f53\u7684\u4f8b\u5b50\u3002 4 DefaultTriggerAsyncIdScope \u00b6 Node.js\u4e3a\u4e86\u907f\u514d\u8fc7\u591a\u901a\u8fc7\u53c2\u6570\u4f20\u9012\u7684\u65b9\u5f0f\u4f20\u9012async id\uff0c\u5c31\u8bbe\u8ba1\u4e86DefaultTriggerAsyncIdScope\u3002DefaultTriggerAsyncIdScope\u7684\u4f5c\u7528\u7c7b\u4f3c\u5728\u591a\u4e2a\u51fd\u6570\u5916\u7ef4\u62a4\u4e00\u4e2a\u53d8\u91cf\uff0c\u591a\u4e2a\u51fd\u6570\u90fd\u53ef\u4ee5\u901a\u8fc7DefaultTriggerAsyncIdScope\u83b7\u5f97trigger async id\uff0c\u800c\u4e0d\u9700\u8981\u901a\u8fc7\u5c42\u5c42\u4f20\u9012\u7684\u65b9\u5f0f\uff0c\u4ed6\u7684\u5b9e\u73b0\u975e\u5e38\u7b80\u5355\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class DefaultTriggerAsyncIdScope { private : AsyncHooks * async_hooks_ ; double old_default_trigger_async_id_ ; }; inline AsyncHooks :: DefaultTriggerAsyncIdScope :: DefaultTriggerAsyncIdScope ( Environment * env , double default_trigger_async_id ) : async_hooks_ ( env -> async_hooks ()) { // \u8bb0\u5f55\u65e7\u7684id\uff0c\u8bbe\u7f6e\u65b0\u7684id old_default_trigger_async_id_ = async_hooks_ -> async_id_fields ()[ AsyncHooks :: kDefaultTriggerAsyncId ]; async_hooks_ -> async_id_fields ()[ AsyncHooks :: kDefaultTriggerAsyncId ] = default_trigger_async_id ; } // \u6062\u590d inline AsyncHooks :: DefaultTriggerAsyncIdScope ::~ DefaultTriggerAsyncIdScope () { async_hooks_ -> async_id_fields ()[ AsyncHooks :: kDefaultTriggerAsyncId ] = old_default_trigger_async_id_ ; } DefaultTriggerAsyncIdScope\u4e3b\u8981\u662f\u8bb0\u5f55\u65e7\u7684id\uff0c\u7136\u540e\u628a\u65b0\u7684id\u8bbe\u7f6e\u5230env\u4e2d\uff0c\u5f53\u5176\u4ed6\u51fd\u6570\u8c03\u7528get_default_trigger_async_id\u65f6\u5c31\u53ef\u4ee5\u83b7\u53d6\u8bbe\u7f6e\u7684async id\u3002\u540c\u6837JS\u5c42\u4e5f\u5b9e\u73b0\u4e86\u7c7b\u4f3c\u7684API\u3002 1 2 3 4 5 6 7 8 9 10 function defaultTriggerAsyncIdScope ( triggerAsyncId , block , ... args ) { const oldDefaultTriggerAsyncId = async_id_fields [ kDefaultTriggerAsyncId ]; async_id_fields [ kDefaultTriggerAsyncId ] = triggerAsyncId ; try { return block (... args ); } finally { async_id_fields [ kDefaultTriggerAsyncId ] = oldDefaultTriggerAsyncId ; } } \u5728\u6267\u884cblock\u51fd\u6570\u65f6\uff0c\u53ef\u4ee5\u83b7\u53d6\u5230\u8bbe\u7f6e\u7684\u503c\uff0c\u800c\u4e0d\u9700\u8981\u4f20\u9012\uff0c\u6267\u884c\u5b8cblock\u540e\u6062\u590d\u3002\u6211\u4eec\u770b\u770b\u5982\u4f55\u4f7f\u7528\u3002\u4e0b\u9762\u6458\u81eanet\u6a21\u5757\u7684\u4ee3\u7801\u3002 1 2 3 4 5 6 // \u83b7\u53d6handle\u91cc\u7684async id this [ async_id_symbol ] = getNewAsyncId ( this . _handle ); defaultTriggerAsyncIdScope ( this [ async_id_symbol ], process . nextTick , emitListeningNT , this ); \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u91cc\u5177\u4f53\u7684\u60c5\u51b5\u3002\u5728defaultTriggerAsyncIdScope\u4e2d\u4f1a\u4ee5emitListeningNT\u4e3a\u5165\u53c2\u6267\u884cprocess.nextTick\u3002\u6211\u4eec\u770b\u770bnextTick\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function nextTick ( callback ) { // \u83b7\u53d6\u65b0\u7684async id const asyncId = newAsyncId (); // \u83b7\u53d6\u9ed8\u8ba4\u7684trigger async id\uff0c\u5373\u521a\u624d\u8bbe\u7f6e\u7684 const triggerAsyncId = getDefaultTriggerAsyncId (); const tickObject = { [ async_id_symbol ] : asyncId , [ trigger_async_id_symbol ] : triggerAsyncId , callback , args }; if ( initHooksExist ()) // \u521b\u5efa\u4e86\u65b0\u7684\u8d44\u6e90\uff0c\u89e6\u53d1init\u94a9\u5b50 emitInit ( asyncId , 'TickObject' , triggerAsyncId , tickObject ); queue . push ( tickObject ); } \u6211\u4eec\u770b\u5230\u5728nextTick\u4e2d\u901a\u8fc7getDefaultTriggerAsyncId\u62ff\u5230\u4e86trigger async id\u3002 1 2 3 4 5 6 function getDefaultTriggerAsyncId () { const defaultTriggerAsyncId = async_id_fields [ kDefaultTriggerAsyncId ]; if ( defaultTriggerAsyncId < 0 ) return async_id_fields [ kExecutionAsyncId ]; return defaultTriggerAsyncId ; } getDefaultTriggerAsyncId\u8fd4\u56de\u7684\u5c31\u662f\u521a\u624d\u901a\u8fc7defaultTriggerAsyncIdScope\u8bbe\u7f6e\u7684async id\u3002\u6240\u4ee5\u5728\u89e6\u53d1TickObject\u7684init\u94a9\u5b50\u65f6\u7528\u6237\u5c31\u53ef\u4ee5\u62ff\u5230\u5bf9\u5e94\u7684id\u3002\u4e0d\u8fc7\u66f4\u91cd\u8981\u7684\u65f6\uff0c\u5728\u5f02\u6b65\u6267\u884cnextTick\u7684\u4efb\u52a1\u65f6\uff0c\u8fd8\u53ef\u4ee5\u62ff\u5230\u539f\u59cb\u7684trigger async id\u3002\u56e0\u4e3a\u8be5id\u8bb0\u5f55\u5728tickObject\u4e2d\u3002\u6211\u4eec\u770b\u770b\u6267\u884ctick\u4efb\u52a1\u65f6\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function processTicksAndRejections () { let tock ; do { while ( tock = queue . shift ()) { // \u62ff\u5230\u5bf9\u5e94\u7684async \u4e0a\u4e0b\u6587 const asyncId = tock [ async_id_symbol ]; emitBefore ( asyncId , tock [ trigger_async_id_symbol ]); try { const callback = tock . callback ; callback (); } finally { if ( destroyHooksExist ()) emitDestroy ( asyncId ); } emitAfter ( asyncId ); } } while ( ! queue . isEmpty () || processPromiseRejections ()); } 5 \u8d44\u6e90\u9500\u6bc1 \u00b6 \u8d44\u6e90\u9500\u6bc1\u7684\u65f6\u5019\u4e5f\u4f1a\u89e6\u53d1\u5bf9\u5e94\u7684\u94a9\u5b50\uff0c\u4e0d\u8fc7\u4e0d\u540c\u7684\u662f\u8fd9\u4e2a\u94a9\u5b50\u662f\u5f02\u6b65\u89e6\u53d1\u7684\u3002\u65e0\u8bba\u662fJS\u8fd8\u662f\u597dC++\u5c42\u89e6\u53d1\u9500\u6bc1\u94a9\u5b50\u7684\u65f6\u5019\uff0c\u903b\u8f91\u90fd\u662f\u4e00\u81f4\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void AsyncWrap::EmitDestroy ( Environment * env , double async_id ) { // \b\u4e4b\u524d\u4e3a\u7a7a\u5219\u8bbe\u7f6e\u56de\u8c03 if ( env -> destroy_async_id_list () -> empty ()) { env -> SetUnrefImmediate ( & DestroyAsyncIdsCallback ); } // async id\u5165\u961f env -> destroy_async_id_list () -> push_back ( async_id ); } template < typename Fn > void Environment :: SetUnrefImmediate ( Fn && cb ) { CreateImmediate ( std :: move ( cb ), false ); } template < typename Fn > void Environment :: CreateImmediate ( Fn && cb , bool ref ) { auto callback = std :: make_unique < NativeImmediateCallbackImpl < Fn >> ( std :: move ( cb ), ref ); // \u52a0\u5165\u4efb\u52a1\u961f\u5217 native_immediates_ . Push ( std :: move ( callback )); } \u5728\u4e8b\u4ef6\u5faa\u73af\u7684check\u9636\u6bb5\u5c31\u4f1a\u6267\u884c\u91cc\u9762\u7684\u4efb\u52a1\uff0c\u4ece\u800c\u6267\u884c\u56de\u8c03DestroyAsyncIdsCallback\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void AsyncWrap::DestroyAsyncIdsCallback ( Environment * env ) { Local < Function > fn = env -> async_hooks_destroy_function (); do { std :: vector < double > destroy_async_id_list ; destroy_async_id_list . swap ( * env -> destroy_async_id_list ()); // \u904d\u5386\u9500\u6bc1\u7684async id for ( auto async_id : destroy_async_id_list ) { HandleScope scope ( env -> isolate ()); Local < Value > async_id_value = Number :: New ( env -> isolate (), async_id ); // \u6267\u884cJS\u5c42\u56de\u8c03 MaybeLocal < Value > ret = fn -> Call ( env -> context (), Undefined ( env -> isolate ()), 1 , & async_id_value ); } } while ( ! env -> destroy_async_id_list () -> empty ()); } 6 Async hooks\u7684\u4f7f\u7528 \u00b6 \u6211\u4eec\u901a\u5e38\u4ee5\u4ee5\u4e0b\u65b9\u5f0f\u4f7f\u7528Async hooks 1 2 3 4 5 6 7 8 9 const async_hooks = require ( 'async_hooks' ); async_hooks . createHook ({ init ( asyncId , type , triggerAsyncId ) {}, before ( asyncId ) {}, after ( asyncId ) {}, destroy ( asyncId ) {}, promiseResolve ( asyncId ), }) . enable (); async_hooks\u662f\u5bf9\u8d44\u6e90\u751f\u547d\u5468\u671f\u7684\u62bd\u8c61\uff0c\u8d44\u6e90\u5c31\u662f\u64cd\u4f5c\u5bf9\u8c61\u548c\u56de\u8c03\u7684\u62bd\u8c61\u3002async_hooks\u5b9a\u4e49\u4e86\u4e94\u4e2a\u751f\u547d\u5468\u671f\u94a9\u5b50\uff0c\u5f53\u8d44\u6e90\u7684\u72b6\u6001\u5230\u8fbe\u67d0\u4e2a\u5468\u671f\u8282\u70b9\u65f6\uff0casync_hooks\u5c31\u4f1a\u89e6\u53d1\u5bf9\u5e94\u7684\u94a9\u5b50\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bcreateHook\u3002 1 2 3 function createHook ( fns ) { return new AsyncHook ( fns ); } createHook\u662f\u5bf9AsyncHook\u7684\u5c01\u88c5 1 2 3 4 5 6 7 8 9 10 class AsyncHook { constructor ({ init , before , after , destroy , promiseResolve }) { // \u8bb0\u5f55\u56de\u8c03 this [ init_symbol ] = init ; this [ before_symbol ] = before ; this [ after_symbol ] = after ; this [ destroy_symbol ] = destroy ; this [ promise_resolve_symbol ] = promiseResolve ; } } AsyncHook\u7684\u521d\u59cb\u5316\u5f88\u7b80\u5355\uff0c\u521b\u5efa\u4e00\u4e2aAsyncHook\u5bf9\u8c61\u8bb0\u5f55\u56de\u8c03\u51fd\u6570\u3002\u521b\u5efa\u4e86AsyncHook\u4e4b\u540e\uff0c\u6211\u4eec\u9700\u8981\u8c03\u7528AsyncHook\u7684enable\u51fd\u6570\u624b\u52a8\u5f00\u542f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class AsyncHook { enable () { // \u83b7\u53d6\u4e00\u4e2aAsyncHook\u5bf9\u8c61\u6570\u7ec4\u548c\u4e00\u4e2a\u6574\u5f62\u6570\u7ec4 const [ hooks_array , hook_fields ] = getHookArrays (); // \u6267\u884c\u8fc7enable\u4e86\u5219\u4e0d\u9700\u8981\u518d\u6267\u884c if ( hooks_array . includes ( this )) return this ; // \u505a\u4e9b\u7edf\u8ba1 const prev_kTotals = hook_fields [ kTotals ]; hook_fields [ kTotals ] = hook_fields [ kInit ] += +!! this [ init_symbol ]; hook_fields [ kTotals ] += hook_fields [ kBefore ] += +!! this [ before_symbol ]; hook_fields [ kTotals ] += hook_fields [ kAfter ] += +!! this [ after_symbol ]; hook_fields [ kTotals ] += hook_fields [ kDestroy ] += +!! this [ destroy_symbol ]; hook_fields [ kTotals ] += hook_fields [ kPromiseResolve ] += +!! this [ promise_resolve_symbol ]; // \u5f53\u524d\u5bf9\u8c61\u63d2\u5165\u6570\u7ec4\u4e2d hooks_array . push ( this ); // \u5982\u679c\u4e4b\u524d\u7684\u6570\u91cf\u662f0\uff0c\u672c\u6b21\u64cd\u4f5c\u540e\u5927\u4e8e0\u5219\u5f00\u542f\u5e95\u5c42\u7684\u903b\u8f91 if ( prev_kTotals === 0 && hook_fields [ kTotals ] > 0 ) { enableHooks (); } return this ; } } 1 hooks_array\uff1a\u662f\u4e00\u4e2aAsyncHook\u5bf9\u8c61\u6570\u7ec4\uff0c\u4e3b\u8981\u7528\u4e8e\u8bb0\u5f55\u7528\u6237\u521b\u5efa\u4e86\u54ea\u4e9bAsyncHook\u5bf9\u8c61\uff0c\u7136\u540e\u54ea\u4e9bAsyncHook\u5bf9\u8c61\u91cc\u90fd\u8bbe\u7f6e\u4e86\u54ea\u4e9b\u94a9\u5b50\uff0c\u5728\u56de\u8c03\u7684\u65f6\u5019\u5c31\u4f1a\u904d\u5386\u8fd9\u4e2a\u5bf9\u8c61\u6570\u7ec4\uff0c\u6267\u884c\u91cc\u9762\u7684\u56de\u8c03\u3002 2 hook_fields\uff1a\u5bf9\u5e94\u5e95\u5c42\u7684async_hook_fields\u3002 3 enableHooks\uff1a 1 2 3 4 function enableHooks () { // \u8bb0\u5f55async_hooks\u7684\u5f00\u542f\u4e2a\u6570 async_hook_fields [ kCheck ] += 1 ; } \u81f3\u6b64\uff0casync_hooks\u7684\u521d\u59cb\u5316\u5c31\u5b8c\u6210\u4e86\uff0c\u6211\u4eec\u53d1\u73b0\u903b\u8f91\u975e\u5e38\u7b80\u5355\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u4ed6\u662f\u5982\u4f55\u4e32\u8d77\u6765\u7684\u3002\u4e0b\u9762\u6211\u4eec\u4ee5TCP\u6a21\u5757\u4e3a\u4f8b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 const { createHook , executionAsyncId } = require ( 'async_hooks' ); const fs = require ( 'fs' ); const net = require ( 'net' ); createHook ({ init ( asyncId , type , triggerAsyncId ) { fs . writeSync ( 1 , ` ${ type } ( ${ asyncId } ): trigger: ${ triggerAsyncId } execution: ${ executionAsyncId () } \\n` ); } }). enable (); net . createServer (( conn ) => {}). listen ( 8080 ); \u4ee5\u4e0a\u4ee3\u7801\u8f93\u51fa 1 2 3 4 init: type: TCPSERVERWRAP asyncId: 2 trigger id: 1 executionAsyncId(): 1 triggerAsyncId(): 0 init: type: TickObject asyncId: 3 trigger id: 2 executionAsyncId(): 1 triggerAsyncId(): 0 before: asyncId: 3 executionAsyncId(): 3 triggerAsyncId(): 2 after: asyncId: 3 executionAsyncId(): 3 triggerAsyncId(): 2 \u4e0b\u9762\u6211\u4eec\u6765\u5206\u6790\u5177\u4f53\u8fc7\u7a0b\u3002\u6211\u4eec\u77e5\u9053\u521b\u5efa\u8d44\u6e90\u7684\u65f6\u5019\u4f1a\u6267\u884cinit\u56de\u8c03\uff0c\u5177\u4f53\u903b\u8f91\u5728listen\u51fd\u6570\u4e2d\uff0c\u5728listen\u51fd\u6570\u4e2d\uff0c\u901a\u8fc7\u5c42\u5c42\u8c03\u7528\u4f1a\u6267\u884cnew TCP\u65b0\u5efa\u4e00\u4e2a\u5bf9\u8c61\uff0c\u8868\u793a\u670d\u52a1\u5668\u3002TCP\u662fC++\u5c42\u5bfc\u51fa\u7684\u7c7b\uff0c\u521a\u624d\u6211\u4eec\u8bf4\u8fc7\uff0cTCP\u4f1a\u7ee7\u627fAsyncWrap\uff0c\u65b0\u5efaAsyncWrap\u5bf9\u8c61\u7684\u65f6\u5019\u4f1a\u89e6\u53d1init\u94a9\u5b50\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5bf9\u5e94\u8f93\u51fa 1 init: type: TCPSERVERWRAP asyncId: 2 trigger id: 1 executionAsyncId(): 1 triggerAsyncId(): 0 \u90a3TickObject\u662f\u600e\u4e48\u6765\u7684\u5462\uff1f\u6211\u4eec\u63a5\u7740\u770blisten\u91cc\u7684\u53e6\u4e00\u6bb5\u903b\u8f91\u3002 1 2 3 4 5 this [ async_id_symbol ] = getNewAsyncId ( this . _handle ); defaultTriggerAsyncIdScope ( this [ async_id_symbol ], process . nextTick , emitListeningNT , this ); \u4e0a\u9762\u7684\u4ee3\u7801\u6211\u4eec\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u5728\u6267\u884cprocess.nextTick\u7684\u65f6\u5019\u4f1a\u521b\u5efa\u4e00\u4e2aTickObject\u5bf9\u8c61\u5c01\u88c5\u6267\u884c\u4e0a\u4e0b\u6587\u548c\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 const asyncId = newAsyncId (); const triggerAsyncId = getDefaultTriggerAsyncId (); const tickObject = { [ async_id_symbol ] : asyncId , [ trigger_async_id_symbol ] : triggerAsyncId , callback , args }; emitInit ( asyncId , 'TickObject' , triggerAsyncId , tickObject ); \u8fd9\u6b21\u518d\u6b21\u89e6\u53d1\u4e86init\u94a9\u5b50\uff0c\u7ed3\u6784\u5982\u4e0b\uff08nextTick\u901a\u8fc7getDefaultTriggerAsyncId\u83b7\u53d6\u7684id\u662fdefaultTriggerAsyncIdScope\u8bbe\u7f6e\u7684id\uff09\u3002 \u5bf9\u5e94\u8f93\u51fa 1 init: type: TickObject asyncId: 3 trigger id: 2 executionAsyncId(): 1 triggerAsyncId(): 0 \u63a5\u7740\u6267\u884ctick\u4efb\u52a1\u3002 1 2 3 4 5 6 7 8 9 const asyncId = tock [ async_id_symbol ]; emitBefore ( asyncId , tock [ trigger_async_id_symbol ]); try { tock . callback (); } finally { if ( destroyHooksExist ()) emitDestroy ( asyncId ); } emitAfter ( asyncId ); emitBefore\u65f6\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5bf9\u5e94\u8f93\u51fa 1 2 before: asyncId: 3 executionAsyncId(): 3 triggerAsyncId(): 2 after: asyncId: 3 executionAsyncId(): 3 triggerAsyncId(): 2 \u6267\u884c\u5b8c\u6211\u4eec\u7684JS\u4ee3\u7801\u540e\uff0c\u6240\u6709\u5165\u6808\u7684\u4e0a\u4e0b\u6587\u90fd\u4f1a\u88ab\u6e05\u7a7a\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5982\u679c\u8fd9\u65f6\u5019\u6709\u4e00\u4e2a\u8fde\u63a5\u5efa\u7acb\u4f1a\u8f93\u51fa\u4ec0\u4e48\u5462\uff1f\u5f53\u6709\u8fde\u63a5\u5efa\u7acb\u65f6\uff0c\u4f1a\u6267\u884cC++\u5c42\u7684OnConnection\u3002 OnConnection\u4f1a\u521b\u5efa\u4e00\u4e2a\u65b0\u7684TCP\u5bf9\u8c61\u8868\u793a\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 MaybeLocal < Object > TCPWrap :: Instantiate ( Environment * env , AsyncWrap * parent , TCPWrap :: SocketType type ) { EscapableHandleScope handle_scope ( env -> isolate ()); AsyncHooks :: DefaultTriggerAsyncIdScope trigger_scope ( parent ); return handle_scope . EscapeMaybe ( constructor -> NewInstance ( env -> context (), 1 , & type_value )); } \u9996\u5148\u5b9a\u4e49\u4e86\u4e00\u4e2aAsyncHooks::DefaultTriggerAsyncIdScope\u3002DefaultTriggerAsyncIdScope\u7528\u4e8e\u8bbe\u7f6e\u9ed8\u8ba4default_trigger_async_id\u4e3aparent\u7684async id\uff08\u503c\u662f2\uff09\uff0c\u6267\u884cInstantiate\u65f6\u4f1a\u6267\u884c\u6790\u6784\u51fd\u6570\u6062\u590d\u539f\u6765\u72b6\u6001\u3002\u63a5\u7740NewInstance\u7684\u65f6\u5019\u5c31\u4f1a\u65b0\u5efa\u4e00\u4e2aTCPWrap\u5bf9\u8c61\uff0c\u4ece\u800c\u521b\u5efa\u4e00\u4e2aAsyncWrap\u5bf9\u8c61\u3002\u7136\u540e\u89e6\u53d1init\u94a9\u5b50\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5bf9\u5e94\u8f93\u51fa 1 init: type: TCPWRAP asyncId: 4 trigger id: 2 executionAsyncId(): 0 triggerAsyncId(): 0 \u521b\u5efa\u5b8c\u5bf9\u8c61\u540e\uff0c\u901a\u8fc7AsyncWrap::MakeCallback\u56de\u8c03JS\u5c42\uff0c\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7AsyncWrap::MakeCallback\u4f1a\u89e6\u53d1before\u548cafter\u94a9\u5b50\uff0c\u89e6\u53d1before\u94a9\u5b50\u65f6\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5bf9\u5e94\u8f93\u51fa 1 before: asyncId: 2 executionAsyncId(): 2 triggerAsyncId(): 1 \u540c\u6837\uff0c\u5728\u56de\u8c03\u51fd\u6570\u91cc\u6267\u884cexecutionAsyncId\u548ctriggerAsyncId\u62ff\u5230\u7684\u5185\u5bb9\u662f\u4e00\u6837\u7684\u3002\u89e6\u53d1after\u540e\u518d\u6062\u590d\u4e0a\u4e0b\u6587\uff0c\u6240\u4ee5\u8f93\u51fa\u4e5f\u662f\u4e00\u6837\u7684\u3002 1 after: asyncId: 2 executionAsyncId(): 2 triggerAsyncId(): 1 7 AsyncResource \u00b6 \u5f02\u6b65\u8d44\u6e90\u5e76\u4e0d\u662fNode.js\u5185\u7f6e\u7684\uff0cNode.js\u53ea\u662f\u63d0\u4f9b\u4e86\u4e00\u5957\u673a\u5236\uff0c\u4e1a\u52a1\u5c42\u4e5f\u53ef\u4ee5\u4f7f\u7528\u3002Node.js\u4e5f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7c7b\u7ed9\u4e1a\u52a1\u4f7f\u7528\uff0c\u6838\u5fc3\u4ee3\u7801\u5982\u4e0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class AsyncResource { constructor ( type , opts = {}) { let triggerAsyncId = opts ; let requireManualDestroy = false ; if ( typeof opts !== 'number' ) { triggerAsyncId = opts . triggerAsyncId === undefined ? getDefaultTriggerAsyncId () : opts . triggerAsyncId ; requireManualDestroy = !! opts . requireManualDestroy ; } const asyncId = newAsyncId (); this [ async_id_symbol ] = asyncId ; this [ trigger_async_id_symbol ] = triggerAsyncId ; if ( initHooksExist ()) { emitInit ( asyncId , type , triggerAsyncId , this ); } } runInAsyncScope ( fn , thisArg , ... args ) { const asyncId = this [ async_id_symbol ]; emitBefore ( asyncId , this [ trigger_async_id_symbol ]); const ret = thisArg === undefined ? fn (... args ) : ReflectApply ( fn , thisArg , args ); emitAfter ( asyncId ); return ret ; } emitDestroy () { if ( this [ destroyedSymbol ] !== undefined ) { this [ destroyedSymbol ]. destroyed = true ; } emitDestroy ( this [ async_id_symbol ]); return this ; } asyncId () { return this [ async_id_symbol ]; } triggerAsyncId () { return this [ trigger_async_id_symbol ]; } } \u4f7f\u7528\u65b9\u5f0f\u5982\u4e0b\u3002 1 2 3 4 5 const { AsyncResource , executionAsyncId , triggerAsyncId } = require ( 'async_hooks' ); const asyncResource = new AsyncResource ( 'Demo' ); asyncResource . runInAsyncScope (() => { console . log ( executionAsyncId (), triggerAsyncId ()) }); runInAsyncScope\u4e2d\u4f1a\u628aasyncResource\u7684\u6267\u884c\u4e0a\u4e0b\u6587\u8bbe\u7f6e\u4e3a\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\uff0casync id\u662f2\uff0ctrigger async id\u662f1\uff0c\u6240\u4ee5\u5728\u56de\u8c03\u91cc\u6267\u884cexecutionAsyncId\u8f93\u51fa\u7684\u662f2\uff0ctriggerAsyncId\u8f93\u51fa\u7684\u662f1\u3002 8 AsyncLocalStorage \u00b6 AsyncLocalStorage\u662f\u57fa\u4e8eAsyncResource\u5b9e\u73b0\u7684\u4e00\u4e2a\u7ef4\u62a4\u5f02\u6b65\u903b\u8f91\u4e2d\u516c\u5171\u4e0a\u4e0b\u6587\u7684\u7c7b\u3002\u6211\u4eec\u53ef\u4ee5\u628a\u4ed6\u7406\u89e3\u4e3aRedis\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u600e\u4e48\u4f7f\u7528\u3002 8.1 \u4f7f\u7528 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const { AsyncLocalStorage } = require ( 'async_hooks' ); const asyncLocalStorage = new AsyncLocalStorage (); function logWithId ( msg ) { const id = asyncLocalStorage . getStore (); console . log ( ` ${ id !== undefined ? id : '-' } :` , msg ); } asyncLocalStorage . run ( 1 , () => { logWithId ( 'start' ); setImmediate (() => { logWithId ( 'finish' ); }); }); \u6267\u884c\u4e0a\u9762\u4ee3\u7801\u4f1a\u8f93\u51fa 1 2 1: start 1: finish run\u7684\u65f6\u5019\u521d\u59cb\u5316\u516c\u5171\u7684\u4e0a\u4e0b\u6587\uff0c\u7136\u540e\u5728run\u91cc\u6267\u884c\u7684\u5f02\u6b65\u4ee3\u7801\u4e5f\u53ef\u4ee5\u62ff\u5f97\u5230\u8fd9\u4e2a\u516c\u5171\u4e0a\u4e0b\u6587\uff0c\u8fd9\u4e2a\u5728\u8bb0\u5f55\u65e5\u5fd7traceId\u65f6\u5c31\u4f1a\u5f88\u6709\u7528\uff0c\u5426\u5219\u6211\u4eec\u5c31\u9700\u8981\u628atraceId\u4f20\u904d\u4ee3\u7801\u6bcf\u4e2a\u9700\u8981\u7684\u5730\u65b9\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0\u3002 8.2 \u5b9e\u73b0 \u00b6 \u6211\u4eec\u5148\u770b\u4e00\u4e0b\u521b\u5efaAsyncLocalStorage\u7684\u903b\u8f91 1 2 3 4 5 6 class AsyncLocalStorage { constructor () { this . kResourceStore = Symbol ( 'kResourceStore' ); this . enabled = false ; } } \u521b\u5efaAsyncLocalStorage\u7684\u65f6\u5019\u5f88\u7b80\u5355\uff0c\u4e3b\u8981\u662f\u7f6e\u72b6\u6001\u4e3afalse\uff0c\u5e76\u4e14\u8bbe\u7f6ekResourceStore\u7684\u503c\u4e3aSymbol('kResourceStore')\u3002\u8bbe\u7f6e\u4e3aSymbol('kResourceStore')\u800c\u4e0d\u662f\u2018kResourceStore\u2018\u5f88\u91cd\u8981\uff0c\u6211\u4eec\u540e\u9762\u4f1a\u770b\u5230\u3002\u7ee7\u7eed\u770b\u4e00\u4e0b\u6267\u884cAsyncLocalStorage.run\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 run ( store , callback , ... args ) { // \u65b0\u5efa\u4e00\u4e2aAsyncResource const resource = new AsyncResource ( 'AsyncLocalStorage' , defaultAlsResourceOpts ); // \u901a\u8fc7runInAsyncScope\u628aresource\u7684\u6267\u884c\u4e0a\u4e0b\u6587\u8bbe\u7f6e\u5b8c\u5f53\u524d\u7684\u6267\u884c\u4e0a\u4e0b\u6587 return resource . emitDestroy (). runInAsyncScope (() => { this . enterWith ( store ); return ReflectApply ( callback , null , args ); }); } \u8bbe\u7f6e\u5b8c\u4e0a\u4e0b\u6587\u4e4b\u540e\u6267\u884crunInAsyncScope\u7684\u56de\u8c03\uff0c\u56de\u8c03\u91cc\u9996\u5148\u6267\u884c\u91ccenterWith\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 enterWith ( store ) { // \u4fee\u6539AsyncLocalStorage\u72b6\u6001 this . _enable (); // \u83b7\u5f97\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5bf9\u4e8e\u591a\u8d44\u6e90\uff0c\u4e5f\u5c31\u662frun\u91cc\u521b\u5efa\u7684resource const resource = executionAsyncResource (); // \u628a\u516c\u5171\u4e0a\u4e0b\u6587\u6302\u8f7d\u5230\u5bf9\u8c61\u4e0a resource [ this . kResourceStore ] = store ; } _enable () { if ( ! this . enabled ) { this . enabled = true ; ArrayPrototypePush ( storageList , this ); storageHook . enable (); } } \u6302\u8f7d\u5b8c\u516c\u5171\u4e0a\u4e0b\u6587\u540e\uff0c\u5c31\u6267\u884c\u4e1a\u52a1\u56de\u8c03\u3002\u56de\u8c03\u91cc\u53ef\u4ee5\u901a\u8fc7asyncLocalStorage.getStore()\u83b7\u5f97\u8bbe\u7f6e\u7684\u516c\u5171\u4e0a\u4e0b\u6587\u3002 1 2 3 4 5 6 getStore () { if ( this . enabled ) { const resource = executionAsyncResource (); return resource [ this . kResourceStore ]; } } getStore\u7684\u539f\u7406\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u9996\u5148\u62ff\u5230\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5bf9\u5e94\u7684\u8d44\u6e90\uff0c\u7136\u540e\u6839\u636eAsyncLocalStorage\u7684kResourceStore\u7684\u503c\u4eceresource\u4e2d\u62ff\u5230\u516c\u5171\u4e0a\u4e0b\u6587\u3002\u5982\u679c\u662f\u540c\u6b65\u6267\u884cgetStore\uff0c\u90a3\u4e48executionAsyncResource\u8fd4\u56de\u7684\u5c31\u662f\u6211\u4eec\u5728run\u7684\u65f6\u5019\u521b\u5efa\u7684AsyncResource\uff0c\u4f46\u662f\u5982\u679c\u662f\u5f02\u6b65getStore\u90a3\u4e48\u600e\u4e48\u529e\u5462\uff1f\u56e0\u4e3a\u8fd9\u65f6\u5019executionAsyncResource\u8fd4\u56de\u7684\u4e0d\u518d\u662f\u6211\u4eec\u521b\u5efa\u7684AsyncResource\uff0c\u4e5f\u5c31\u62ff\u4e0d\u5230\u4ed6\u6302\u8f7d\u7684\u516c\u5171\u4e0a\u4e0b\u6587\u3002\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0cNode.js\u5bf9\u516c\u5171\u4e0a\u4e0b\u6587\u8fdb\u884c\u4e86\u4f20\u9012\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const storageList = []; // AsyncLocalStorage\u5bf9\u8c61\u6570\u7ec4 const storageHook = createHook ({ init ( asyncId , type , triggerAsyncId , resource ) { const currentResource = executionAsyncResource (); for ( let i = 0 ; i < storageList . length ; ++ i ) { storageList [ i ]. _propagate ( resource , currentResource ); } } }); _propagate ( resource , triggerResource ) { const store = triggerResource [ this . kResourceStore ]; if ( this . enabled ) { resource [ this . kResourceStore ] = store ; } } \u6211\u4eec\u770b\u5230Node.js\u5185\u90e8\u521b\u5efa\u4e86\u4e00\u4e2aHooks\uff0c\u5728\u6bcf\u6b21\u8d44\u6e90\u521b\u5efa\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u628a\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5bf9\u5e94\u7684\u8d44\u6e90\u4e2d\u7684\u4e00\u4e2a\u6216\u591a\u4e2akey\uff08\u6839\u636estorageList\u91cc\u5bf9\u8c61\u7684this.kResourceStore\u5b57\u6bb5\uff09\u5bf9\u5e94\u7684\u503c\u6302\u8f7d\u5230\u65b0\u521b\u5efa\u7684\u8d44\u6e90\u4e2d\u3002\u6240\u4ee5\u5728asyncLocalStorage.getStore()\u65f6\u5373\u4f7f\u4e0d\u662f\u6211\u4eec\u5728\u6267\u884crun\u65f6\u521b\u5efa\u7684\u8d44\u6e90\u5bf9\u8c61\uff0c\u4e5f\u53ef\u4ee5\u83b7\u5f97\u5177\u4f53asyncLocalStorage\u5bf9\u8c61\u6240\u8bbe\u7f6e\u7684\u8d44\u6e90\uff0c\u6211\u4eec\u518d\u6765\u770b\u4e00\u4e2a\u4f8b\u5b50\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const { AsyncLocalStorage } = require ( 'async_hooks' ); const asyncLocalStorage = new AsyncLocalStorage (); const asyncLocalStorage2 = new AsyncLocalStorage (); function logWithId ( msg ) { console . log ( asyncLocalStorage2 . getStore ()); const id = asyncLocalStorage . getStore (); console . log ( ` ${ id !== undefined ? id : '-' } :` , msg ); } asyncLocalStorage . run ( 0 , () => { asyncLocalStorage2 . enterWith ({ hello : \"world\" }); logWithId ( 'start' ); setImmediate (() => { logWithId ( 'finish' ); }); }); \u9664\u4e86\u901a\u8fc7asyncLocalStorage.run\u8bbe\u7f6e\u4e0a\u4e0b\u6587\uff0c\u6211\u4eec\u901a\u8fc7asyncLocalStorage2.enterWith\u4e5f\u7ed9\u5bf9\u8c61\u4e0a\u4e0b\u6587\u7684\u8d44\u6e90\u5bf9\u8c61\u6302\u8f7d\u4e00\u4e2a\u65b0\u5c5e\u6027\uff0ckey\u662fSymbol('kResourceStore')\uff0c\u503c\u662f{hello: \"world\"}\uff0c\u7136\u540e\u5728logWithId\u4e2d\u8f93\u51faasyncLocalStorage2.getStore()\u3002\u4ece\u8f93\u51fa\u4e2d\u53ef\u4ee5\u770b\u5230\u6210\u529f\u4ece\u8d44\u6e90\u4e2d\u83b7\u5f97\u6302\u8f7d\u7684\u6240\u6709\u4e0a\u4e0b\u6587\u3002 1 2 3 4 { hello: 'world' } 0: start { hello: 'world' } 0: finish \u6211\u4eec\u4e5f\u53ef\u4ee5\u4fee\u6539\u6e90\u7801\u9a8c\u8bc1 1 2 3 4 5 6 7 8 9 10 11 12 Immediate { _idleNext : null , _idlePrev : null , _onImmediate : [ Function ( anonymous )], _argv : undefined , _destroyed : true , [ Symbol ( refed )] : null , [ Symbol ( asyncId )] : 6 , [ Symbol ( triggerId )] : 2 , [ Symbol ( kResourceStore )] : 0 , [ Symbol ( kResourceStore )] : { hello : ' world ' } } \u53ef\u4ee5\u770b\u5230\u8d44\u6e90\u5bf9\u8c61\u6302\u8f7d\u91cc\u4e24\u4e2akey\u4e3aSymbol(kResourceStore)\u7684\u5c5e\u6027\u3002 9 \u521d\u59cb\u5316\u65f6\u7684Async hooks \u00b6 1 2 3 4 const async_hooks = require ( 'async_hooks' ); const eid = async_hooks . executionAsyncId (); const tid = async_hooks . triggerAsyncId (); console . log ( eid , tid ); \u4ee5\u4e0a\u4ee3\u7801\u4e2d,\u8f93\u51fa1\u548c0\u3002\u5bf9\u5e94\u7684API\u5b9e\u73b0\u5982\u4e0b\u3002 1 2 3 4 5 6 7 8 // \u83b7\u53d6\u5f53\u524d\u7684async id function executionAsyncId () { return async_id_fields [ kExecutionAsyncId ]; } // \u83b7\u53d6\u5f53\u524d\u7684trigger async id\uff0c\u5373\u89e6\u53d1\u5f53\u524d\u4ee3\u7801\u7684async id function triggerAsyncId () { return async_id_fields [ kTriggerAsyncId ]; } \u90a3\u4e48async_id_fields\u7684\u521d\u59cb\u5316\u662f\u4ec0\u4e48\u5462\uff1f\u4eceenv.h\u5b9a\u4e49\u4e2d\u53ef\u4ee5\u770b\u5230async_id_fields_\uff08async_id_fields\u662f\u4e0a\u5c42\u4f7f\u7528\u7684\u540d\u79f0\uff0c\u5bf9\u5e94\u5e95\u5c42\u7684async_id_fields_\uff09\u662fAliasedFloat64Array\u7c7b\u578b\u3002 1 AliasedFloat64Array async_id_fields_ ; AliasedFloat64Array\u662f\u4e2a\u7c7b\u578b\u522b\u540d\u3002 1 typedef AliasedBufferBase < double , v8 :: Float64Array > AliasedFloat64Array ; AliasedBufferBase\u7684\u6784\u9020\u51fd\u6570\u5982\u4e0b 1 2 3 4 5 6 7 8 AliasedBufferBase ( v8 :: Isolate * isolate , const size_t count ) : isolate_ ( isolate ), count_ ( count ), byte_offset_ ( 0 ) { const v8 :: HandleScope handle_scope ( isolate_ ); const size_t size_in_bytes = MultiplyWithOverflowCheck ( sizeof ( NativeT ), count ); v8 :: Local < v8 :: ArrayBuffer > ab = v8 :: ArrayBuffer :: New ( isolate_ , size_in_bytes ); // ... } \u5e95\u5c42\u662f\u4e00\u4e2aArrayBuffer\u3002 1 2 3 4 5 6 7 8 9 Local < ArrayBuffer > v8 :: ArrayBuffer :: New ( Isolate * isolate , size_t byte_length ) { i :: Isolate * i_isolate = reinterpret_cast < i :: Isolate *> ( isolate ); LOG_API ( i_isolate , ArrayBuffer , New ); ENTER_V8_NO_SCRIPT_NO_EXCEPTION ( i_isolate ); i :: MaybeHandle < i :: JSArrayBuffer > result = i_isolate -> factory () -> NewJSArrayBufferAndBackingStore ( byte_length , i :: InitializedFlag :: kZeroInitialized ); // ... } ArrayBuffer::New\u5728\u7533\u8bf7\u5185\u5b58\u65f6\u4f20\u5165\u4e86i::InitializedFlag::kZeroInitialized\u3002\u4eceV8\u5b9a\u4e49\u4e2d\u53ef\u4ee5\u770b\u5230\u4f1a\u521d\u59cb\u5316\u5185\u5b58\u7684\u5185\u5bb9\u4e3a0\u3002 1 2 // Whether the backing store memory is initialied to zero or not. enum class InitializedFlag : uint8_t { kUninitialized , kZeroInitialized }; \u56de\u5230\u4f8b\u5b50\u4e2d\uff0c\u4e3a\u4ec0\u4e48\u8f93\u51fa\u4f1a\u662f1\u548c0\u800c\u4e0d\u662f0\u548c0\u5462\uff1f\u7b54\u6848\u5728Node.js\u542f\u52a8\u65f6\u7684\u8fd9\u6bb5\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 { InternalCallbackScope callback_scope ( env . get (), Local < Object > (), // async id\u548ctrigger async id { 1 , 0 }, InternalCallbackScope :: kAllowEmptyResource | InternalCallbackScope :: kSkipAsyncHooks ); // \u6267\u884c\u6211\u4eec\u7684js LoadEnvironment ( env . get ()); } InternalCallbackScope\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4ed6\u4f1a\u628a1\u548c0\u8bbe\u7f6e\u4e3a\u5f53\u524d\u7684\u6267\u884c\u4e0a\u4e0b\u6587\u3002\u7136\u540e\u5728LoadEnvironment\u91cc\u6267\u884c\u6211\u7684JS\u4ee3\u7801\u65f6\u83b7\u53d6\u5230\u7684\u503c\u5c31\u662f1\u548c0\u3002\u90a3\u4e48\u5982\u679c\u6211\u4eec\u6539\u6210\u4ee5\u4e0b\u4ee3\u7801\u4f1a\u8f93\u51fa\u4ec0\u4e48\u5462\uff1f 1 2 3 4 5 6 const async_hooks = require ( 'async_hooks' ); Promise . resolve (). then (() => { const eid = async_hooks . executionAsyncId (); const tid = async_hooks . triggerAsyncId (); console . log ( eid , tid ); }) \u4ee5\u4e0a\u4ee3\u7801\u4f1a\u8f93\u51fa0\u548c\u3002\u56e0\u4e3a\u6267\u884c\u5b8c\u6211\u4eec\u7684JS\u4ee3\u7801\u540e\uff0cInternalCallbackScope\u5c31\u88ab\u6790\u6784\u4e86\uff0c\u4ece\u800c\u6062\u590d\u4e3a0\u548c0\u3002","title":"22-Async hooks"},{"location":"chapter23-Async%20hooks/#1-envasynchooks","text":"\u5728Node.js\u7684env\u5bf9\u8c61\u4e2d\u6709\u4e00\u4e2aAsyncHooks\u5bf9\u8c61\uff0c\u8d1f\u8d23Node.js\u8fdb\u7a0b\u4e2dasync_hooks\u7684\u7ba1\u7406\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u5b9a\u4e49\u3002","title":"1 env\u4e2d\u7684AsyncHooks"},{"location":"chapter23-Async%20hooks/#11","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class AsyncHooks : public MemoryRetainer { public : enum Fields { // \u4e94\u79cd\u94a9\u5b50 kInit , kBefore , kAfter , kDestroy , kPromiseResolve , // \u94a9\u5b50\u603b\u6570 kTotals , // async_hooks\u5f00\u542f\u7684\u4e2a\u6570 kCheck , // \u8bb0\u5f55\u6808\u7684top\u6307\u9488 kStackLength , // \u6570\u7ec4\u5927\u5c0f kFieldsCount , }; enum UidFields { kExecutionAsyncId , kTriggerAsyncId , // \u5f53\u524dasync id\u7684\u503c kAsyncIdCounter , kDefaultTriggerAsyncId , kUidFieldsCount , }; private : inline AsyncHooks (); // \u5f02\u6b65\u8d44\u6e90\u7684\u7c7b\u578b std :: array < v8 :: Eternal < v8 :: String > , AsyncWrap :: PROVIDERS_LENGTH > providers_ ; // \u6808 AliasedFloat64Array async_ids_stack_ ; // \u6574\u5f62\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5143\u7d20\u503c\u7684\u610f\u4e49\u548cFields\u5bf9\u5e94 AliasedUint32Array fields_ ; // \u6574\u5f62\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5143\u7d20\u503c\u7684\u610f\u4e49\u548cUidFields\u5bf9\u5e94 AliasedFloat64Array async_id_fields_ ; }; \u7ed3\u6784\u56fe\u5982\u4e0b \u63a5\u4e0b\u6765\u770b\u4e00\u4e0benv\u7684AsyncHooks\u5bf9\u8c61\u63d0\u4f9b\u4e86\u54ea\u4e9bAPI\uff0c\u8fd9\u4e9bAPI\u662f\u4e0a\u5c42\u7684\u57fa\u7840\u3002","title":"1.1 \u7c7b\u5b9a\u4e49"},{"location":"chapter23-Async%20hooks/#12-api","text":"\u6211\u4eec\u770b\u4e00\u4e0benv\u5bf9\u8c61\u4e2d\u83b7\u53d6AsyncHooks\u5bf9\u8c61\u5bf9\u5e94\u5b57\u6bb5\u7684API\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // \u83b7\u53d6\u5bf9\u5e94\u7684\u5b57\u6bb5 inline AliasedUint32Array & AsyncHooks::fields () { return fields_ ; } inline AliasedFloat64Array & AsyncHooks::async_id_fields () { return async_id_fields_ ; } inline AliasedFloat64Array & AsyncHooks::async_ids_stack () { return async_ids_stack_ ; } // \u83b7\u53d6\u8d44\u6e90\u7c7b\u578b inline v8 :: Local < v8 :: String > AsyncHooks :: provider_string ( int idx ) { return providers_ [ idx ]. Get ( env () -> isolate ()); } // \u65b0\u5efa\u8d44\u6e90\u7684\u65f6\u5019\uff0c\u83b7\u53d6\u65b0\u7684async id inline double Environment :: new_async_id () { async_hooks () -> async_id_fields ()[ AsyncHooks :: kAsyncIdCounter ] += 1 ; return async_hooks () -> async_id_fields ()[ AsyncHooks :: kAsyncIdCounter ]; } // \u83b7\u53d6\u5f53\u524dasync id inline double Environment :: execution_async_id () { return async_hooks () -> async_id_fields ()[ AsyncHooks :: kExecutionAsyncId ]; } // \u83b7\u53d6\u5f53\u524dtrigger async id inline double Environment :: trigger_async_id () { return async_hooks () -> async_id_fields ()[ AsyncHooks :: kTriggerAsyncId ]; } // \u83b7\u53d6\u9ed8\u8ba4\u7684trigger async id\uff0c\u5982\u679c\u6ca1\u6709\u8bbe\u7f6e\uff0c\u5219\u83b7\u53d6\u5f53\u524d\u7684async id inline double Environment :: get_default_trigger_async_id () { double default_trigger_async_id = async_hooks () -> async_id_fields ()[ AsyncHooks :: kDefaultTriggerAsyncId ]; // If defaultTriggerAsyncId isn't set, use the executionAsyncId if ( default_trigger_async_id < 0 ) default_trigger_async_id = execution_async_id (); return default_trigger_async_id ; }","title":"1.2 \u8bfbAPI"},{"location":"chapter23-Async%20hooks/#13-api","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 inline void AsyncHooks::push_async_ids ( double async_id , double trigger_async_id ) { // \u83b7\u53d6\u5f53\u524d\u6808\u9876\u6307\u9488 uint32_t offset = fields_ [ kStackLength ]; // \u4e0d\u591f\u5219\u6269\u5bb9 if ( offset * 2 >= async_ids_stack_ . Length ()) grow_async_ids_stack (); // \u628a\u65e7\u7684\u4e0a\u4e0b\u6587\u538b\u6808 async_ids_stack_ [ 2 * offset ] = async_id_fields_ [ kExecutionAsyncId ]; async_ids_stack_ [ 2 * offset + 1 ] = async_id_fields_ [ kTriggerAsyncId ]; // \u6808\u6307\u9488\u52a0\u4e00 fields_ [ kStackLength ] += 1 ; // \u8bb0\u5f55\u5f53\u524d\u4e0a\u4e0b\u6587 async_id_fields_ [ kExecutionAsyncId ] = async_id ; async_id_fields_ [ kTriggerAsyncId ] = trigger_async_id ; } // \u548c\u4e0a\u9762\u7684\u903b\u8f91\u76f8\u53cd inline bool AsyncHooks::pop_async_id ( double async_id ) { if ( fields_ [ kStackLength ] == 0 ) return false ; uint32_t offset = fields_ [ kStackLength ] - 1 ; async_id_fields_ [ kExecutionAsyncId ] = async_ids_stack_ [ 2 * offset ]; async_id_fields_ [ kTriggerAsyncId ] = async_ids_stack_ [ 2 * offset + 1 ]; fields_ [ kStackLength ] = offset ; return fields_ [ kStackLength ] > 0 ; }","title":"1.3 \u5199API"},{"location":"chapter23-Async%20hooks/#2-asyncwrap","text":"\u63a5\u7740\u770b\u4e00\u4e0b\u5f02\u6b65\u8d44\u6e90\u7684\u57fa\u7c7bAsyncWrap\u3002\u6240\u6709\u4f9d\u8d56\u4e8eC\u3001C++\u5c42\u5b9e\u73b0\u7684\u8d44\u6e90\uff08\u6bd4\u5982TCP\u3001UDP\uff09\u90fd\u4f1a\u7ee7\u627fAsyncWrap\u3002\u770b\u770b\u8be5\u7c7b\u7684\u5b9a\u4e49\u3002 1 2 3 4 5 6 class AsyncWrap : public BaseObject { private : ProviderType provider_type_ = PROVIDER_NONE ; double async_id_ = kInvalidAsyncId ; double trigger_async_id_ ; }; \u6211\u4eec\u770b\u5230\u6bcf\u4e2aAsyncWrap\u5bf9\u8c61\u90fd\u6709async_id_\u3001trigger_async_id_\u548cprovider_type_\u5c5e\u6027\uff0c\u8fd9\u6b63\u662f\u5728init\u56de\u8c03\u91cc\u62ff\u5230\u7684\u6570\u636e\u3002\u6211\u4eec\u770b\u770bAsyncWrap\u7684\u6784\u9020\u51fd\u6570\u3002\u63a5\u4e0b\u6765\u770b\u4e00\u4e0b\u65b0\u5efa\u4e00\u4e2a\u8d44\u6e90\uff08AsyncWrap\uff09\u65f6\u7684\u903b\u8f91\u3002","title":"2 \u5e95\u5c42\u8d44\u6e90\u5c01\u88c5\u7c7b - AsyncWrap"},{"location":"chapter23-Async%20hooks/#21","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 AsyncWrap :: AsyncWrap ( Environment * env , Local < Object > object , ProviderType provider , double execution_async_id , bool silent ) : AsyncWrap ( env , object ) { // \u8d44\u6e90\u7c7b\u578b provider_type_ = provider ; AsyncReset ( execution_async_id , silent ); } void AsyncWrap :: AsyncReset ( Local < Object > resource , double execution_async_id , bool silent ) { // \u83b7\u53d6\u4e00\u4e2a\u65b0\u7684async id\uff0cexecution_async_id\u9ed8\u8ba4\u662fkInvalidAsyncId async_id_ = execution_async_id == kInvalidAsyncId ? env () -> new_async_id () : execution_async_id ; // \u83b7\u53d6trigger async id trigger_async_id_ = env () -> get_default_trigger_async_id (); // \u6267\u884cinit\u94a9\u5b50 EmitAsyncInit ( env (), resource , env () -> async_hooks () -> provider_string ( provider_type ()), async_id_ , trigger_async_id_ ); } \u63a5\u7740\u770bEmitAsyncInit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void AsyncWrap::EmitAsyncInit ( Environment * env , Local < Object > object , Local < String > type , double async_id , double trigger_async_id ) { AsyncHooks * async_hooks = env -> async_hooks (); HandleScope scope ( env -> isolate ()); Local < Function > init_fn = env -> async_hooks_init_function (); Local < Value > argv [] = { Number :: New ( env -> isolate (), async_id ), type , Number :: New ( env -> isolate (), trigger_async_id ), object , }; TryCatchScope try_catch ( env , TryCatchScope :: CatchMode :: kFatal ); // \u6267\u884cinit\u56de\u8c03 USE ( init_fn -> Call ( env -> context (), object , arraysize ( argv ), argv )); } \u90a3\u4e48env->async_hooks_init_function()\u7684\u503c\u662f\u4ec0\u4e48\u5462\uff1f\u8fd9\u662f\u5728Node.js\u521d\u59cb\u5316\u65f6\u8bbe\u7f6e\u7684\u3002 1 2 const { nativeHooks } = require ( 'internal/async_hooks' ); internalBinding ( 'async_wrap' ). setupHooks ( nativeHooks ); SetupHooks\u7684\u5b9e\u73b0\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 static void SetupHooks ( const FunctionCallbackInfo < Value >& args ) { Environment * env = Environment :: GetCurrent ( args ); Local < Object > fn_obj = args [ 0 ]. As < Object > (); #define SET_HOOK_FN(name) \\ do { \\ Local<Value> v = \\ fn_obj->Get(env->context(), \\ FIXED_ONE_BYTE_STRING(env->isolate(), #name)) \\ .ToLocalChecked(); \\ CHECK(v->IsFunction()); \\ env->set_async_hooks_##name##_function(v.As<Function>()); \\ } while (0) // \u4fdd\u5b58\u5230env\u4e2d SET_HOOK_FN ( init ); SET_HOOK_FN ( before ); SET_HOOK_FN ( after ); SET_HOOK_FN ( destroy ); SET_HOOK_FN ( promise_resolve ); #undef SET_HOOK_FN } nativeHooks\u7684\u5b9e\u73b0\u5982\u4e0b 1 2 3 4 5 6 7 nativeHooks : { init : emitInitNative , before : emitBeforeNative , after : emitAfterNative , destroy : emitDestroyNative , promise_resolve : emitPromiseResolveNative } \u8fd9\u4e9bHooks\u4f1a\u6267\u884c\u5bf9\u5e94\u7684\u56de\u8c03\uff0c\u6bd4\u5982emitInitNative 1 2 3 4 5 6 7 8 9 10 function emitInitNative ( asyncId , type , triggerAsyncId , resource ) { for ( var i = 0 ; i < active_hooks . array . length ; i ++ ) { if ( typeof active_hooks . array [ i ][ init_symbol ] === 'function' ) { active_hooks . array [ i ][ init_symbol ]( asyncId , type , triggerAsyncId , resource ); } } } active_hooks.array\u7684\u503c\u5c31\u662f\u6211\u4eec\u5728\u4e1a\u52a1\u4ee3\u7801\u91cc\u8bbe\u7f6e\u7684\u94a9\u5b50\uff0c\u6bcf\u6b21\u8c03\u7814createHooks\u7684\u65f6\u5019\u5c31\u5bf9\u5e94\u6570\u7ec4\u7684\u4e00\u4e2a\u5143\u7d20\u3002","title":"2.1 \u8d44\u6e90\u521d\u59cb\u5316"},{"location":"chapter23-Async%20hooks/#22","text":"\u5f53\u4e1a\u52a1\u4ee3\u7801\u5f02\u6b65\u8bf7\u6c42\u5e95\u5c42API\uff0c\u5e76\u4e14\u5e95\u5c42\u6ee1\u8db3\u6761\u4ef6\u65f6\uff0c\u5c31\u4f1a\u6267\u884c\u4e0a\u5c42\u7684\u56de\u8c03\uff0c\u6bd4\u5982\u76d1\u542c\u4e00\u4e2asocket\u65f6\uff0c\u6709\u8fde\u63a5\u5230\u6765\u3002Node.js\u5c31\u4f1a\u8c03\u7528MakeCallback\u51fd\u6570\u6267\u884c\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 10 MaybeLocal < Value > AsyncWrap :: MakeCallback ( const Local < Function > cb , int argc , Local < Value >* argv ) { // \u5f53\u524dAsyncWrap\u5bf9\u8c61\u5bf9\u5e94\u7684\u6267\u884c\u4e0a\u4e0b\u6587 ProviderType provider = provider_type (); async_context context { get_async_id (), get_trigger_async_id () }; MaybeLocal < Value > ret = InternalMakeCallback ( env (), object (), cb , argc , argv , context ); return ret ; } MakeCallback\u4e2d\u4f1a\u8c03\u7528InternalMakeCallback\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 MaybeLocal < Value > InternalMakeCallback ( Environment * env , Local < Object > recv , const Local < Function > callback , int argc , Local < Value > argv [], async_context asyncContext ) { // \u65b0\u5efa\u4e00\u4e2ascope InternalCallbackScope scope ( env , recv , asyncContext ); // \u6267\u884c\u56de\u8c03 callback -> Call ( env -> context (), recv , argc , argv ); // \u5173\u95edscope scope . Close (); } \u6211\u4eec\u770b\u770b\u65b0\u5efa\u548c\u5173\u95edscope\u90fd\u505a\u4e86\u4ec0\u4e48\u4e8b\u60c5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 InternalCallbackScope :: InternalCallbackScope ( Environment * env , Local < Object > object , const async_context & asyncContext , int flags ) : env_ ( env ), async_context_ ( asyncContext ), object_ ( object ), skip_hooks_ ( flags & kSkipAsyncHooks ), skip_task_queues_ ( flags & kSkipTaskQueues ) { // v14\u7248\u672c\u4e2d\uff0c\u662f\u5148\u89e6\u53d1before\u518dpush\u4e0a\u4e0b\u6587\uff0c\u987a\u5e8f\u662f\u4e0d\u5bf9\u7684\uff0cv16\u5df2\u7ecf\u6539\u8fc7\u6765\u3002 // \u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5165\u6808 env -> async_hooks () -> push_async_ids ( async_context_ . async_id , async_context_ . trigger_async_id ); // \u89e6\u53d1before\u94a9\u5b50 if ( asyncContext . async_id != 0 && ! skip_hooks_ ) { AsyncWrap :: EmitBefore ( env , asyncContext . async_id ); } pushed_ids_ = true ; } \u5728scope\u91cc\u4f1a\u628a\u5f53\u524dAsyncWrap\u5bf9\u8c61\u7684\u6267\u884c\u4e0a\u4e0b\u6587\u4f5c\u4e3a\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\uff0c\u5e76\u4e14\u89e6\u53d1before\u94a9\u5b50\uff0c\u7136\u540e\u6267\u884c\u4e1a\u52a1\u56de\u8c03\uff0c\u6240\u4ee5\u6211\u4eec\u5728\u56de\u8c03\u91cc\u83b7\u53d6\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u65f6\u5c31\u62ff\u5230\u4e86AsyncWrap\u5bf9\u5e94\u7684\u503c\uff08 \u8c03\u7528executionAsyncId\uff09\uff0c\u63a5\u7740\u770bClose 1 2 3 4 5 6 7 8 9 void InternalCallbackScope::Close () { // \u6267\u884c if ( pushed_ids_ ) env_ -> async_hooks () -> pop_async_id ( async_context_ . async_id ); if ( async_context_ . async_id != 0 && ! skip_hooks_ ) { AsyncWrap :: EmitAfter ( env_ , async_context_ . async_id ); } } Close\u5728\u6267\u884c\u56de\u8c03\u540e\u88ab\u8c03\u7528\uff0c\u4e3b\u8981\u662f\u6062\u590d\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5e76\u4e14\u89e6\u53d1after\u94a9\u5b50\u3002","title":"2.2 \u6267\u884c\u8d44\u6e90\u56de\u8c03"},{"location":"chapter23-Async%20hooks/#3-timeouttickobjecd","text":"\u5e76\u4e0d\u662f\u6240\u6709\u7684\u5f02\u6b65\u8d44\u6e90\u90fd\u662f\u5e95\u5c42\u5b9e\u73b0\u7684\uff0c\u6bd4\u5982\u5b9a\u65f6\u5668\uff0ctick\u4e5f\u88ab\u5b9a\u4e49\u4e3a\u5f02\u6b65\u8d44\u6e90\uff0c\u56e0\u4e3a\u4ed6\u4eec\u90fd\u662f\u548c\u56de\u8c03\u76f8\u5173\u3002\u8fd9\u79cd\u5f02\u6b65\u8d44\u6e90\u662f\u5728JS\u5c42\u5b9e\u73b0\u7684\uff0c\u8fd9\u91cc\u53ea\u5206\u6790Timeout\u3002","title":"3 \u4e0a\u5c42\u8d44\u6e90\u7684\u5c01\u88c5 - Timeout\u3001TickObjecd\u7b49"},{"location":"chapter23-Async%20hooks/#31","text":"\u6211\u4eec\u770b\u4e00\u4e0b\u6267\u884csetTimeout\u65f6\u7684\u6838\u5fc3\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function setTimeout ( callback , after , arg1 , arg2 , arg3 ) { const timeout = new Timeout ( callback , after , args , false , true ); return timeout ; } function Timeout ( callback , after , args , isRepeat , isRefed ) { initAsyncResource ( this , 'Timeout' ); } function initAsyncResource ( resource , type ) { // \u83b7\u53d6\u65b0\u7684async id const asyncId = resource [ async_id_symbol ] = newAsyncId (); const triggerAsyncId = resource [ trigger_async_id_symbol ] = getDefaultTriggerAsyncId (); // \u662f\u5426\u8bbe\u7f6e\u4e86init\u94a9\u5b50\uff0c\u662f\u5219\u89e6\u53d1\u56de\u8c03 if ( initHooksExist ()) emitInit ( asyncId , type , triggerAsyncId , resource ); } \u6267\u884csetTimeout\u65f6\uff0cNode.js\u4f1a\u521b\u5efa\u4e00\u4e2aTimeout\u5bf9\u8c61\uff0c\u8bbe\u7f6easync_hooks\u76f8\u5173\u7684\u4e0a\u4e0b\u6587\u5e76\u8bb0\u5f55\u5230Timeout\u5bf9\u8c61\u4e2d\u3002\u7136\u540e\u89e6\u53d1init\u94a9\u5b50\u3002 1 2 3 function emitInitScript ( asyncId , type , triggerAsyncId , resource ) { emitInitNative ( asyncId , type , triggerAsyncId , resource ); } \u4ee5\u4e0a\u4ee3\u7801\u4f1a\u6267\u884c\u6bcf\u4e2aasync_hooks\u5bf9\u8c61\u7684init\u56de\u8c03(\u901a\u5e38\u6211\u4eec\u53ea\u6709\u4e00\u4e2aasync_hooks\u5bf9\u8c61)\u3002","title":"3.1 \u521b\u5efa\u8d44\u6e90"},{"location":"chapter23-Async%20hooks/#31_1","text":"\u5f53\u5b9a\u65f6\u5668\u5230\u671f\u65f6\uff0c\u4f1a\u6267\u884c\u56de\u8c03\uff0c\u6211\u4eec\u770b\u770b\u76f8\u5173\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 // \u89e6\u53d1before\u94a9\u5b50 emitBefore ( asyncId , timer [ trigger_async_id_symbol ]); // \u6267\u884c\u56de\u8c03 timer . _onTimeout (); // \u89e6\u53d1after\u56de\u8c03 emitAfter ( asyncId ); \u6211\u4eec\u770b\u5230\u6267\u884c\u8d85\u65f6\u56de\u8c03\u7684\u524d\u540e\u4f1a\u89e6\u53d1\u5bf9\u5e94\u7684\u94a9\u5b50\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function emitBeforeScript ( asyncId , triggerAsyncId ) { // \u548c\u5e95\u5c42\u7684push_async_ids\u903b\u8f91\u4e00\u6837 pushAsyncIds ( asyncId , triggerAsyncId ); // \u5982\u679c\u6709\u56de\u8c03\u5219\u6267\u884c if ( async_hook_fields [ kBefore ] > 0 ) emitBeforeNative ( asyncId ); } function emitAfterScript ( asyncId ) { // \u8bbe\u7f6e\u4e86after\u56de\u8c03\u5219emit if ( async_hook_fields [ kAfter ] > 0 ) emitAfterNative ( asyncId ); // \u548c\u5e95\u5c42\u7684pop_async_ids\u903b\u8f91\u4e00\u6837 popAsyncIds ( asyncId ); } JS\u5c42\u7684\u5b9e\u73b0\u548c\u5e95\u5c42\u662f\u4fdd\u6301\u4e00\u81f4\u7684\u3002\u5982\u679c\u6211\u4eec\u5728setTimeout\u56de\u8c03\u91cc\u65b0\u5efa\u4e00\u4e2a\u8d44\u6e90\uff0c\u6bd4\u5982\u518d\u6b21\u6267\u884csetTimeout\uff0c\u8fd9\u65f6\u5019trigger async id\u5c31\u662f\u7b2c\u4e00\u4e2asetTimeout\u5bf9\u5e94\u7684async id\uff0c\u6240\u4ee5\u5c31\u8fde\u8d77\u6765\u4e86\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u770b\u5230\u5177\u4f53\u7684\u4f8b\u5b50\u3002","title":"3.1 \u6267\u884c\u56de\u8c03"},{"location":"chapter23-Async%20hooks/#4-defaulttriggerasyncidscope","text":"Node.js\u4e3a\u4e86\u907f\u514d\u8fc7\u591a\u901a\u8fc7\u53c2\u6570\u4f20\u9012\u7684\u65b9\u5f0f\u4f20\u9012async id\uff0c\u5c31\u8bbe\u8ba1\u4e86DefaultTriggerAsyncIdScope\u3002DefaultTriggerAsyncIdScope\u7684\u4f5c\u7528\u7c7b\u4f3c\u5728\u591a\u4e2a\u51fd\u6570\u5916\u7ef4\u62a4\u4e00\u4e2a\u53d8\u91cf\uff0c\u591a\u4e2a\u51fd\u6570\u90fd\u53ef\u4ee5\u901a\u8fc7DefaultTriggerAsyncIdScope\u83b7\u5f97trigger async id\uff0c\u800c\u4e0d\u9700\u8981\u901a\u8fc7\u5c42\u5c42\u4f20\u9012\u7684\u65b9\u5f0f\uff0c\u4ed6\u7684\u5b9e\u73b0\u975e\u5e38\u7b80\u5355\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class DefaultTriggerAsyncIdScope { private : AsyncHooks * async_hooks_ ; double old_default_trigger_async_id_ ; }; inline AsyncHooks :: DefaultTriggerAsyncIdScope :: DefaultTriggerAsyncIdScope ( Environment * env , double default_trigger_async_id ) : async_hooks_ ( env -> async_hooks ()) { // \u8bb0\u5f55\u65e7\u7684id\uff0c\u8bbe\u7f6e\u65b0\u7684id old_default_trigger_async_id_ = async_hooks_ -> async_id_fields ()[ AsyncHooks :: kDefaultTriggerAsyncId ]; async_hooks_ -> async_id_fields ()[ AsyncHooks :: kDefaultTriggerAsyncId ] = default_trigger_async_id ; } // \u6062\u590d inline AsyncHooks :: DefaultTriggerAsyncIdScope ::~ DefaultTriggerAsyncIdScope () { async_hooks_ -> async_id_fields ()[ AsyncHooks :: kDefaultTriggerAsyncId ] = old_default_trigger_async_id_ ; } DefaultTriggerAsyncIdScope\u4e3b\u8981\u662f\u8bb0\u5f55\u65e7\u7684id\uff0c\u7136\u540e\u628a\u65b0\u7684id\u8bbe\u7f6e\u5230env\u4e2d\uff0c\u5f53\u5176\u4ed6\u51fd\u6570\u8c03\u7528get_default_trigger_async_id\u65f6\u5c31\u53ef\u4ee5\u83b7\u53d6\u8bbe\u7f6e\u7684async id\u3002\u540c\u6837JS\u5c42\u4e5f\u5b9e\u73b0\u4e86\u7c7b\u4f3c\u7684API\u3002 1 2 3 4 5 6 7 8 9 10 function defaultTriggerAsyncIdScope ( triggerAsyncId , block , ... args ) { const oldDefaultTriggerAsyncId = async_id_fields [ kDefaultTriggerAsyncId ]; async_id_fields [ kDefaultTriggerAsyncId ] = triggerAsyncId ; try { return block (... args ); } finally { async_id_fields [ kDefaultTriggerAsyncId ] = oldDefaultTriggerAsyncId ; } } \u5728\u6267\u884cblock\u51fd\u6570\u65f6\uff0c\u53ef\u4ee5\u83b7\u53d6\u5230\u8bbe\u7f6e\u7684\u503c\uff0c\u800c\u4e0d\u9700\u8981\u4f20\u9012\uff0c\u6267\u884c\u5b8cblock\u540e\u6062\u590d\u3002\u6211\u4eec\u770b\u770b\u5982\u4f55\u4f7f\u7528\u3002\u4e0b\u9762\u6458\u81eanet\u6a21\u5757\u7684\u4ee3\u7801\u3002 1 2 3 4 5 6 // \u83b7\u53d6handle\u91cc\u7684async id this [ async_id_symbol ] = getNewAsyncId ( this . _handle ); defaultTriggerAsyncIdScope ( this [ async_id_symbol ], process . nextTick , emitListeningNT , this ); \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u91cc\u5177\u4f53\u7684\u60c5\u51b5\u3002\u5728defaultTriggerAsyncIdScope\u4e2d\u4f1a\u4ee5emitListeningNT\u4e3a\u5165\u53c2\u6267\u884cprocess.nextTick\u3002\u6211\u4eec\u770b\u770bnextTick\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function nextTick ( callback ) { // \u83b7\u53d6\u65b0\u7684async id const asyncId = newAsyncId (); // \u83b7\u53d6\u9ed8\u8ba4\u7684trigger async id\uff0c\u5373\u521a\u624d\u8bbe\u7f6e\u7684 const triggerAsyncId = getDefaultTriggerAsyncId (); const tickObject = { [ async_id_symbol ] : asyncId , [ trigger_async_id_symbol ] : triggerAsyncId , callback , args }; if ( initHooksExist ()) // \u521b\u5efa\u4e86\u65b0\u7684\u8d44\u6e90\uff0c\u89e6\u53d1init\u94a9\u5b50 emitInit ( asyncId , 'TickObject' , triggerAsyncId , tickObject ); queue . push ( tickObject ); } \u6211\u4eec\u770b\u5230\u5728nextTick\u4e2d\u901a\u8fc7getDefaultTriggerAsyncId\u62ff\u5230\u4e86trigger async id\u3002 1 2 3 4 5 6 function getDefaultTriggerAsyncId () { const defaultTriggerAsyncId = async_id_fields [ kDefaultTriggerAsyncId ]; if ( defaultTriggerAsyncId < 0 ) return async_id_fields [ kExecutionAsyncId ]; return defaultTriggerAsyncId ; } getDefaultTriggerAsyncId\u8fd4\u56de\u7684\u5c31\u662f\u521a\u624d\u901a\u8fc7defaultTriggerAsyncIdScope\u8bbe\u7f6e\u7684async id\u3002\u6240\u4ee5\u5728\u89e6\u53d1TickObject\u7684init\u94a9\u5b50\u65f6\u7528\u6237\u5c31\u53ef\u4ee5\u62ff\u5230\u5bf9\u5e94\u7684id\u3002\u4e0d\u8fc7\u66f4\u91cd\u8981\u7684\u65f6\uff0c\u5728\u5f02\u6b65\u6267\u884cnextTick\u7684\u4efb\u52a1\u65f6\uff0c\u8fd8\u53ef\u4ee5\u62ff\u5230\u539f\u59cb\u7684trigger async id\u3002\u56e0\u4e3a\u8be5id\u8bb0\u5f55\u5728tickObject\u4e2d\u3002\u6211\u4eec\u770b\u770b\u6267\u884ctick\u4efb\u52a1\u65f6\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function processTicksAndRejections () { let tock ; do { while ( tock = queue . shift ()) { // \u62ff\u5230\u5bf9\u5e94\u7684async \u4e0a\u4e0b\u6587 const asyncId = tock [ async_id_symbol ]; emitBefore ( asyncId , tock [ trigger_async_id_symbol ]); try { const callback = tock . callback ; callback (); } finally { if ( destroyHooksExist ()) emitDestroy ( asyncId ); } emitAfter ( asyncId ); } } while ( ! queue . isEmpty () || processPromiseRejections ()); }","title":"4 DefaultTriggerAsyncIdScope"},{"location":"chapter23-Async%20hooks/#5","text":"\u8d44\u6e90\u9500\u6bc1\u7684\u65f6\u5019\u4e5f\u4f1a\u89e6\u53d1\u5bf9\u5e94\u7684\u94a9\u5b50\uff0c\u4e0d\u8fc7\u4e0d\u540c\u7684\u662f\u8fd9\u4e2a\u94a9\u5b50\u662f\u5f02\u6b65\u89e6\u53d1\u7684\u3002\u65e0\u8bba\u662fJS\u8fd8\u662f\u597dC++\u5c42\u89e6\u53d1\u9500\u6bc1\u94a9\u5b50\u7684\u65f6\u5019\uff0c\u903b\u8f91\u90fd\u662f\u4e00\u81f4\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void AsyncWrap::EmitDestroy ( Environment * env , double async_id ) { // \b\u4e4b\u524d\u4e3a\u7a7a\u5219\u8bbe\u7f6e\u56de\u8c03 if ( env -> destroy_async_id_list () -> empty ()) { env -> SetUnrefImmediate ( & DestroyAsyncIdsCallback ); } // async id\u5165\u961f env -> destroy_async_id_list () -> push_back ( async_id ); } template < typename Fn > void Environment :: SetUnrefImmediate ( Fn && cb ) { CreateImmediate ( std :: move ( cb ), false ); } template < typename Fn > void Environment :: CreateImmediate ( Fn && cb , bool ref ) { auto callback = std :: make_unique < NativeImmediateCallbackImpl < Fn >> ( std :: move ( cb ), ref ); // \u52a0\u5165\u4efb\u52a1\u961f\u5217 native_immediates_ . Push ( std :: move ( callback )); } \u5728\u4e8b\u4ef6\u5faa\u73af\u7684check\u9636\u6bb5\u5c31\u4f1a\u6267\u884c\u91cc\u9762\u7684\u4efb\u52a1\uff0c\u4ece\u800c\u6267\u884c\u56de\u8c03DestroyAsyncIdsCallback\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void AsyncWrap::DestroyAsyncIdsCallback ( Environment * env ) { Local < Function > fn = env -> async_hooks_destroy_function (); do { std :: vector < double > destroy_async_id_list ; destroy_async_id_list . swap ( * env -> destroy_async_id_list ()); // \u904d\u5386\u9500\u6bc1\u7684async id for ( auto async_id : destroy_async_id_list ) { HandleScope scope ( env -> isolate ()); Local < Value > async_id_value = Number :: New ( env -> isolate (), async_id ); // \u6267\u884cJS\u5c42\u56de\u8c03 MaybeLocal < Value > ret = fn -> Call ( env -> context (), Undefined ( env -> isolate ()), 1 , & async_id_value ); } } while ( ! env -> destroy_async_id_list () -> empty ()); }","title":"5 \u8d44\u6e90\u9500\u6bc1"},{"location":"chapter23-Async%20hooks/#6-async-hooks","text":"\u6211\u4eec\u901a\u5e38\u4ee5\u4ee5\u4e0b\u65b9\u5f0f\u4f7f\u7528Async hooks 1 2 3 4 5 6 7 8 9 const async_hooks = require ( 'async_hooks' ); async_hooks . createHook ({ init ( asyncId , type , triggerAsyncId ) {}, before ( asyncId ) {}, after ( asyncId ) {}, destroy ( asyncId ) {}, promiseResolve ( asyncId ), }) . enable (); async_hooks\u662f\u5bf9\u8d44\u6e90\u751f\u547d\u5468\u671f\u7684\u62bd\u8c61\uff0c\u8d44\u6e90\u5c31\u662f\u64cd\u4f5c\u5bf9\u8c61\u548c\u56de\u8c03\u7684\u62bd\u8c61\u3002async_hooks\u5b9a\u4e49\u4e86\u4e94\u4e2a\u751f\u547d\u5468\u671f\u94a9\u5b50\uff0c\u5f53\u8d44\u6e90\u7684\u72b6\u6001\u5230\u8fbe\u67d0\u4e2a\u5468\u671f\u8282\u70b9\u65f6\uff0casync_hooks\u5c31\u4f1a\u89e6\u53d1\u5bf9\u5e94\u7684\u94a9\u5b50\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u7684\u5b9e\u73b0\u3002\u6211\u4eec\u9996\u5148\u770b\u4e00\u4e0bcreateHook\u3002 1 2 3 function createHook ( fns ) { return new AsyncHook ( fns ); } createHook\u662f\u5bf9AsyncHook\u7684\u5c01\u88c5 1 2 3 4 5 6 7 8 9 10 class AsyncHook { constructor ({ init , before , after , destroy , promiseResolve }) { // \u8bb0\u5f55\u56de\u8c03 this [ init_symbol ] = init ; this [ before_symbol ] = before ; this [ after_symbol ] = after ; this [ destroy_symbol ] = destroy ; this [ promise_resolve_symbol ] = promiseResolve ; } } AsyncHook\u7684\u521d\u59cb\u5316\u5f88\u7b80\u5355\uff0c\u521b\u5efa\u4e00\u4e2aAsyncHook\u5bf9\u8c61\u8bb0\u5f55\u56de\u8c03\u51fd\u6570\u3002\u521b\u5efa\u4e86AsyncHook\u4e4b\u540e\uff0c\u6211\u4eec\u9700\u8981\u8c03\u7528AsyncHook\u7684enable\u51fd\u6570\u624b\u52a8\u5f00\u542f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class AsyncHook { enable () { // \u83b7\u53d6\u4e00\u4e2aAsyncHook\u5bf9\u8c61\u6570\u7ec4\u548c\u4e00\u4e2a\u6574\u5f62\u6570\u7ec4 const [ hooks_array , hook_fields ] = getHookArrays (); // \u6267\u884c\u8fc7enable\u4e86\u5219\u4e0d\u9700\u8981\u518d\u6267\u884c if ( hooks_array . includes ( this )) return this ; // \u505a\u4e9b\u7edf\u8ba1 const prev_kTotals = hook_fields [ kTotals ]; hook_fields [ kTotals ] = hook_fields [ kInit ] += +!! this [ init_symbol ]; hook_fields [ kTotals ] += hook_fields [ kBefore ] += +!! this [ before_symbol ]; hook_fields [ kTotals ] += hook_fields [ kAfter ] += +!! this [ after_symbol ]; hook_fields [ kTotals ] += hook_fields [ kDestroy ] += +!! this [ destroy_symbol ]; hook_fields [ kTotals ] += hook_fields [ kPromiseResolve ] += +!! this [ promise_resolve_symbol ]; // \u5f53\u524d\u5bf9\u8c61\u63d2\u5165\u6570\u7ec4\u4e2d hooks_array . push ( this ); // \u5982\u679c\u4e4b\u524d\u7684\u6570\u91cf\u662f0\uff0c\u672c\u6b21\u64cd\u4f5c\u540e\u5927\u4e8e0\u5219\u5f00\u542f\u5e95\u5c42\u7684\u903b\u8f91 if ( prev_kTotals === 0 && hook_fields [ kTotals ] > 0 ) { enableHooks (); } return this ; } } 1 hooks_array\uff1a\u662f\u4e00\u4e2aAsyncHook\u5bf9\u8c61\u6570\u7ec4\uff0c\u4e3b\u8981\u7528\u4e8e\u8bb0\u5f55\u7528\u6237\u521b\u5efa\u4e86\u54ea\u4e9bAsyncHook\u5bf9\u8c61\uff0c\u7136\u540e\u54ea\u4e9bAsyncHook\u5bf9\u8c61\u91cc\u90fd\u8bbe\u7f6e\u4e86\u54ea\u4e9b\u94a9\u5b50\uff0c\u5728\u56de\u8c03\u7684\u65f6\u5019\u5c31\u4f1a\u904d\u5386\u8fd9\u4e2a\u5bf9\u8c61\u6570\u7ec4\uff0c\u6267\u884c\u91cc\u9762\u7684\u56de\u8c03\u3002 2 hook_fields\uff1a\u5bf9\u5e94\u5e95\u5c42\u7684async_hook_fields\u3002 3 enableHooks\uff1a 1 2 3 4 function enableHooks () { // \u8bb0\u5f55async_hooks\u7684\u5f00\u542f\u4e2a\u6570 async_hook_fields [ kCheck ] += 1 ; } \u81f3\u6b64\uff0casync_hooks\u7684\u521d\u59cb\u5316\u5c31\u5b8c\u6210\u4e86\uff0c\u6211\u4eec\u53d1\u73b0\u903b\u8f91\u975e\u5e38\u7b80\u5355\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u4ed6\u662f\u5982\u4f55\u4e32\u8d77\u6765\u7684\u3002\u4e0b\u9762\u6211\u4eec\u4ee5TCP\u6a21\u5757\u4e3a\u4f8b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 const { createHook , executionAsyncId } = require ( 'async_hooks' ); const fs = require ( 'fs' ); const net = require ( 'net' ); createHook ({ init ( asyncId , type , triggerAsyncId ) { fs . writeSync ( 1 , ` ${ type } ( ${ asyncId } ): trigger: ${ triggerAsyncId } execution: ${ executionAsyncId () } \\n` ); } }). enable (); net . createServer (( conn ) => {}). listen ( 8080 ); \u4ee5\u4e0a\u4ee3\u7801\u8f93\u51fa 1 2 3 4 init: type: TCPSERVERWRAP asyncId: 2 trigger id: 1 executionAsyncId(): 1 triggerAsyncId(): 0 init: type: TickObject asyncId: 3 trigger id: 2 executionAsyncId(): 1 triggerAsyncId(): 0 before: asyncId: 3 executionAsyncId(): 3 triggerAsyncId(): 2 after: asyncId: 3 executionAsyncId(): 3 triggerAsyncId(): 2 \u4e0b\u9762\u6211\u4eec\u6765\u5206\u6790\u5177\u4f53\u8fc7\u7a0b\u3002\u6211\u4eec\u77e5\u9053\u521b\u5efa\u8d44\u6e90\u7684\u65f6\u5019\u4f1a\u6267\u884cinit\u56de\u8c03\uff0c\u5177\u4f53\u903b\u8f91\u5728listen\u51fd\u6570\u4e2d\uff0c\u5728listen\u51fd\u6570\u4e2d\uff0c\u901a\u8fc7\u5c42\u5c42\u8c03\u7528\u4f1a\u6267\u884cnew TCP\u65b0\u5efa\u4e00\u4e2a\u5bf9\u8c61\uff0c\u8868\u793a\u670d\u52a1\u5668\u3002TCP\u662fC++\u5c42\u5bfc\u51fa\u7684\u7c7b\uff0c\u521a\u624d\u6211\u4eec\u8bf4\u8fc7\uff0cTCP\u4f1a\u7ee7\u627fAsyncWrap\uff0c\u65b0\u5efaAsyncWrap\u5bf9\u8c61\u7684\u65f6\u5019\u4f1a\u89e6\u53d1init\u94a9\u5b50\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5bf9\u5e94\u8f93\u51fa 1 init: type: TCPSERVERWRAP asyncId: 2 trigger id: 1 executionAsyncId(): 1 triggerAsyncId(): 0 \u90a3TickObject\u662f\u600e\u4e48\u6765\u7684\u5462\uff1f\u6211\u4eec\u63a5\u7740\u770blisten\u91cc\u7684\u53e6\u4e00\u6bb5\u903b\u8f91\u3002 1 2 3 4 5 this [ async_id_symbol ] = getNewAsyncId ( this . _handle ); defaultTriggerAsyncIdScope ( this [ async_id_symbol ], process . nextTick , emitListeningNT , this ); \u4e0a\u9762\u7684\u4ee3\u7801\u6211\u4eec\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u5728\u6267\u884cprocess.nextTick\u7684\u65f6\u5019\u4f1a\u521b\u5efa\u4e00\u4e2aTickObject\u5bf9\u8c61\u5c01\u88c5\u6267\u884c\u4e0a\u4e0b\u6587\u548c\u56de\u8c03\u3002 1 2 3 4 5 6 7 8 9 const asyncId = newAsyncId (); const triggerAsyncId = getDefaultTriggerAsyncId (); const tickObject = { [ async_id_symbol ] : asyncId , [ trigger_async_id_symbol ] : triggerAsyncId , callback , args }; emitInit ( asyncId , 'TickObject' , triggerAsyncId , tickObject ); \u8fd9\u6b21\u518d\u6b21\u89e6\u53d1\u4e86init\u94a9\u5b50\uff0c\u7ed3\u6784\u5982\u4e0b\uff08nextTick\u901a\u8fc7getDefaultTriggerAsyncId\u83b7\u53d6\u7684id\u662fdefaultTriggerAsyncIdScope\u8bbe\u7f6e\u7684id\uff09\u3002 \u5bf9\u5e94\u8f93\u51fa 1 init: type: TickObject asyncId: 3 trigger id: 2 executionAsyncId(): 1 triggerAsyncId(): 0 \u63a5\u7740\u6267\u884ctick\u4efb\u52a1\u3002 1 2 3 4 5 6 7 8 9 const asyncId = tock [ async_id_symbol ]; emitBefore ( asyncId , tock [ trigger_async_id_symbol ]); try { tock . callback (); } finally { if ( destroyHooksExist ()) emitDestroy ( asyncId ); } emitAfter ( asyncId ); emitBefore\u65f6\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5bf9\u5e94\u8f93\u51fa 1 2 before: asyncId: 3 executionAsyncId(): 3 triggerAsyncId(): 2 after: asyncId: 3 executionAsyncId(): 3 triggerAsyncId(): 2 \u6267\u884c\u5b8c\u6211\u4eec\u7684JS\u4ee3\u7801\u540e\uff0c\u6240\u6709\u5165\u6808\u7684\u4e0a\u4e0b\u6587\u90fd\u4f1a\u88ab\u6e05\u7a7a\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5982\u679c\u8fd9\u65f6\u5019\u6709\u4e00\u4e2a\u8fde\u63a5\u5efa\u7acb\u4f1a\u8f93\u51fa\u4ec0\u4e48\u5462\uff1f\u5f53\u6709\u8fde\u63a5\u5efa\u7acb\u65f6\uff0c\u4f1a\u6267\u884cC++\u5c42\u7684OnConnection\u3002 OnConnection\u4f1a\u521b\u5efa\u4e00\u4e2a\u65b0\u7684TCP\u5bf9\u8c61\u8868\u793a\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 MaybeLocal < Object > TCPWrap :: Instantiate ( Environment * env , AsyncWrap * parent , TCPWrap :: SocketType type ) { EscapableHandleScope handle_scope ( env -> isolate ()); AsyncHooks :: DefaultTriggerAsyncIdScope trigger_scope ( parent ); return handle_scope . EscapeMaybe ( constructor -> NewInstance ( env -> context (), 1 , & type_value )); } \u9996\u5148\u5b9a\u4e49\u4e86\u4e00\u4e2aAsyncHooks::DefaultTriggerAsyncIdScope\u3002DefaultTriggerAsyncIdScope\u7528\u4e8e\u8bbe\u7f6e\u9ed8\u8ba4default_trigger_async_id\u4e3aparent\u7684async id\uff08\u503c\u662f2\uff09\uff0c\u6267\u884cInstantiate\u65f6\u4f1a\u6267\u884c\u6790\u6784\u51fd\u6570\u6062\u590d\u539f\u6765\u72b6\u6001\u3002\u63a5\u7740NewInstance\u7684\u65f6\u5019\u5c31\u4f1a\u65b0\u5efa\u4e00\u4e2aTCPWrap\u5bf9\u8c61\uff0c\u4ece\u800c\u521b\u5efa\u4e00\u4e2aAsyncWrap\u5bf9\u8c61\u3002\u7136\u540e\u89e6\u53d1init\u94a9\u5b50\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5bf9\u5e94\u8f93\u51fa 1 init: type: TCPWRAP asyncId: 4 trigger id: 2 executionAsyncId(): 0 triggerAsyncId(): 0 \u521b\u5efa\u5b8c\u5bf9\u8c61\u540e\uff0c\u901a\u8fc7AsyncWrap::MakeCallback\u56de\u8c03JS\u5c42\uff0c\u521a\u624d\u6211\u4eec\u5df2\u7ecf\u5206\u6790\u8fc7AsyncWrap::MakeCallback\u4f1a\u89e6\u53d1before\u548cafter\u94a9\u5b50\uff0c\u89e6\u53d1before\u94a9\u5b50\u65f6\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u5bf9\u5e94\u8f93\u51fa 1 before: asyncId: 2 executionAsyncId(): 2 triggerAsyncId(): 1 \u540c\u6837\uff0c\u5728\u56de\u8c03\u51fd\u6570\u91cc\u6267\u884cexecutionAsyncId\u548ctriggerAsyncId\u62ff\u5230\u7684\u5185\u5bb9\u662f\u4e00\u6837\u7684\u3002\u89e6\u53d1after\u540e\u518d\u6062\u590d\u4e0a\u4e0b\u6587\uff0c\u6240\u4ee5\u8f93\u51fa\u4e5f\u662f\u4e00\u6837\u7684\u3002 1 after: asyncId: 2 executionAsyncId(): 2 triggerAsyncId(): 1","title":"6 Async hooks\u7684\u4f7f\u7528"},{"location":"chapter23-Async%20hooks/#7-asyncresource","text":"\u5f02\u6b65\u8d44\u6e90\u5e76\u4e0d\u662fNode.js\u5185\u7f6e\u7684\uff0cNode.js\u53ea\u662f\u63d0\u4f9b\u4e86\u4e00\u5957\u673a\u5236\uff0c\u4e1a\u52a1\u5c42\u4e5f\u53ef\u4ee5\u4f7f\u7528\u3002Node.js\u4e5f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u7c7b\u7ed9\u4e1a\u52a1\u4f7f\u7528\uff0c\u6838\u5fc3\u4ee3\u7801\u5982\u4e0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class AsyncResource { constructor ( type , opts = {}) { let triggerAsyncId = opts ; let requireManualDestroy = false ; if ( typeof opts !== 'number' ) { triggerAsyncId = opts . triggerAsyncId === undefined ? getDefaultTriggerAsyncId () : opts . triggerAsyncId ; requireManualDestroy = !! opts . requireManualDestroy ; } const asyncId = newAsyncId (); this [ async_id_symbol ] = asyncId ; this [ trigger_async_id_symbol ] = triggerAsyncId ; if ( initHooksExist ()) { emitInit ( asyncId , type , triggerAsyncId , this ); } } runInAsyncScope ( fn , thisArg , ... args ) { const asyncId = this [ async_id_symbol ]; emitBefore ( asyncId , this [ trigger_async_id_symbol ]); const ret = thisArg === undefined ? fn (... args ) : ReflectApply ( fn , thisArg , args ); emitAfter ( asyncId ); return ret ; } emitDestroy () { if ( this [ destroyedSymbol ] !== undefined ) { this [ destroyedSymbol ]. destroyed = true ; } emitDestroy ( this [ async_id_symbol ]); return this ; } asyncId () { return this [ async_id_symbol ]; } triggerAsyncId () { return this [ trigger_async_id_symbol ]; } } \u4f7f\u7528\u65b9\u5f0f\u5982\u4e0b\u3002 1 2 3 4 5 const { AsyncResource , executionAsyncId , triggerAsyncId } = require ( 'async_hooks' ); const asyncResource = new AsyncResource ( 'Demo' ); asyncResource . runInAsyncScope (() => { console . log ( executionAsyncId (), triggerAsyncId ()) }); runInAsyncScope\u4e2d\u4f1a\u628aasyncResource\u7684\u6267\u884c\u4e0a\u4e0b\u6587\u8bbe\u7f6e\u4e3a\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\uff0casync id\u662f2\uff0ctrigger async id\u662f1\uff0c\u6240\u4ee5\u5728\u56de\u8c03\u91cc\u6267\u884cexecutionAsyncId\u8f93\u51fa\u7684\u662f2\uff0ctriggerAsyncId\u8f93\u51fa\u7684\u662f1\u3002","title":"7 AsyncResource"},{"location":"chapter23-Async%20hooks/#8-asynclocalstorage","text":"AsyncLocalStorage\u662f\u57fa\u4e8eAsyncResource\u5b9e\u73b0\u7684\u4e00\u4e2a\u7ef4\u62a4\u5f02\u6b65\u903b\u8f91\u4e2d\u516c\u5171\u4e0a\u4e0b\u6587\u7684\u7c7b\u3002\u6211\u4eec\u53ef\u4ee5\u628a\u4ed6\u7406\u89e3\u4e3aRedis\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u600e\u4e48\u4f7f\u7528\u3002","title":"8 AsyncLocalStorage"},{"location":"chapter23-Async%20hooks/#81","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 const { AsyncLocalStorage } = require ( 'async_hooks' ); const asyncLocalStorage = new AsyncLocalStorage (); function logWithId ( msg ) { const id = asyncLocalStorage . getStore (); console . log ( ` ${ id !== undefined ? id : '-' } :` , msg ); } asyncLocalStorage . run ( 1 , () => { logWithId ( 'start' ); setImmediate (() => { logWithId ( 'finish' ); }); }); \u6267\u884c\u4e0a\u9762\u4ee3\u7801\u4f1a\u8f93\u51fa 1 2 1: start 1: finish run\u7684\u65f6\u5019\u521d\u59cb\u5316\u516c\u5171\u7684\u4e0a\u4e0b\u6587\uff0c\u7136\u540e\u5728run\u91cc\u6267\u884c\u7684\u5f02\u6b65\u4ee3\u7801\u4e5f\u53ef\u4ee5\u62ff\u5f97\u5230\u8fd9\u4e2a\u516c\u5171\u4e0a\u4e0b\u6587\uff0c\u8fd9\u4e2a\u5728\u8bb0\u5f55\u65e5\u5fd7traceId\u65f6\u5c31\u4f1a\u5f88\u6709\u7528\uff0c\u5426\u5219\u6211\u4eec\u5c31\u9700\u8981\u628atraceId\u4f20\u904d\u4ee3\u7801\u6bcf\u4e2a\u9700\u8981\u7684\u5730\u65b9\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u5b9e\u73b0\u3002","title":"8.1 \u4f7f\u7528"},{"location":"chapter23-Async%20hooks/#82","text":"\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u521b\u5efaAsyncLocalStorage\u7684\u903b\u8f91 1 2 3 4 5 6 class AsyncLocalStorage { constructor () { this . kResourceStore = Symbol ( 'kResourceStore' ); this . enabled = false ; } } \u521b\u5efaAsyncLocalStorage\u7684\u65f6\u5019\u5f88\u7b80\u5355\uff0c\u4e3b\u8981\u662f\u7f6e\u72b6\u6001\u4e3afalse\uff0c\u5e76\u4e14\u8bbe\u7f6ekResourceStore\u7684\u503c\u4e3aSymbol('kResourceStore')\u3002\u8bbe\u7f6e\u4e3aSymbol('kResourceStore')\u800c\u4e0d\u662f\u2018kResourceStore\u2018\u5f88\u91cd\u8981\uff0c\u6211\u4eec\u540e\u9762\u4f1a\u770b\u5230\u3002\u7ee7\u7eed\u770b\u4e00\u4e0b\u6267\u884cAsyncLocalStorage.run\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 run ( store , callback , ... args ) { // \u65b0\u5efa\u4e00\u4e2aAsyncResource const resource = new AsyncResource ( 'AsyncLocalStorage' , defaultAlsResourceOpts ); // \u901a\u8fc7runInAsyncScope\u628aresource\u7684\u6267\u884c\u4e0a\u4e0b\u6587\u8bbe\u7f6e\u5b8c\u5f53\u524d\u7684\u6267\u884c\u4e0a\u4e0b\u6587 return resource . emitDestroy (). runInAsyncScope (() => { this . enterWith ( store ); return ReflectApply ( callback , null , args ); }); } \u8bbe\u7f6e\u5b8c\u4e0a\u4e0b\u6587\u4e4b\u540e\u6267\u884crunInAsyncScope\u7684\u56de\u8c03\uff0c\u56de\u8c03\u91cc\u9996\u5148\u6267\u884c\u91ccenterWith\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 enterWith ( store ) { // \u4fee\u6539AsyncLocalStorage\u72b6\u6001 this . _enable (); // \u83b7\u5f97\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5bf9\u4e8e\u591a\u8d44\u6e90\uff0c\u4e5f\u5c31\u662frun\u91cc\u521b\u5efa\u7684resource const resource = executionAsyncResource (); // \u628a\u516c\u5171\u4e0a\u4e0b\u6587\u6302\u8f7d\u5230\u5bf9\u8c61\u4e0a resource [ this . kResourceStore ] = store ; } _enable () { if ( ! this . enabled ) { this . enabled = true ; ArrayPrototypePush ( storageList , this ); storageHook . enable (); } } \u6302\u8f7d\u5b8c\u516c\u5171\u4e0a\u4e0b\u6587\u540e\uff0c\u5c31\u6267\u884c\u4e1a\u52a1\u56de\u8c03\u3002\u56de\u8c03\u91cc\u53ef\u4ee5\u901a\u8fc7asyncLocalStorage.getStore()\u83b7\u5f97\u8bbe\u7f6e\u7684\u516c\u5171\u4e0a\u4e0b\u6587\u3002 1 2 3 4 5 6 getStore () { if ( this . enabled ) { const resource = executionAsyncResource (); return resource [ this . kResourceStore ]; } } getStore\u7684\u539f\u7406\u5f88\u7b80\u5355\uff0c\u5c31\u662f\u9996\u5148\u62ff\u5230\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5bf9\u5e94\u7684\u8d44\u6e90\uff0c\u7136\u540e\u6839\u636eAsyncLocalStorage\u7684kResourceStore\u7684\u503c\u4eceresource\u4e2d\u62ff\u5230\u516c\u5171\u4e0a\u4e0b\u6587\u3002\u5982\u679c\u662f\u540c\u6b65\u6267\u884cgetStore\uff0c\u90a3\u4e48executionAsyncResource\u8fd4\u56de\u7684\u5c31\u662f\u6211\u4eec\u5728run\u7684\u65f6\u5019\u521b\u5efa\u7684AsyncResource\uff0c\u4f46\u662f\u5982\u679c\u662f\u5f02\u6b65getStore\u90a3\u4e48\u600e\u4e48\u529e\u5462\uff1f\u56e0\u4e3a\u8fd9\u65f6\u5019executionAsyncResource\u8fd4\u56de\u7684\u4e0d\u518d\u662f\u6211\u4eec\u521b\u5efa\u7684AsyncResource\uff0c\u4e5f\u5c31\u62ff\u4e0d\u5230\u4ed6\u6302\u8f7d\u7684\u516c\u5171\u4e0a\u4e0b\u6587\u3002\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0cNode.js\u5bf9\u516c\u5171\u4e0a\u4e0b\u6587\u8fdb\u884c\u4e86\u4f20\u9012\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const storageList = []; // AsyncLocalStorage\u5bf9\u8c61\u6570\u7ec4 const storageHook = createHook ({ init ( asyncId , type , triggerAsyncId , resource ) { const currentResource = executionAsyncResource (); for ( let i = 0 ; i < storageList . length ; ++ i ) { storageList [ i ]. _propagate ( resource , currentResource ); } } }); _propagate ( resource , triggerResource ) { const store = triggerResource [ this . kResourceStore ]; if ( this . enabled ) { resource [ this . kResourceStore ] = store ; } } \u6211\u4eec\u770b\u5230Node.js\u5185\u90e8\u521b\u5efa\u4e86\u4e00\u4e2aHooks\uff0c\u5728\u6bcf\u6b21\u8d44\u6e90\u521b\u5efa\u7684\u65f6\u5019\uff0cNode.js\u4f1a\u628a\u5f53\u524d\u6267\u884c\u4e0a\u4e0b\u6587\u5bf9\u5e94\u7684\u8d44\u6e90\u4e2d\u7684\u4e00\u4e2a\u6216\u591a\u4e2akey\uff08\u6839\u636estorageList\u91cc\u5bf9\u8c61\u7684this.kResourceStore\u5b57\u6bb5\uff09\u5bf9\u5e94\u7684\u503c\u6302\u8f7d\u5230\u65b0\u521b\u5efa\u7684\u8d44\u6e90\u4e2d\u3002\u6240\u4ee5\u5728asyncLocalStorage.getStore()\u65f6\u5373\u4f7f\u4e0d\u662f\u6211\u4eec\u5728\u6267\u884crun\u65f6\u521b\u5efa\u7684\u8d44\u6e90\u5bf9\u8c61\uff0c\u4e5f\u53ef\u4ee5\u83b7\u5f97\u5177\u4f53asyncLocalStorage\u5bf9\u8c61\u6240\u8bbe\u7f6e\u7684\u8d44\u6e90\uff0c\u6211\u4eec\u518d\u6765\u770b\u4e00\u4e2a\u4f8b\u5b50\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const { AsyncLocalStorage } = require ( 'async_hooks' ); const asyncLocalStorage = new AsyncLocalStorage (); const asyncLocalStorage2 = new AsyncLocalStorage (); function logWithId ( msg ) { console . log ( asyncLocalStorage2 . getStore ()); const id = asyncLocalStorage . getStore (); console . log ( ` ${ id !== undefined ? id : '-' } :` , msg ); } asyncLocalStorage . run ( 0 , () => { asyncLocalStorage2 . enterWith ({ hello : \"world\" }); logWithId ( 'start' ); setImmediate (() => { logWithId ( 'finish' ); }); }); \u9664\u4e86\u901a\u8fc7asyncLocalStorage.run\u8bbe\u7f6e\u4e0a\u4e0b\u6587\uff0c\u6211\u4eec\u901a\u8fc7asyncLocalStorage2.enterWith\u4e5f\u7ed9\u5bf9\u8c61\u4e0a\u4e0b\u6587\u7684\u8d44\u6e90\u5bf9\u8c61\u6302\u8f7d\u4e00\u4e2a\u65b0\u5c5e\u6027\uff0ckey\u662fSymbol('kResourceStore')\uff0c\u503c\u662f{hello: \"world\"}\uff0c\u7136\u540e\u5728logWithId\u4e2d\u8f93\u51faasyncLocalStorage2.getStore()\u3002\u4ece\u8f93\u51fa\u4e2d\u53ef\u4ee5\u770b\u5230\u6210\u529f\u4ece\u8d44\u6e90\u4e2d\u83b7\u5f97\u6302\u8f7d\u7684\u6240\u6709\u4e0a\u4e0b\u6587\u3002 1 2 3 4 { hello: 'world' } 0: start { hello: 'world' } 0: finish \u6211\u4eec\u4e5f\u53ef\u4ee5\u4fee\u6539\u6e90\u7801\u9a8c\u8bc1 1 2 3 4 5 6 7 8 9 10 11 12 Immediate { _idleNext : null , _idlePrev : null , _onImmediate : [ Function ( anonymous )], _argv : undefined , _destroyed : true , [ Symbol ( refed )] : null , [ Symbol ( asyncId )] : 6 , [ Symbol ( triggerId )] : 2 , [ Symbol ( kResourceStore )] : 0 , [ Symbol ( kResourceStore )] : { hello : ' world ' } } \u53ef\u4ee5\u770b\u5230\u8d44\u6e90\u5bf9\u8c61\u6302\u8f7d\u91cc\u4e24\u4e2akey\u4e3aSymbol(kResourceStore)\u7684\u5c5e\u6027\u3002","title":"8.2 \u5b9e\u73b0"},{"location":"chapter23-Async%20hooks/#9-async-hooks","text":"1 2 3 4 const async_hooks = require ( 'async_hooks' ); const eid = async_hooks . executionAsyncId (); const tid = async_hooks . triggerAsyncId (); console . log ( eid , tid ); \u4ee5\u4e0a\u4ee3\u7801\u4e2d,\u8f93\u51fa1\u548c0\u3002\u5bf9\u5e94\u7684API\u5b9e\u73b0\u5982\u4e0b\u3002 1 2 3 4 5 6 7 8 // \u83b7\u53d6\u5f53\u524d\u7684async id function executionAsyncId () { return async_id_fields [ kExecutionAsyncId ]; } // \u83b7\u53d6\u5f53\u524d\u7684trigger async id\uff0c\u5373\u89e6\u53d1\u5f53\u524d\u4ee3\u7801\u7684async id function triggerAsyncId () { return async_id_fields [ kTriggerAsyncId ]; } \u90a3\u4e48async_id_fields\u7684\u521d\u59cb\u5316\u662f\u4ec0\u4e48\u5462\uff1f\u4eceenv.h\u5b9a\u4e49\u4e2d\u53ef\u4ee5\u770b\u5230async_id_fields_\uff08async_id_fields\u662f\u4e0a\u5c42\u4f7f\u7528\u7684\u540d\u79f0\uff0c\u5bf9\u5e94\u5e95\u5c42\u7684async_id_fields_\uff09\u662fAliasedFloat64Array\u7c7b\u578b\u3002 1 AliasedFloat64Array async_id_fields_ ; AliasedFloat64Array\u662f\u4e2a\u7c7b\u578b\u522b\u540d\u3002 1 typedef AliasedBufferBase < double , v8 :: Float64Array > AliasedFloat64Array ; AliasedBufferBase\u7684\u6784\u9020\u51fd\u6570\u5982\u4e0b 1 2 3 4 5 6 7 8 AliasedBufferBase ( v8 :: Isolate * isolate , const size_t count ) : isolate_ ( isolate ), count_ ( count ), byte_offset_ ( 0 ) { const v8 :: HandleScope handle_scope ( isolate_ ); const size_t size_in_bytes = MultiplyWithOverflowCheck ( sizeof ( NativeT ), count ); v8 :: Local < v8 :: ArrayBuffer > ab = v8 :: ArrayBuffer :: New ( isolate_ , size_in_bytes ); // ... } \u5e95\u5c42\u662f\u4e00\u4e2aArrayBuffer\u3002 1 2 3 4 5 6 7 8 9 Local < ArrayBuffer > v8 :: ArrayBuffer :: New ( Isolate * isolate , size_t byte_length ) { i :: Isolate * i_isolate = reinterpret_cast < i :: Isolate *> ( isolate ); LOG_API ( i_isolate , ArrayBuffer , New ); ENTER_V8_NO_SCRIPT_NO_EXCEPTION ( i_isolate ); i :: MaybeHandle < i :: JSArrayBuffer > result = i_isolate -> factory () -> NewJSArrayBufferAndBackingStore ( byte_length , i :: InitializedFlag :: kZeroInitialized ); // ... } ArrayBuffer::New\u5728\u7533\u8bf7\u5185\u5b58\u65f6\u4f20\u5165\u4e86i::InitializedFlag::kZeroInitialized\u3002\u4eceV8\u5b9a\u4e49\u4e2d\u53ef\u4ee5\u770b\u5230\u4f1a\u521d\u59cb\u5316\u5185\u5b58\u7684\u5185\u5bb9\u4e3a0\u3002 1 2 // Whether the backing store memory is initialied to zero or not. enum class InitializedFlag : uint8_t { kUninitialized , kZeroInitialized }; \u56de\u5230\u4f8b\u5b50\u4e2d\uff0c\u4e3a\u4ec0\u4e48\u8f93\u51fa\u4f1a\u662f1\u548c0\u800c\u4e0d\u662f0\u548c0\u5462\uff1f\u7b54\u6848\u5728Node.js\u542f\u52a8\u65f6\u7684\u8fd9\u6bb5\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 { InternalCallbackScope callback_scope ( env . get (), Local < Object > (), // async id\u548ctrigger async id { 1 , 0 }, InternalCallbackScope :: kAllowEmptyResource | InternalCallbackScope :: kSkipAsyncHooks ); // \u6267\u884c\u6211\u4eec\u7684js LoadEnvironment ( env . get ()); } InternalCallbackScope\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u4ed6\u4f1a\u628a1\u548c0\u8bbe\u7f6e\u4e3a\u5f53\u524d\u7684\u6267\u884c\u4e0a\u4e0b\u6587\u3002\u7136\u540e\u5728LoadEnvironment\u91cc\u6267\u884c\u6211\u7684JS\u4ee3\u7801\u65f6\u83b7\u53d6\u5230\u7684\u503c\u5c31\u662f1\u548c0\u3002\u90a3\u4e48\u5982\u679c\u6211\u4eec\u6539\u6210\u4ee5\u4e0b\u4ee3\u7801\u4f1a\u8f93\u51fa\u4ec0\u4e48\u5462\uff1f 1 2 3 4 5 6 const async_hooks = require ( 'async_hooks' ); Promise . resolve (). then (() => { const eid = async_hooks . executionAsyncId (); const tid = async_hooks . triggerAsyncId (); console . log ( eid , tid ); }) \u4ee5\u4e0a\u4ee3\u7801\u4f1a\u8f93\u51fa0\u548c\u3002\u56e0\u4e3a\u6267\u884c\u5b8c\u6211\u4eec\u7684JS\u4ee3\u7801\u540e\uff0cInternalCallbackScope\u5c31\u88ab\u6790\u6784\u4e86\uff0c\u4ece\u800c\u6062\u590d\u4e3a0\u548c0\u3002","title":"9 \u521d\u59cb\u5316\u65f6\u7684Async hooks"},{"location":"chapter24-Inspector/","text":"\u524d\u8a00\uff1aNode.js\u63d0\u4f9b\u7684Inspector\u4e0d\u4ec5\u53ef\u4ee5\u7528\u6765\u8c03\u8bd5Node.js\u4ee3\u7801\uff0c\u8fd8\u53ef\u4ee5\u5b9e\u65f6\u6536\u96c6Node.js\u8fdb\u7a0b\u7684\u5185\u5b58\uff0cCPU\u7b49\u6570\u636e\uff0c\u540c\u65f6\u652f\u6301\u9759\u6001\u3001\u52a8\u6001\u5f00\u542f\uff0c\u662f\u4e00\u4e2a\u975e\u5e38\u5f3a\u5927\u7684\u5de5\u5177\uff0c\u672c\u6587\u4ece\u4f7f\u7528\u548c\u539f\u7406\u8be6\u7ec6\u8bb2\u89e3Inspector Node.js\u7684\u6587\u6863\u4e2d\u5bf9inspector\u7684\u63cf\u8ff0\u5f88\u5c11\uff0c\u4f46\u662f\u5982\u679c\u6df1\u5165\u63a2\u7d22\uff0c\u5176\u5b9e\u91cc\u9762\u7684\u5185\u5bb9\u8fd8\u662f\u633a\u591a\u7684\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0bInspector\u7684\u4f7f\u7528\u3002 1 Inspector\u7684\u4f7f\u7528 \u00b6 1.1 \u672c\u5730\u8c03\u8bd5 \u00b6 \u6211\u4eec\u5148\u4ece\u4e00\u4e2a\u4f8b\u5b50\u5f00\u59cb\u3002\u4e0b\u9762\u662f\u4e00\u4e2ahttp\u670d\u52a1\u5668\u3002 1 2 3 4 const http = require ( 'http' ); http . createServer (( req , res ) => { res . end ( 'ok' ); }). listen ( 80 ); \u7136\u540e\u6211\u4eec\u4ee5node --inspect httpServer.js\u7684\u65b9\u5f0f\u542f\u52a8\u3002\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4ee5\u4e0b\u8f93\u51fa\u3002 1 2 Debugger listening on ws://127.0.0.1:9229/fbbd9d8f-e088-48cc-b1e0-e16bfe58db44 For help, see: https://nodejs.org/en/docs/inspector 9229\u7aef\u53e3\u662fNode.js\u9ed8\u8ba4\u9009\u62e9\u7684\u7aef\u53e3\uff0c\u5f53\u7136\u6211\u4eec\u4e5f\u53ef\u4ee5\u81ea\u5b9a\u4e49\uff0c\u5177\u4f53\u53ef\u53c2\u8003\u6587\u6863\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53bb\u6d4f\u89c8\u5668\u6253\u5f00\u5f00\u53d1\u8005\u5de5\u5177\uff0c\u83dc\u5355\u680f\u591a\u4e86\u4e00\u4e2a\u8c03\u8bd5Node.js\u7684\u6309\u94ae\u3002 \u70b9\u51fb\u8fd9\u4e2a\u6309\u94ae\u3002\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4ee5\u4e0b\u754c\u9762\u3002 \u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u67d0\u4e00\u884c\u4ee3\u7801\u6253\u65ad\u70b9\uff0c\u6bd4\u5982\u6211\u5728\u7b2c\u4e09\u884c\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u8bbf\u95ee80\u7aef\u53e3\uff0c\u5f00\u53d1\u8005\u5de5\u5177\u5c31\u4f1a\u505c\u7559\u5728\u65ad\u70b9\u5904\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4e00\u4e9b\u6267\u884c\u4e0a\u4e0b\u6587\u3002 1.2 \u8fdc\u7a0b\u8c03\u8bd5 \u00b6 \u4f46\u5f88\u591a\u65f6\u5019\u6211\u4eec\u53ef\u80fd\u9700\u8981\u8fdc\u7a0b\u8c03\u8bd5\u3002\u6bd4\u5982\u6211\u5728\u4e00\u53f0\u4e91\u670d\u52a1\u5668\u4e0a\u90e8\u7f72\u4ee5\u4e0a\u670d\u52a1\u5668\u4ee3\u7801\u3002\u7136\u540e\u6267\u884c 1 node --inspect=0.0.0.0:8888 httpServer.js \u4e0d\u8fc7\u8fd9\u65f6\u5019\u6211\u4eec\u6253\u5f00\u5f00\u53d1\u8005\u5de5\u5177\u5c31\u4f1a\u53d1\u73b0\u6309\u94ae\u7f6e\u7070\u6216\u8005\u627e\u4e0d\u5230\u6211\u4eec\u8fdc\u7a0b\u670d\u52a1\u5668\u7684\u4fe1\u606f\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u9700\u8981\u7528\u53e6\u4e00\u79cd\u65b9\u5f0f\u3002\u901a\u8fc7\u5728\u6d4f\u89c8\u5668url\u8f93\u5165\u6846\u8f93\u5165devtools://devtools/bundled/js_app.html?experiments=true&v8only=true&ws={host}:{port}/{path}\u7684\u65b9\u5f0f\uff08\u66ff\u6362{}\u91cc\u9762\u7684\u5185\u5bb9\u4e3a\u4f60\u6267\u884cNode.js\u65f6\u8f93\u51fa\u7684\u4fe1\u606f\uff09\uff0c\u6d4f\u89c8\u5668\u5c31\u4f1a\u53bb\u8fde\u63a5\u4f60\u8f93\u5165\u7684\u5730\u5740\uff0c\u6bd4\u59821.1.1.1:9229/abc\u3002\u8fd9\u79cd\u6bd4\u8f83\u9002\u5408\u4e8e\u5bf9\u4e8e\u901a\u7528\u7684\u573a\u666f\u3002 1.3 \u81ea\u52a8\u63a2\u6d4b \u00b6 \u5982\u679c\u662f\u6211\u4eec\u81ea\u5df1\u8c03\u8bd5\u7684\u8bdd\uff0c\u8fd9\u79cd\u65b9\u5f0f\u770b\u8d77\u6765\u5c31\u6709\u70b9\u9ebb\u70e6\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u6d4f\u89c8\u5668\u63d0\u4f9b\u7684\u81ea\u52a8\u63a2\u6d4b\u529f\u80fd\u3002 1 url\u8f93\u5165\u6846\u8f93\u5165chrome://inspect/#devices\u6211\u4eec\u4f1a\u770b\u5230\u4ee5\u4e0b\u754c\u9762 2 \u70b9\u51fbconfigure\u6309\u94ae\uff0c\u5728\u5f39\u51fa\u7684\u5f39\u6846\u91cc\u8f93\u5165\u4f60\u8fdc\u7a0b\u670d\u52a1\u5668\u7684\u5730\u5740 3 \u914d\u7f6e\u5b8c\u6bd5\u540e\uff0c\u6211\u4eec\u4f1a\u770b\u5230\u754c\u9762\u53d8\u6210\u8fd9\u6837\u4e86\uff0c\u6216\u8005\u6253\u5f00\u65b0\u7684tab\uff0c\u6211\u4eec\u770b\u5230\u5f00\u53d1\u8005\u5de5\u5177\u7684\u8c03\u8bd5\u6309\u94ae\u4e5f\u53d8\u4eae\u4e86\u3002 4 \u8fd9\u65f6\u5019\u6211\u4eec\u70b9\u51fbinspect\u6309\u94ae\u3001Open dedicated DevTools for Node\u6309\u94ae\u6216\u8005\u6253\u5f00\u65b0tab\u7684\u5f00\u53d1\u8005\u5de5\u5177\uff0c\u5c31\u53ef\u4ee5\u5f00\u59cb\u8c03\u8bd5\u3002\u800c\u4e14\u8fd8\u53ef\u4ee5\u8c03\u8bd5Node.js\u7684\u539f\u751fjs\u6a21\u5757\u3002 2 Inspector\u8c03\u8bd5\u7684\u539f\u7406 \u00b6 \u4e0b\u9762\u4ee5\u901a\u8fc7url\u7684\u65b9\u5f0f\u8c03\u8bd5\uff08\u53ef\u4ee5\u770b\u5230network\uff09\uff0c\u6765\u770b\u770b\u8c03\u8bd5\u7684\u65f6\u5019\u90fd\u53d1\u751f\u4e86\u4ec0\u4e48\uff0c\u6d4f\u89c8\u5668\u548c\u8fdc\u7a0b\u670d\u52a1\u5668\u5efa\u7acb\u8fde\u63a5\u540e\uff0c\u662f\u901a\u8fc7websocket\u534f\u8bae\u901a\u4fe1\u7684\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u547d\u4ee4\u662f\u4ec0\u4e48\u610f\u601d\uff0c\u9996\u5148\u770bDebugger.scriptParsed\u3002 Debugger.scriptParsed # Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger. \u4ece\u8bf4\u660e\u4e2d\u6211\u4eec\u770b\u5230\uff0c\u5f53V8\u89e3\u6790\u811a\u672c\u7684\u65f6\u5019\u5c31\u4f1a\u89e6\u53d1\u8fd9\u4e2a\u4e8b\u4ef6\uff0c\u90a3\u5c31\u4f1a\u544a\u8bc9\u6d4f\u89c8\u5668\u8fd9\u4e2a\u4fe1\u606f\u3002 \u6211\u4eec\u53d1\u73b0\u8fd4\u56de\u7684\u90fd\u662f\u4e00\u4e9b\u5143\u6570\u636e\uff0c\u6ca1\u6709\u811a\u672c\u7684\u5177\u4f53\u4ee3\u7801\u5185\u5bb9\uff0c\u8fd9\u65f6\u5019\u6d4f\u89c8\u5668\u4f1a\u518d\u6b21\u53d1\u8d77\u8bf7\u6c42\uff0c \u6211\u4eec\u770b\u5230\u8fd9\u4e2a\u811a\u672c\u7684scriptId\u662f103\u3002\u6240\u4ee5\u8bf7\u6c42\u91cc\u5e26\u4e86\u8fd9\u4e2ascriptId\u3002\u5bf9\u5e94\u7684\u8bf7\u6c42id\u662f11\u3002\u63a5\u7740\u770b\u4e00\u4e0b\u54cd\u5e94\u3002 \u81f3\u6b64\uff0c\u6211\u4eec\u4e86\u89e3\u4e86\u83b7\u53d6\u811a\u672c\u5185\u5bb9\u7684\u8fc7\u7a0b\uff0c\u7136\u540e\u6211\u4eec\u770b\u770b\u8c03\u8bd5\u7684\u65f6\u5019\u662f\u600e\u6837\u7684\u8fc7\u7a0b\u3002\u5f53\u6211\u4eec\u5728\u6d4f\u89c8\u5668\u4e0a\u70b9\u51fb\u67d0\u4e00\u884c\u8bbe\u7f6e\u65ad\u70b9\u7684\u65f6\u5019\uff0c\u6d4f\u89c8\u5668\u5c31\u4f1a\u53d1\u9001\u4e00\u4e2a\u8bf7\u6c42\u3002 \u8fd9\u4e2a\u547d\u4ee4\u7684\u610f\u4e49\u987e\u540d\u601d\u4e49\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u5b9a\u4e49\u3002 Debugger.setBreakpointByUrl # Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in locations property. Further matching script parsing will result in subsequent breakpointResolved events issued. This logical breakpoint will survive page reloads. \u63a5\u7740\u670d\u52a1\u8fd4\u56de\u54cd\u5e94\u3002 \u8fd9\u65f6\u5019\u6211\u4eec\u4ece\u53e6\u5916\u4e00\u4e2atab\u8bbf\u95ee80\u7aef\u53e3\u3002\u670d\u52a1\u5668\u5c31\u4f1a\u5728\u6211\u4eec\u8bbe\u7f6e\u7684\u65ad\u70b9\u5904\u505c\u7559\uff0c\u5e76\u4e14\u901a\u77e5\u6d4f\u89c8\u5668\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u547d\u4ee4\u7684\u610f\u601d\u3002 \u8fd9\u4e2a\u547d\u4ee4\u5c31\u662f\u5f53\u670d\u52a1\u5668\u6267\u884c\u5230\u65ad\u70b9\u65f6\u901a\u77e5\u6d4f\u89c8\u5668\uff0c\u5e76\u4e14\u8fd4\u56de\u6267\u884c\u7684\u4e00\u4e9b\u4e0a\u4e0b\u6587\uff0c\u6bd4\u5982\u662f\u54ea\u4e2a\u6267\u884c\u5230\u54ea\u4e2a\u65ad\u70b9\u505c\u7559\u4e86\u3002\u8fd9\u65f6\u5019\u6d4f\u89c8\u5668\u4fa7\u4e5f\u4f1a\u505c\u7559\u5728\u5bf9\u5e94\u7684\u5730\u65b9\uff0c\u5f53\u6211\u4eechover\u67d0\u4e2a\u53d8\u91cf\u65f6\uff0c\u5c31\u4f1a\u770b\u5230\u5bf9\u5e94\u7684\u4e0a\u4e0b\u6587\u3002\u8fd9\u4e9b\u90fd\u662f\u901a\u8fc7\u5177\u4f53\u7684\u547d\u4ee4\u83b7\u53d6\u7684\u6570\u636e\u3002\u5c31\u4e0d\u4e00\u4e00\u5206\u6790\u4e86\uff0c\u53ef\u4ee5\u53c2\u8003\u5177\u4f53\u6587\u6863\u3002 3 Inspector\u7684\u5b9e\u73b0 \u00b6 \u5927\u81f4\u4e86\u89e3\u4e86\u6d4f\u89c8\u5668\u548c\u670d\u52a1\u5668\u7684\u4ea4\u4e92\u8fc7\u7a0b\u548c\u534f\u8bae\u540e\uff0c\u6211\u4eec\u518d\u6765\u6df1\u5165\u4e86\u89e3\u4e00\u4e0b\u5173\u4e8einspector\u7684\u4e00\u4e9b\u5b9e\u73b0\u3002\u5f53\u7136\u8fd9\u91cc\u4e0d\u662f\u5206\u6790V8\u4e2dInspector\u7684\u5b9e\u73b0\uff0c\u800c\u662f\u5206\u6790\u5982\u4f55\u4f7f\u7528V8\u7684Inspector\u4ee5\u53caNode.js\u4e2d\u5173\u4e8eInspector\u7684\u5b9e\u73b0\u90e8\u5206\u3002 3.1 \u5f00\u6e90\u5b9e\u73b0 \u00b6 \u56e0\u4e3aNode.js\u7684\u5b9e\u73b0\u6bd4\u8f83\u590d\u6742\uff0c\u8fd9\u91cc\u5148\u4ee5\u4e00\u4e2a\u7b80\u5355\u7248\u7684\u8c03\u8bd5\u5de5\u5177\u6e90\u7801\u6765\u5206\u6790inspector\u7684\u539f\u7406\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u521d\u59cb\u5316\u4ee3\u7801\u3002 1 2 inspector = std :: unique_ptr < Inspector > ( new Inspector ( v8Platform , context , port )); inspector -> startAgent (); \u9996\u5148\u65b0\u5efa\u4e00\u4e2aInspector\u3002\u7136\u540e\u542f\u52a8\u5b83\u3002\u63a5\u4e0b\u6765\u770b\u770bInspector\u91cc\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Inspector :: Inspector ( const std :: unique_ptr < v8 :: Platform > & platform , const v8 :: Local < v8 :: Context > & context , const int webSocketPort ) { context_ = context ; // \u65b0\u5efa\u4e00\u4e2awebsocket server\u7528\u4e8e\u548c\u5ba2\u6237\u7aef\u901a\u4fe1 websocket_server_ = std :: unique_ptr < WebSocketServer > ( new WebSocketServer ( webSocketPort , // \u6536\u5230\u5ba2\u6237\u7684\u7684\u6d88\u606f\u540e\u6267\u884conMessage\u56de\u8c03 std :: bind ( & Inspector :: onMessage , this , std :: placeholders :: _1 ) ) ); // \u65b0\u5efa\u4e00\u4e2ainspector client\u548cV8\u901a\u4fe1 inspector_client_ = std :: unique_ptr < V8InspectorClientImpl > ( new V8InspectorClientImpl ( platform , context_ , // \u6536\u5230V8\u7684\u6d88\u606f\u540e\u8c03\u7528sendMessage\u56de\u590d\u7ed9\u5ba2\u6237\u7684 std :: bind ( & Inspector :: sendMessage , this , std :: placeholders :: _1 ), std :: bind ( & Inspector :: waitForFrontendMessage , this ) ) ); } \u4ee3\u7801\u770b\u8d77\u6765\u5f88\u590d\u6742\uff0c\u4e0d\u8fc7\u6211\u4eec\u4e0d\u9700\u8981\u6df1\u7a76\u3002\u4e3b\u8981\u662f\u4e24\u4e2a\u90e8\u5206\uff0c\u4e00\u4e2a\u662f\u65b0\u5efa\u4e00\u4e2awebsocket\u670d\u52a1\u5668\uff0c\u4e00\u4e2a\u662f\u65b0\u5efa\u4e00\u4e2ainspector\u5ba2\u6237\u7aef\uff08\u7528\u4e8e\u548cV8 Inspector\u901a\u4fe1\uff09\uff0c\u6574\u4f53\u67b6\u6784\u5982\u4e0b\u3002 \u63a5\u4e0b\u6765\u5206\u522b\u770b\u4e00\u4e0bwebsocket\u670d\u52a1\u5668\u548cinspector\u5ba2\u6237\u7aef\u7684\u5b9e\u73b0\u3002\u9996\u5148\u770b\u4e00\u4e0bwebsocket\u670d\u52a1\u5668\u7684\u6784\u9020\u51fd\u6570\u3002 1 2 3 4 5 WebSocketServer :: WebSocketServer ( int port , std :: function < void ( std :: string ) > onMessage ) { port_ = port ; onMessage_ = std :: move ( onMessage ); } WebSocketServer\u6784\u9020\u51fd\u6570\u7684\u5b9e\u73b0\u5f88\u7b80\u5355\uff0c\u53ea\u662f\u521d\u59cb\u5316\u4e00\u4e9b\u5b57\u6bb5\u3002\u63a5\u7740\u770binspector\u5ba2\u6237\u7aef\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 V8InspectorClientImpl :: V8InspectorClientImpl ( const std :: unique_ptr < v8 :: Platform > & platform , const v8 :: Local < v8 :: Context > & context , const std :: function < void ( std :: string ) > & onResponse , const std :: function < int ( void ) > & onWaitFrontendMessageOnPause ) { platform_ = platform . get (); context_ = context ; onWaitFrontendMessageOnPause_ = onWaitFrontendMessageOnPause ; isolate_ = context_ -> GetIsolate (); // \u521b\u5efa\u4e00\u4e2achannel\u548cinspector\u901a\u4fe1\uff0c\u6536\u5230V8\u6d88\u606f\u65f6\u4f1a\u6267\u884conResponse channel_ . reset ( new V8InspectorChannelImp ( isolate_ , onResponse )); // \u65b0\u5efa\u4e00\u4e2aV8\u63d0\u4f9b\u7684inspector inspector_ = v8_inspector :: V8Inspector :: create ( isolate_ , this ); // \u521b\u5efa\u4e00\u4e2a\u548cinspector\u901a\u4fe1\u7684session\u3002 session_ = inspector_ -> connect ( kContextGroupId , channel_ . get (), v8_inspector :: StringView ()); context_ -> SetAlignedPointerInEmbedderData ( 1 , this ); v8_inspector :: StringView contextName = convertToStringView ( \"inspector\" ); inspector_ -> contextCreated ( v8_inspector :: V8ContextInfo ( context , kContextGroupId , contextName )); terminated_ = true ; run_nested_loop_ = false ; } \u4e0a\u9762\u4ee3\u7801\u5f88\u591a\uff0c\u4e3b\u8981\u662f\u6839\u636eV8\u63d0\u4f9b\u7684API\u6765\u5c31\u884c\u3002\u8fd9\u91cc\u4e3b\u8981\u6709\u4e09\u4e2a\u6982\u5ff5 1 V8Inspector\u662fV8\u63d0\u4f9b\u7684\u7c7b\u3002 2 session\u8868\u793a\u548cV8 inspector\u901a\u4fe1\u7684\u4f1a\u8bdd\u3002 3 channel\u7528\u4e8e\u548cV8 inspector\u901a\u4fe1\uff0c\u4eceAPI\u6765\u770b\uff0cchannel\u53ea\u80fd\u4eceV8\u83b7\u53d6\u6570\u636e\uff0c\u5199\u5165\u6570\u636e\u662f\u53e6\u5916\u7684API\u3002 \u8fd9\u65f6\u5019\u7684\u67b6\u6784\u5982\u4e0b \u81f3\u6b64\uff0cwebsocket\u670d\u52a1\u5668\u548cinspector\u5ba2\u6237\u7aef\u5c31\u5206\u6790\u5b8c\u6bd5\u4e86\uff0c\u56de\u5230\u6700\u5f00\u59cb\u7684\u4ee3\u7801\uff0c\u521d\u59cb\u5316\u5b8c\u6bd5\u540e\u4f1a\u6267\u884cstartAgent\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void Inspector::startAgent () { websocket_server_ -> run (); } // \u542f\u52a8websocket\u670d\u52a1\u5668 void WebSocketServer::run () { auto const address = net :: ip :: make_address ( \"127.0.0.1\" ); net :: io_context ioc { 1 }; tcp :: acceptor acceptor { ioc , { address , static_cast < unsigned short > ( port_ )}}; tcp :: socket socket { ioc }; acceptor . accept ( socket ); ws_ = std :: unique_ptr < websocket :: stream < tcp :: socket >> ( new websocket :: stream < tcp :: socket > ( std :: move ( socket ))); startListening (); } // \u7b49\u5f85\u8fde\u63a5 void WebSocketServer::startListening () { ws_ -> accept (); while ( true ) { waitFrontendMessage (); } } // \u8bfb\u53d6\u8fde\u63a5\u4e2d\u7684\u6d88\u606f void WebSocketServer::waitFrontendMessage () { beast :: flat_buffer buffer ; ws_ -> read ( buffer ); std :: string message = boost :: beast :: buffers_to_string ( buffer . data ()); onMessage_ ( std :: move ( message )); } startAgent\u7684\u903b\u8f91\u5c31\u662f\u542f\u52a8websocket\u670d\u52a1\u5668\u3002\u542f\u52a8\u5b8c\u6bd5\u540e\u5c31\u7b49\u5f85\u5ba2\u6237\u7684\u8fde\u63a5\u3002\u8fde\u63a5\u6210\u529f\u540e\u6267\u884conMessage_\u3002\u6211\u4eec\u770b\u4e00\u4e0bonMessage\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 void Inspector::onMessage ( const std :: string & message ) { std :: cout << \"CDT message: \" << message << std :: endl ; // StringView\u662fV8\u8981\u6c42\u7684\u683c\u5f0f v8_inspector :: StringView protocolMessage = convertToStringView ( message ); // \u901a\u77e5V8 Inspector inspector_client_ -> dispatchProtocolMessage ( protocolMessage ); } onMessage\u901a\u8fc7Inspector\u5ba2\u6237\u7aef\u628a\u6d88\u606f\u4ea4\u7ed9V8 Inspector\u5904\u7406\u3002V8 Inspector\u5904\u7406\u5b8c\u540e\uff0c\u901a\u8fc7channel\u901a\u77e5Inspector\u5ba2\u6237\u7aef\uff0c\u5bf9\u5e94\u7684\u51fd\u6570\u662fsendResponse\u3002V8InspectorChannelImp\u662f\u7ee7\u627fV8\u63d0\u4f9b\u7684Channel\uff0csendResponse\u662f\u4e00\u4e2a\u7eaf\u865a\u51fd\u6570\uff0c\u7531V8InspectorChannelImp\u5b9e\u73b0\u3002 1 2 3 4 void V8InspectorChannelImp::sendResponse ( int callId , std :: unique_ptr < v8_inspector :: StringBuffer > message ) { const std :: string response = convertToString ( isolate_ , message -> string ()); onResponse_ ( response ); } onResponse_\u662f\u5728Chnnel\u521d\u59cb\u5316\u65f6\u8bbe\u7f6e\u7684\uff0c\u5bf9\u5e94\u51fd\u6570\u662finspector\u5ba2\u6237\u7aef\u7684sendMessage\u3002 1 2 3 void Inspector::sendMessage ( const std :: string & message ) { websocket_server_ -> sendMessage ( message ); } sendMessage\u901a\u8fc7websocket\u670d\u52a1\u5668\u628aV8 Inspector\u8fd4\u56de\u7684\u6d88\u606f\u8fd4\u56de\u7ed9\u5ba2\u6237\u7684\u3002\u81f3\u6b64\uff0c\u6574\u4e2a\u901a\u4fe1\u6d41\u7a0b\u5c31\u5b8c\u6210\u4e86\u3002 3.2 Node.js\u7684\u5b9e\u73b0(v14) \u00b6 Node.js\u7684\u5b9e\u73b0\u975e\u5e38\u590d\u6742\u5e76\u4e14\u5f88\u7ed5\uff0c\u4e5f\u65e0\u6cd5\u901a\u4fd7\u6613\u61c2\u5730\u4ecb\u7ecd\u548c\u5206\u6790\uff0c\u53ea\u80fd\u6309\u7167\u6211\u81ea\u5df1\u7684\u601d\u8def\u5927\u81f4\u8bb2\u89e3\u4e00\u4e0b\u6d41\u7a0b\uff0c\u6709\u5174\u8da3\u7684\u540c\u5b66\u53ef\u4ee5\u81ea\u884c\u9605\u8bfb\u6e90\u7801\u3002\u5f53\u6211\u4eec\u4ee5\u4ee5\u4e0b\u65b9\u5f0f\u6267\u884c\u6211\u4eec\u7684\u5e94\u7528\u65f6 1 node --inspect app.js 3.2.1 \u521d\u59cb\u5316 \u00b6 Node.js\u5728\u542f\u52a8\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5c31\u4f1a\u521d\u59cb\u5316Inspector\u76f8\u5173\u7684\u903b\u8f91\u3002 1 inspector_agent_ = std :: make_unique < inspector :: Agent > ( this ); Agent\u662f\u8d1f\u8d23\u548cV8 Inspector\u901a\u4fe1\u7684\u5bf9\u8c61\u3002\u521b\u5efa\u5b8c\u540e\u63a5\u7740\u6267\u884cenv->InitializeInspector({})\u542f\u52a8Agent\u3002 1 inspector_agent_ -> Start (...); Start\u7ee7\u7eed\u6267\u884cAgent::StartIoThread\u3002 1 2 3 4 bool Agent::StartIoThread () { io_ = InspectorIo :: Start ( client_ -> getThreadHandle (), ...); return true ; } StartIoThread\u4e2d\u7684client_->getThreadHandle()\u662f\u91cd\u8981\u7684\u903b\u8f91\uff0c\u6211\u4eec\u5148\u6765\u5206\u6790\u8be5\u51fd\u6570\u3002 1 2 3 4 5 6 std :: shared_ptr < MainThreadHandle > getThreadHandle () { if ( ! interface_ ) { interface_ = std :: make_shared < MainThreadInterface > ( env_ -> inspector_agent (), ...); } return interface_ -> GetHandle (); } getThreadHandle\u9996\u5148\u521b\u5efa\u6765\u4e00\u4e2aMainThreadInterface\u5bf9\u8c61\uff0c\u63a5\u7740\u53c8\u8c03\u7528\u4e86\u4ed6\u7684GetHandle\u65b9\u6cd5\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8be5\u65b9\u6cd5\u7684\u903b\u8f91\u3002 1 2 3 4 5 std :: shared_ptr < MainThreadHandle > MainThreadInterface :: GetHandle () { if ( handle_ == nullptr ) handle_ = std :: make_shared < MainThreadHandle > ( this ); return handle_ ; } GetHandlei\u4e86\u521b\u5efa\u4e86\u4e00\u4e2aMainThreadHandle\u5bf9\u8c61\uff0c\u6700\u7ec8\u7ed3\u6784\u5982\u4e0b\u6240\u793a\u3002 \u5206\u6790\u5b8c\u540e\u6211\u4eec\u7ee7\u7eed\u770bAgent::StartIoThread\u4e2dInspectorIo::Start\u7684\u903b\u8f91\u3002 1 2 3 4 std :: unique_ptr < InspectorIo > InspectorIo :: Start ( std :: shared_ptr < MainThreadHandle > main_thread , ...) { auto io = std :: unique_ptr < InspectorIo > ( new InspectorIo ( main_thread , ...)); return io ; } InspectorIo::Star\u91cc\u65b0\u5efa\u4e86\u4e00\u4e2aInspectorIo\u5bf9\u8c61\uff0c\u6211\u4eec\u770b\u770bInspectorIo\u6784\u9020\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 InspectorIo :: InspectorIo ( std :: shared_ptr < MainThreadHandle > main_thread , ...) : // \u521d\u59cb\u5316main_thread_ main_thread_ ( main_thread )) { // \u65b0\u5efa\u4e00\u4e2a\u5b50\u7ebf\u7a0b\uff0c\u5b50\u7ebf\u7a0b\u4e2d\u6267\u884cInspectorIo::ThreadMain uv_thread_create ( & thread_ , InspectorIo :: ThreadMain , this ); } \u8fd9\u65f6\u5019\u7ed3\u6784\u5982\u4e0b\u3002 Inspector\u5728\u5b50\u7ebf\u7a0b\u91cc\u542f\u52a8\u7684\u539f\u56e0\u4e3b\u8981\u6709\u4e24\u4e2a\u3002 1 \u5982\u679c\u5728\u4e3b\u7ebf\u7a0b\u91cc\u8fd0\u884c\uff0c\u90a3\u4e48\u5f53\u6211\u4eec\u65ad\u70b9\u8c03\u8bd5\u7684\u65f6\u5019\uff0cNode.js\u4e3b\u7ebf\u7a0b\u5c31\u4f1a\u88ab\u505c\u4f4f\uff0c\u4e5f\u5c31\u65e0\u6cd5\u5904\u7406\u5ba2\u6237\u7aef\u53d1\u8fc7\u6765\u7684\u8c03\u8bd5\u6307\u4ee4\u3002 2 \u5982\u679c\u4e3b\u7ebf\u7a0b\u9677\u5165\u6b7b\u5faa\u73af\uff0c\u6211\u4eec\u5c31\u65e0\u6cd5\u5b9e\u65f6\u6293\u53d6\u8fdb\u7a0b\u7684profile\u6570\u636e\u6765\u5206\u6790\u539f\u56e0\u3002 \u63a5\u7740\u7ee7\u7eed\u770b\u4e00\u4e0b\u5b50\u7ebf\u7a0b\u91cc\u6267\u884cInspectorIo::ThreadMain\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void InspectorIo::ThreadMain ( void * io ) { static_cast < InspectorIo *> ( io ) -> ThreadMain (); } void InspectorIo::ThreadMain () { uv_loop_t loop ; loop . data = nullptr ; // \u5728\u5b50\u7ebf\u7a0b\u5f00\u542f\u4e00\u4e2a\u65b0\u7684\u4e8b\u4ef6\u5faa\u73af int err = uv_loop_init ( & loop ); std :: shared_ptr < RequestQueueData > queue ( new RequestQueueData ( & loop ), ...); // \u65b0\u5efa\u4e00\u4e2adelegate\uff0c\u7528\u4e8e\u5904\u7406\u8bf7\u6c42 std :: unique_ptr < InspectorIoDelegate > delegate ( new InspectorIoDelegate ( queue , main_thread_ , ...) ); InspectorSocketServer server ( std :: move ( delegate ), ...); server . Start () uv_run ( & loop , UV_RUN_DEFAULT ); } ThreadMain\u91cc\u4e3b\u8981\u4e09\u4e2a\u903b\u8f91 1 \u521b\u5efa\u4e00\u4e2adelegate\u5bf9\u8c61\uff0c\u8be5\u5bf9\u8c61\u662f\u6838\u5fc3\u7684\u5bf9\u8c61\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u770b\u5230\u6709\u4ec0\u4e48\u4f5c\u7528\u3002 2 \u521b\u5efa\u4e00\u4e2a\u670d\u52a1\u5668\u5e76\u542f\u52a8\u3002 3 \u5f00\u542f\u4e8b\u4ef6\u5faa\u73af\u3002 \u63a5\u4e0b\u6765\u770b\u4e00\u4e0b\u670d\u52a1\u5668\u7684\u903b\u8f91\uff0c\u9996\u5148\u770b\u4e00\u4e0b\u521b\u5efa\u670d\u52a1\u5668\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 InspectorSocketServer :: InspectorSocketServer ( std :: unique_ptr < SocketServerDelegate > delegate , ...) : // \u4fdd\u5b58delegate delegate_ ( std :: move ( delegate )), // \u521d\u59cb\u5316sessionId next_session_id_ ( 0 ) { // \u8bbe\u7f6edelegate\u7684server\u4e3a\u5f53\u524d\u670d\u52a1\u5668 delegate_ -> AssignServer ( this ); } \u6267\u884c\u5b8c\u540e\u5f62\u6210\u4ee5\u4e0b\u7ed3\u6784\u3002 \u63a5\u7740\u6211\u4eec\u770b\u542f\u52a8\u670d\u52a1\u5668\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool InspectorSocketServer::Start () { // DNS\u89e3\u6790,\u6bd4\u5982\u8f93\u5165\u7684\u662flocalhost struct addrinfo hints ; memset ( & hints , 0 , sizeof ( hints )); hints . ai_flags = AI_NUMERICSERV ; hints . ai_socktype = SOCK_STREAM ; uv_getaddrinfo_t req ; const std :: string port_string = std :: to_string ( port_ ); uv_getaddrinfo ( loop_ , & req , nullptr , host_ . c_str (), port_string . c_str (), & hints ); // \u76d1\u542c\u89e3\u6790\u5230\u7684ip\u5217\u8868 for ( addrinfo * address = req . addrinfo ; address != nullptr ; address = address -> ai_next ) { auto server_socket = ServerSocketPtr ( new ServerSocket ( this )); err = server_socket -> Listen ( address -> ai_addr , loop_ ); if ( err == 0 ) server_sockets_ . push_back ( std :: move ( server_socket )); } return true ; } \u9996\u5148\u6839\u636e\u53c2\u6570\u505a\u4e00\u4e2aDNS\u89e3\u6790\uff0c\u7136\u540e\u6839\u636e\u62ff\u5230\u7684ip\u5217\u8868\uff08\u901a\u5e38\u662f\u4e00\u4e2a\uff09\uff0c\u521b\u5efa\u5bf9\u5e94\u4e2a\u6570\u7684ServerSocket\u5bf9\u8c61\uff0c\u5e76\u6267\u884c\u4ed6\u7684Listen\u65b9\u6cd5\u3002ServerSocket\u8868\u793a\u4e00\u4e2a\u76d1\u542csocket\u3002\u770b\u4e00\u4e0bServerSocket\u7684\u6784\u9020\u51fd\u6570\u3002 1 2 ServerSocket ( InspectorSocketServer * server ) : tcp_socket_ ( uv_tcp_t ()), server_ ( server ) {} \u6267\u884c\u5b8c\u540e\u7ed3\u6784\u5982\u4e0b\u3002 \u63a5\u7740\u770b\u4e00\u4e0bServerSocket\u7684Listen\u65b9\u6cd5\u3002 1 2 3 4 5 6 7 8 int ServerSocket::Listen ( sockaddr * addr , uv_loop_t * loop ) { uv_tcp_t * server = & tcp_socket_ ; uv_tcp_init ( loop , server ) uv_tcp_bind ( server , addr , 0 ); uv_listen ( reinterpret_cast < uv_stream_t *> ( server ), 511 , ServerSocket :: SocketConnectedCallback ); } Listen\u8c03\u7528Libuv\u7684\u63a5\u53e3\u5b8c\u6210\u670d\u52a1\u5668\u7684\u542f\u52a8\u3002\u81f3\u6b64\uff0cInspector\u63d0\u4f9b\u7684Weboscket\u670d\u52a1\u5668\u542f\u52a8\u4e86\u3002 3.2.2 \u5904\u7406\u8fde\u63a5 \u00b6 \u4ece\u521a\u624d\u5206\u6790\u4e2d\u53ef\u4ee5\u770b\u5230\uff0c\u5f53\u6709\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c\u56de\u8c03ServerSocket::SocketConnectedCallback\u3002 1 2 3 4 5 6 7 8 9 void ServerSocket::SocketConnectedCallback ( uv_stream_t * tcp_socket , int status ) { if ( status == 0 ) { // \u6839\u636eLibuv handle\u627e\u5230\u5bf9\u5e94\u7684ServerSocket\u5bf9\u8c61 ServerSocket * server_socket = ServerSocket :: FromTcpSocket ( tcp_socket ); // Socket\u5bf9\u8c61\u7684server_\u5b57\u6bb5\u4fdd\u5b58\u4e86\u6240\u5728\u7684InspectorSocketServer server_socket -> server_ -> Accept ( server_socket -> port_ , tcp_socket ); } } \u63a5\u7740\u770bInspectorSocketServer\u7684Accept\u662f\u5982\u4f55\u5904\u7406\u8fde\u63a5\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void InspectorSocketServer::Accept ( int server_port , uv_stream_t * server_socket ) { std :: unique_ptr < SocketSession > session ( new SocketSession ( this , next_session_id_ ++ , server_port ) ); InspectorSocket :: DelegatePointer delegate = InspectorSocket :: DelegatePointer ( new SocketSession :: Delegate ( this , session -> id ()) ); InspectorSocket :: Pointer inspector = InspectorSocket :: Accept ( server_socket , std :: move ( delegate )); if ( inspector ) { session -> Own ( std :: move ( inspector )); connected_sessions_ [ session -> id ()]. second = std :: move ( session ); } } Accept\u7684\u9996\u5148\u521b\u5efa\u91cc\u4e00\u4e2aSocketSession\u548cSocketSession::Delegate\u5bf9\u8c61\u3002\u7136\u540e\u8c03\u7528InspectorSocket::Accept\uff0c\u4ece\u4ee3\u7801\u4e2d\u53ef\u4ee5\u770b\u5230InspectorSocket::Accept\u4f1a\u8fd4\u56de\u4e00\u4e2aInspectorSocket\u5bf9\u8c61\u3002InspectorSocket\u662f\u5bf9\u901a\u4fe1socket\u7684\u5c01\u88c5\uff08\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684socket\uff0c\u533a\u522b\u4e8e\u670d\u52a1\u5668\u7684\u76d1\u542csocket\uff09\u3002\u7136\u540e\u8bb0\u5f55session\u5bf9\u8c61\u5bf9\u5e94\u7684InspectorSocket\u5bf9\u8c61\uff0c\u540c\u65f6\u8bb0\u5f55sessionId\u548csession\u7684\u6620\u5c04\u5173\u7cfb\u3002\u7ed3\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u63a5\u7740\u770b\u4e00\u4e0bInspectorSocket::Accept\u8fd4\u56deInspectorSocket\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 InspectorSocket :: Pointer InspectorSocket::Accept ( uv_stream_t * server , DelegatePointer delegate ) { auto tcp = TcpHolder :: Accept ( server , std :: move ( delegate )); InspectorSocket * inspector = new InspectorSocket (); inspector -> SwitchProtocol ( new HttpHandler ( inspector , std :: move ( tcp ))); return InspectorSocket :: Pointer ( inspector ); } InspectorSocket::Accept\u7684\u4ee3\u7801\u4e0d\u591a\uff0c\u4f46\u662f\u903b\u8f91\u8fd8\u662f\u633a\u591a\u7684\u3002 1 InspectorSocket::Accept\u518d\u6b21\u8c03\u7528TcpHolder::Accept\u83b7\u5f97\u4e00\u4e2aTcpHolder\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 TcpHolder :: Pointer TcpHolder::Accept ( uv_stream_t * server , InspectorSocket :: DelegatePointer delegate ) { // \u65b0\u5efa\u4e00\u4e2aTcpHolder\u5bf9\u8c61\uff0cTcpHolder\u662f\u5bf9uv_tcp_t\u548cdelegate\u7684\u5c01\u88c5 TcpHolder * result = new TcpHolder ( std :: move ( delegate )); // \u62ff\u5230TcpHolder\u5bf9\u8c61\u7684uv_tcp_t\u7ed3\u6784\u4f53 uv_stream_t * tcp = reinterpret_cast < uv_stream_t *> ( & result -> tcp_ ); // \u521d\u59cb\u5316 int err = uv_tcp_init ( server -> loop , & result -> tcp_ ); // \u6458\u53d6\u4e00\u4e2aTCP\u8fde\u63a5\u5bf9\u5e94\u7684fd\u4fdd\u5b58\u5230TcpHolder\u7684uv_tcp_t\u7ed3\u6784\u4f53\u4e2d\uff08\u5373\u7b2c\u4e8c\u4e2a\u53c2\u6570\u7684tcp\u5b57\u6bb5\uff09 uv_accept ( server , tcp ); // \u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u6709\u6570\u636e\u65f6\u6267\u884cOnDataReceivedCb\u56de\u8c03 uv_read_start ( tcp , allocate_buffer , OnDataReceivedCb ); return TcpHolder :: Pointer ( result ); } 2 \u65b0\u5efa\u4e00\u4e2aHttpHandler\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 explicit HttpHandler ( InspectorSocket * inspector , TcpHolder :: Pointer tcp ) : ProtocolHandler ( inspector , std :: move ( tcp )){ llhttp_init ( & parser_ , HTTP_REQUEST , & parser_settings ); llhttp_settings_init ( & parser_settings ); parser_settings . on_header_field = OnHeaderField ; parser_settings . on_header_value = OnHeaderValue ; parser_settings . on_message_complete = OnMessageComplete ; parser_settings . on_url = OnPath ; } ProtocolHandler :: ProtocolHandler ( InspectorSocket * inspector , TcpHolder :: Pointer tcp ) : inspector_ ( inspector ), tcp_ ( std :: move ( tcp )) { // \u8bbe\u7f6eTCP\u6570\u636e\u7684handler\uff0cTCP\u662f\u53ea\u8d1f\u8d23\u4f20\u8f93\uff0c\u6570\u636e\u7684\u89e3\u6790\u4ea4\u7ed9handler\u5904\u7406 tcp_ -> SetHandler ( this ); } HttpHandler\u662f\u5bf9uv_tcp_t\u7684\u5c01\u88c5\uff0c\u4e3b\u8981\u901a\u8fc7HTTP\u89e3\u6790\u5668llhttp\u5bf9HTTP\u534f\u8bae\u8fdb\u884c\u89e3\u6790\u3002 3 \u8c03\u7528inspector->SwitchProtocol()\u5207\u6362\u5f53\u524d\u534f\u8bae\u4e3aHTTP\uff0c\u5efa\u7acbTCP\u8fde\u63a5\u540e\uff0c\u9996\u5148\u8981\u7ecf\u8fc7\u4e00\u4e2aHTTP\u8bf7\u6c42\u4eceHTTP\u534f\u8bae\u5347\u7ea7\u5230WebSocket\u534f\u8bae\uff0c\u5347\u7ea7\u6210\u529f\u540e\u5c31\u4f7f\u7528Websocket\u534f\u8bae\u8fdb\u884c\u901a\u4fe1\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u65f6\u5019\u7684\u7ed3\u6784\u56fe\u3002 \u81f3\u6b64\uff0c\u5c31\u5b8c\u6210\u4e86\u8fde\u63a5\u5904\u7406\u7684\u5206\u6790\u3002 3.2.3 \u534f\u8bae\u5347\u7ea7 \u00b6 \u5b8c\u6210\u4e86TCP\u8fde\u63a5\u7684\u5904\u7406\u540e\uff0c\u63a5\u4e0b\u6765\u8981\u5b8c\u6210\u534f\u8bae\u5347\u7ea7\uff0c\u56e0\u4e3aInspector\u662f\u901a\u8fc7WebSocket\u534f\u8bae\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\uff0c\u6240\u4ee5\u9700\u8981\u901a\u8fc7\u4e00\u4e2aHTTP\u8bf7\u6c42\u6765\u5b8c\u6210HTTP\u5230WebSocekt\u534f\u8bae\u7684\u5347\u7ea7\u3002\u4ece\u521a\u624d\u7684\u5206\u6790\u4e2d\u770b\u5f53\u6709\u6570\u636e\u5230\u6765\u65f6\u4f1a\u6267\u884cOnDataReceivedCb\u56de\u8c03\u3002 1 2 3 4 5 6 7 void TcpHolder::OnDataReceivedCb ( uv_stream_t * tcp , ssize_t nread , const uv_buf_t * buf ) { TcpHolder * holder = From ( tcp ); holder -> ReclaimUvBuf ( buf , nread ); // \u8c03\u7528handler\u7684onData\uff0c\u76ee\u524dhandler\u662fHTTP\u534f\u8bae holder -> handler_ -> OnData ( & holder -> buffer ); } TCP\u5c42\u6536\u5230\u6570\u636e\u540e\u4ea4\u7ed9\u5e94\u7528\u5c42\u89e3\u6790\uff0c\u76f4\u63a5\u8c03\u7528\u4e0a\u5c42\u7684OnData\u56de\u8c03\u3002 1 2 3 4 5 6 void OnData ( std :: vector < char >* data ) override { // \u89e3\u6790HTTP\u534f\u8bae llhttp_execute ( & parser_ , data -> data (), data -> size ()); // \u89e3\u6790\u5b8c\u5e76\u4e14\u662f\u5347\u7ea7\u534f\u8bae\u7684\u8bf7\u6c42\u5219\u8c03\u7528delegate\u7684\u56de\u8c03OnSocketUpgrade delegate () -> OnSocketUpgrade ( event . host , event . path , event . ws_key ); } OnData\u53ef\u80fd\u4f1a\u88ab\u591a\u6b21\u56de\u8c03\uff0c\u5e76\u901a\u8fc7llhttp_execute\u89e3\u6790\u6536\u5230\u7684HTTP\u62a5\u6587\uff0c\u5f53\u53d1\u73b0\u662f\u4e00\u4e2a\u534f\u8bae\u5347\u7ea7\u7684\u8bf7\u6c42\u540e\uff0c\u5c31\u8c03\u7528OnSocketUpgrade\u56de\u8c03\u3002delegate\u662fTCP\u5c42\u4fdd\u5b58\u7684SocketSession::Delegate\u5bf9\u8c61\u3002\u6765\u770b\u4e00\u4e0b\u8be5\u5bf9\u8c61\u7684OnSocketUpgrade\u65b9\u6cd5\u3002 1 2 3 4 5 6 void SocketSession::Delegate::OnSocketUpgrade ( const std :: string & host , const std :: string & path , const std :: string & ws_key ) { std :: string id = path . empty () ? path : path . substr ( 1 ); server_ -> SessionStarted ( session_id_ , id , ws_key ); } OnSocketUpgrade\u53c8\u8c03\u7528\u6765server_\uff08InspectorSocketServer\u5bf9\u8c61\uff09\u7684SessionStarted\u3002 1 2 3 4 5 6 7 8 9 void InspectorSocketServer::SessionStarted ( int session_id , const std :: string & id , const std :: string & ws_key ) { // \u627e\u5230\u5bf9\u5e94\u7684session\u5bf9\u8c61 SocketSession * session = Session ( session_id ); connected_sessions_ [ session_id ]. first = id ; session -> Accept ( ws_key ); delegate_ -> StartSession ( session_id , id ); } \u9996\u5148\u901a\u8fc7session_id\u627e\u5230\u5efa\u7acbTCP\u8fde\u63a5\u65f6\u5206\u914d\u7684SocketSession\u5bf9\u8c61\u3002 1 \u6267\u884csession->Accept(ws_key);\u56de\u590d\u5ba2\u6237\u7aef\u540c\u610f\u534f\u8bae\u5347\u7ea7\u3002 1 2 3 void Accept ( const std :: string & ws_key ) { ws_socket_ -> AcceptUpgrade ( ws_key ); } \u4ece\u7ed3\u6784\u56fe\u6211\u4eec\u53ef\u4ee5\u770b\u5230ws_socket_\u662f\u4e00\u4e2aInspectorSocket\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void AcceptUpgrade ( const std :: string & accept_key ) override { char accept_string [ ACCEPT_KEY_LENGTH ]; generate_accept_string ( accept_key , & accept_string ); const char accept_ws_prefix [] = \"HTTP/1.1 101 Switching Protocols \\r\\n \" \"Upgrade: websocket \\r\\n \" \"Connection: Upgrade \\r\\n \" \"Sec-WebSocket-Accept: \" ; const char accept_ws_suffix [] = \" \\r\\n\\r\\n \" ; std :: vector < char > reply ( accept_ws_prefix , accept_ws_prefix + sizeof ( accept_ws_prefix ) - 1 ); reply . insert ( reply . end (), accept_string , accept_string + sizeof ( accept_string )); reply . insert ( reply . end (), accept_ws_suffix , accept_ws_suffix + sizeof ( accept_ws_suffix ) - 1 ); // \u56de\u590d101\u7ed9\u5ba2\u6237\u7aef WriteRaw ( reply , WriteRequest :: Cleanup ); // \u5207\u6362handler\u4e3aWebSocket handler inspector_ -> SwitchProtocol ( new WsHandler ( inspector_ , std :: move ( tcp_ ))); } AcceptUpgradeh\u9996\u5148\u56de\u590d\u5ba2\u6237\u7aef101\u8868\u793a\u540c\u610f\u5347\u7ea7\u9053WebSocket\u534f\u8bae\uff0c\u7136\u540e\u5207\u6362\u6570\u636e\u5904\u7406\u5668\u4e3aWsHandler\uff0c\u5373\u540e\u7eed\u7684\u6570\u636e\u6309\u7167WebSocket\u534f\u8bae\u5904\u7406\u3002 2 \u6267\u884cdelegate_->StartSession(session_id, id)\u5efa\u7acb\u548cV8 Inspector\u7684\u4f1a\u8bdd\u3002delegate_\u662fInspectorIoDelegate\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 void InspectorIoDelegate::StartSession ( int session_id , const std :: string & target_id ) { auto session = main_thread_ -> Connect ( std :: unique_ptr < InspectorSessionDelegate > ( new IoSessionDelegate ( request_queue_ -> handle (), session_id ) ), true ); if ( session ) { sessions_ [ session_id ] = std :: move ( session ); fprintf ( stderr , \"Debugger attached. \\n \" ); } } \u9996\u5148\u901a\u8fc7main_thread_->Connect\u62ff\u5230\u4e00\u4e2asession\uff0c\u5e76\u5728InspectorIoDelegate\u4e2d\u8bb0\u5f55\u6620\u5c04\u5173\u7cfb\u3002\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u63a5\u4e0b\u6765\u770b\u4e00\u4e0bmain_thread_->Connect\u7684\u903b\u8f91\uff08main_thread_\u662fMainThreadHandle\u5bf9\u8c61\uff09\u3002 1 2 3 4 5 6 7 8 9 10 std :: unique_ptr < InspectorSession > MainThreadHandle :: Connect ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { return std :: unique_ptr < InspectorSession > ( new CrossThreadInspectorSession ( ++ next_session_id_ , shared_from_this (), std :: move ( delegate ), prevent_shutdown )); } Connect\u51fd\u6570\u65b0\u5efa\u4e86\u4e00\u4e2aCrossThreadInspectorSession\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 CrossThreadInspectorSession ( int id , std :: shared_ptr < MainThreadHandle > thread , std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) // \u521b\u5efa\u4e00\u4e2aMainThreadSessionState\u5bf9\u8c61 : state_ ( thread , std :: bind ( MainThreadSessionState :: Create , std :: placeholders :: _1 , prevent_shutdown )) { // \u6267\u884cMainThreadSessionState::Connect state_ . Call ( & MainThreadSessionState :: Connect , std :: move ( delegate )); } \u7ee7\u7eed\u770bMainThreadSessionState::Connect\u3002 1 2 3 4 void Connect ( std :: unique_ptr < InspectorSessionDelegate > delegate ) { Agent * agent = thread_ -> inspector_agent (); session_ = agent -> Connect ( std :: move ( delegate ), prevent_shutdown_ ); } \u7ee7\u7eed\u8c03agent->Connect\u3002 1 2 3 4 5 6 7 8 9 std :: unique_ptr < InspectorSession > Agent :: Connect ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { int session_id = client_ -> connectFrontend ( std :: move ( delegate ), prevent_shutdown ); return std :: unique_ptr < InspectorSession > ( new SameThreadInspectorSession ( session_id , client_ )); } \u7ee7\u7eed\u8c03connectFrontend 1 2 3 4 5 6 7 8 9 10 11 int connectFrontend ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { int session_id = next_session_id_ ++ ; channels_ [ session_id ] = std :: make_unique < ChannelImpl > ( env_ , client_ , getWorkerManager (), std :: move ( delegate ), getThreadHandle (), prevent_shutdown ); return session_id ; } connectFrontend\u521b\u5efa\u4e86\u4e00\u4e2aChannelImpl\u5e76\u4e14\u5728channels_\u4e2d\u4fdd\u5b58\u4e86\u6620\u5c04\u5173\u7cfb\u3002\u770b\u770bChannelImpl\u7684\u6784\u9020\u51fd\u6570\u3002 1 2 3 4 5 6 7 explicit ChannelImpl ( Environment * env , const std :: unique_ptr < V8Inspector >& inspector , std :: unique_ptr < InspectorSessionDelegate > delegate , ...) : delegate_ ( std :: move ( delegate )) { session_ = inspector -> connect ( CONTEXT_GROUP_ID , this , StringView ()); } ChannelImpl\u8c03\u7528inspector->connect\u5efa\u7acb\u4e86\u4e00\u4e2a\u548cV8 Inspector\u7684\u4f1a\u8bdd\u3002\u7ed3\u6784\u56fe\u5927\u81f4\u5982\u4e0b\u3002 3.2.4 \u5ba2\u6237\u7aef\u5230V8 Inspector\u7684\u6570\u636e\u5904\u7406 \u00b6 TCP\u8fde\u63a5\u5efa\u7acb\u4e86\uff0c\u534f\u8bae\u5347\u7ea7\u4e5f\u5b8c\u6210\u4e86\uff0c\u63a5\u4e0b\u6765\u5c31\u53ef\u4ee5\u5f00\u59cb\u5904\u7406\u4e1a\u52a1\u6570\u636e\u3002\u4ece\u524d\u9762\u7684\u5206\u6790\u4e2d\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u6570\u636e\u5230\u6765\u65f6\u4f1a\u6267\u884cTcpHoldler\u7684handler_->OnData\u56de\u8c03\u3002\u56e0\u4e3a\u5df2\u7ecf\u5b8c\u6210\u4e86\u534f\u8bae\u5347\u7ea7\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\u7684handler\u53d8\u6210\u4e86WeSocket handler\u3002 1 2 3 4 5 6 7 8 9 10 11 void OnData ( std :: vector < char >* data ) override { // 1. Parse. int processed = 0 ; do { processed = ParseWsFrames ( * data ); // 2. Fix the data size & length if ( processed > 0 ) { remove_from_beginning ( data , processed ); } } while ( processed > 0 && ! data -> empty ()); } OnData\u901a\u8fc7ParseWsFrames\u89e3\u6790WebSocket\u534f\u8bae\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 int ParseWsFrames ( const std :: vector < char >& buffer ) { int bytes_consumed = 0 ; std :: vector < char > output ; bool compressed = false ; // \u89e3\u6790WebSocket\u534f\u8bae ws_decode_result r = decode_frame_hybi17 ( buffer , true /* client_frame */ , & bytes_consumed , & output , & compressed ); // \u6267\u884cdelegate\u7684\u56de\u8c03 delegate () -> OnWsFrame ( output ); return bytes_consumed ; } \u524d\u9762\u5df2\u7ecf\u5206\u6790\u8fc7delegate\u662fTcpHoldler\u7684delegate\uff0c\u5373SocketSession::Delegate\u5bf9\u8c61\u3002 1 2 3 4 5 void SocketSession::Delegate::OnWsFrame ( const std :: vector < char >& data ) { server_ -> MessageReceived ( session_id_ , std :: string ( data . data (), data . size ())); } \u7ee7\u7eed\u56de\u8c03server_->MessageReceived\u3002\u4ece\u7ed3\u6784\u56fe\u53ef\u4ee5\u770b\u5230server_\u662fInspectorSocketServer\u5bf9\u8c61\u3002 1 2 3 void MessageReceived ( int session_id , const std :: string & message ) { delegate_ -> MessageReceived ( session_id , message ); } \u7ee7\u7eed\u56de\u8c03delegate_->MessageReceived\u3002InspectorSocketServer\u7684delegate_\u662fInspectorIoDelegate\u5bf9\u8c61\u3002 1 2 3 4 5 6 void InspectorIoDelegate::MessageReceived ( int session_id , const std :: string & message ) { auto session = sessions_ . find ( session_id ); if ( session != sessions_ . end ()) session -> second -> Dispatch ( Utf8ToStringView ( message ) -> string ()); } \u9996\u5148\u901a\u8fc7session_id\u627e\u5230\u5bf9\u5e94\u7684session\u3002session\u662f\u4e00\u4e2aCrossThreadInspectorSession\u5bf9\u8c61\u3002\u770b\u770b\u4ed6\u7684Dispatch\u65b9\u6cd5\u3002 1 2 3 4 void Dispatch ( const StringView & message ) override { state_ . Call ( & MainThreadSessionState :: Dispatch , StringBuffer :: create ( message )); } \u6267\u884cMainThreadSessionState::Dispatch\u3002 1 2 3 void Dispatch ( std :: unique_ptr < StringBuffer > message ) { session_ -> Dispatch ( message -> string ()); } session_\u662fSameThreadInspectorSession\u5bf9\u8c61\u3002 1 2 3 4 5 6 void SameThreadInspectorSession::Dispatch ( const v8_inspector :: StringView & message ) { auto client = client_ . lock (); if ( client ) client -> dispatchMessageFromFrontend ( session_id_ , message ); } \u7ee7\u7eed\u8c03client->dispatchMessageFromFrontend\u3002 1 2 3 void dispatchMessageFromFrontend ( int session_id , const StringView & message ) { channels_ [ session_id ] -> dispatchProtocolMessage ( message ); } \u901a\u8fc7session_id\u627e\u5230\u5bf9\u5e94\u7684ChannelImpl\uff0c\u7ee7\u7eed\u8c03ChannelImpl\u7684dispatchProtocolMessage\u3002 1 2 3 voiddispatchProtocolMessage ( const StringView & message ) { session_ -> dispatchProtocolMessage ( message ); } \u6700\u7ec8\u8c03\u7528\u548cV8 Inspector\u7684\u4f1a\u8bdd\u5bf9\u8c61\u628a\u6570\u636e\u53d1\u9001\u7ed9V8\u3002\u81f3\u6b64\u5ba2\u6237\u7aef\u5230V8 Inspector\u7684\u901a\u4fe1\u8fc7\u7a0b\u5c31\u5b8c\u6210\u4e86\u3002 3.2.5 V8 Inspector\u5230\u5ba2\u6237\u7aef\u7684\u6570\u636e\u5904\u7406 \u00b6 \u63a5\u7740\u770b\u4eceV8 inspector\u5230\u5ba2\u6237\u7aef\u7684\u6570\u636e\u4f20\u9012\u903b\u8f91\u3002V8 inspector\u662f\u901a\u8fc7channel\u7684sendResponse\u51fd\u6570\u4f20\u9012\u7ed9\u5ba2\u6237\u7aef\u7684\u3002 1 2 3 4 5 6 7 8 9 10 void sendResponse ( int callId , std :: unique_ptr < v8_inspector :: StringBuffer > message ) override { sendMessageToFrontend ( message -> string ()); } void sendMessageToFrontend ( const StringView & message ) { delegate_ -> SendMessageToFrontend ( message ); } delegate_\u662fIoSessionDelegate\u5bf9\u8c61\u3002 1 2 3 4 void SendMessageToFrontend ( const v8_inspector :: StringView & message ) override { request_queue_ -> Post ( id_ , TransportAction :: kSendMessage , StringBuffer :: create ( message )); } request_queue_\u662fRequestQueueData\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 void Post ( int session_id , TransportAction action , std :: unique_ptr < StringBuffer > message ) { Mutex :: ScopedLock scoped_lock ( state_lock_ ); bool notify = messages_ . empty (); messages_ . emplace_back ( action , session_id , std :: move ( message )); if ( notify ) { CHECK_EQ ( 0 , uv_async_send ( & async_ )); incoming_message_cond_ . Broadcast ( scoped_lock ); } } Post\u9996\u5148\u628a\u6d88\u606f\u5165\u961f\uff0c\u7136\u540e\u901a\u8fc7\u5f02\u6b65\u7684\u65b9\u5f0f\u901a\u77e5async_\u63a5\u7740\u770basync_\u7684\u5904\u7406\u51fd\u6570\uff08\u5728\u5b50\u7ebf\u7a0b\u7684\u4e8b\u4ef6\u5faa\u73af\u91cc\u6267\u884c\uff09\u3002 1 2 3 4 5 6 uv_async_init ( loop , & async_ , []( uv_async_t * async ) { // \u62ff\u5230async\u5bf9\u5e94\u7684\u4e0a\u4e0b\u6587 RequestQueueData * wrapper = node :: ContainerOf ( & RequestQueueData :: async_ , async ); // \u6267\u884cRequestQueueData\u7684DoDispatch wrapper -> DoDispatch (); }); 1 2 3 4 5 void DoDispatch () { for ( const auto & request : GetMessages ()) { request . Dispatch ( server_ ); } } request\u662fRequestToServer\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 void Dispatch ( InspectorSocketServer * server ) const { switch ( action_ ) { case TransportAction :: kSendMessage : server -> Send ( session_id_ , protocol :: StringUtil :: StringViewToUtf8 ( message_ -> string ())); break ; } } \u63a5\u7740\u770bInspectorSocketServer\u7684Send\u3002 1 2 3 4 5 6 void InspectorSocketServer::Send ( int session_id , const std :: string & message ) { SocketSession * session = Session ( session_id ); if ( session != nullptr ) { session -> Send ( message ); } } session\u4ee3\u8868\u53ef\u5ba2\u6237\u7aef\u7684\u4e00\u4e2a\u8fde\u63a5\u3002 1 2 3 void SocketSession::Send ( const std :: string & message ) { ws_socket_ -> Write ( message . data (), message . length ()); } \u63a5\u7740\u8c03\u7528WebSocket handler\u7684Write\u3002 1 2 3 4 void Write ( const std :: vector < char > data ) override { std :: vector < char > output = encode_frame_hybi17 ( data ); WriteRaw ( output , WriteRequest :: Cleanup ); } WriteRaw\u662f\u57fa\u7c7bProtocolHandler\u5b9e\u73b0\u7684\u3002 1 2 3 4 int ProtocolHandler::WriteRaw ( const std :: vector < char >& buffer , uv_write_cb write_cb ) { return tcp_ -> WriteRaw ( buffer , write_cb ); } \u6700\u7ec8\u662f\u901a\u8fc7TCP\u8fde\u63a5\u8fd4\u56de\u7ed9\u5ba2\u6237\u7aef\u3002 1 2 3 4 5 6 7 8 9 int TcpHolder::WriteRaw ( const std :: vector < char >& buffer , uv_write_cb write_cb ) { // Freed in write_request_cleanup WriteRequest * wr = new WriteRequest ( handler_ , buffer ); uv_stream_t * stream = reinterpret_cast < uv_stream_t *> ( & tcp_ ); int err = uv_write ( & wr -> req , stream , & wr -> buf , 1 , write_cb ); if ( err < 0 ) delete wr ; return err < 0 ; } \u65b0\u5efa\u4e00\u4e2a\u5199\u8bf7\u6c42\uff0csocket\u53ef\u5199\u7684\u65f6\u5019\u53d1\u9001\u6570\u636e\u7ed9\u5ba2\u6237\u7aef\u3002 4 \u52a8\u6001\u5f00\u542fInspector \u00b6 \u9ed8\u8ba4\u6253\u5f00Inspector\u80fd\u529b\u662f\u4e0d\u5b89\u5168\u7684\uff0c\u8fd9\u610f\u5473\u7740\u80fd\u8fde\u4e0awebsocket\u670d\u52a1\u5668\u7684\u5ba2\u6237\u7aef\u90fd\u80fd\u901a\u8fc7\u534f\u8bae\u63a7\u5236Node.js\u8fdb\u7a0b\uff0c\u901a\u5e38\u6211\u4eec\u662f\u5728Node.js\u8fdb\u7a0b\u51fa\u73b0\u95ee\u9898\u7684\u65f6\u5019\uff0c\u52a8\u6001\u5f00\u542fInspector\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const http = require ( 'http' ); const inspector = require ( 'inspector' ); const fs = require ( 'fs' ); http . createServer (( req , res ) => { if ( req . url == 'debug' ) { const session = new inspector . Session (); session . connect (); session . post ( 'Profiler.enable' , () => { session . post ( 'Profiler.start' , () => { session . post ( 'Profiler.stop' , ( err , { profile }) => { if ( ! err ) { fs . writeFileSync ( './profile.cpuprofile' , JSON . stringify ( profile )); } session . disconnect (); res . end ( 'ok' ); }); }); }); } else { res . end ( 'ok' ); } }). listen ( 80 ); \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7url\u53c2\u6570\u63a7\u5236Inspector\u7684\u80fd\u529b\uff0c\u672c\u5730\u8c03\u8bd5\u65f6\u53ef\u4ee5\u5728vscode\u91cc\u53ef\u4ee5\u76f4\u63a5\u770b\u5230\u6570\u636e\u3002 5 \u6536\u96c6\u6570\u636e \u00b6 V8 inspector\u662f\u4e00\u4e2a\u975e\u5e38\u5f3a\u5927\u7684\u5de5\u5177\uff0c\u8c03\u8bd5\u53ea\u662f\u5b83\u5176\u4e2d\u4e00\u4e2a\u80fd\u529b\uff0c\u4ed6\u8fd8\u53ef\u4ee5\u83b7\u53d6\u5185\u5b58\u3001CPU\u7b49\u6570\u636e\uff0c\u5177\u4f53\u80fd\u529b\u8bf7\u53c2\u8003\u6587\u6863\u3002 \u540e\u8bb0\uff1aNode.js\u7684inspector\u662f\u5728Node.js\u989d\u5916\u7ebf\u7a0b\u91cc\u5f00\u542f\u7684\u4e00\u4e2a\u975e\u5e38\u5f3a\u5927\u7684\u5de5\u5177\uff0c\u901a\u8fc7Node.js\u4f5c\u4e3a\u4e2d\u95f4\u4eba\uff0c\u5b8c\u6210\u5ba2\u6237\u7aef\u548cV8 inspector\u7684\u901a\u4fe1\uff08\u8c03\u8bd5\u3001\u6536\u96c6\u6570\u636e\uff09\uff0c\u662f\u6211\u4eec\u8c03\u8bd5\u548c\u8bca\u65adNode.js\u8fdb\u7a0b\u975e\u5e38\u597d\u7684\u65b9\u5f0f\u3002 \u53c2\u8003\u5185\u5bb9\uff1a 1 Debugging Guide 2 inspector 3 \u5f00\u6e90\u7684inspector agent\u5b9e\u73b0 4 inpector\u534f\u8bae\u6587\u6863 5 Debugging Node.js with Chrome DevTools","title":"23-Inspector"},{"location":"chapter24-Inspector/#1-inspector","text":"","title":"1 Inspector\u7684\u4f7f\u7528"},{"location":"chapter24-Inspector/#11","text":"\u6211\u4eec\u5148\u4ece\u4e00\u4e2a\u4f8b\u5b50\u5f00\u59cb\u3002\u4e0b\u9762\u662f\u4e00\u4e2ahttp\u670d\u52a1\u5668\u3002 1 2 3 4 const http = require ( 'http' ); http . createServer (( req , res ) => { res . end ( 'ok' ); }). listen ( 80 ); \u7136\u540e\u6211\u4eec\u4ee5node --inspect httpServer.js\u7684\u65b9\u5f0f\u542f\u52a8\u3002\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4ee5\u4e0b\u8f93\u51fa\u3002 1 2 Debugger listening on ws://127.0.0.1:9229/fbbd9d8f-e088-48cc-b1e0-e16bfe58db44 For help, see: https://nodejs.org/en/docs/inspector 9229\u7aef\u53e3\u662fNode.js\u9ed8\u8ba4\u9009\u62e9\u7684\u7aef\u53e3\uff0c\u5f53\u7136\u6211\u4eec\u4e5f\u53ef\u4ee5\u81ea\u5b9a\u4e49\uff0c\u5177\u4f53\u53ef\u53c2\u8003\u6587\u6863\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53bb\u6d4f\u89c8\u5668\u6253\u5f00\u5f00\u53d1\u8005\u5de5\u5177\uff0c\u83dc\u5355\u680f\u591a\u4e86\u4e00\u4e2a\u8c03\u8bd5Node.js\u7684\u6309\u94ae\u3002 \u70b9\u51fb\u8fd9\u4e2a\u6309\u94ae\u3002\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4ee5\u4e0b\u754c\u9762\u3002 \u6211\u4eec\u53ef\u4ee5\u9009\u62e9\u67d0\u4e00\u884c\u4ee3\u7801\u6253\u65ad\u70b9\uff0c\u6bd4\u5982\u6211\u5728\u7b2c\u4e09\u884c\uff0c\u8fd9\u65f6\u5019\u6211\u4eec\u8bbf\u95ee80\u7aef\u53e3\uff0c\u5f00\u53d1\u8005\u5de5\u5177\u5c31\u4f1a\u505c\u7559\u5728\u65ad\u70b9\u5904\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u53ef\u4ee5\u770b\u5230\u4e00\u4e9b\u6267\u884c\u4e0a\u4e0b\u6587\u3002","title":"1.1 \u672c\u5730\u8c03\u8bd5"},{"location":"chapter24-Inspector/#12","text":"\u4f46\u5f88\u591a\u65f6\u5019\u6211\u4eec\u53ef\u80fd\u9700\u8981\u8fdc\u7a0b\u8c03\u8bd5\u3002\u6bd4\u5982\u6211\u5728\u4e00\u53f0\u4e91\u670d\u52a1\u5668\u4e0a\u90e8\u7f72\u4ee5\u4e0a\u670d\u52a1\u5668\u4ee3\u7801\u3002\u7136\u540e\u6267\u884c 1 node --inspect=0.0.0.0:8888 httpServer.js \u4e0d\u8fc7\u8fd9\u65f6\u5019\u6211\u4eec\u6253\u5f00\u5f00\u53d1\u8005\u5de5\u5177\u5c31\u4f1a\u53d1\u73b0\u6309\u94ae\u7f6e\u7070\u6216\u8005\u627e\u4e0d\u5230\u6211\u4eec\u8fdc\u7a0b\u670d\u52a1\u5668\u7684\u4fe1\u606f\u3002\u8fd9\u65f6\u5019\u6211\u4eec\u9700\u8981\u7528\u53e6\u4e00\u79cd\u65b9\u5f0f\u3002\u901a\u8fc7\u5728\u6d4f\u89c8\u5668url\u8f93\u5165\u6846\u8f93\u5165devtools://devtools/bundled/js_app.html?experiments=true&v8only=true&ws={host}:{port}/{path}\u7684\u65b9\u5f0f\uff08\u66ff\u6362{}\u91cc\u9762\u7684\u5185\u5bb9\u4e3a\u4f60\u6267\u884cNode.js\u65f6\u8f93\u51fa\u7684\u4fe1\u606f\uff09\uff0c\u6d4f\u89c8\u5668\u5c31\u4f1a\u53bb\u8fde\u63a5\u4f60\u8f93\u5165\u7684\u5730\u5740\uff0c\u6bd4\u59821.1.1.1:9229/abc\u3002\u8fd9\u79cd\u6bd4\u8f83\u9002\u5408\u4e8e\u5bf9\u4e8e\u901a\u7528\u7684\u573a\u666f\u3002","title":"1.2 \u8fdc\u7a0b\u8c03\u8bd5"},{"location":"chapter24-Inspector/#13","text":"\u5982\u679c\u662f\u6211\u4eec\u81ea\u5df1\u8c03\u8bd5\u7684\u8bdd\uff0c\u8fd9\u79cd\u65b9\u5f0f\u770b\u8d77\u6765\u5c31\u6709\u70b9\u9ebb\u70e6\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u6d4f\u89c8\u5668\u63d0\u4f9b\u7684\u81ea\u52a8\u63a2\u6d4b\u529f\u80fd\u3002 1 url\u8f93\u5165\u6846\u8f93\u5165chrome://inspect/#devices\u6211\u4eec\u4f1a\u770b\u5230\u4ee5\u4e0b\u754c\u9762 2 \u70b9\u51fbconfigure\u6309\u94ae\uff0c\u5728\u5f39\u51fa\u7684\u5f39\u6846\u91cc\u8f93\u5165\u4f60\u8fdc\u7a0b\u670d\u52a1\u5668\u7684\u5730\u5740 3 \u914d\u7f6e\u5b8c\u6bd5\u540e\uff0c\u6211\u4eec\u4f1a\u770b\u5230\u754c\u9762\u53d8\u6210\u8fd9\u6837\u4e86\uff0c\u6216\u8005\u6253\u5f00\u65b0\u7684tab\uff0c\u6211\u4eec\u770b\u5230\u5f00\u53d1\u8005\u5de5\u5177\u7684\u8c03\u8bd5\u6309\u94ae\u4e5f\u53d8\u4eae\u4e86\u3002 4 \u8fd9\u65f6\u5019\u6211\u4eec\u70b9\u51fbinspect\u6309\u94ae\u3001Open dedicated DevTools for Node\u6309\u94ae\u6216\u8005\u6253\u5f00\u65b0tab\u7684\u5f00\u53d1\u8005\u5de5\u5177\uff0c\u5c31\u53ef\u4ee5\u5f00\u59cb\u8c03\u8bd5\u3002\u800c\u4e14\u8fd8\u53ef\u4ee5\u8c03\u8bd5Node.js\u7684\u539f\u751fjs\u6a21\u5757\u3002","title":"1.3 \u81ea\u52a8\u63a2\u6d4b"},{"location":"chapter24-Inspector/#2-inspector","text":"\u4e0b\u9762\u4ee5\u901a\u8fc7url\u7684\u65b9\u5f0f\u8c03\u8bd5\uff08\u53ef\u4ee5\u770b\u5230network\uff09\uff0c\u6765\u770b\u770b\u8c03\u8bd5\u7684\u65f6\u5019\u90fd\u53d1\u751f\u4e86\u4ec0\u4e48\uff0c\u6d4f\u89c8\u5668\u548c\u8fdc\u7a0b\u670d\u52a1\u5668\u5efa\u7acb\u8fde\u63a5\u540e\uff0c\u662f\u901a\u8fc7websocket\u534f\u8bae\u901a\u4fe1\u7684\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u547d\u4ee4\u662f\u4ec0\u4e48\u610f\u601d\uff0c\u9996\u5148\u770bDebugger.scriptParsed\u3002 Debugger.scriptParsed # Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger. \u4ece\u8bf4\u660e\u4e2d\u6211\u4eec\u770b\u5230\uff0c\u5f53V8\u89e3\u6790\u811a\u672c\u7684\u65f6\u5019\u5c31\u4f1a\u89e6\u53d1\u8fd9\u4e2a\u4e8b\u4ef6\uff0c\u90a3\u5c31\u4f1a\u544a\u8bc9\u6d4f\u89c8\u5668\u8fd9\u4e2a\u4fe1\u606f\u3002 \u6211\u4eec\u53d1\u73b0\u8fd4\u56de\u7684\u90fd\u662f\u4e00\u4e9b\u5143\u6570\u636e\uff0c\u6ca1\u6709\u811a\u672c\u7684\u5177\u4f53\u4ee3\u7801\u5185\u5bb9\uff0c\u8fd9\u65f6\u5019\u6d4f\u89c8\u5668\u4f1a\u518d\u6b21\u53d1\u8d77\u8bf7\u6c42\uff0c \u6211\u4eec\u770b\u5230\u8fd9\u4e2a\u811a\u672c\u7684scriptId\u662f103\u3002\u6240\u4ee5\u8bf7\u6c42\u91cc\u5e26\u4e86\u8fd9\u4e2ascriptId\u3002\u5bf9\u5e94\u7684\u8bf7\u6c42id\u662f11\u3002\u63a5\u7740\u770b\u4e00\u4e0b\u54cd\u5e94\u3002 \u81f3\u6b64\uff0c\u6211\u4eec\u4e86\u89e3\u4e86\u83b7\u53d6\u811a\u672c\u5185\u5bb9\u7684\u8fc7\u7a0b\uff0c\u7136\u540e\u6211\u4eec\u770b\u770b\u8c03\u8bd5\u7684\u65f6\u5019\u662f\u600e\u6837\u7684\u8fc7\u7a0b\u3002\u5f53\u6211\u4eec\u5728\u6d4f\u89c8\u5668\u4e0a\u70b9\u51fb\u67d0\u4e00\u884c\u8bbe\u7f6e\u65ad\u70b9\u7684\u65f6\u5019\uff0c\u6d4f\u89c8\u5668\u5c31\u4f1a\u53d1\u9001\u4e00\u4e2a\u8bf7\u6c42\u3002 \u8fd9\u4e2a\u547d\u4ee4\u7684\u610f\u4e49\u987e\u540d\u601d\u4e49\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u5177\u4f53\u5b9a\u4e49\u3002 Debugger.setBreakpointByUrl # Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in locations property. Further matching script parsing will result in subsequent breakpointResolved events issued. This logical breakpoint will survive page reloads. \u63a5\u7740\u670d\u52a1\u8fd4\u56de\u54cd\u5e94\u3002 \u8fd9\u65f6\u5019\u6211\u4eec\u4ece\u53e6\u5916\u4e00\u4e2atab\u8bbf\u95ee80\u7aef\u53e3\u3002\u670d\u52a1\u5668\u5c31\u4f1a\u5728\u6211\u4eec\u8bbe\u7f6e\u7684\u65ad\u70b9\u5904\u505c\u7559\uff0c\u5e76\u4e14\u901a\u77e5\u6d4f\u89c8\u5668\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u4e2a\u547d\u4ee4\u7684\u610f\u601d\u3002 \u8fd9\u4e2a\u547d\u4ee4\u5c31\u662f\u5f53\u670d\u52a1\u5668\u6267\u884c\u5230\u65ad\u70b9\u65f6\u901a\u77e5\u6d4f\u89c8\u5668\uff0c\u5e76\u4e14\u8fd4\u56de\u6267\u884c\u7684\u4e00\u4e9b\u4e0a\u4e0b\u6587\uff0c\u6bd4\u5982\u662f\u54ea\u4e2a\u6267\u884c\u5230\u54ea\u4e2a\u65ad\u70b9\u505c\u7559\u4e86\u3002\u8fd9\u65f6\u5019\u6d4f\u89c8\u5668\u4fa7\u4e5f\u4f1a\u505c\u7559\u5728\u5bf9\u5e94\u7684\u5730\u65b9\uff0c\u5f53\u6211\u4eechover\u67d0\u4e2a\u53d8\u91cf\u65f6\uff0c\u5c31\u4f1a\u770b\u5230\u5bf9\u5e94\u7684\u4e0a\u4e0b\u6587\u3002\u8fd9\u4e9b\u90fd\u662f\u901a\u8fc7\u5177\u4f53\u7684\u547d\u4ee4\u83b7\u53d6\u7684\u6570\u636e\u3002\u5c31\u4e0d\u4e00\u4e00\u5206\u6790\u4e86\uff0c\u53ef\u4ee5\u53c2\u8003\u5177\u4f53\u6587\u6863\u3002","title":"2 Inspector\u8c03\u8bd5\u7684\u539f\u7406"},{"location":"chapter24-Inspector/#3-inspector","text":"\u5927\u81f4\u4e86\u89e3\u4e86\u6d4f\u89c8\u5668\u548c\u670d\u52a1\u5668\u7684\u4ea4\u4e92\u8fc7\u7a0b\u548c\u534f\u8bae\u540e\uff0c\u6211\u4eec\u518d\u6765\u6df1\u5165\u4e86\u89e3\u4e00\u4e0b\u5173\u4e8einspector\u7684\u4e00\u4e9b\u5b9e\u73b0\u3002\u5f53\u7136\u8fd9\u91cc\u4e0d\u662f\u5206\u6790V8\u4e2dInspector\u7684\u5b9e\u73b0\uff0c\u800c\u662f\u5206\u6790\u5982\u4f55\u4f7f\u7528V8\u7684Inspector\u4ee5\u53caNode.js\u4e2d\u5173\u4e8eInspector\u7684\u5b9e\u73b0\u90e8\u5206\u3002","title":"3 Inspector\u7684\u5b9e\u73b0"},{"location":"chapter24-Inspector/#31","text":"\u56e0\u4e3aNode.js\u7684\u5b9e\u73b0\u6bd4\u8f83\u590d\u6742\uff0c\u8fd9\u91cc\u5148\u4ee5\u4e00\u4e2a\u7b80\u5355\u7248\u7684\u8c03\u8bd5\u5de5\u5177\u6e90\u7801\u6765\u5206\u6790inspector\u7684\u539f\u7406\u3002\u6211\u4eec\u5148\u770b\u4e00\u4e0b\u521d\u59cb\u5316\u4ee3\u7801\u3002 1 2 inspector = std :: unique_ptr < Inspector > ( new Inspector ( v8Platform , context , port )); inspector -> startAgent (); \u9996\u5148\u65b0\u5efa\u4e00\u4e2aInspector\u3002\u7136\u540e\u542f\u52a8\u5b83\u3002\u63a5\u4e0b\u6765\u770b\u770bInspector\u91cc\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Inspector :: Inspector ( const std :: unique_ptr < v8 :: Platform > & platform , const v8 :: Local < v8 :: Context > & context , const int webSocketPort ) { context_ = context ; // \u65b0\u5efa\u4e00\u4e2awebsocket server\u7528\u4e8e\u548c\u5ba2\u6237\u7aef\u901a\u4fe1 websocket_server_ = std :: unique_ptr < WebSocketServer > ( new WebSocketServer ( webSocketPort , // \u6536\u5230\u5ba2\u6237\u7684\u7684\u6d88\u606f\u540e\u6267\u884conMessage\u56de\u8c03 std :: bind ( & Inspector :: onMessage , this , std :: placeholders :: _1 ) ) ); // \u65b0\u5efa\u4e00\u4e2ainspector client\u548cV8\u901a\u4fe1 inspector_client_ = std :: unique_ptr < V8InspectorClientImpl > ( new V8InspectorClientImpl ( platform , context_ , // \u6536\u5230V8\u7684\u6d88\u606f\u540e\u8c03\u7528sendMessage\u56de\u590d\u7ed9\u5ba2\u6237\u7684 std :: bind ( & Inspector :: sendMessage , this , std :: placeholders :: _1 ), std :: bind ( & Inspector :: waitForFrontendMessage , this ) ) ); } \u4ee3\u7801\u770b\u8d77\u6765\u5f88\u590d\u6742\uff0c\u4e0d\u8fc7\u6211\u4eec\u4e0d\u9700\u8981\u6df1\u7a76\u3002\u4e3b\u8981\u662f\u4e24\u4e2a\u90e8\u5206\uff0c\u4e00\u4e2a\u662f\u65b0\u5efa\u4e00\u4e2awebsocket\u670d\u52a1\u5668\uff0c\u4e00\u4e2a\u662f\u65b0\u5efa\u4e00\u4e2ainspector\u5ba2\u6237\u7aef\uff08\u7528\u4e8e\u548cV8 Inspector\u901a\u4fe1\uff09\uff0c\u6574\u4f53\u67b6\u6784\u5982\u4e0b\u3002 \u63a5\u4e0b\u6765\u5206\u522b\u770b\u4e00\u4e0bwebsocket\u670d\u52a1\u5668\u548cinspector\u5ba2\u6237\u7aef\u7684\u5b9e\u73b0\u3002\u9996\u5148\u770b\u4e00\u4e0bwebsocket\u670d\u52a1\u5668\u7684\u6784\u9020\u51fd\u6570\u3002 1 2 3 4 5 WebSocketServer :: WebSocketServer ( int port , std :: function < void ( std :: string ) > onMessage ) { port_ = port ; onMessage_ = std :: move ( onMessage ); } WebSocketServer\u6784\u9020\u51fd\u6570\u7684\u5b9e\u73b0\u5f88\u7b80\u5355\uff0c\u53ea\u662f\u521d\u59cb\u5316\u4e00\u4e9b\u5b57\u6bb5\u3002\u63a5\u7740\u770binspector\u5ba2\u6237\u7aef\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 V8InspectorClientImpl :: V8InspectorClientImpl ( const std :: unique_ptr < v8 :: Platform > & platform , const v8 :: Local < v8 :: Context > & context , const std :: function < void ( std :: string ) > & onResponse , const std :: function < int ( void ) > & onWaitFrontendMessageOnPause ) { platform_ = platform . get (); context_ = context ; onWaitFrontendMessageOnPause_ = onWaitFrontendMessageOnPause ; isolate_ = context_ -> GetIsolate (); // \u521b\u5efa\u4e00\u4e2achannel\u548cinspector\u901a\u4fe1\uff0c\u6536\u5230V8\u6d88\u606f\u65f6\u4f1a\u6267\u884conResponse channel_ . reset ( new V8InspectorChannelImp ( isolate_ , onResponse )); // \u65b0\u5efa\u4e00\u4e2aV8\u63d0\u4f9b\u7684inspector inspector_ = v8_inspector :: V8Inspector :: create ( isolate_ , this ); // \u521b\u5efa\u4e00\u4e2a\u548cinspector\u901a\u4fe1\u7684session\u3002 session_ = inspector_ -> connect ( kContextGroupId , channel_ . get (), v8_inspector :: StringView ()); context_ -> SetAlignedPointerInEmbedderData ( 1 , this ); v8_inspector :: StringView contextName = convertToStringView ( \"inspector\" ); inspector_ -> contextCreated ( v8_inspector :: V8ContextInfo ( context , kContextGroupId , contextName )); terminated_ = true ; run_nested_loop_ = false ; } \u4e0a\u9762\u4ee3\u7801\u5f88\u591a\uff0c\u4e3b\u8981\u662f\u6839\u636eV8\u63d0\u4f9b\u7684API\u6765\u5c31\u884c\u3002\u8fd9\u91cc\u4e3b\u8981\u6709\u4e09\u4e2a\u6982\u5ff5 1 V8Inspector\u662fV8\u63d0\u4f9b\u7684\u7c7b\u3002 2 session\u8868\u793a\u548cV8 inspector\u901a\u4fe1\u7684\u4f1a\u8bdd\u3002 3 channel\u7528\u4e8e\u548cV8 inspector\u901a\u4fe1\uff0c\u4eceAPI\u6765\u770b\uff0cchannel\u53ea\u80fd\u4eceV8\u83b7\u53d6\u6570\u636e\uff0c\u5199\u5165\u6570\u636e\u662f\u53e6\u5916\u7684API\u3002 \u8fd9\u65f6\u5019\u7684\u67b6\u6784\u5982\u4e0b \u81f3\u6b64\uff0cwebsocket\u670d\u52a1\u5668\u548cinspector\u5ba2\u6237\u7aef\u5c31\u5206\u6790\u5b8c\u6bd5\u4e86\uff0c\u56de\u5230\u6700\u5f00\u59cb\u7684\u4ee3\u7801\uff0c\u521d\u59cb\u5316\u5b8c\u6bd5\u540e\u4f1a\u6267\u884cstartAgent\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 void Inspector::startAgent () { websocket_server_ -> run (); } // \u542f\u52a8websocket\u670d\u52a1\u5668 void WebSocketServer::run () { auto const address = net :: ip :: make_address ( \"127.0.0.1\" ); net :: io_context ioc { 1 }; tcp :: acceptor acceptor { ioc , { address , static_cast < unsigned short > ( port_ )}}; tcp :: socket socket { ioc }; acceptor . accept ( socket ); ws_ = std :: unique_ptr < websocket :: stream < tcp :: socket >> ( new websocket :: stream < tcp :: socket > ( std :: move ( socket ))); startListening (); } // \u7b49\u5f85\u8fde\u63a5 void WebSocketServer::startListening () { ws_ -> accept (); while ( true ) { waitFrontendMessage (); } } // \u8bfb\u53d6\u8fde\u63a5\u4e2d\u7684\u6d88\u606f void WebSocketServer::waitFrontendMessage () { beast :: flat_buffer buffer ; ws_ -> read ( buffer ); std :: string message = boost :: beast :: buffers_to_string ( buffer . data ()); onMessage_ ( std :: move ( message )); } startAgent\u7684\u903b\u8f91\u5c31\u662f\u542f\u52a8websocket\u670d\u52a1\u5668\u3002\u542f\u52a8\u5b8c\u6bd5\u540e\u5c31\u7b49\u5f85\u5ba2\u6237\u7684\u8fde\u63a5\u3002\u8fde\u63a5\u6210\u529f\u540e\u6267\u884conMessage_\u3002\u6211\u4eec\u770b\u4e00\u4e0bonMessage\u7684\u5b9e\u73b0\u3002 1 2 3 4 5 6 7 void Inspector::onMessage ( const std :: string & message ) { std :: cout << \"CDT message: \" << message << std :: endl ; // StringView\u662fV8\u8981\u6c42\u7684\u683c\u5f0f v8_inspector :: StringView protocolMessage = convertToStringView ( message ); // \u901a\u77e5V8 Inspector inspector_client_ -> dispatchProtocolMessage ( protocolMessage ); } onMessage\u901a\u8fc7Inspector\u5ba2\u6237\u7aef\u628a\u6d88\u606f\u4ea4\u7ed9V8 Inspector\u5904\u7406\u3002V8 Inspector\u5904\u7406\u5b8c\u540e\uff0c\u901a\u8fc7channel\u901a\u77e5Inspector\u5ba2\u6237\u7aef\uff0c\u5bf9\u5e94\u7684\u51fd\u6570\u662fsendResponse\u3002V8InspectorChannelImp\u662f\u7ee7\u627fV8\u63d0\u4f9b\u7684Channel\uff0csendResponse\u662f\u4e00\u4e2a\u7eaf\u865a\u51fd\u6570\uff0c\u7531V8InspectorChannelImp\u5b9e\u73b0\u3002 1 2 3 4 void V8InspectorChannelImp::sendResponse ( int callId , std :: unique_ptr < v8_inspector :: StringBuffer > message ) { const std :: string response = convertToString ( isolate_ , message -> string ()); onResponse_ ( response ); } onResponse_\u662f\u5728Chnnel\u521d\u59cb\u5316\u65f6\u8bbe\u7f6e\u7684\uff0c\u5bf9\u5e94\u51fd\u6570\u662finspector\u5ba2\u6237\u7aef\u7684sendMessage\u3002 1 2 3 void Inspector::sendMessage ( const std :: string & message ) { websocket_server_ -> sendMessage ( message ); } sendMessage\u901a\u8fc7websocket\u670d\u52a1\u5668\u628aV8 Inspector\u8fd4\u56de\u7684\u6d88\u606f\u8fd4\u56de\u7ed9\u5ba2\u6237\u7684\u3002\u81f3\u6b64\uff0c\u6574\u4e2a\u901a\u4fe1\u6d41\u7a0b\u5c31\u5b8c\u6210\u4e86\u3002","title":"3.1 \u5f00\u6e90\u5b9e\u73b0"},{"location":"chapter24-Inspector/#32-nodejsv14","text":"Node.js\u7684\u5b9e\u73b0\u975e\u5e38\u590d\u6742\u5e76\u4e14\u5f88\u7ed5\uff0c\u4e5f\u65e0\u6cd5\u901a\u4fd7\u6613\u61c2\u5730\u4ecb\u7ecd\u548c\u5206\u6790\uff0c\u53ea\u80fd\u6309\u7167\u6211\u81ea\u5df1\u7684\u601d\u8def\u5927\u81f4\u8bb2\u89e3\u4e00\u4e0b\u6d41\u7a0b\uff0c\u6709\u5174\u8da3\u7684\u540c\u5b66\u53ef\u4ee5\u81ea\u884c\u9605\u8bfb\u6e90\u7801\u3002\u5f53\u6211\u4eec\u4ee5\u4ee5\u4e0b\u65b9\u5f0f\u6267\u884c\u6211\u4eec\u7684\u5e94\u7528\u65f6 1 node --inspect app.js","title":"3.2 Node.js\u7684\u5b9e\u73b0(v14)"},{"location":"chapter24-Inspector/#321","text":"Node.js\u5728\u542f\u52a8\u7684\u8fc7\u7a0b\u4e2d\uff0c\u5c31\u4f1a\u521d\u59cb\u5316Inspector\u76f8\u5173\u7684\u903b\u8f91\u3002 1 inspector_agent_ = std :: make_unique < inspector :: Agent > ( this ); Agent\u662f\u8d1f\u8d23\u548cV8 Inspector\u901a\u4fe1\u7684\u5bf9\u8c61\u3002\u521b\u5efa\u5b8c\u540e\u63a5\u7740\u6267\u884cenv->InitializeInspector({})\u542f\u52a8Agent\u3002 1 inspector_agent_ -> Start (...); Start\u7ee7\u7eed\u6267\u884cAgent::StartIoThread\u3002 1 2 3 4 bool Agent::StartIoThread () { io_ = InspectorIo :: Start ( client_ -> getThreadHandle (), ...); return true ; } StartIoThread\u4e2d\u7684client_->getThreadHandle()\u662f\u91cd\u8981\u7684\u903b\u8f91\uff0c\u6211\u4eec\u5148\u6765\u5206\u6790\u8be5\u51fd\u6570\u3002 1 2 3 4 5 6 std :: shared_ptr < MainThreadHandle > getThreadHandle () { if ( ! interface_ ) { interface_ = std :: make_shared < MainThreadInterface > ( env_ -> inspector_agent (), ...); } return interface_ -> GetHandle (); } getThreadHandle\u9996\u5148\u521b\u5efa\u6765\u4e00\u4e2aMainThreadInterface\u5bf9\u8c61\uff0c\u63a5\u7740\u53c8\u8c03\u7528\u4e86\u4ed6\u7684GetHandle\u65b9\u6cd5\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8be5\u65b9\u6cd5\u7684\u903b\u8f91\u3002 1 2 3 4 5 std :: shared_ptr < MainThreadHandle > MainThreadInterface :: GetHandle () { if ( handle_ == nullptr ) handle_ = std :: make_shared < MainThreadHandle > ( this ); return handle_ ; } GetHandlei\u4e86\u521b\u5efa\u4e86\u4e00\u4e2aMainThreadHandle\u5bf9\u8c61\uff0c\u6700\u7ec8\u7ed3\u6784\u5982\u4e0b\u6240\u793a\u3002 \u5206\u6790\u5b8c\u540e\u6211\u4eec\u7ee7\u7eed\u770bAgent::StartIoThread\u4e2dInspectorIo::Start\u7684\u903b\u8f91\u3002 1 2 3 4 std :: unique_ptr < InspectorIo > InspectorIo :: Start ( std :: shared_ptr < MainThreadHandle > main_thread , ...) { auto io = std :: unique_ptr < InspectorIo > ( new InspectorIo ( main_thread , ...)); return io ; } InspectorIo::Star\u91cc\u65b0\u5efa\u4e86\u4e00\u4e2aInspectorIo\u5bf9\u8c61\uff0c\u6211\u4eec\u770b\u770bInspectorIo\u6784\u9020\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 InspectorIo :: InspectorIo ( std :: shared_ptr < MainThreadHandle > main_thread , ...) : // \u521d\u59cb\u5316main_thread_ main_thread_ ( main_thread )) { // \u65b0\u5efa\u4e00\u4e2a\u5b50\u7ebf\u7a0b\uff0c\u5b50\u7ebf\u7a0b\u4e2d\u6267\u884cInspectorIo::ThreadMain uv_thread_create ( & thread_ , InspectorIo :: ThreadMain , this ); } \u8fd9\u65f6\u5019\u7ed3\u6784\u5982\u4e0b\u3002 Inspector\u5728\u5b50\u7ebf\u7a0b\u91cc\u542f\u52a8\u7684\u539f\u56e0\u4e3b\u8981\u6709\u4e24\u4e2a\u3002 1 \u5982\u679c\u5728\u4e3b\u7ebf\u7a0b\u91cc\u8fd0\u884c\uff0c\u90a3\u4e48\u5f53\u6211\u4eec\u65ad\u70b9\u8c03\u8bd5\u7684\u65f6\u5019\uff0cNode.js\u4e3b\u7ebf\u7a0b\u5c31\u4f1a\u88ab\u505c\u4f4f\uff0c\u4e5f\u5c31\u65e0\u6cd5\u5904\u7406\u5ba2\u6237\u7aef\u53d1\u8fc7\u6765\u7684\u8c03\u8bd5\u6307\u4ee4\u3002 2 \u5982\u679c\u4e3b\u7ebf\u7a0b\u9677\u5165\u6b7b\u5faa\u73af\uff0c\u6211\u4eec\u5c31\u65e0\u6cd5\u5b9e\u65f6\u6293\u53d6\u8fdb\u7a0b\u7684profile\u6570\u636e\u6765\u5206\u6790\u539f\u56e0\u3002 \u63a5\u7740\u7ee7\u7eed\u770b\u4e00\u4e0b\u5b50\u7ebf\u7a0b\u91cc\u6267\u884cInspectorIo::ThreadMain\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void InspectorIo::ThreadMain ( void * io ) { static_cast < InspectorIo *> ( io ) -> ThreadMain (); } void InspectorIo::ThreadMain () { uv_loop_t loop ; loop . data = nullptr ; // \u5728\u5b50\u7ebf\u7a0b\u5f00\u542f\u4e00\u4e2a\u65b0\u7684\u4e8b\u4ef6\u5faa\u73af int err = uv_loop_init ( & loop ); std :: shared_ptr < RequestQueueData > queue ( new RequestQueueData ( & loop ), ...); // \u65b0\u5efa\u4e00\u4e2adelegate\uff0c\u7528\u4e8e\u5904\u7406\u8bf7\u6c42 std :: unique_ptr < InspectorIoDelegate > delegate ( new InspectorIoDelegate ( queue , main_thread_ , ...) ); InspectorSocketServer server ( std :: move ( delegate ), ...); server . Start () uv_run ( & loop , UV_RUN_DEFAULT ); } ThreadMain\u91cc\u4e3b\u8981\u4e09\u4e2a\u903b\u8f91 1 \u521b\u5efa\u4e00\u4e2adelegate\u5bf9\u8c61\uff0c\u8be5\u5bf9\u8c61\u662f\u6838\u5fc3\u7684\u5bf9\u8c61\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u770b\u5230\u6709\u4ec0\u4e48\u4f5c\u7528\u3002 2 \u521b\u5efa\u4e00\u4e2a\u670d\u52a1\u5668\u5e76\u542f\u52a8\u3002 3 \u5f00\u542f\u4e8b\u4ef6\u5faa\u73af\u3002 \u63a5\u4e0b\u6765\u770b\u4e00\u4e0b\u670d\u52a1\u5668\u7684\u903b\u8f91\uff0c\u9996\u5148\u770b\u4e00\u4e0b\u521b\u5efa\u670d\u52a1\u5668\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 InspectorSocketServer :: InspectorSocketServer ( std :: unique_ptr < SocketServerDelegate > delegate , ...) : // \u4fdd\u5b58delegate delegate_ ( std :: move ( delegate )), // \u521d\u59cb\u5316sessionId next_session_id_ ( 0 ) { // \u8bbe\u7f6edelegate\u7684server\u4e3a\u5f53\u524d\u670d\u52a1\u5668 delegate_ -> AssignServer ( this ); } \u6267\u884c\u5b8c\u540e\u5f62\u6210\u4ee5\u4e0b\u7ed3\u6784\u3002 \u63a5\u7740\u6211\u4eec\u770b\u542f\u52a8\u670d\u52a1\u5668\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bool InspectorSocketServer::Start () { // DNS\u89e3\u6790,\u6bd4\u5982\u8f93\u5165\u7684\u662flocalhost struct addrinfo hints ; memset ( & hints , 0 , sizeof ( hints )); hints . ai_flags = AI_NUMERICSERV ; hints . ai_socktype = SOCK_STREAM ; uv_getaddrinfo_t req ; const std :: string port_string = std :: to_string ( port_ ); uv_getaddrinfo ( loop_ , & req , nullptr , host_ . c_str (), port_string . c_str (), & hints ); // \u76d1\u542c\u89e3\u6790\u5230\u7684ip\u5217\u8868 for ( addrinfo * address = req . addrinfo ; address != nullptr ; address = address -> ai_next ) { auto server_socket = ServerSocketPtr ( new ServerSocket ( this )); err = server_socket -> Listen ( address -> ai_addr , loop_ ); if ( err == 0 ) server_sockets_ . push_back ( std :: move ( server_socket )); } return true ; } \u9996\u5148\u6839\u636e\u53c2\u6570\u505a\u4e00\u4e2aDNS\u89e3\u6790\uff0c\u7136\u540e\u6839\u636e\u62ff\u5230\u7684ip\u5217\u8868\uff08\u901a\u5e38\u662f\u4e00\u4e2a\uff09\uff0c\u521b\u5efa\u5bf9\u5e94\u4e2a\u6570\u7684ServerSocket\u5bf9\u8c61\uff0c\u5e76\u6267\u884c\u4ed6\u7684Listen\u65b9\u6cd5\u3002ServerSocket\u8868\u793a\u4e00\u4e2a\u76d1\u542csocket\u3002\u770b\u4e00\u4e0bServerSocket\u7684\u6784\u9020\u51fd\u6570\u3002 1 2 ServerSocket ( InspectorSocketServer * server ) : tcp_socket_ ( uv_tcp_t ()), server_ ( server ) {} \u6267\u884c\u5b8c\u540e\u7ed3\u6784\u5982\u4e0b\u3002 \u63a5\u7740\u770b\u4e00\u4e0bServerSocket\u7684Listen\u65b9\u6cd5\u3002 1 2 3 4 5 6 7 8 int ServerSocket::Listen ( sockaddr * addr , uv_loop_t * loop ) { uv_tcp_t * server = & tcp_socket_ ; uv_tcp_init ( loop , server ) uv_tcp_bind ( server , addr , 0 ); uv_listen ( reinterpret_cast < uv_stream_t *> ( server ), 511 , ServerSocket :: SocketConnectedCallback ); } Listen\u8c03\u7528Libuv\u7684\u63a5\u53e3\u5b8c\u6210\u670d\u52a1\u5668\u7684\u542f\u52a8\u3002\u81f3\u6b64\uff0cInspector\u63d0\u4f9b\u7684Weboscket\u670d\u52a1\u5668\u542f\u52a8\u4e86\u3002","title":"3.2.1 \u521d\u59cb\u5316"},{"location":"chapter24-Inspector/#322","text":"\u4ece\u521a\u624d\u5206\u6790\u4e2d\u53ef\u4ee5\u770b\u5230\uff0c\u5f53\u6709\u8fde\u63a5\u5230\u6765\u65f6\u6267\u884c\u56de\u8c03ServerSocket::SocketConnectedCallback\u3002 1 2 3 4 5 6 7 8 9 void ServerSocket::SocketConnectedCallback ( uv_stream_t * tcp_socket , int status ) { if ( status == 0 ) { // \u6839\u636eLibuv handle\u627e\u5230\u5bf9\u5e94\u7684ServerSocket\u5bf9\u8c61 ServerSocket * server_socket = ServerSocket :: FromTcpSocket ( tcp_socket ); // Socket\u5bf9\u8c61\u7684server_\u5b57\u6bb5\u4fdd\u5b58\u4e86\u6240\u5728\u7684InspectorSocketServer server_socket -> server_ -> Accept ( server_socket -> port_ , tcp_socket ); } } \u63a5\u7740\u770bInspectorSocketServer\u7684Accept\u662f\u5982\u4f55\u5904\u7406\u8fde\u63a5\u7684\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void InspectorSocketServer::Accept ( int server_port , uv_stream_t * server_socket ) { std :: unique_ptr < SocketSession > session ( new SocketSession ( this , next_session_id_ ++ , server_port ) ); InspectorSocket :: DelegatePointer delegate = InspectorSocket :: DelegatePointer ( new SocketSession :: Delegate ( this , session -> id ()) ); InspectorSocket :: Pointer inspector = InspectorSocket :: Accept ( server_socket , std :: move ( delegate )); if ( inspector ) { session -> Own ( std :: move ( inspector )); connected_sessions_ [ session -> id ()]. second = std :: move ( session ); } } Accept\u7684\u9996\u5148\u521b\u5efa\u91cc\u4e00\u4e2aSocketSession\u548cSocketSession::Delegate\u5bf9\u8c61\u3002\u7136\u540e\u8c03\u7528InspectorSocket::Accept\uff0c\u4ece\u4ee3\u7801\u4e2d\u53ef\u4ee5\u770b\u5230InspectorSocket::Accept\u4f1a\u8fd4\u56de\u4e00\u4e2aInspectorSocket\u5bf9\u8c61\u3002InspectorSocket\u662f\u5bf9\u901a\u4fe1socket\u7684\u5c01\u88c5\uff08\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684socket\uff0c\u533a\u522b\u4e8e\u670d\u52a1\u5668\u7684\u76d1\u542csocket\uff09\u3002\u7136\u540e\u8bb0\u5f55session\u5bf9\u8c61\u5bf9\u5e94\u7684InspectorSocket\u5bf9\u8c61\uff0c\u540c\u65f6\u8bb0\u5f55sessionId\u548csession\u7684\u6620\u5c04\u5173\u7cfb\u3002\u7ed3\u6784\u5982\u4e0b\u56fe\u6240\u793a\u3002 \u63a5\u7740\u770b\u4e00\u4e0bInspectorSocket::Accept\u8fd4\u56deInspectorSocket\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 InspectorSocket :: Pointer InspectorSocket::Accept ( uv_stream_t * server , DelegatePointer delegate ) { auto tcp = TcpHolder :: Accept ( server , std :: move ( delegate )); InspectorSocket * inspector = new InspectorSocket (); inspector -> SwitchProtocol ( new HttpHandler ( inspector , std :: move ( tcp ))); return InspectorSocket :: Pointer ( inspector ); } InspectorSocket::Accept\u7684\u4ee3\u7801\u4e0d\u591a\uff0c\u4f46\u662f\u903b\u8f91\u8fd8\u662f\u633a\u591a\u7684\u3002 1 InspectorSocket::Accept\u518d\u6b21\u8c03\u7528TcpHolder::Accept\u83b7\u5f97\u4e00\u4e2aTcpHolder\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 TcpHolder :: Pointer TcpHolder::Accept ( uv_stream_t * server , InspectorSocket :: DelegatePointer delegate ) { // \u65b0\u5efa\u4e00\u4e2aTcpHolder\u5bf9\u8c61\uff0cTcpHolder\u662f\u5bf9uv_tcp_t\u548cdelegate\u7684\u5c01\u88c5 TcpHolder * result = new TcpHolder ( std :: move ( delegate )); // \u62ff\u5230TcpHolder\u5bf9\u8c61\u7684uv_tcp_t\u7ed3\u6784\u4f53 uv_stream_t * tcp = reinterpret_cast < uv_stream_t *> ( & result -> tcp_ ); // \u521d\u59cb\u5316 int err = uv_tcp_init ( server -> loop , & result -> tcp_ ); // \u6458\u53d6\u4e00\u4e2aTCP\u8fde\u63a5\u5bf9\u5e94\u7684fd\u4fdd\u5b58\u5230TcpHolder\u7684uv_tcp_t\u7ed3\u6784\u4f53\u4e2d\uff08\u5373\u7b2c\u4e8c\u4e2a\u53c2\u6570\u7684tcp\u5b57\u6bb5\uff09 uv_accept ( server , tcp ); // \u6ce8\u518c\u7b49\u5f85\u53ef\u8bfb\u4e8b\u4ef6\uff0c\u6709\u6570\u636e\u65f6\u6267\u884cOnDataReceivedCb\u56de\u8c03 uv_read_start ( tcp , allocate_buffer , OnDataReceivedCb ); return TcpHolder :: Pointer ( result ); } 2 \u65b0\u5efa\u4e00\u4e2aHttpHandler\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 explicit HttpHandler ( InspectorSocket * inspector , TcpHolder :: Pointer tcp ) : ProtocolHandler ( inspector , std :: move ( tcp )){ llhttp_init ( & parser_ , HTTP_REQUEST , & parser_settings ); llhttp_settings_init ( & parser_settings ); parser_settings . on_header_field = OnHeaderField ; parser_settings . on_header_value = OnHeaderValue ; parser_settings . on_message_complete = OnMessageComplete ; parser_settings . on_url = OnPath ; } ProtocolHandler :: ProtocolHandler ( InspectorSocket * inspector , TcpHolder :: Pointer tcp ) : inspector_ ( inspector ), tcp_ ( std :: move ( tcp )) { // \u8bbe\u7f6eTCP\u6570\u636e\u7684handler\uff0cTCP\u662f\u53ea\u8d1f\u8d23\u4f20\u8f93\uff0c\u6570\u636e\u7684\u89e3\u6790\u4ea4\u7ed9handler\u5904\u7406 tcp_ -> SetHandler ( this ); } HttpHandler\u662f\u5bf9uv_tcp_t\u7684\u5c01\u88c5\uff0c\u4e3b\u8981\u901a\u8fc7HTTP\u89e3\u6790\u5668llhttp\u5bf9HTTP\u534f\u8bae\u8fdb\u884c\u89e3\u6790\u3002 3 \u8c03\u7528inspector->SwitchProtocol()\u5207\u6362\u5f53\u524d\u534f\u8bae\u4e3aHTTP\uff0c\u5efa\u7acbTCP\u8fde\u63a5\u540e\uff0c\u9996\u5148\u8981\u7ecf\u8fc7\u4e00\u4e2aHTTP\u8bf7\u6c42\u4eceHTTP\u534f\u8bae\u5347\u7ea7\u5230WebSocket\u534f\u8bae\uff0c\u5347\u7ea7\u6210\u529f\u540e\u5c31\u4f7f\u7528Websocket\u534f\u8bae\u8fdb\u884c\u901a\u4fe1\u3002 \u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u65f6\u5019\u7684\u7ed3\u6784\u56fe\u3002 \u81f3\u6b64\uff0c\u5c31\u5b8c\u6210\u4e86\u8fde\u63a5\u5904\u7406\u7684\u5206\u6790\u3002","title":"3.2.2 \u5904\u7406\u8fde\u63a5"},{"location":"chapter24-Inspector/#323","text":"\u5b8c\u6210\u4e86TCP\u8fde\u63a5\u7684\u5904\u7406\u540e\uff0c\u63a5\u4e0b\u6765\u8981\u5b8c\u6210\u534f\u8bae\u5347\u7ea7\uff0c\u56e0\u4e3aInspector\u662f\u901a\u8fc7WebSocket\u534f\u8bae\u548c\u5ba2\u6237\u7aef\u901a\u4fe1\u7684\uff0c\u6240\u4ee5\u9700\u8981\u901a\u8fc7\u4e00\u4e2aHTTP\u8bf7\u6c42\u6765\u5b8c\u6210HTTP\u5230WebSocekt\u534f\u8bae\u7684\u5347\u7ea7\u3002\u4ece\u521a\u624d\u7684\u5206\u6790\u4e2d\u770b\u5f53\u6709\u6570\u636e\u5230\u6765\u65f6\u4f1a\u6267\u884cOnDataReceivedCb\u56de\u8c03\u3002 1 2 3 4 5 6 7 void TcpHolder::OnDataReceivedCb ( uv_stream_t * tcp , ssize_t nread , const uv_buf_t * buf ) { TcpHolder * holder = From ( tcp ); holder -> ReclaimUvBuf ( buf , nread ); // \u8c03\u7528handler\u7684onData\uff0c\u76ee\u524dhandler\u662fHTTP\u534f\u8bae holder -> handler_ -> OnData ( & holder -> buffer ); } TCP\u5c42\u6536\u5230\u6570\u636e\u540e\u4ea4\u7ed9\u5e94\u7528\u5c42\u89e3\u6790\uff0c\u76f4\u63a5\u8c03\u7528\u4e0a\u5c42\u7684OnData\u56de\u8c03\u3002 1 2 3 4 5 6 void OnData ( std :: vector < char >* data ) override { // \u89e3\u6790HTTP\u534f\u8bae llhttp_execute ( & parser_ , data -> data (), data -> size ()); // \u89e3\u6790\u5b8c\u5e76\u4e14\u662f\u5347\u7ea7\u534f\u8bae\u7684\u8bf7\u6c42\u5219\u8c03\u7528delegate\u7684\u56de\u8c03OnSocketUpgrade delegate () -> OnSocketUpgrade ( event . host , event . path , event . ws_key ); } OnData\u53ef\u80fd\u4f1a\u88ab\u591a\u6b21\u56de\u8c03\uff0c\u5e76\u901a\u8fc7llhttp_execute\u89e3\u6790\u6536\u5230\u7684HTTP\u62a5\u6587\uff0c\u5f53\u53d1\u73b0\u662f\u4e00\u4e2a\u534f\u8bae\u5347\u7ea7\u7684\u8bf7\u6c42\u540e\uff0c\u5c31\u8c03\u7528OnSocketUpgrade\u56de\u8c03\u3002delegate\u662fTCP\u5c42\u4fdd\u5b58\u7684SocketSession::Delegate\u5bf9\u8c61\u3002\u6765\u770b\u4e00\u4e0b\u8be5\u5bf9\u8c61\u7684OnSocketUpgrade\u65b9\u6cd5\u3002 1 2 3 4 5 6 void SocketSession::Delegate::OnSocketUpgrade ( const std :: string & host , const std :: string & path , const std :: string & ws_key ) { std :: string id = path . empty () ? path : path . substr ( 1 ); server_ -> SessionStarted ( session_id_ , id , ws_key ); } OnSocketUpgrade\u53c8\u8c03\u7528\u6765server_\uff08InspectorSocketServer\u5bf9\u8c61\uff09\u7684SessionStarted\u3002 1 2 3 4 5 6 7 8 9 void InspectorSocketServer::SessionStarted ( int session_id , const std :: string & id , const std :: string & ws_key ) { // \u627e\u5230\u5bf9\u5e94\u7684session\u5bf9\u8c61 SocketSession * session = Session ( session_id ); connected_sessions_ [ session_id ]. first = id ; session -> Accept ( ws_key ); delegate_ -> StartSession ( session_id , id ); } \u9996\u5148\u901a\u8fc7session_id\u627e\u5230\u5efa\u7acbTCP\u8fde\u63a5\u65f6\u5206\u914d\u7684SocketSession\u5bf9\u8c61\u3002 1 \u6267\u884csession->Accept(ws_key);\u56de\u590d\u5ba2\u6237\u7aef\u540c\u610f\u534f\u8bae\u5347\u7ea7\u3002 1 2 3 void Accept ( const std :: string & ws_key ) { ws_socket_ -> AcceptUpgrade ( ws_key ); } \u4ece\u7ed3\u6784\u56fe\u6211\u4eec\u53ef\u4ee5\u770b\u5230ws_socket_\u662f\u4e00\u4e2aInspectorSocket\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 void AcceptUpgrade ( const std :: string & accept_key ) override { char accept_string [ ACCEPT_KEY_LENGTH ]; generate_accept_string ( accept_key , & accept_string ); const char accept_ws_prefix [] = \"HTTP/1.1 101 Switching Protocols \\r\\n \" \"Upgrade: websocket \\r\\n \" \"Connection: Upgrade \\r\\n \" \"Sec-WebSocket-Accept: \" ; const char accept_ws_suffix [] = \" \\r\\n\\r\\n \" ; std :: vector < char > reply ( accept_ws_prefix , accept_ws_prefix + sizeof ( accept_ws_prefix ) - 1 ); reply . insert ( reply . end (), accept_string , accept_string + sizeof ( accept_string )); reply . insert ( reply . end (), accept_ws_suffix , accept_ws_suffix + sizeof ( accept_ws_suffix ) - 1 ); // \u56de\u590d101\u7ed9\u5ba2\u6237\u7aef WriteRaw ( reply , WriteRequest :: Cleanup ); // \u5207\u6362handler\u4e3aWebSocket handler inspector_ -> SwitchProtocol ( new WsHandler ( inspector_ , std :: move ( tcp_ ))); } AcceptUpgradeh\u9996\u5148\u56de\u590d\u5ba2\u6237\u7aef101\u8868\u793a\u540c\u610f\u5347\u7ea7\u9053WebSocket\u534f\u8bae\uff0c\u7136\u540e\u5207\u6362\u6570\u636e\u5904\u7406\u5668\u4e3aWsHandler\uff0c\u5373\u540e\u7eed\u7684\u6570\u636e\u6309\u7167WebSocket\u534f\u8bae\u5904\u7406\u3002 2 \u6267\u884cdelegate_->StartSession(session_id, id)\u5efa\u7acb\u548cV8 Inspector\u7684\u4f1a\u8bdd\u3002delegate_\u662fInspectorIoDelegate\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 void InspectorIoDelegate::StartSession ( int session_id , const std :: string & target_id ) { auto session = main_thread_ -> Connect ( std :: unique_ptr < InspectorSessionDelegate > ( new IoSessionDelegate ( request_queue_ -> handle (), session_id ) ), true ); if ( session ) { sessions_ [ session_id ] = std :: move ( session ); fprintf ( stderr , \"Debugger attached. \\n \" ); } } \u9996\u5148\u901a\u8fc7main_thread_->Connect\u62ff\u5230\u4e00\u4e2asession\uff0c\u5e76\u5728InspectorIoDelegate\u4e2d\u8bb0\u5f55\u6620\u5c04\u5173\u7cfb\u3002\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u63a5\u4e0b\u6765\u770b\u4e00\u4e0bmain_thread_->Connect\u7684\u903b\u8f91\uff08main_thread_\u662fMainThreadHandle\u5bf9\u8c61\uff09\u3002 1 2 3 4 5 6 7 8 9 10 std :: unique_ptr < InspectorSession > MainThreadHandle :: Connect ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { return std :: unique_ptr < InspectorSession > ( new CrossThreadInspectorSession ( ++ next_session_id_ , shared_from_this (), std :: move ( delegate ), prevent_shutdown )); } Connect\u51fd\u6570\u65b0\u5efa\u4e86\u4e00\u4e2aCrossThreadInspectorSession\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 CrossThreadInspectorSession ( int id , std :: shared_ptr < MainThreadHandle > thread , std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) // \u521b\u5efa\u4e00\u4e2aMainThreadSessionState\u5bf9\u8c61 : state_ ( thread , std :: bind ( MainThreadSessionState :: Create , std :: placeholders :: _1 , prevent_shutdown )) { // \u6267\u884cMainThreadSessionState::Connect state_ . Call ( & MainThreadSessionState :: Connect , std :: move ( delegate )); } \u7ee7\u7eed\u770bMainThreadSessionState::Connect\u3002 1 2 3 4 void Connect ( std :: unique_ptr < InspectorSessionDelegate > delegate ) { Agent * agent = thread_ -> inspector_agent (); session_ = agent -> Connect ( std :: move ( delegate ), prevent_shutdown_ ); } \u7ee7\u7eed\u8c03agent->Connect\u3002 1 2 3 4 5 6 7 8 9 std :: unique_ptr < InspectorSession > Agent :: Connect ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { int session_id = client_ -> connectFrontend ( std :: move ( delegate ), prevent_shutdown ); return std :: unique_ptr < InspectorSession > ( new SameThreadInspectorSession ( session_id , client_ )); } \u7ee7\u7eed\u8c03connectFrontend 1 2 3 4 5 6 7 8 9 10 11 int connectFrontend ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { int session_id = next_session_id_ ++ ; channels_ [ session_id ] = std :: make_unique < ChannelImpl > ( env_ , client_ , getWorkerManager (), std :: move ( delegate ), getThreadHandle (), prevent_shutdown ); return session_id ; } connectFrontend\u521b\u5efa\u4e86\u4e00\u4e2aChannelImpl\u5e76\u4e14\u5728channels_\u4e2d\u4fdd\u5b58\u4e86\u6620\u5c04\u5173\u7cfb\u3002\u770b\u770bChannelImpl\u7684\u6784\u9020\u51fd\u6570\u3002 1 2 3 4 5 6 7 explicit ChannelImpl ( Environment * env , const std :: unique_ptr < V8Inspector >& inspector , std :: unique_ptr < InspectorSessionDelegate > delegate , ...) : delegate_ ( std :: move ( delegate )) { session_ = inspector -> connect ( CONTEXT_GROUP_ID , this , StringView ()); } ChannelImpl\u8c03\u7528inspector->connect\u5efa\u7acb\u4e86\u4e00\u4e2a\u548cV8 Inspector\u7684\u4f1a\u8bdd\u3002\u7ed3\u6784\u56fe\u5927\u81f4\u5982\u4e0b\u3002","title":"3.2.3 \u534f\u8bae\u5347\u7ea7"},{"location":"chapter24-Inspector/#324-v8-inspector","text":"TCP\u8fde\u63a5\u5efa\u7acb\u4e86\uff0c\u534f\u8bae\u5347\u7ea7\u4e5f\u5b8c\u6210\u4e86\uff0c\u63a5\u4e0b\u6765\u5c31\u53ef\u4ee5\u5f00\u59cb\u5904\u7406\u4e1a\u52a1\u6570\u636e\u3002\u4ece\u524d\u9762\u7684\u5206\u6790\u4e2d\u6211\u4eec\u5df2\u7ecf\u77e5\u9053\u6570\u636e\u5230\u6765\u65f6\u4f1a\u6267\u884cTcpHoldler\u7684handler_->OnData\u56de\u8c03\u3002\u56e0\u4e3a\u5df2\u7ecf\u5b8c\u6210\u4e86\u534f\u8bae\u5347\u7ea7\uff0c\u6240\u4ee5\u8fd9\u65f6\u5019\u7684handler\u53d8\u6210\u4e86WeSocket handler\u3002 1 2 3 4 5 6 7 8 9 10 11 void OnData ( std :: vector < char >* data ) override { // 1. Parse. int processed = 0 ; do { processed = ParseWsFrames ( * data ); // 2. Fix the data size & length if ( processed > 0 ) { remove_from_beginning ( data , processed ); } } while ( processed > 0 && ! data -> empty ()); } OnData\u901a\u8fc7ParseWsFrames\u89e3\u6790WebSocket\u534f\u8bae\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 int ParseWsFrames ( const std :: vector < char >& buffer ) { int bytes_consumed = 0 ; std :: vector < char > output ; bool compressed = false ; // \u89e3\u6790WebSocket\u534f\u8bae ws_decode_result r = decode_frame_hybi17 ( buffer , true /* client_frame */ , & bytes_consumed , & output , & compressed ); // \u6267\u884cdelegate\u7684\u56de\u8c03 delegate () -> OnWsFrame ( output ); return bytes_consumed ; } \u524d\u9762\u5df2\u7ecf\u5206\u6790\u8fc7delegate\u662fTcpHoldler\u7684delegate\uff0c\u5373SocketSession::Delegate\u5bf9\u8c61\u3002 1 2 3 4 5 void SocketSession::Delegate::OnWsFrame ( const std :: vector < char >& data ) { server_ -> MessageReceived ( session_id_ , std :: string ( data . data (), data . size ())); } \u7ee7\u7eed\u56de\u8c03server_->MessageReceived\u3002\u4ece\u7ed3\u6784\u56fe\u53ef\u4ee5\u770b\u5230server_\u662fInspectorSocketServer\u5bf9\u8c61\u3002 1 2 3 void MessageReceived ( int session_id , const std :: string & message ) { delegate_ -> MessageReceived ( session_id , message ); } \u7ee7\u7eed\u56de\u8c03delegate_->MessageReceived\u3002InspectorSocketServer\u7684delegate_\u662fInspectorIoDelegate\u5bf9\u8c61\u3002 1 2 3 4 5 6 void InspectorIoDelegate::MessageReceived ( int session_id , const std :: string & message ) { auto session = sessions_ . find ( session_id ); if ( session != sessions_ . end ()) session -> second -> Dispatch ( Utf8ToStringView ( message ) -> string ()); } \u9996\u5148\u901a\u8fc7session_id\u627e\u5230\u5bf9\u5e94\u7684session\u3002session\u662f\u4e00\u4e2aCrossThreadInspectorSession\u5bf9\u8c61\u3002\u770b\u770b\u4ed6\u7684Dispatch\u65b9\u6cd5\u3002 1 2 3 4 void Dispatch ( const StringView & message ) override { state_ . Call ( & MainThreadSessionState :: Dispatch , StringBuffer :: create ( message )); } \u6267\u884cMainThreadSessionState::Dispatch\u3002 1 2 3 void Dispatch ( std :: unique_ptr < StringBuffer > message ) { session_ -> Dispatch ( message -> string ()); } session_\u662fSameThreadInspectorSession\u5bf9\u8c61\u3002 1 2 3 4 5 6 void SameThreadInspectorSession::Dispatch ( const v8_inspector :: StringView & message ) { auto client = client_ . lock (); if ( client ) client -> dispatchMessageFromFrontend ( session_id_ , message ); } \u7ee7\u7eed\u8c03client->dispatchMessageFromFrontend\u3002 1 2 3 void dispatchMessageFromFrontend ( int session_id , const StringView & message ) { channels_ [ session_id ] -> dispatchProtocolMessage ( message ); } \u901a\u8fc7session_id\u627e\u5230\u5bf9\u5e94\u7684ChannelImpl\uff0c\u7ee7\u7eed\u8c03ChannelImpl\u7684dispatchProtocolMessage\u3002 1 2 3 voiddispatchProtocolMessage ( const StringView & message ) { session_ -> dispatchProtocolMessage ( message ); } \u6700\u7ec8\u8c03\u7528\u548cV8 Inspector\u7684\u4f1a\u8bdd\u5bf9\u8c61\u628a\u6570\u636e\u53d1\u9001\u7ed9V8\u3002\u81f3\u6b64\u5ba2\u6237\u7aef\u5230V8 Inspector\u7684\u901a\u4fe1\u8fc7\u7a0b\u5c31\u5b8c\u6210\u4e86\u3002","title":"3.2.4 \u5ba2\u6237\u7aef\u5230V8 Inspector\u7684\u6570\u636e\u5904\u7406"},{"location":"chapter24-Inspector/#325-v8-inspector","text":"\u63a5\u7740\u770b\u4eceV8 inspector\u5230\u5ba2\u6237\u7aef\u7684\u6570\u636e\u4f20\u9012\u903b\u8f91\u3002V8 inspector\u662f\u901a\u8fc7channel\u7684sendResponse\u51fd\u6570\u4f20\u9012\u7ed9\u5ba2\u6237\u7aef\u7684\u3002 1 2 3 4 5 6 7 8 9 10 void sendResponse ( int callId , std :: unique_ptr < v8_inspector :: StringBuffer > message ) override { sendMessageToFrontend ( message -> string ()); } void sendMessageToFrontend ( const StringView & message ) { delegate_ -> SendMessageToFrontend ( message ); } delegate_\u662fIoSessionDelegate\u5bf9\u8c61\u3002 1 2 3 4 void SendMessageToFrontend ( const v8_inspector :: StringView & message ) override { request_queue_ -> Post ( id_ , TransportAction :: kSendMessage , StringBuffer :: create ( message )); } request_queue_\u662fRequestQueueData\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 void Post ( int session_id , TransportAction action , std :: unique_ptr < StringBuffer > message ) { Mutex :: ScopedLock scoped_lock ( state_lock_ ); bool notify = messages_ . empty (); messages_ . emplace_back ( action , session_id , std :: move ( message )); if ( notify ) { CHECK_EQ ( 0 , uv_async_send ( & async_ )); incoming_message_cond_ . Broadcast ( scoped_lock ); } } Post\u9996\u5148\u628a\u6d88\u606f\u5165\u961f\uff0c\u7136\u540e\u901a\u8fc7\u5f02\u6b65\u7684\u65b9\u5f0f\u901a\u77e5async_\u63a5\u7740\u770basync_\u7684\u5904\u7406\u51fd\u6570\uff08\u5728\u5b50\u7ebf\u7a0b\u7684\u4e8b\u4ef6\u5faa\u73af\u91cc\u6267\u884c\uff09\u3002 1 2 3 4 5 6 uv_async_init ( loop , & async_ , []( uv_async_t * async ) { // \u62ff\u5230async\u5bf9\u5e94\u7684\u4e0a\u4e0b\u6587 RequestQueueData * wrapper = node :: ContainerOf ( & RequestQueueData :: async_ , async ); // \u6267\u884cRequestQueueData\u7684DoDispatch wrapper -> DoDispatch (); }); 1 2 3 4 5 void DoDispatch () { for ( const auto & request : GetMessages ()) { request . Dispatch ( server_ ); } } request\u662fRequestToServer\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 void Dispatch ( InspectorSocketServer * server ) const { switch ( action_ ) { case TransportAction :: kSendMessage : server -> Send ( session_id_ , protocol :: StringUtil :: StringViewToUtf8 ( message_ -> string ())); break ; } } \u63a5\u7740\u770bInspectorSocketServer\u7684Send\u3002 1 2 3 4 5 6 void InspectorSocketServer::Send ( int session_id , const std :: string & message ) { SocketSession * session = Session ( session_id ); if ( session != nullptr ) { session -> Send ( message ); } } session\u4ee3\u8868\u53ef\u5ba2\u6237\u7aef\u7684\u4e00\u4e2a\u8fde\u63a5\u3002 1 2 3 void SocketSession::Send ( const std :: string & message ) { ws_socket_ -> Write ( message . data (), message . length ()); } \u63a5\u7740\u8c03\u7528WebSocket handler\u7684Write\u3002 1 2 3 4 void Write ( const std :: vector < char > data ) override { std :: vector < char > output = encode_frame_hybi17 ( data ); WriteRaw ( output , WriteRequest :: Cleanup ); } WriteRaw\u662f\u57fa\u7c7bProtocolHandler\u5b9e\u73b0\u7684\u3002 1 2 3 4 int ProtocolHandler::WriteRaw ( const std :: vector < char >& buffer , uv_write_cb write_cb ) { return tcp_ -> WriteRaw ( buffer , write_cb ); } \u6700\u7ec8\u662f\u901a\u8fc7TCP\u8fde\u63a5\u8fd4\u56de\u7ed9\u5ba2\u6237\u7aef\u3002 1 2 3 4 5 6 7 8 9 int TcpHolder::WriteRaw ( const std :: vector < char >& buffer , uv_write_cb write_cb ) { // Freed in write_request_cleanup WriteRequest * wr = new WriteRequest ( handler_ , buffer ); uv_stream_t * stream = reinterpret_cast < uv_stream_t *> ( & tcp_ ); int err = uv_write ( & wr -> req , stream , & wr -> buf , 1 , write_cb ); if ( err < 0 ) delete wr ; return err < 0 ; } \u65b0\u5efa\u4e00\u4e2a\u5199\u8bf7\u6c42\uff0csocket\u53ef\u5199\u7684\u65f6\u5019\u53d1\u9001\u6570\u636e\u7ed9\u5ba2\u6237\u7aef\u3002","title":"3.2.5 V8 Inspector\u5230\u5ba2\u6237\u7aef\u7684\u6570\u636e\u5904\u7406"},{"location":"chapter24-Inspector/#4-inspector","text":"\u9ed8\u8ba4\u6253\u5f00Inspector\u80fd\u529b\u662f\u4e0d\u5b89\u5168\u7684\uff0c\u8fd9\u610f\u5473\u7740\u80fd\u8fde\u4e0awebsocket\u670d\u52a1\u5668\u7684\u5ba2\u6237\u7aef\u90fd\u80fd\u901a\u8fc7\u534f\u8bae\u63a7\u5236Node.js\u8fdb\u7a0b\uff0c\u901a\u5e38\u6211\u4eec\u662f\u5728Node.js\u8fdb\u7a0b\u51fa\u73b0\u95ee\u9898\u7684\u65f6\u5019\uff0c\u52a8\u6001\u5f00\u542fInspector\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const http = require ( 'http' ); const inspector = require ( 'inspector' ); const fs = require ( 'fs' ); http . createServer (( req , res ) => { if ( req . url == 'debug' ) { const session = new inspector . Session (); session . connect (); session . post ( 'Profiler.enable' , () => { session . post ( 'Profiler.start' , () => { session . post ( 'Profiler.stop' , ( err , { profile }) => { if ( ! err ) { fs . writeFileSync ( './profile.cpuprofile' , JSON . stringify ( profile )); } session . disconnect (); res . end ( 'ok' ); }); }); }); } else { res . end ( 'ok' ); } }). listen ( 80 ); \u6211\u4eec\u53ef\u4ee5\u901a\u8fc7url\u53c2\u6570\u63a7\u5236Inspector\u7684\u80fd\u529b\uff0c\u672c\u5730\u8c03\u8bd5\u65f6\u53ef\u4ee5\u5728vscode\u91cc\u53ef\u4ee5\u76f4\u63a5\u770b\u5230\u6570\u636e\u3002","title":"4 \u52a8\u6001\u5f00\u542fInspector"},{"location":"chapter24-Inspector/#5","text":"V8 inspector\u662f\u4e00\u4e2a\u975e\u5e38\u5f3a\u5927\u7684\u5de5\u5177\uff0c\u8c03\u8bd5\u53ea\u662f\u5b83\u5176\u4e2d\u4e00\u4e2a\u80fd\u529b\uff0c\u4ed6\u8fd8\u53ef\u4ee5\u83b7\u53d6\u5185\u5b58\u3001CPU\u7b49\u6570\u636e\uff0c\u5177\u4f53\u80fd\u529b\u8bf7\u53c2\u8003\u6587\u6863\u3002 \u540e\u8bb0\uff1aNode.js\u7684inspector\u662f\u5728Node.js\u989d\u5916\u7ebf\u7a0b\u91cc\u5f00\u542f\u7684\u4e00\u4e2a\u975e\u5e38\u5f3a\u5927\u7684\u5de5\u5177\uff0c\u901a\u8fc7Node.js\u4f5c\u4e3a\u4e2d\u95f4\u4eba\uff0c\u5b8c\u6210\u5ba2\u6237\u7aef\u548cV8 inspector\u7684\u901a\u4fe1\uff08\u8c03\u8bd5\u3001\u6536\u96c6\u6570\u636e\uff09\uff0c\u662f\u6211\u4eec\u8c03\u8bd5\u548c\u8bca\u65adNode.js\u8fdb\u7a0b\u975e\u5e38\u597d\u7684\u65b9\u5f0f\u3002 \u53c2\u8003\u5185\u5bb9\uff1a 1 Debugging Guide 2 inspector 3 \u5f00\u6e90\u7684inspector agent\u5b9e\u73b0 4 inpector\u534f\u8bae\u6587\u6863 5 Debugging Node.js with Chrome DevTools","title":"5 \u6536\u96c6\u6570\u636e"},{"location":"chapter25-Node.js%E5%AD%90%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95%E5%92%8C%E8%AF%8A%E6%96%AD%E6%8C%87%E5%8D%97/","text":"\u8c03\u8bd5\u3001\u8bca\u65ad\u5b50\u7ebf\u7a0b\u6700\u76f4\u63a5\u7684\u65b9\u5f0f\u5c31\u662f\u50cf\u8c03\u8bd5\u3001\u8bca\u65ad\u4e3b\u7ebf\u7a0b\u4e00\u6837\uff0c\u4f46\u662f\u65e0\u8bba\u662f\u52a8\u6001\u5f00\u542f\u8fd8\u662f\u9759\u6001\u5f00\u542f\uff0c\u5b50\u7ebf\u7a0b\u90fd\u4e0d\u53ef\u907f\u514d\u5730\u9700\u8981\u5185\u7f6e\u4e00\u4e9b\u76f8\u5173\u7684\u975e\u4e1a\u52a1\u4ee3\u7801\uff0c\u672c\u6587\u4ecb\u7ecd\u53e6\u5916\u4e00\u79cd\u5bf9\u5b50\u7ebf\u7a0b\u4ee3\u7801\u65e0\u4fb5\u5165\u7684\u8c03\u8bd5\u65b9\u5f0f\uff0c\u53e6\u5916\u4e5f\u4ecb\u7ecd\u4e00\u4e0b\u901a\u8fc7\u5b50\u7ebf\u7a0b\u8c03\u8bd5\u4e3b\u7ebf\u7a0b\u7684\u65b9\u5f0f\u3002 1 \u521d\u59cb\u5316\u5b50\u7ebf\u7a0b\u7684Inspector \u00b6 \u5728Node.js\u542f\u52a8\u5b50\u7ebf\u7a0b\u7684\u65f6\u5019\uff0c\u4f1a\u521d\u59cb\u5316Inspector\u3002 1 env_ -> InitializeInspector ( std :: move ( inspector_parent_handle_ )); \u5728\u5206\u6790InitializeInspector\u4e4b\u524d\uff0c\u6211\u4eec\u5148\u770b\u4e00\u4e0binspector_parent_handle_\u3002 1 std :: unique_ptr < inspector :: ParentInspectorHandle > inspector_parent_handle_ ; inspector_parent_handle_\u662f\u4e00\u4e2aParentInspectorHandle\u5bf9\u8c61\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u662f\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u7684\u6865\u6881\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4ed6\u7684\u521d\u59cb\u5316\u903b\u8f91\uff08\u5728\u4e3b\u7ebf\u7a0b\u91cc\u6267\u884c\uff09\u3002 1 inspector_parent_handle_ = env -> inspector_agent () -> GetParentHandle ( thread_id_ , url ); \u8c03\u7528agent\u7684GetParentHandle\u83b7\u53d6\u4e00\u4e2aParentInspectorHandle\u5bf9\u8c61\u3002 1 2 3 std :: unique_ptr < ParentInspectorHandle > Agent :: GetParentHandle ( int thread_id , const std :: string & url ) { return client_ -> getWorkerManager () -> NewParentHandle ( thread_id , url ); } \u5185\u90e8\u5176\u5b9e\u662f\u901a\u8fc7client_->getWorkerManager()\u5bf9\u8c61\u7684NewParentHandle\u65b9\u6cd5\u83b7\u53d6ParentInspectorHandle\u5bf9\u8c61\uff0c\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0bWorkerManager\u7684NewParentHandle\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 std :: unique_ptr < ParentInspectorHandle > WorkerManager :: NewParentHandle ( int thread_id , const std :: string & url ) { bool wait = ! delegates_waiting_on_start_ . empty (); return std :: make_unique < ParentInspectorHandle > ( thread_id , url , thread_ , wait ); } ParentInspectorHandle :: ParentInspectorHandle ( int id , const std :: string & url , std :: shared_ptr < MainThreadHandle > parent_thread , bool wait_for_connect ) : id_ ( id ), url_ ( url ), parent_thread_ ( parent_thread ), wait_ ( wait_for_connect ) {} \u6700\u7ec8\u7684\u67b6\u6784\u56fe\u5982\u4e0b\u5165\u6240\u793a\u3002 \u5206\u6790\u5b8cParentInspectorHandle\u540e\u7ee7\u7eed\u770b\u4e00\u4e0benv_->InitializeInspector(std::move(inspector_parent_handle_))\u7684\u903b\u8f91\uff08\u5728\u5b50\u7ebf\u7a0b\u91cc\u6267\u884c\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 int Environment::InitializeInspector ( std :: unique_ptr < inspector :: ParentInspectorHandle > parent_handle ) { std :: string inspector_path ; inspector_path = parent_handle -> url (); inspector_agent_ -> SetParentHandle ( std :: move ( parent_handle )); inspector_agent_ -> Start ( inspector_path , options_ -> debug_options (), inspector_host_port (), is_main_thread ()); } \u9996\u5148\u628aParentInspectorHandle\u5bf9\u8c61\u4fdd\u5b58\u5230agent\u4e2d\uff0c\u7136\u540e\u8c03\u7528agent\u7684Start\u65b9\u6cd5\u3002 1 2 3 4 5 6 bool Agent::Start (...) { // \u65b0\u5efaclient\u5bf9\u8c61 client_ = std :: make_shared < NodeInspectorClient > ( parent_env_ , is_main ); // \u8c03\u7528agent\u4e2d\u4fdd\u5b58\u7684ParentInspectorHandle\u5bf9\u8c61\u7684WorkerStarted parent_handle_ -> WorkerStarted ( client_ -> getThreadHandle (), ...); } Agent::Start\u521b\u5efa\u4e86\u4e00\u4e2aclient\u5bf9\u8c61\uff0c\u7136\u540e\u8c03\u7528ParentInspectorHandle\u5bf9\u8c61\u7684WorkerStarted\u65b9\u6cd5\uff08\u521a\u624dSetParentHandle\u7684\u65f6\u5019\u4fdd\u5b58\u7684\uff09\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u65f6\u5019\u7684\u67b6\u6784\u56fe\u3002 \u63a5\u7740\u770bparent_handle_->WorkerStarted\u3002 1 2 3 4 5 6 void ParentInspectorHandle::WorkerStarted ( std :: shared_ptr < MainThreadHandle > worker_thread , bool waiting ) { std :: unique_ptr < Request > request ( new WorkerStartedRequest ( id_ , url_ , worker_thread , waiting )); parent_thread_ -> Post ( std :: move ( request )); } WorkerStarted\u521b\u5efa\u4e86\u4e00\u4e2aWorkerStartedRequest\u8bf7\u6c42\uff0c\u7136\u540e\u901a\u8fc7parent_thread_->Post\u63d0\u4ea4\uff0cparent_thread_\u662fMainThreadInterface\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void MainThreadInterface::Post ( std :: unique_ptr < Request > request ) { Mutex :: ScopedLock scoped_lock ( requests_lock_ ); // \u4e4b\u524d\u662f\u7a7a\u5219\u9700\u8981\u5524\u9192\u6d88\u8d39\u8005 bool needs_notify = requests_ . empty (); // \u6d88\u606f\u5165\u961f requests_ . push_back ( std :: move ( request )); if ( needs_notify ) { // \u83b7\u53d6\u5f53\u524d\u5bf9\u8c61\u7684\u4e00\u4e2a\u5f31\u5f15\u7528 std :: weak_ptr < MainThreadInterface >* interface_ptr = new std :: weak_ptr < MainThreadInterface > ( shared_from_this ()); // \u8bf7\u6c42V8\u6267\u884cRequestInterrupt\u5165\u53c2\u5bf9\u5e94\u7684\u56de\u8c03 isolate_ -> RequestInterrupt ([]( v8 :: Isolate * isolate , void * opaque ) { // \u628a\u6267\u884c\u65f6\u4f20\u5165\u7684\u53c2\u6570\u8f6c\u6210MainThreadInterface std :: unique_ptr < std :: weak_ptr < MainThreadInterface >> interface_ptr { static_cast < std :: weak_ptr < MainThreadInterface >*> ( opaque ) }; // \u5224\u65ad\u5bf9\u8c61\u662f\u5426\u8fd8\u6709\u6548\uff0c\u662f\u5219\u8c03\u7528DispatchMessages if ( auto iface = interface_ptr -> lock ()) iface -> DispatchMessages (); }, static_cast < void *> ( interface_ptr )); } // \u5524\u9192\u6d88\u8d39\u8005 incoming_message_cond_ . Broadcast ( scoped_lock ); } \u6211\u4eec\u770b\u770b\u8fd9\u65f6\u5019\u7684\u67b6\u6784\u56fe\u3002 \u63a5\u7740\u770b\u56de\u8c03\u91cc\u6267\u884cMainThreadInterface\u5bf9\u8c61DispatchMessages\u65b9\u6cd5\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 void MainThreadInterface::DispatchMessages () { // \u904d\u5386\u8bf7\u6c42\u961f\u5217 requests_ . swap ( dispatching_message_queue_ ); while ( ! dispatching_message_queue_ . empty ()) { MessageQueue :: value_type task ; std :: swap ( dispatching_message_queue_ . front (), task ); dispatching_message_queue_ . pop_front (); // \u6267\u884c\u4efb\u52a1\u51fd\u6570 task -> Call ( this ); } } task\u662fWorkerStartedRequest\u5bf9\u8c61\uff0c\u770b\u4e00\u4e0bCall\u65b9\u6cd5\u7684\u4ee3\u7801\u3002 1 2 3 4 void Call ( MainThreadInterface * thread ) override { auto manager = thread -> inspector_agent () -> GetWorkerManager (); manager -> WorkerStarted ( id_ , info_ , waiting_ ); } \u63a5\u7740\u8c03\u7528agent\u7684WorkerManager\u7684WorkerStarted\u3002 1 2 3 4 5 6 7 8 void WorkerManager::WorkerStarted ( int session_id , const WorkerInfo & info , bool waiting ) { children_ . emplace ( session_id , info ); for ( const auto & delegate : delegates_ ) { Report ( delegate . second , info , waiting ); } } WorkerStarted\u8bb0\u5f55\u4e86\u4e00\u4e2aid\u548c\u4e0a\u4e0b\u6587\uff0c\u56e0\u4e3adelegates_\u521d\u59cb\u5316\u7684\u65f6\u5019\u662f\u7a7a\u7684\uff0c\u6240\u4ee5\u4e0d\u4f1a\u6267\u884c\u3002\u81f3\u6b64\uff0c\u5b50\u7ebf\u7a0bInspector\u521d\u59cb\u5316\u7684\u903b\u8f91\u5c31\u5206\u6790\u5b8c\u4e86\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u6211\u4eec\u53d1\u73b0\uff0c\u548c\u4e3b\u7ebf\u7a0b\u4e0d\u4e00\u6837\uff0c\u4e3b\u7ebf\u7a0b\u4f1a\u542f\u52a8\u4e00\u4e2aWebSocket\u670d\u52a1\u5668\u63a5\u6536\u5ba2\u6237\u7aef\u7684\u8fde\u63a5\u8bf7\u6c42\uff0c\u800c\u5b50\u7ebf\u7a0b\u53ea\u662f\u521d\u59cb\u5316\u4e86\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u57fa\u4e8e\u8fd9\u4e9b\u6570\u636e\u7ed3\u6784\uff0c\u4e3b\u7ebf\u7a0b\u662f\u5982\u4f55\u52a8\u6001\u5f00\u542f\u8c03\u8bd5\u5b50\u7ebf\u7a0b\u7684\u3002 2 \u4e3b\u7ebf\u7a0b\u5f00\u542f\u8c03\u8bd5\u5b50\u7ebf\u7a0b\u7684\u80fd\u529b \u00b6 \u6211\u4eec\u53ef\u4ee5\u4ee5\u4ee5\u4e0b\u65b9\u5f0f\u5f00\u542f\u5bf9\u5b50\u7ebf\u7a0b\u7684\u8c03\u8bd5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const { Worker , workerData } = require ( 'worker_threads' ); const { Session } = require ( 'inspector' ); // \u65b0\u5efa\u4e00\u4e2a\u65b0\u7684\u901a\u4fe1\u901a\u9053 const session = new Session (); session . connect (); // \u521b\u5efa\u5b50\u7ebf\u7a0b const worker = new Worker ( './httpServer.js' , { workerData : { port : 80 }}); // \u5b50\u7ebf\u7a0b\u542f\u52a8\u6210\u529f\u540e\u5f00\u542f\u8c03\u8bd5\u5b50\u7ebf\u7a0b\u7684\u80fd\u529b worker . on ( 'online' , () => { session . post ( \"NodeWorker.enable\" , { waitForDebuggerOnStart : false }, ( err ) => { err && console . log ( \"NodeWorker.enable\" , err ); }); }); // \u9632\u6b62\u4e3b\u7ebf\u7a0b\u9000\u51fa setInterval (() => {}, 100000 ); \u6211\u4eec\u5148\u6765\u5206\u6790\u4e00\u4e0bconnect\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 connect () { this [ connectionSymbol ] = new Connection (( message ) => this [ onMessageSymbol ]( message )); } \u65b0\u5efa\u4e86\u4e00\u4e2aConnection\u5bf9\u8c61\u5e76\u4f20\u5165\u4e00\u4e2a\u56de\u8c03\u51fd\u6570\uff0c\u8be5\u56de\u8c03\u51fd\u6570\u5728\u6536\u5230\u6d88\u606f\u65f6\u88ab\u56de\u8c03\u3002Connection\u662fC++\u5c42\u5bfc\u51fa\u7684\u5bf9\u8c61\uff0c\u7531\u6a21\u7248\u7c7bJSBindingsConnection\u5b9e\u73b0\u3002 1 2 template < typename ConnectionType > class JSBindingsConnection {} \u6211\u4eec\u770b\u770b\u5bfc\u51fa\u7684\u8def\u903b\u8f91\u3002 1 JSBindingsConnection < Connection >:: Bind ( env , target ); \u63a5\u7740\u770bBind\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 static void Bind ( Environment * env , Local < Object > target ) { // class_name\u662fConnection Local < String > class_name = ConnectionType :: GetClassName ( env ); Local < FunctionTemplate > tmpl = env -> NewFunctionTemplate ( JSBindingsConnection :: New ); tmpl -> InstanceTemplate () -> SetInternalFieldCount ( 1 ); tmpl -> SetClassName ( class_name ); tmpl -> Inherit ( AsyncWrap :: GetConstructorTemplate ( env )); env -> SetProtoMethod ( tmpl , \"dispatch\" , JSBindingsConnection :: Dispatch ); env -> SetProtoMethod ( tmpl , \"disconnect\" , JSBindingsConnection :: Disconnect ); target -> Set ( env -> context (), class_name , tmpl -> GetFunction ( env -> context ()). ToLocalChecked ()) . ToChecked (); } \u5f53\u6211\u4eec\u5728JS\u5c42\u6267\u884cnew Connection\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884cJSBindingsConnection::New\u3002 1 2 3 4 5 static void New ( const FunctionCallbackInfo < Value >& info ) { Environment * env = Environment :: GetCurrent ( info ); Local < Function > callback = info [ 0 ]. As < Function > (); new JSBindingsConnection ( env , info . This (), callback ); } \u6211\u4eec\u770b\u770b\u65b0\u5efa\u4e00\u4e2aJSBindingsConnection\u5bf9\u8c61\u65f6\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 JSBindingsConnection ( Environment * env , Local < Object > wrap , Local < Function > callback ) : AsyncWrap ( env , wrap , PROVIDER_INSPECTORJSBINDING ), callback_ ( env -> isolate (), callback ) { Agent * inspector = env -> inspector_agent (); session_ = LocalConnection :: Connect ( inspector , std :: make_unique < JSBindingsSessionDelegate > ( env , this ) ); } static std :: unique_ptr < InspectorSession > Connect ( Agent * inspector , std :: unique_ptr < InspectorSessionDelegate > delegate ) { return inspector -> Connect ( std :: move ( delegate ), false ); } \u6700\u7ec8\u662f\u4f20\u5165\u4e86\u4e00\u4e2aJSBindingsSessionDelegate\u5bf9\u8c61\u8c03\u7528Agent\u7684Connect\u65b9\u6cd5\u3002 1 2 3 4 5 6 7 8 9 10 std :: unique_ptr < InspectorSession > Agent :: Connect ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { int session_id = client_ -> connectFrontend ( std :: move ( delegate ), prevent_shutdown ); // JSBindingsConnection\u5bf9\u8c61\u7684session_\u5b57\u6bb5\u6307\u5411\u7684\u5bf9\u8c61 return std :: unique_ptr < InspectorSession > ( new SameThreadInspectorSession ( session_id , client_ ) ); } Agent\u7684Connect\u65b9\u6cd5\u7ee7\u7eed\u8c03\u7528client_->connectFrontend\u3002 1 2 3 4 5 6 7 8 9 10 11 int connectFrontend ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { int session_id = next_session_id_ ++ ; channels_ [ session_id ] = std :: make_unique < ChannelImpl > ( env_ , client_ , getWorkerManager (), std :: move ( delegate ), getThreadHandle (), prevent_shutdown ); return session_id ; } connectFrontend\u65b0\u5efa\u4e86\u4e00\u4e2aChannelImpl\u5bf9\u8c61\uff0c\u5728\u65b0\u5efaChannelImpl\u65f6\uff0c\u4f1a\u521d\u59cb\u5316\u5b50\u7ebf\u7a0b\u5904\u7406\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 explicit ChannelImpl ( Environment * env , const std :: unique_ptr < V8Inspector >& inspector , std :: shared_ptr < WorkerManager > worker_manager , std :: unique_ptr < InspectorSessionDelegate > delegate , std :: shared_ptr < MainThreadHandle > main_thread_ , bool prevent_shutdown ) : delegate_ ( std :: move ( delegate )), prevent_shutdown_ ( prevent_shutdown ), retaining_context_ ( false ) { session_ = inspector -> connect ( CONTEXT_GROUP_ID , this , StringView ()); // Node.js\u62d3\u5c55\u547d\u4ee4\u7684\u5904\u7406\u5206\u53d1\u5668 node_dispatcher_ = std :: make_unique < protocol :: UberDispatcher > ( this ); // trace\u76f8\u5173 tracing_agent_ = std :: make_unique < protocol :: TracingAgent > ( env , main_thread_ ); tracing_agent_ -> Wire ( node_dispatcher_ . get ()); // \u5904\u7406\u5b50\u7ebf\u7a0b\u76f8\u5173 if ( worker_manager ) { worker_agent_ = std :: make_unique < protocol :: WorkerAgent > ( worker_manager ); worker_agent_ -> Wire ( node_dispatcher_ . get ()); } // \u5904\u7406runtime runtime_agent_ = std :: make_unique < protocol :: RuntimeAgent > (); runtime_agent_ -> Wire ( node_dispatcher_ . get ()); } \u6211\u4eec\u8fd9\u91cc\u53ea\u5173\u6ce8\u5904\u7406\u5b50\u7ebf\u7a0b\u76f8\u5173\u7684\u903b\u8f91\u3002\u770b\u4e00\u4e0b worker_agent_->Wire\u3002 1 2 3 4 5 6 void WorkerAgent::Wire ( UberDispatcher * dispatcher ) { frontend_ . reset ( new NodeWorker :: Frontend ( dispatcher -> channel ())); NodeWorker :: Dispatcher :: wire ( dispatcher , this ); auto manager = manager_ . lock (); workers_ = std :: make_shared < NodeWorkers > ( frontend_ , manager -> MainThread ()); } \u8fd9\u65f6\u5019\u7684\u67b6\u6784\u56fe\u5982\u4e0b \u63a5\u7740\u770b\u4e00\u4e0bNodeWorker::Dispatcher::wire(dispatcher, this)\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 void Dispatcher::wire ( UberDispatcher * uber , Backend * backend ) { std :: unique_ptr < DispatcherImpl > dispatcher ( new DispatcherImpl ( uber -> channel (), backend )); uber -> setupRedirects ( dispatcher -> redirects ()); uber -> registerBackend ( \"NodeWorker\" , std :: move ( dispatcher )); } \u9996\u5148\u65b0\u5efa\u4e86\u4e00\u4e2aDispatcherImpl\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 DispatcherImpl ( FrontendChannel * frontendChannel , Backend * backend ) : DispatcherBase ( frontendChannel ) , m_backend ( backend ) { m_dispatchMap [ \"NodeWorker.sendMessageToWorker\" ] = & DispatcherImpl :: sendMessageToWorker ; m_dispatchMap [ \"NodeWorker.enable\" ] = & DispatcherImpl :: enable ; m_dispatchMap [ \"NodeWorker.disable\" ] = & DispatcherImpl :: disable ; m_dispatchMap [ \"NodeWorker.detach\" ] = & DispatcherImpl :: detach ; } \u9664\u4e86\u521d\u59cb\u5316\u4e00\u4e9b\u5b57\u6bb5\uff0c\u53e6\u5916\u4e86\u4e00\u4e2akv\u6570\u636e\u7ed3\u6784\uff0c\u8fd9\u4e2a\u662f\u4e00\u4e2a\u8def\u7531\u914d\u7f6e\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u770b\u5230\u5b83\u7684\u4f5c\u7528\u3002\u65b0\u5efa\u5b8cDispatcherImpl\u540e\u53c8\u8c03\u7528\u4e86uber->registerBackend(\"NodeWorker\", std::move(dispatcher))\u6ce8\u518c\u8be5\u5bf9\u8c61\u3002 1 2 3 4 void UberDispatcher::registerBackend ( const String & name , std :: unique_ptr < protocol :: DispatcherBase > dispatcher ) { m_dispatchers [ name ] = std :: move ( dispatcher ); } \u8fd9\u65f6\u5019\u7684\u67b6\u6784\u56fe\u5982\u4e0b\u3002 \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u5176\u5b9e\u662f\u5efa\u7acb\u4e86\u4e00\u4e2a\u8def\u7531\u4f53\u7cfb\uff0c\u540e\u9762\u6536\u5230\u547d\u4ee4\u65f6\u5c31\u4f1a\u6839\u636e\u8fd9\u4e9b\u8def\u7531\u914d\u7f6e\u8fdb\u884c\u8f6c\u53d1\uff0c\u7c7b\u4f3cNode.js Express\u6846\u67b6\u8def\u7531\u673a\u5236\u3002\u8fd9\u65f6\u5019\u53ef\u4ee5\u901a\u8fc7session\u7684post\u7ed9\u4e3b\u7ebf\u7a0b\u53d1\u9001NodeWorker.enable\u547d\u4ee4\u6765\u5f00\u542f\u5b50\u7ebf\u7a0b\u7684\u8c03\u8bd5\u3002\u6211\u4eec\u5206\u6790\u8fd9\u4e2a\u8fc7\u7a0b\u3002 1 2 3 4 5 6 7 8 9 post ( method , params , callback ) { // \u5ffd\u7565\u53c2\u6570\u5904\u7406 // \u4fdd\u5b58\u8bf7\u6c42\u5bf9\u5e94\u7684\u56de\u8c03 if ( callback ) { this [ messageCallbacksSymbol ]. set ( id , callback ); } // \u8c03\u7528C++\u7684dispatch this [ connectionSymbol ]. dispatch ( JSONStringify ( message )); } this[connectionSymbol]\u5bf9\u5e94\u7684\u662fJSBindingsConnection\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 static void Dispatch ( const FunctionCallbackInfo < Value >& info ) { Environment * env = Environment :: GetCurrent ( info ); JSBindingsConnection * session ; ASSIGN_OR_RETURN_UNWRAP ( & session , info . Holder ()); if ( session -> session_ ) { session -> session_ -> Dispatch ( ToProtocolString ( env -> isolate (), info [ 0 ]) -> string ()); } } session_\u662f\u4e00\u4e2aSameThreadInspectorSession\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 void SameThreadInspectorSession::Dispatch ( const v8_inspector :: StringView & message ) { auto client = client_ . lock (); client -> dispatchMessageFromFrontend ( session_id_ , message ); } void dispatchMessageFromFrontend ( int session_id , const StringView & message ) { channels_ [ session_id ] -> dispatchProtocolMessage ( message ); } \u6700\u7ec8\u8c03\u7528\u4e86ChannelImpl\u7684dispatchProtocolMessage\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void dispatchProtocolMessage ( const StringView & message ) { std :: string raw_message = protocol :: StringUtil :: StringViewToUtf8 ( message ); std :: unique_ptr < protocol :: DictionaryValue > value = protocol :: DictionaryValue :: cast ( protocol :: StringUtil :: parseMessage ( raw_message , false )); int call_id ; std :: string method ; // \u89e3\u6790\u547d\u4ee4 node_dispatcher_ -> parseCommand ( value . get (), & call_id , & method ); // \u5224\u65ad\u547d\u4ee4\u662fV8\u5185\u7f6e\u547d\u4ee4\u8fd8\u662fNode.js\u62d3\u5c55\u7684\u547d\u4ee4 if ( v8_inspector :: V8InspectorSession :: canDispatchMethod ( Utf8ToStringView ( method ) -> string ())) { session_ -> dispatchProtocolMessage ( message ); } else { node_dispatcher_ -> dispatch ( call_id , method , std :: move ( value ), raw_message ); } } \u56e0\u4e3aNodeWorker.enable\u662fNode.js\u62d3\u5c55\u7684\u547d\u4ee4\uff0c\u6240\u4ee5\u4f1a\u8d70\u5230else\u91cc\u9762\u7684\u903b\u8f91\u3002\u6839\u636e\u8def\u7531\u914d\u7f6e\u627e\u5230\u8be5\u547d\u4ee4\u5bf9\u5e94\u7684\u5904\u7406\u903b\u8f91\uff08NodeWorker.enable\u4ee5.\u5207\u5206\uff0c\u5bf9\u5e94\u4e24\u7ea7\u8def\u7531\uff09\u3002 1 2 3 4 5 6 7 8 void UberDispatcher::dispatch ( int callId , const String & in_method , std :: unique_ptr < Value > parsedMessage , const ProtocolMessage & rawMessage ) { // \u627e\u5230\u4e00\u7ea7\u8def\u7531\u914d\u7f6e protocol :: DispatcherBase * dispatcher = findDispatcher ( method ); std :: unique_ptr < protocol :: DictionaryValue > messageObject = DictionaryValue :: cast ( std :: move ( parsedMessage )); // \u4ea4\u7ed9\u4e00\u7ea7\u8def\u7531\u5904\u7406\u5668\u5904\u7406 dispatcher -> dispatch ( callId , method , rawMessage , std :: move ( messageObject )); } NodeWorker.enable\u5bf9\u5e94\u7684\u8def\u7531\u5904\u7406\u5668\u4ee3\u7801\u5982\u4e0b 1 2 3 4 5 6 7 8 void DispatcherImpl::dispatch ( int callId , const String & method , const ProtocolMessage & message , std :: unique_ptr < protocol :: DictionaryValue > messageObject ) { // \u67e5\u627e\u4e8c\u7ea7\u8def\u7531 std :: unordered_map < String , CallHandler >:: iterator it = m_dispatchMap . find ( method ); protocol :: ErrorSupport errors ; // \u627e\u5230\u5904\u7406\u51fd\u6570 ( this ->* ( it -> second ))( callId , method , message , std :: move ( messageObject ), & errors ); } dispatch\u7ee7\u7eed\u5bfb\u627e\u547d\u4ee4\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff0c\u6700\u7ec8\u627e\u5230NodeWorker.enable\u547d\u4ee4\u7684\u5904\u7406\u51fd\u6570\u4e3aDispatcherImpl::enable\u3002 1 2 3 4 5 6 7 void DispatcherImpl::enable (...) { std :: unique_ptr < DispatcherBase :: WeakPtr > weak = weakPtr (); DispatchResponse response = m_backend -> enable (...); // \u8fd4\u56de\u54cd\u5e94\u7ed9\u547d\u4ee4\uff08\u7c7b\u4f3c\u8bf7\u6c42/\u54cd\u5e94\u6a21\u5f0f\uff09 weak -> get () -> sendResponse ( callId , response ); } \u6839\u636e\u67b6\u6784\u56fe\u53ef\u4ee5\u77e5\u9053m_backend\u662fWorkerAgent\u5bf9\u8c61\u3002 1 2 3 4 5 6 DispatchResponse WorkerAgent::enable ( bool waitForDebuggerOnStart ) { auto manager = manager_ . lock (); std :: unique_ptr < AgentWorkerInspectorDelegate > delegate ( new AgentWorkerInspectorDelegate ( workers_ )); event_handle_ = manager -> SetAutoAttach ( std :: move ( delegate )); return DispatchResponse :: OK (); } \u7ee7\u7eed\u8c03\u7528WorkerManager\u7684SetAutoAttach\u65b9\u6cd5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 std :: unique_ptr < WorkerManagerEventHandle > WorkerManager :: SetAutoAttach ( std :: unique_ptr < WorkerDelegate > attach_delegate ) { int id = ++ next_delegate_id_ ; // \u4fdd\u5b58delegate delegates_ [ id ] = std :: move ( attach_delegate ); const auto & delegate = delegates_ [ id ]; // \u901a\u77e5\u5b50\u7ebf\u7a0b for ( const auto & worker : children_ ) { Report ( delegate , worker . second , false ); } ... } SetAutoAttach\u904d\u5386\u5b50\u7ebf\u7a0b\u3002 1 2 3 4 5 void Report ( const std :: unique_ptr < WorkerDelegate >& delegate , const WorkerInfo & info , bool waiting ) { if ( info . worker_thread ) delegate -> WorkerCreated ( info . title , info . url , waiting , info . worker_thread ); } info\u662f\u4e00\u4e2aWorkerInfo\u5bf9\u8c61\uff0c\u8be5\u5bf9\u8c61\u662f\u5b50\u7ebf\u7a0b\u521d\u59cb\u5316\u548c\u4e3b\u7ebf\u7a0b\u5efa\u7acb\u5173\u7cfb\u7684\u6570\u636e\u7ed3\u6784\u3002delegate\u662fAgentWorkerInspectorDelegate\u5bf9\u8c61\u3002 1 2 3 4 5 6 void WorkerCreated ( const std :: string & title , const std :: string & url , bool waiting , std :: shared_ptr < MainThreadHandle > target ) override { workers_ -> WorkerCreated ( title , url , waiting , target ); } workers_\u662f\u4e00\u4e2aNodeWorkers\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void NodeWorkers::WorkerCreated ( const std :: string & title , const std :: string & url , bool waiting , std :: shared_ptr < MainThreadHandle > target ) { auto frontend = frontend_ . lock (); std :: string id = std :: to_string ( ++ next_target_id_ ); // \u5904\u7406\u6570\u636e\u901a\u4fe1\u7684delegate auto delegate = thread_ -> MakeDelegateThreadSafe ( std :: unique_ptr < InspectorSessionDelegate > ( new ParentInspectorSessionDelegate ( id , shared_from_this ()) ) ); // \u5efa\u7acb\u548c\u5b50\u7ebf\u7a0bV8 Inspector\u7684\u901a\u4fe1\u901a\u9053 sessions_ [ id ] = target -> Connect ( std :: move ( delegate ), true ); frontend -> attachedToWorker ( id , WorkerInfo ( id , title , url ), waiting ); } WorkerCreated\u5efa\u7acb\u4e86\u4e00\u6761\u548c\u5b50\u7ebf\u7a0b\u901a\u4fe1\u7684\u901a\u9053\uff0c\u7136\u540e\u901a\u77e5\u547d\u4ee4\u7684\u53d1\u9001\u65b9\u901a\u9053\u5efa\u7acb\u6210\u529f\u3002\u8fd9\u65f6\u5019\u67b6\u6784\u56fe\u5982\u4e0b\u3002 \u63a5\u7740\u770battachedToWorker\u3002 1 2 3 4 5 6 7 8 9 10 void Frontend::attachedToWorker ( const String & sessionId , std :: unique_ptr < protocol :: NodeWorker :: WorkerInfo > workerInfo , bool waitingForDebugger ) { std :: unique_ptr < AttachedToWorkerNotification > messageData = AttachedToWorkerNotification :: create () . setSessionId ( sessionId ) . setWorkerInfo ( std :: move ( workerInfo )) . setWaitingForDebugger ( waitingForDebugger ) . build (); // \u89e6\u53d1NodeWorker.attachedToWorker m_frontendChannel -> sendProtocolNotification ( InternalResponse :: createNotification ( \"NodeWorker.attachedToWorker\" , std :: move ( messageData ))); } \u7ee7\u7eed\u770bsendProtocolNotification 1 2 3 4 5 6 7 8 void sendProtocolNotification ( std :: unique_ptr < Serializable > message ) override { sendMessageToFrontend ( message -> serializeToJSON ()); } void sendMessageToFrontend ( const StringView & message ) { delegate_ -> SendMessageToFrontend ( message ); } \u8fd9\u91cc\u7684delegate_\u662f\u4e00\u4e2aJSBindingsSessionDelegate\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void SendMessageToFrontend ( const v8_inspector :: StringView & message ) override { Isolate * isolate = env_ -> isolate (); HandleScope handle_scope ( isolate ); Context :: Scope context_scope ( env_ -> context ()); MaybeLocal < String > v8string = String :: NewFromTwoByte ( isolate , message . characters16 (), NewStringType :: kNormal , message . length () ); Local < Value > argument = v8string . ToLocalChecked (). As < Value > (); // \u6536\u5230\u6d88\u606f\u6267\u884c\u56de\u8c03 connection_ -> OnMessage ( argument ); } // \u6267\u884cJS\u5c42\u56de\u8c03 void OnMessage ( Local < Value > value ) { MakeCallback ( callback_ . Get ( env () -> isolate ()), 1 , & value ); } JS\u5c42\u56de\u8c03\u903b\u8f91\u5982\u4e0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [ onMessageSymbol ]( message ) { const parsed = JSONParse ( message ); // \u6536\u5230\u7684\u6d88\u606f\u5982\u679c\u662f\u67d0\u4e2a\u8bf7\u6c42\u7684\u54cd\u5e94\uff0c\u5219\u6709\u4e2aid\u5b57\u6bb5\u8bb0\u5f55\u4e86\u8bf7\u6c42\u5bf9\u5e94\u7684id\uff0c\u5426\u5219\u5219\u89e6\u53d1\u4e8b\u4ef6 if ( parsed . id ) { const callback = this [ messageCallbacksSymbol ]. get ( parsed . id ); this [ messageCallbacksSymbol ]. delete ( parsed . id ); if ( callback ) { callback ( null , parsed . result ); } } else { this . emit ( parsed . method , parsed ); this . emit ( 'inspectorNotification' , parsed ); } } \u4e3b\u7ebf\u7a0b\u62ff\u5230Worker Session\u5bf9\u4e00\u4e2a\u7684id\uff0c\u540e\u7eed\u5c31\u53ef\u4ee5\u901a\u8fc7\u547d\u4ee4NodeWorker.sendMessageToWorker\u52a0\u4e0a\u8be5id\u548c\u5b50\u7ebf\u7a0b\u901a\u4fe1\u3002\u5927\u81f4\u539f\u7406\u5982\u4e0b\uff0c\u4e3b\u7ebf\u7a0b\u901a\u8fc7\u81ea\u5df1\u7684channel\u548c\u5b50\u7ebf\u7a0b\u7684channel\u8fdb\u884c\u901a\u4fe1\uff0c\u4ece\u800c\u8fbe\u5230\u63a7\u5236\u5b50\u7ebf\u7a0b\u7684\u76ee\u7684\u3002 \u6211\u4eec\u5206\u6790\u4e00\u4e0bNodeWorker.sendMessageToWorker\u547d\u4ee4\u7684\u903b\u8f91\uff0c\u5bf9\u5e94\u5904\u7406\u51fd\u6570\u4e3aDispatcherImpl::sendMessageToWorker\u3002 1 2 3 4 5 6 7 8 void DispatcherImpl::sendMessageToWorker (...) { std :: unique_ptr < DispatcherBase :: WeakPtr > weak = weakPtr (); DispatchResponse response = m_backend -> sendMessageToWorker ( in_message , in_sessionId ); // \u54cd\u5e94 weak -> get () -> sendResponse ( callId , response ); return ; } \u7ee7\u7eed\u5206\u6790m_backend->sendMessageToWorker\u3002 1 2 3 4 5 6 7 8 9 10 DispatchResponse WorkerAgent::sendMessageToWorker ( const String & message , const String & sessionId ) { workers_ -> Receive ( sessionId , message ); return DispatchResponse :: OK (); } void NodeWorkers::Receive ( const std :: string & id , const std :: string & message ) { auto it = sessions_ . find ( id ); it -> second -> Dispatch ( Utf8ToStringView ( message ) -> string ()); } sessions_\u5bf9\u5e94\u7684\u662f\u548c\u5b50\u7ebf\u7a0b\u7684\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784CrossThreadInspectorSession\u3002\u770b\u4e00\u4e0b\u8be5\u5bf9\u8c61\u7684Dispatch\u65b9\u6cd5\u3002 1 2 3 4 void Dispatch ( const StringView & message ) override { state_ . Call ( & MainThreadSessionState :: Dispatch , StringBuffer :: create ( message )); } \u518d\u6b21\u8c03\u4e86MainThreadSessionState::Dispatch 1 2 3 void Dispatch ( std :: unique_ptr < StringBuffer > message ) { session_ -> Dispatch ( message -> string ()); } session_\u662fSameThreadInspectorSession\u5bf9\u8c61\u3002\u7ee7\u7eed\u770b\u5b83\u7684Dispatch\u65b9\u6cd5\u3002 1 2 3 4 5 6 7 8 9 void SameThreadInspectorSession::Dispatch ( const v8_inspector :: StringView & message ) { auto client = client_ . lock (); client -> dispatchMessageFromFrontend ( session_id_ , message ); } void dispatchMessageFromFrontend ( int session_id , const StringView & message ) { channels_ [ session_id ] -> dispatchProtocolMessage ( message ); } \u901a\u8fc7\u5c42\u5c42\u8c03\u7528\uff0c\u6700\u7ec8\u62ff\u5230\u4e86\u4e00\u4e2a\u5408\u5b50\u7ebf\u7a0b\u901a\u4fe1\u7684channel\uff0cdispatchProtocolMessage\u65b9\u6cd5\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u8be5\u65b9\u6cd5\u4f1a\u6839\u636e\u547d\u4ee4\u505a\u4e0d\u540c\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8fd9\u91cc\u53d1\u9001\u7684\u662fV8\u5185\u7f6e\u7684\u547d\u4ee4\uff0c\u6240\u4ee5\u4f1a\u4ea4\u7ed9V8 Inspector\u5904\u7406\u3002\u5f53V8 Inspector\u5904\u7406\u5b8c\u540e\uff0c\u4f1a\u901a\u8fc7ChannelImpl\u7684sendResponse\u8fd4\u56de\u7ed3\u679c\u3002 1 2 3 4 5 6 7 8 9 void sendResponse ( int callId , std :: unique_ptr < v8_inspector :: StringBuffer > message ) override { sendMessageToFrontend ( message -> string ()); } void sendMessageToFrontend ( const StringView & message ) { delegate_ -> SendMessageToFrontend ( message ); } \u8fd9\u91cc\u7684delegate_\u662fParentInspectorSessionDelegate\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void SendMessageToFrontend ( const v8_inspector :: StringView & msg ) override { std :: string message = protocol :: StringUtil :: StringViewToUtf8 ( msg ); workers_ -> Send ( id_ , message ); } void NodeWorkers::Send ( const std :: string & id , const std :: string & message ) { auto frontend = frontend_ . lock (); if ( frontend ) frontend -> receivedMessageFromWorker ( id , message ); } void Frontend::receivedMessageFromWorker ( const String & sessionId , const String & message ) { std :: unique_ptr < ReceivedMessageFromWorkerNotification > messageData = ReceivedMessageFromWorkerNotification :: create () . setSessionId ( sessionId ) . setMessage ( message ) . build (); // \u89e6\u53d1NodeWorker.receivedMessageFromWorker m_frontendChannel -> sendProtocolNotification ( InternalResponse :: createNotification ( \"NodeWorker.receivedMessageFromWorker\" , std :: move ( messageData ))); } m_frontendChannel\u662f\u4e3b\u7ebf\u7a0b\u7684ChannelImpl\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 void sendProtocolNotification ( std :: unique_ptr < Serializable > message ) override { sendMessageToFrontend ( message -> serializeToJSON ()); } void sendMessageToFrontend ( const StringView & message ) { delegate_ -> SendMessageToFrontend ( message ); } delegate_\u662fC++\u5c42\u4f20\u5165\u7684JSBindingsSessionDelegate\u5bf9\u8c61\u3002\u6700\u7ec8\u901a\u8fc7JSBindingsSessionDelegate\u5bf9\u8c61\u56de\u8c03JS\u5c42\uff0c\u4e4b\u524d\u5df2\u7ecf\u5206\u6790\u8fc7\u5c31\u4e0d\u518d\u8d58\u8ff0\u3002\u81f3\u6b64\uff0c\u4e3b\u7ebf\u7a0b\u5c31\u5177\u5907\u4e86\u63a7\u5236\u5b50\u7ebf\u7a0b\u7684\u80fd\u529b\uff0c\u4f46\u662f\u63a7\u5236\u65b9\u5f0f\u6709\u5f88\u591a\u79cd\u3002 2.1 \u4f7f\u7528\u901a\u7528\u7684V8\u547d\u4ee4 \u00b6 \u901a\u8fc7\u4e0b\u9762\u4ee3\u7801\u6536\u96c6\u5b50\u7ebf\u7a0b\u7684CPU Profile\u4fe1\u606f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const { Worker , workerData } = require ( 'worker_threads' ); const { Session } = require ( 'inspector' ); const session = new Session (); session . connect (); let id = 1 ; function post ( sessionId , method , params , callback ) { session . post ( 'NodeWorker.sendMessageToWorker' , { sessionId , message : JSON . stringify ({ id : id ++ , method , params }) }, callback ); } session . on ( 'NodeWorker.attachedToWorker' , ( data ) => { post ( data . params . sessionId , 'Profiler.enable' ); post ( data . params . sessionId , 'Profiler.start' ); // \u6536\u96c6\u4e00\u6bb5\u65f6\u95f4\u540e\u63d0\u4ea4\u505c\u6b62\u6536\u96c6\u547d\u4ee4 setTimeout (() => { post ( data . params . sessionId , 'Profiler.stop' ); }, 10000 ) }); session . on ( 'NodeWorker.receivedMessageFromWorker' , ({ params : { message }}) => { const data = JSON . parse ( message ); console . log ( data ); }); const worker = new Worker ( './httpServer.js' , { workerData : { port : 80 }}); worker . on ( 'online' , () => { session . post ( \"NodeWorker.enable\" ,{ waitForDebuggerOnStart : false }, ( err ) => { console . log ( err , \"NodeWorker.enable\" );}); }); setInterval (() => {}, 100000 ); \u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u53ef\u4ee5\u901a\u8fc7\u547d\u4ee4\u63a7\u5236\u5b50\u7ebf\u7a0b\u7684\u8c03\u8bd5\u548c\u6570\u636e\u6536\u96c6\u3002 2.2 \u5728\u5b50\u7ebf\u7a0b\u4e2d\u52a8\u6001\u6267\u884c\u811a\u672c \u00b6 \u53ef\u4ee5\u901a\u8fc7\u6267\u884c\u811a\u672c\u5f00\u542f\u5b50\u7ebf\u7a0b\u7684WebSocket\u670d\u52a1\uff0c\u50cf\u8c03\u8bd5\u4e3b\u7ebf\u7a0b\u4e00\u6837\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 const { Worker , workerData } = require ( 'worker_threads' ); const { Session } = require ( 'inspector' ); const session = new Session (); session . connect (); let workerSessionId ; let id = 1 ; function post ( method , params ) { session . post ( 'NodeWorker.sendMessageToWorker' , { sessionId : workerSessionId , message : JSON . stringify ({ id : id ++ , method , params }) }); } session . on ( 'NodeWorker.receivedMessageFromWorker' , ({ params : { message }}) => { const data = JSON . parse ( message ); console . log ( data ); }); session . on ( 'NodeWorker.attachedToWorker' , ( data ) => { workerSessionId = data . params . sessionId ; post ( \"Runtime.evaluate\" , { includeCommandLineAPI : true , expression : `const inspector = process.binding('inspector'); inspector.open(); inspector.url(); ` } ); }); const worker = new Worker ( './httpServer.js' , { workerData : { port : 80 }}); worker . on ( 'online' , () => { session . post ( \"NodeWorker.enable\" ,{ waitForDebuggerOnStart : false }, ( err ) => { err && console . log ( \"NodeWorker.enable\" , err );}); }); setInterval (() => {}, 100000 ); \u6267\u884c\u4e0a\u9762\u7684\u4ee3\u7801\u5c31\u62ff\u5230\u4ee5\u4e0b\u8f93\u51fa 1 2 3 4 5 6 7 8 9 { id : 1 , result : { result : { type : 'string' , value : 'ws://127.0.0.1:9229/c0ca16c8-55aa-4651-9776-fca1b27fc718' } } } \u901a\u8fc7\u8be5\u5730\u5740\uff0c\u5ba2\u6237\u7aef\u5c31\u53ef\u4ee5\u5bf9\u5b50\u7ebf\u7a0b\u8fdb\u884c\u8c03\u8bd5\u4e86\u3002\u4e0a\u9762\u4ee3\u7801\u91cc\u4f7f\u7528process.binding\u800c\u4e0d\u662frequire\u52a0\u8f7dinspector\uff0c\u56e0\u4e3a\u521a\u624d\u901a\u8fc7NodeWorker.enable\u547d\u4ee4\u4e3a\u5b50\u7ebf\u7a0b\u521b\u5efa\u4e86\u4e00\u4e2a\u5230\u5b50\u7ebf\u7a0bInspector\u7684channel\uff0c\u800cJS\u6a21\u5757\u91cc\u5224\u65ad\u5982\u679cchannel\u975e\u7a7a\u5219\u62a5\u9519Inspector\u5df2\u7ecf\u6253\u5f00\u3002\u6240\u4ee5\u8fd9\u91cc\u9700\u8981\u7ed5\u8fc7\u8fd9\u4e2a\u9650\u5236\uff0c\u76f4\u63a5\u52a0\u8f7dC++\u6a21\u5757\u5f00\u542fWebSocket\u670d\u52a1\u5668\u3002 3 \u5b50\u7ebf\u7a0b\u8c03\u8bd5\u4e3b\u7ebf\u7a0b \u00b6 \u4e0d\u4ec5\u53ef\u4ee5\u901a\u8fc7\u4e3b\u7ebf\u7a0b\u8c03\u8bd5\u5b50\u7ebf\u7a0b\uff0c\u8fd8\u53ef\u4ee5\u901a\u8fc7\u5b50\u7ebf\u7a0b\u8c03\u8bd5\u4e3b\u7ebf\u7a0b\u3002Node.js\u5728\u5b50\u7ebf\u7a0b\u66b4\u9732\u4e86connectToMainThread\u65b9\u6cd5\u8fde\u63a5\u5230\u4e3b\u7ebf\u7a0b\u7684Inspector\uff08\u53ea\u80fd\u5728work_threads\u4e2d\u4f7f\u7528\uff09\uff0c\u5b9e\u73b0\u7684\u539f\u7406\u548c\u4e4b\u524d\u5206\u6790\u7684\u7c7b\u4f3c\uff0c\u4e3b\u8981\u662f\u5b50\u7ebf\u7a0b\u8fde\u63a5\u5230\u4e3b\u7ebf\u7a0b\u7684V8 Inspector\uff0c\u901a\u8fc7\u548c\u8be5Inspector\u5b8c\u6210\u5bf9\u4e3b\u7ebf\u7a0b\u7684\u63a7\u5236\u3002\u770b\u4e0b\u9762\u4e00\u4e2a\u4f8b\u5b50\u3002 \u4e3b\u7ebf\u7a0b\u4ee3\u7801 1 2 3 4 5 6 7 8 const { Worker , workerData } = require ( 'worker_threads' ); const http = require ( 'http' ); const worker = new Worker ( './worker.js' , { workerData : { port : 80 }}); http . createServer (( _ , res ) => { res . end ( 'main' ); }). listen ( 8000 ); worker.js\u4ee3\u7801\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const fs = require ( 'fs' ); const { workerData : { port } } = require ( 'worker_threads' ); const { Session } = require ( 'inspector' ); const session = new Session (); session . connectToMainThread (); session . post ( 'Profiler.enable' ); session . post ( 'Profiler.start' ); setTimeout (() => { session . post ( 'Profiler.stop' , ( err , data ) => { if ( data . profile ) { fs . writeFileSync ( './profile.cpuprofile' , JSON . stringify ( data . profile )); } }); }, 5000 )","title":"chapter25 Node.js\u5b50\u7ebf\u7a0b\u8c03\u8bd5\u548c\u8bca\u65ad\u6307\u5357"},{"location":"chapter25-Node.js%E5%AD%90%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95%E5%92%8C%E8%AF%8A%E6%96%AD%E6%8C%87%E5%8D%97/#1-inspector","text":"\u5728Node.js\u542f\u52a8\u5b50\u7ebf\u7a0b\u7684\u65f6\u5019\uff0c\u4f1a\u521d\u59cb\u5316Inspector\u3002 1 env_ -> InitializeInspector ( std :: move ( inspector_parent_handle_ )); \u5728\u5206\u6790InitializeInspector\u4e4b\u524d\uff0c\u6211\u4eec\u5148\u770b\u4e00\u4e0binspector_parent_handle_\u3002 1 std :: unique_ptr < inspector :: ParentInspectorHandle > inspector_parent_handle_ ; inspector_parent_handle_\u662f\u4e00\u4e2aParentInspectorHandle\u5bf9\u8c61\uff0c\u8fd9\u4e2a\u5bf9\u8c61\u662f\u5b50\u7ebf\u7a0b\u548c\u4e3b\u7ebf\u7a0b\u901a\u4fe1\u7684\u6865\u6881\u3002\u6211\u4eec\u770b\u4e00\u4e0b\u4ed6\u7684\u521d\u59cb\u5316\u903b\u8f91\uff08\u5728\u4e3b\u7ebf\u7a0b\u91cc\u6267\u884c\uff09\u3002 1 inspector_parent_handle_ = env -> inspector_agent () -> GetParentHandle ( thread_id_ , url ); \u8c03\u7528agent\u7684GetParentHandle\u83b7\u53d6\u4e00\u4e2aParentInspectorHandle\u5bf9\u8c61\u3002 1 2 3 std :: unique_ptr < ParentInspectorHandle > Agent :: GetParentHandle ( int thread_id , const std :: string & url ) { return client_ -> getWorkerManager () -> NewParentHandle ( thread_id , url ); } \u5185\u90e8\u5176\u5b9e\u662f\u901a\u8fc7client_->getWorkerManager()\u5bf9\u8c61\u7684NewParentHandle\u65b9\u6cd5\u83b7\u53d6ParentInspectorHandle\u5bf9\u8c61\uff0c\u63a5\u4e0b\u6765\u6211\u4eec\u770b\u4e00\u4e0bWorkerManager\u7684NewParentHandle\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 std :: unique_ptr < ParentInspectorHandle > WorkerManager :: NewParentHandle ( int thread_id , const std :: string & url ) { bool wait = ! delegates_waiting_on_start_ . empty (); return std :: make_unique < ParentInspectorHandle > ( thread_id , url , thread_ , wait ); } ParentInspectorHandle :: ParentInspectorHandle ( int id , const std :: string & url , std :: shared_ptr < MainThreadHandle > parent_thread , bool wait_for_connect ) : id_ ( id ), url_ ( url ), parent_thread_ ( parent_thread ), wait_ ( wait_for_connect ) {} \u6700\u7ec8\u7684\u67b6\u6784\u56fe\u5982\u4e0b\u5165\u6240\u793a\u3002 \u5206\u6790\u5b8cParentInspectorHandle\u540e\u7ee7\u7eed\u770b\u4e00\u4e0benv_->InitializeInspector(std::move(inspector_parent_handle_))\u7684\u903b\u8f91\uff08\u5728\u5b50\u7ebf\u7a0b\u91cc\u6267\u884c\uff09\u3002 1 2 3 4 5 6 7 8 9 10 11 int Environment::InitializeInspector ( std :: unique_ptr < inspector :: ParentInspectorHandle > parent_handle ) { std :: string inspector_path ; inspector_path = parent_handle -> url (); inspector_agent_ -> SetParentHandle ( std :: move ( parent_handle )); inspector_agent_ -> Start ( inspector_path , options_ -> debug_options (), inspector_host_port (), is_main_thread ()); } \u9996\u5148\u628aParentInspectorHandle\u5bf9\u8c61\u4fdd\u5b58\u5230agent\u4e2d\uff0c\u7136\u540e\u8c03\u7528agent\u7684Start\u65b9\u6cd5\u3002 1 2 3 4 5 6 bool Agent::Start (...) { // \u65b0\u5efaclient\u5bf9\u8c61 client_ = std :: make_shared < NodeInspectorClient > ( parent_env_ , is_main ); // \u8c03\u7528agent\u4e2d\u4fdd\u5b58\u7684ParentInspectorHandle\u5bf9\u8c61\u7684WorkerStarted parent_handle_ -> WorkerStarted ( client_ -> getThreadHandle (), ...); } Agent::Start\u521b\u5efa\u4e86\u4e00\u4e2aclient\u5bf9\u8c61\uff0c\u7136\u540e\u8c03\u7528ParentInspectorHandle\u5bf9\u8c61\u7684WorkerStarted\u65b9\u6cd5\uff08\u521a\u624dSetParentHandle\u7684\u65f6\u5019\u4fdd\u5b58\u7684\uff09\uff0c\u6211\u4eec\u770b\u4e00\u4e0b\u8fd9\u65f6\u5019\u7684\u67b6\u6784\u56fe\u3002 \u63a5\u7740\u770bparent_handle_->WorkerStarted\u3002 1 2 3 4 5 6 void ParentInspectorHandle::WorkerStarted ( std :: shared_ptr < MainThreadHandle > worker_thread , bool waiting ) { std :: unique_ptr < Request > request ( new WorkerStartedRequest ( id_ , url_ , worker_thread , waiting )); parent_thread_ -> Post ( std :: move ( request )); } WorkerStarted\u521b\u5efa\u4e86\u4e00\u4e2aWorkerStartedRequest\u8bf7\u6c42\uff0c\u7136\u540e\u901a\u8fc7parent_thread_->Post\u63d0\u4ea4\uff0cparent_thread_\u662fMainThreadInterface\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void MainThreadInterface::Post ( std :: unique_ptr < Request > request ) { Mutex :: ScopedLock scoped_lock ( requests_lock_ ); // \u4e4b\u524d\u662f\u7a7a\u5219\u9700\u8981\u5524\u9192\u6d88\u8d39\u8005 bool needs_notify = requests_ . empty (); // \u6d88\u606f\u5165\u961f requests_ . push_back ( std :: move ( request )); if ( needs_notify ) { // \u83b7\u53d6\u5f53\u524d\u5bf9\u8c61\u7684\u4e00\u4e2a\u5f31\u5f15\u7528 std :: weak_ptr < MainThreadInterface >* interface_ptr = new std :: weak_ptr < MainThreadInterface > ( shared_from_this ()); // \u8bf7\u6c42V8\u6267\u884cRequestInterrupt\u5165\u53c2\u5bf9\u5e94\u7684\u56de\u8c03 isolate_ -> RequestInterrupt ([]( v8 :: Isolate * isolate , void * opaque ) { // \u628a\u6267\u884c\u65f6\u4f20\u5165\u7684\u53c2\u6570\u8f6c\u6210MainThreadInterface std :: unique_ptr < std :: weak_ptr < MainThreadInterface >> interface_ptr { static_cast < std :: weak_ptr < MainThreadInterface >*> ( opaque ) }; // \u5224\u65ad\u5bf9\u8c61\u662f\u5426\u8fd8\u6709\u6548\uff0c\u662f\u5219\u8c03\u7528DispatchMessages if ( auto iface = interface_ptr -> lock ()) iface -> DispatchMessages (); }, static_cast < void *> ( interface_ptr )); } // \u5524\u9192\u6d88\u8d39\u8005 incoming_message_cond_ . Broadcast ( scoped_lock ); } \u6211\u4eec\u770b\u770b\u8fd9\u65f6\u5019\u7684\u67b6\u6784\u56fe\u3002 \u63a5\u7740\u770b\u56de\u8c03\u91cc\u6267\u884cMainThreadInterface\u5bf9\u8c61DispatchMessages\u65b9\u6cd5\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 void MainThreadInterface::DispatchMessages () { // \u904d\u5386\u8bf7\u6c42\u961f\u5217 requests_ . swap ( dispatching_message_queue_ ); while ( ! dispatching_message_queue_ . empty ()) { MessageQueue :: value_type task ; std :: swap ( dispatching_message_queue_ . front (), task ); dispatching_message_queue_ . pop_front (); // \u6267\u884c\u4efb\u52a1\u51fd\u6570 task -> Call ( this ); } } task\u662fWorkerStartedRequest\u5bf9\u8c61\uff0c\u770b\u4e00\u4e0bCall\u65b9\u6cd5\u7684\u4ee3\u7801\u3002 1 2 3 4 void Call ( MainThreadInterface * thread ) override { auto manager = thread -> inspector_agent () -> GetWorkerManager (); manager -> WorkerStarted ( id_ , info_ , waiting_ ); } \u63a5\u7740\u8c03\u7528agent\u7684WorkerManager\u7684WorkerStarted\u3002 1 2 3 4 5 6 7 8 void WorkerManager::WorkerStarted ( int session_id , const WorkerInfo & info , bool waiting ) { children_ . emplace ( session_id , info ); for ( const auto & delegate : delegates_ ) { Report ( delegate . second , info , waiting ); } } WorkerStarted\u8bb0\u5f55\u4e86\u4e00\u4e2aid\u548c\u4e0a\u4e0b\u6587\uff0c\u56e0\u4e3adelegates_\u521d\u59cb\u5316\u7684\u65f6\u5019\u662f\u7a7a\u7684\uff0c\u6240\u4ee5\u4e0d\u4f1a\u6267\u884c\u3002\u81f3\u6b64\uff0c\u5b50\u7ebf\u7a0bInspector\u521d\u59cb\u5316\u7684\u903b\u8f91\u5c31\u5206\u6790\u5b8c\u4e86\uff0c\u7ed3\u6784\u56fe\u5982\u4e0b\u3002 \u6211\u4eec\u53d1\u73b0\uff0c\u548c\u4e3b\u7ebf\u7a0b\u4e0d\u4e00\u6837\uff0c\u4e3b\u7ebf\u7a0b\u4f1a\u542f\u52a8\u4e00\u4e2aWebSocket\u670d\u52a1\u5668\u63a5\u6536\u5ba2\u6237\u7aef\u7684\u8fde\u63a5\u8bf7\u6c42\uff0c\u800c\u5b50\u7ebf\u7a0b\u53ea\u662f\u521d\u59cb\u5316\u4e86\u4e00\u4e9b\u6570\u636e\u7ed3\u6784\u3002\u4e0b\u9762\u6211\u4eec\u770b\u4e00\u4e0b\u57fa\u4e8e\u8fd9\u4e9b\u6570\u636e\u7ed3\u6784\uff0c\u4e3b\u7ebf\u7a0b\u662f\u5982\u4f55\u52a8\u6001\u5f00\u542f\u8c03\u8bd5\u5b50\u7ebf\u7a0b\u7684\u3002","title":"1 \u521d\u59cb\u5316\u5b50\u7ebf\u7a0b\u7684Inspector"},{"location":"chapter25-Node.js%E5%AD%90%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95%E5%92%8C%E8%AF%8A%E6%96%AD%E6%8C%87%E5%8D%97/#2","text":"\u6211\u4eec\u53ef\u4ee5\u4ee5\u4ee5\u4e0b\u65b9\u5f0f\u5f00\u542f\u5bf9\u5b50\u7ebf\u7a0b\u7684\u8c03\u8bd5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const { Worker , workerData } = require ( 'worker_threads' ); const { Session } = require ( 'inspector' ); // \u65b0\u5efa\u4e00\u4e2a\u65b0\u7684\u901a\u4fe1\u901a\u9053 const session = new Session (); session . connect (); // \u521b\u5efa\u5b50\u7ebf\u7a0b const worker = new Worker ( './httpServer.js' , { workerData : { port : 80 }}); // \u5b50\u7ebf\u7a0b\u542f\u52a8\u6210\u529f\u540e\u5f00\u542f\u8c03\u8bd5\u5b50\u7ebf\u7a0b\u7684\u80fd\u529b worker . on ( 'online' , () => { session . post ( \"NodeWorker.enable\" , { waitForDebuggerOnStart : false }, ( err ) => { err && console . log ( \"NodeWorker.enable\" , err ); }); }); // \u9632\u6b62\u4e3b\u7ebf\u7a0b\u9000\u51fa setInterval (() => {}, 100000 ); \u6211\u4eec\u5148\u6765\u5206\u6790\u4e00\u4e0bconnect\u51fd\u6570\u7684\u903b\u8f91\u3002 1 2 3 connect () { this [ connectionSymbol ] = new Connection (( message ) => this [ onMessageSymbol ]( message )); } \u65b0\u5efa\u4e86\u4e00\u4e2aConnection\u5bf9\u8c61\u5e76\u4f20\u5165\u4e00\u4e2a\u56de\u8c03\u51fd\u6570\uff0c\u8be5\u56de\u8c03\u51fd\u6570\u5728\u6536\u5230\u6d88\u606f\u65f6\u88ab\u56de\u8c03\u3002Connection\u662fC++\u5c42\u5bfc\u51fa\u7684\u5bf9\u8c61\uff0c\u7531\u6a21\u7248\u7c7bJSBindingsConnection\u5b9e\u73b0\u3002 1 2 template < typename ConnectionType > class JSBindingsConnection {} \u6211\u4eec\u770b\u770b\u5bfc\u51fa\u7684\u8def\u903b\u8f91\u3002 1 JSBindingsConnection < Connection >:: Bind ( env , target ); \u63a5\u7740\u770bBind\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 static void Bind ( Environment * env , Local < Object > target ) { // class_name\u662fConnection Local < String > class_name = ConnectionType :: GetClassName ( env ); Local < FunctionTemplate > tmpl = env -> NewFunctionTemplate ( JSBindingsConnection :: New ); tmpl -> InstanceTemplate () -> SetInternalFieldCount ( 1 ); tmpl -> SetClassName ( class_name ); tmpl -> Inherit ( AsyncWrap :: GetConstructorTemplate ( env )); env -> SetProtoMethod ( tmpl , \"dispatch\" , JSBindingsConnection :: Dispatch ); env -> SetProtoMethod ( tmpl , \"disconnect\" , JSBindingsConnection :: Disconnect ); target -> Set ( env -> context (), class_name , tmpl -> GetFunction ( env -> context ()). ToLocalChecked ()) . ToChecked (); } \u5f53\u6211\u4eec\u5728JS\u5c42\u6267\u884cnew Connection\u7684\u65f6\u5019\uff0c\u5c31\u4f1a\u6267\u884cJSBindingsConnection::New\u3002 1 2 3 4 5 static void New ( const FunctionCallbackInfo < Value >& info ) { Environment * env = Environment :: GetCurrent ( info ); Local < Function > callback = info [ 0 ]. As < Function > (); new JSBindingsConnection ( env , info . This (), callback ); } \u6211\u4eec\u770b\u770b\u65b0\u5efa\u4e00\u4e2aJSBindingsConnection\u5bf9\u8c61\u65f6\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 JSBindingsConnection ( Environment * env , Local < Object > wrap , Local < Function > callback ) : AsyncWrap ( env , wrap , PROVIDER_INSPECTORJSBINDING ), callback_ ( env -> isolate (), callback ) { Agent * inspector = env -> inspector_agent (); session_ = LocalConnection :: Connect ( inspector , std :: make_unique < JSBindingsSessionDelegate > ( env , this ) ); } static std :: unique_ptr < InspectorSession > Connect ( Agent * inspector , std :: unique_ptr < InspectorSessionDelegate > delegate ) { return inspector -> Connect ( std :: move ( delegate ), false ); } \u6700\u7ec8\u662f\u4f20\u5165\u4e86\u4e00\u4e2aJSBindingsSessionDelegate\u5bf9\u8c61\u8c03\u7528Agent\u7684Connect\u65b9\u6cd5\u3002 1 2 3 4 5 6 7 8 9 10 std :: unique_ptr < InspectorSession > Agent :: Connect ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { int session_id = client_ -> connectFrontend ( std :: move ( delegate ), prevent_shutdown ); // JSBindingsConnection\u5bf9\u8c61\u7684session_\u5b57\u6bb5\u6307\u5411\u7684\u5bf9\u8c61 return std :: unique_ptr < InspectorSession > ( new SameThreadInspectorSession ( session_id , client_ ) ); } Agent\u7684Connect\u65b9\u6cd5\u7ee7\u7eed\u8c03\u7528client_->connectFrontend\u3002 1 2 3 4 5 6 7 8 9 10 11 int connectFrontend ( std :: unique_ptr < InspectorSessionDelegate > delegate , bool prevent_shutdown ) { int session_id = next_session_id_ ++ ; channels_ [ session_id ] = std :: make_unique < ChannelImpl > ( env_ , client_ , getWorkerManager (), std :: move ( delegate ), getThreadHandle (), prevent_shutdown ); return session_id ; } connectFrontend\u65b0\u5efa\u4e86\u4e00\u4e2aChannelImpl\u5bf9\u8c61\uff0c\u5728\u65b0\u5efaChannelImpl\u65f6\uff0c\u4f1a\u521d\u59cb\u5316\u5b50\u7ebf\u7a0b\u5904\u7406\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 explicit ChannelImpl ( Environment * env , const std :: unique_ptr < V8Inspector >& inspector , std :: shared_ptr < WorkerManager > worker_manager , std :: unique_ptr < InspectorSessionDelegate > delegate , std :: shared_ptr < MainThreadHandle > main_thread_ , bool prevent_shutdown ) : delegate_ ( std :: move ( delegate )), prevent_shutdown_ ( prevent_shutdown ), retaining_context_ ( false ) { session_ = inspector -> connect ( CONTEXT_GROUP_ID , this , StringView ()); // Node.js\u62d3\u5c55\u547d\u4ee4\u7684\u5904\u7406\u5206\u53d1\u5668 node_dispatcher_ = std :: make_unique < protocol :: UberDispatcher > ( this ); // trace\u76f8\u5173 tracing_agent_ = std :: make_unique < protocol :: TracingAgent > ( env , main_thread_ ); tracing_agent_ -> Wire ( node_dispatcher_ . get ()); // \u5904\u7406\u5b50\u7ebf\u7a0b\u76f8\u5173 if ( worker_manager ) { worker_agent_ = std :: make_unique < protocol :: WorkerAgent > ( worker_manager ); worker_agent_ -> Wire ( node_dispatcher_ . get ()); } // \u5904\u7406runtime runtime_agent_ = std :: make_unique < protocol :: RuntimeAgent > (); runtime_agent_ -> Wire ( node_dispatcher_ . get ()); } \u6211\u4eec\u8fd9\u91cc\u53ea\u5173\u6ce8\u5904\u7406\u5b50\u7ebf\u7a0b\u76f8\u5173\u7684\u903b\u8f91\u3002\u770b\u4e00\u4e0b worker_agent_->Wire\u3002 1 2 3 4 5 6 void WorkerAgent::Wire ( UberDispatcher * dispatcher ) { frontend_ . reset ( new NodeWorker :: Frontend ( dispatcher -> channel ())); NodeWorker :: Dispatcher :: wire ( dispatcher , this ); auto manager = manager_ . lock (); workers_ = std :: make_shared < NodeWorkers > ( frontend_ , manager -> MainThread ()); } \u8fd9\u65f6\u5019\u7684\u67b6\u6784\u56fe\u5982\u4e0b \u63a5\u7740\u770b\u4e00\u4e0bNodeWorker::Dispatcher::wire(dispatcher, this)\u7684\u903b\u8f91\u3002 1 2 3 4 5 6 void Dispatcher::wire ( UberDispatcher * uber , Backend * backend ) { std :: unique_ptr < DispatcherImpl > dispatcher ( new DispatcherImpl ( uber -> channel (), backend )); uber -> setupRedirects ( dispatcher -> redirects ()); uber -> registerBackend ( \"NodeWorker\" , std :: move ( dispatcher )); } \u9996\u5148\u65b0\u5efa\u4e86\u4e00\u4e2aDispatcherImpl\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 DispatcherImpl ( FrontendChannel * frontendChannel , Backend * backend ) : DispatcherBase ( frontendChannel ) , m_backend ( backend ) { m_dispatchMap [ \"NodeWorker.sendMessageToWorker\" ] = & DispatcherImpl :: sendMessageToWorker ; m_dispatchMap [ \"NodeWorker.enable\" ] = & DispatcherImpl :: enable ; m_dispatchMap [ \"NodeWorker.disable\" ] = & DispatcherImpl :: disable ; m_dispatchMap [ \"NodeWorker.detach\" ] = & DispatcherImpl :: detach ; } \u9664\u4e86\u521d\u59cb\u5316\u4e00\u4e9b\u5b57\u6bb5\uff0c\u53e6\u5916\u4e86\u4e00\u4e2akv\u6570\u636e\u7ed3\u6784\uff0c\u8fd9\u4e2a\u662f\u4e00\u4e2a\u8def\u7531\u914d\u7f6e\uff0c\u540e\u9762\u6211\u4eec\u4f1a\u770b\u5230\u5b83\u7684\u4f5c\u7528\u3002\u65b0\u5efa\u5b8cDispatcherImpl\u540e\u53c8\u8c03\u7528\u4e86uber->registerBackend(\"NodeWorker\", std::move(dispatcher))\u6ce8\u518c\u8be5\u5bf9\u8c61\u3002 1 2 3 4 void UberDispatcher::registerBackend ( const String & name , std :: unique_ptr < protocol :: DispatcherBase > dispatcher ) { m_dispatchers [ name ] = std :: move ( dispatcher ); } \u8fd9\u65f6\u5019\u7684\u67b6\u6784\u56fe\u5982\u4e0b\u3002 \u6211\u4eec\u770b\u5230\u8fd9\u91cc\u5176\u5b9e\u662f\u5efa\u7acb\u4e86\u4e00\u4e2a\u8def\u7531\u4f53\u7cfb\uff0c\u540e\u9762\u6536\u5230\u547d\u4ee4\u65f6\u5c31\u4f1a\u6839\u636e\u8fd9\u4e9b\u8def\u7531\u914d\u7f6e\u8fdb\u884c\u8f6c\u53d1\uff0c\u7c7b\u4f3cNode.js Express\u6846\u67b6\u8def\u7531\u673a\u5236\u3002\u8fd9\u65f6\u5019\u53ef\u4ee5\u901a\u8fc7session\u7684post\u7ed9\u4e3b\u7ebf\u7a0b\u53d1\u9001NodeWorker.enable\u547d\u4ee4\u6765\u5f00\u542f\u5b50\u7ebf\u7a0b\u7684\u8c03\u8bd5\u3002\u6211\u4eec\u5206\u6790\u8fd9\u4e2a\u8fc7\u7a0b\u3002 1 2 3 4 5 6 7 8 9 post ( method , params , callback ) { // \u5ffd\u7565\u53c2\u6570\u5904\u7406 // \u4fdd\u5b58\u8bf7\u6c42\u5bf9\u5e94\u7684\u56de\u8c03 if ( callback ) { this [ messageCallbacksSymbol ]. set ( id , callback ); } // \u8c03\u7528C++\u7684dispatch this [ connectionSymbol ]. dispatch ( JSONStringify ( message )); } this[connectionSymbol]\u5bf9\u5e94\u7684\u662fJSBindingsConnection\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 static void Dispatch ( const FunctionCallbackInfo < Value >& info ) { Environment * env = Environment :: GetCurrent ( info ); JSBindingsConnection * session ; ASSIGN_OR_RETURN_UNWRAP ( & session , info . Holder ()); if ( session -> session_ ) { session -> session_ -> Dispatch ( ToProtocolString ( env -> isolate (), info [ 0 ]) -> string ()); } } session_\u662f\u4e00\u4e2aSameThreadInspectorSession\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 void SameThreadInspectorSession::Dispatch ( const v8_inspector :: StringView & message ) { auto client = client_ . lock (); client -> dispatchMessageFromFrontend ( session_id_ , message ); } void dispatchMessageFromFrontend ( int session_id , const StringView & message ) { channels_ [ session_id ] -> dispatchProtocolMessage ( message ); } \u6700\u7ec8\u8c03\u7528\u4e86ChannelImpl\u7684dispatchProtocolMessage\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void dispatchProtocolMessage ( const StringView & message ) { std :: string raw_message = protocol :: StringUtil :: StringViewToUtf8 ( message ); std :: unique_ptr < protocol :: DictionaryValue > value = protocol :: DictionaryValue :: cast ( protocol :: StringUtil :: parseMessage ( raw_message , false )); int call_id ; std :: string method ; // \u89e3\u6790\u547d\u4ee4 node_dispatcher_ -> parseCommand ( value . get (), & call_id , & method ); // \u5224\u65ad\u547d\u4ee4\u662fV8\u5185\u7f6e\u547d\u4ee4\u8fd8\u662fNode.js\u62d3\u5c55\u7684\u547d\u4ee4 if ( v8_inspector :: V8InspectorSession :: canDispatchMethod ( Utf8ToStringView ( method ) -> string ())) { session_ -> dispatchProtocolMessage ( message ); } else { node_dispatcher_ -> dispatch ( call_id , method , std :: move ( value ), raw_message ); } } \u56e0\u4e3aNodeWorker.enable\u662fNode.js\u62d3\u5c55\u7684\u547d\u4ee4\uff0c\u6240\u4ee5\u4f1a\u8d70\u5230else\u91cc\u9762\u7684\u903b\u8f91\u3002\u6839\u636e\u8def\u7531\u914d\u7f6e\u627e\u5230\u8be5\u547d\u4ee4\u5bf9\u5e94\u7684\u5904\u7406\u903b\u8f91\uff08NodeWorker.enable\u4ee5.\u5207\u5206\uff0c\u5bf9\u5e94\u4e24\u7ea7\u8def\u7531\uff09\u3002 1 2 3 4 5 6 7 8 void UberDispatcher::dispatch ( int callId , const String & in_method , std :: unique_ptr < Value > parsedMessage , const ProtocolMessage & rawMessage ) { // \u627e\u5230\u4e00\u7ea7\u8def\u7531\u914d\u7f6e protocol :: DispatcherBase * dispatcher = findDispatcher ( method ); std :: unique_ptr < protocol :: DictionaryValue > messageObject = DictionaryValue :: cast ( std :: move ( parsedMessage )); // \u4ea4\u7ed9\u4e00\u7ea7\u8def\u7531\u5904\u7406\u5668\u5904\u7406 dispatcher -> dispatch ( callId , method , rawMessage , std :: move ( messageObject )); } NodeWorker.enable\u5bf9\u5e94\u7684\u8def\u7531\u5904\u7406\u5668\u4ee3\u7801\u5982\u4e0b 1 2 3 4 5 6 7 8 void DispatcherImpl::dispatch ( int callId , const String & method , const ProtocolMessage & message , std :: unique_ptr < protocol :: DictionaryValue > messageObject ) { // \u67e5\u627e\u4e8c\u7ea7\u8def\u7531 std :: unordered_map < String , CallHandler >:: iterator it = m_dispatchMap . find ( method ); protocol :: ErrorSupport errors ; // \u627e\u5230\u5904\u7406\u51fd\u6570 ( this ->* ( it -> second ))( callId , method , message , std :: move ( messageObject ), & errors ); } dispatch\u7ee7\u7eed\u5bfb\u627e\u547d\u4ee4\u5bf9\u5e94\u7684\u5904\u7406\u51fd\u6570\uff0c\u6700\u7ec8\u627e\u5230NodeWorker.enable\u547d\u4ee4\u7684\u5904\u7406\u51fd\u6570\u4e3aDispatcherImpl::enable\u3002 1 2 3 4 5 6 7 void DispatcherImpl::enable (...) { std :: unique_ptr < DispatcherBase :: WeakPtr > weak = weakPtr (); DispatchResponse response = m_backend -> enable (...); // \u8fd4\u56de\u54cd\u5e94\u7ed9\u547d\u4ee4\uff08\u7c7b\u4f3c\u8bf7\u6c42/\u54cd\u5e94\u6a21\u5f0f\uff09 weak -> get () -> sendResponse ( callId , response ); } \u6839\u636e\u67b6\u6784\u56fe\u53ef\u4ee5\u77e5\u9053m_backend\u662fWorkerAgent\u5bf9\u8c61\u3002 1 2 3 4 5 6 DispatchResponse WorkerAgent::enable ( bool waitForDebuggerOnStart ) { auto manager = manager_ . lock (); std :: unique_ptr < AgentWorkerInspectorDelegate > delegate ( new AgentWorkerInspectorDelegate ( workers_ )); event_handle_ = manager -> SetAutoAttach ( std :: move ( delegate )); return DispatchResponse :: OK (); } \u7ee7\u7eed\u8c03\u7528WorkerManager\u7684SetAutoAttach\u65b9\u6cd5\u3002 1 2 3 4 5 6 7 8 9 10 11 12 std :: unique_ptr < WorkerManagerEventHandle > WorkerManager :: SetAutoAttach ( std :: unique_ptr < WorkerDelegate > attach_delegate ) { int id = ++ next_delegate_id_ ; // \u4fdd\u5b58delegate delegates_ [ id ] = std :: move ( attach_delegate ); const auto & delegate = delegates_ [ id ]; // \u901a\u77e5\u5b50\u7ebf\u7a0b for ( const auto & worker : children_ ) { Report ( delegate , worker . second , false ); } ... } SetAutoAttach\u904d\u5386\u5b50\u7ebf\u7a0b\u3002 1 2 3 4 5 void Report ( const std :: unique_ptr < WorkerDelegate >& delegate , const WorkerInfo & info , bool waiting ) { if ( info . worker_thread ) delegate -> WorkerCreated ( info . title , info . url , waiting , info . worker_thread ); } info\u662f\u4e00\u4e2aWorkerInfo\u5bf9\u8c61\uff0c\u8be5\u5bf9\u8c61\u662f\u5b50\u7ebf\u7a0b\u521d\u59cb\u5316\u548c\u4e3b\u7ebf\u7a0b\u5efa\u7acb\u5173\u7cfb\u7684\u6570\u636e\u7ed3\u6784\u3002delegate\u662fAgentWorkerInspectorDelegate\u5bf9\u8c61\u3002 1 2 3 4 5 6 void WorkerCreated ( const std :: string & title , const std :: string & url , bool waiting , std :: shared_ptr < MainThreadHandle > target ) override { workers_ -> WorkerCreated ( title , url , waiting , target ); } workers_\u662f\u4e00\u4e2aNodeWorkers\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void NodeWorkers::WorkerCreated ( const std :: string & title , const std :: string & url , bool waiting , std :: shared_ptr < MainThreadHandle > target ) { auto frontend = frontend_ . lock (); std :: string id = std :: to_string ( ++ next_target_id_ ); // \u5904\u7406\u6570\u636e\u901a\u4fe1\u7684delegate auto delegate = thread_ -> MakeDelegateThreadSafe ( std :: unique_ptr < InspectorSessionDelegate > ( new ParentInspectorSessionDelegate ( id , shared_from_this ()) ) ); // \u5efa\u7acb\u548c\u5b50\u7ebf\u7a0bV8 Inspector\u7684\u901a\u4fe1\u901a\u9053 sessions_ [ id ] = target -> Connect ( std :: move ( delegate ), true ); frontend -> attachedToWorker ( id , WorkerInfo ( id , title , url ), waiting ); } WorkerCreated\u5efa\u7acb\u4e86\u4e00\u6761\u548c\u5b50\u7ebf\u7a0b\u901a\u4fe1\u7684\u901a\u9053\uff0c\u7136\u540e\u901a\u77e5\u547d\u4ee4\u7684\u53d1\u9001\u65b9\u901a\u9053\u5efa\u7acb\u6210\u529f\u3002\u8fd9\u65f6\u5019\u67b6\u6784\u56fe\u5982\u4e0b\u3002 \u63a5\u7740\u770battachedToWorker\u3002 1 2 3 4 5 6 7 8 9 10 void Frontend::attachedToWorker ( const String & sessionId , std :: unique_ptr < protocol :: NodeWorker :: WorkerInfo > workerInfo , bool waitingForDebugger ) { std :: unique_ptr < AttachedToWorkerNotification > messageData = AttachedToWorkerNotification :: create () . setSessionId ( sessionId ) . setWorkerInfo ( std :: move ( workerInfo )) . setWaitingForDebugger ( waitingForDebugger ) . build (); // \u89e6\u53d1NodeWorker.attachedToWorker m_frontendChannel -> sendProtocolNotification ( InternalResponse :: createNotification ( \"NodeWorker.attachedToWorker\" , std :: move ( messageData ))); } \u7ee7\u7eed\u770bsendProtocolNotification 1 2 3 4 5 6 7 8 void sendProtocolNotification ( std :: unique_ptr < Serializable > message ) override { sendMessageToFrontend ( message -> serializeToJSON ()); } void sendMessageToFrontend ( const StringView & message ) { delegate_ -> SendMessageToFrontend ( message ); } \u8fd9\u91cc\u7684delegate_\u662f\u4e00\u4e2aJSBindingsSessionDelegate\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void SendMessageToFrontend ( const v8_inspector :: StringView & message ) override { Isolate * isolate = env_ -> isolate (); HandleScope handle_scope ( isolate ); Context :: Scope context_scope ( env_ -> context ()); MaybeLocal < String > v8string = String :: NewFromTwoByte ( isolate , message . characters16 (), NewStringType :: kNormal , message . length () ); Local < Value > argument = v8string . ToLocalChecked (). As < Value > (); // \u6536\u5230\u6d88\u606f\u6267\u884c\u56de\u8c03 connection_ -> OnMessage ( argument ); } // \u6267\u884cJS\u5c42\u56de\u8c03 void OnMessage ( Local < Value > value ) { MakeCallback ( callback_ . Get ( env () -> isolate ()), 1 , & value ); } JS\u5c42\u56de\u8c03\u903b\u8f91\u5982\u4e0b\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [ onMessageSymbol ]( message ) { const parsed = JSONParse ( message ); // \u6536\u5230\u7684\u6d88\u606f\u5982\u679c\u662f\u67d0\u4e2a\u8bf7\u6c42\u7684\u54cd\u5e94\uff0c\u5219\u6709\u4e2aid\u5b57\u6bb5\u8bb0\u5f55\u4e86\u8bf7\u6c42\u5bf9\u5e94\u7684id\uff0c\u5426\u5219\u5219\u89e6\u53d1\u4e8b\u4ef6 if ( parsed . id ) { const callback = this [ messageCallbacksSymbol ]. get ( parsed . id ); this [ messageCallbacksSymbol ]. delete ( parsed . id ); if ( callback ) { callback ( null , parsed . result ); } } else { this . emit ( parsed . method , parsed ); this . emit ( 'inspectorNotification' , parsed ); } } \u4e3b\u7ebf\u7a0b\u62ff\u5230Worker Session\u5bf9\u4e00\u4e2a\u7684id\uff0c\u540e\u7eed\u5c31\u53ef\u4ee5\u901a\u8fc7\u547d\u4ee4NodeWorker.sendMessageToWorker\u52a0\u4e0a\u8be5id\u548c\u5b50\u7ebf\u7a0b\u901a\u4fe1\u3002\u5927\u81f4\u539f\u7406\u5982\u4e0b\uff0c\u4e3b\u7ebf\u7a0b\u901a\u8fc7\u81ea\u5df1\u7684channel\u548c\u5b50\u7ebf\u7a0b\u7684channel\u8fdb\u884c\u901a\u4fe1\uff0c\u4ece\u800c\u8fbe\u5230\u63a7\u5236\u5b50\u7ebf\u7a0b\u7684\u76ee\u7684\u3002 \u6211\u4eec\u5206\u6790\u4e00\u4e0bNodeWorker.sendMessageToWorker\u547d\u4ee4\u7684\u903b\u8f91\uff0c\u5bf9\u5e94\u5904\u7406\u51fd\u6570\u4e3aDispatcherImpl::sendMessageToWorker\u3002 1 2 3 4 5 6 7 8 void DispatcherImpl::sendMessageToWorker (...) { std :: unique_ptr < DispatcherBase :: WeakPtr > weak = weakPtr (); DispatchResponse response = m_backend -> sendMessageToWorker ( in_message , in_sessionId ); // \u54cd\u5e94 weak -> get () -> sendResponse ( callId , response ); return ; } \u7ee7\u7eed\u5206\u6790m_backend->sendMessageToWorker\u3002 1 2 3 4 5 6 7 8 9 10 DispatchResponse WorkerAgent::sendMessageToWorker ( const String & message , const String & sessionId ) { workers_ -> Receive ( sessionId , message ); return DispatchResponse :: OK (); } void NodeWorkers::Receive ( const std :: string & id , const std :: string & message ) { auto it = sessions_ . find ( id ); it -> second -> Dispatch ( Utf8ToStringView ( message ) -> string ()); } sessions_\u5bf9\u5e94\u7684\u662f\u548c\u5b50\u7ebf\u7a0b\u7684\u901a\u4fe1\u7684\u6570\u636e\u7ed3\u6784CrossThreadInspectorSession\u3002\u770b\u4e00\u4e0b\u8be5\u5bf9\u8c61\u7684Dispatch\u65b9\u6cd5\u3002 1 2 3 4 void Dispatch ( const StringView & message ) override { state_ . Call ( & MainThreadSessionState :: Dispatch , StringBuffer :: create ( message )); } \u518d\u6b21\u8c03\u4e86MainThreadSessionState::Dispatch 1 2 3 void Dispatch ( std :: unique_ptr < StringBuffer > message ) { session_ -> Dispatch ( message -> string ()); } session_\u662fSameThreadInspectorSession\u5bf9\u8c61\u3002\u7ee7\u7eed\u770b\u5b83\u7684Dispatch\u65b9\u6cd5\u3002 1 2 3 4 5 6 7 8 9 void SameThreadInspectorSession::Dispatch ( const v8_inspector :: StringView & message ) { auto client = client_ . lock (); client -> dispatchMessageFromFrontend ( session_id_ , message ); } void dispatchMessageFromFrontend ( int session_id , const StringView & message ) { channels_ [ session_id ] -> dispatchProtocolMessage ( message ); } \u901a\u8fc7\u5c42\u5c42\u8c03\u7528\uff0c\u6700\u7ec8\u62ff\u5230\u4e86\u4e00\u4e2a\u5408\u5b50\u7ebf\u7a0b\u901a\u4fe1\u7684channel\uff0cdispatchProtocolMessage\u65b9\u6cd5\u521a\u624d\u5df2\u7ecf\u5206\u6790\u8fc7\uff0c\u8be5\u65b9\u6cd5\u4f1a\u6839\u636e\u547d\u4ee4\u505a\u4e0d\u540c\u7684\u5904\u7406\uff0c\u56e0\u4e3a\u6211\u4eec\u8fd9\u91cc\u53d1\u9001\u7684\u662fV8\u5185\u7f6e\u7684\u547d\u4ee4\uff0c\u6240\u4ee5\u4f1a\u4ea4\u7ed9V8 Inspector\u5904\u7406\u3002\u5f53V8 Inspector\u5904\u7406\u5b8c\u540e\uff0c\u4f1a\u901a\u8fc7ChannelImpl\u7684sendResponse\u8fd4\u56de\u7ed3\u679c\u3002 1 2 3 4 5 6 7 8 9 void sendResponse ( int callId , std :: unique_ptr < v8_inspector :: StringBuffer > message ) override { sendMessageToFrontend ( message -> string ()); } void sendMessageToFrontend ( const StringView & message ) { delegate_ -> SendMessageToFrontend ( message ); } \u8fd9\u91cc\u7684delegate_\u662fParentInspectorSessionDelegate\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void SendMessageToFrontend ( const v8_inspector :: StringView & msg ) override { std :: string message = protocol :: StringUtil :: StringViewToUtf8 ( msg ); workers_ -> Send ( id_ , message ); } void NodeWorkers::Send ( const std :: string & id , const std :: string & message ) { auto frontend = frontend_ . lock (); if ( frontend ) frontend -> receivedMessageFromWorker ( id , message ); } void Frontend::receivedMessageFromWorker ( const String & sessionId , const String & message ) { std :: unique_ptr < ReceivedMessageFromWorkerNotification > messageData = ReceivedMessageFromWorkerNotification :: create () . setSessionId ( sessionId ) . setMessage ( message ) . build (); // \u89e6\u53d1NodeWorker.receivedMessageFromWorker m_frontendChannel -> sendProtocolNotification ( InternalResponse :: createNotification ( \"NodeWorker.receivedMessageFromWorker\" , std :: move ( messageData ))); } m_frontendChannel\u662f\u4e3b\u7ebf\u7a0b\u7684ChannelImpl\u5bf9\u8c61\u3002 1 2 3 4 5 6 7 8 void sendProtocolNotification ( std :: unique_ptr < Serializable > message ) override { sendMessageToFrontend ( message -> serializeToJSON ()); } void sendMessageToFrontend ( const StringView & message ) { delegate_ -> SendMessageToFrontend ( message ); } delegate_\u662fC++\u5c42\u4f20\u5165\u7684JSBindingsSessionDelegate\u5bf9\u8c61\u3002\u6700\u7ec8\u901a\u8fc7JSBindingsSessionDelegate\u5bf9\u8c61\u56de\u8c03JS\u5c42\uff0c\u4e4b\u524d\u5df2\u7ecf\u5206\u6790\u8fc7\u5c31\u4e0d\u518d\u8d58\u8ff0\u3002\u81f3\u6b64\uff0c\u4e3b\u7ebf\u7a0b\u5c31\u5177\u5907\u4e86\u63a7\u5236\u5b50\u7ebf\u7a0b\u7684\u80fd\u529b\uff0c\u4f46\u662f\u63a7\u5236\u65b9\u5f0f\u6709\u5f88\u591a\u79cd\u3002","title":"2 \u4e3b\u7ebf\u7a0b\u5f00\u542f\u8c03\u8bd5\u5b50\u7ebf\u7a0b\u7684\u80fd\u529b"},{"location":"chapter25-Node.js%E5%AD%90%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95%E5%92%8C%E8%AF%8A%E6%96%AD%E6%8C%87%E5%8D%97/#21-v8","text":"\u901a\u8fc7\u4e0b\u9762\u4ee3\u7801\u6536\u96c6\u5b50\u7ebf\u7a0b\u7684CPU Profile\u4fe1\u606f\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const { Worker , workerData } = require ( 'worker_threads' ); const { Session } = require ( 'inspector' ); const session = new Session (); session . connect (); let id = 1 ; function post ( sessionId , method , params , callback ) { session . post ( 'NodeWorker.sendMessageToWorker' , { sessionId , message : JSON . stringify ({ id : id ++ , method , params }) }, callback ); } session . on ( 'NodeWorker.attachedToWorker' , ( data ) => { post ( data . params . sessionId , 'Profiler.enable' ); post ( data . params . sessionId , 'Profiler.start' ); // \u6536\u96c6\u4e00\u6bb5\u65f6\u95f4\u540e\u63d0\u4ea4\u505c\u6b62\u6536\u96c6\u547d\u4ee4 setTimeout (() => { post ( data . params . sessionId , 'Profiler.stop' ); }, 10000 ) }); session . on ( 'NodeWorker.receivedMessageFromWorker' , ({ params : { message }}) => { const data = JSON . parse ( message ); console . log ( data ); }); const worker = new Worker ( './httpServer.js' , { workerData : { port : 80 }}); worker . on ( 'online' , () => { session . post ( \"NodeWorker.enable\" ,{ waitForDebuggerOnStart : false }, ( err ) => { console . log ( err , \"NodeWorker.enable\" );}); }); setInterval (() => {}, 100000 ); \u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u53ef\u4ee5\u901a\u8fc7\u547d\u4ee4\u63a7\u5236\u5b50\u7ebf\u7a0b\u7684\u8c03\u8bd5\u548c\u6570\u636e\u6536\u96c6\u3002","title":"2.1 \u4f7f\u7528\u901a\u7528\u7684V8\u547d\u4ee4"},{"location":"chapter25-Node.js%E5%AD%90%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95%E5%92%8C%E8%AF%8A%E6%96%AD%E6%8C%87%E5%8D%97/#22","text":"\u53ef\u4ee5\u901a\u8fc7\u6267\u884c\u811a\u672c\u5f00\u542f\u5b50\u7ebf\u7a0b\u7684WebSocket\u670d\u52a1\uff0c\u50cf\u8c03\u8bd5\u4e3b\u7ebf\u7a0b\u4e00\u6837\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 const { Worker , workerData } = require ( 'worker_threads' ); const { Session } = require ( 'inspector' ); const session = new Session (); session . connect (); let workerSessionId ; let id = 1 ; function post ( method , params ) { session . post ( 'NodeWorker.sendMessageToWorker' , { sessionId : workerSessionId , message : JSON . stringify ({ id : id ++ , method , params }) }); } session . on ( 'NodeWorker.receivedMessageFromWorker' , ({ params : { message }}) => { const data = JSON . parse ( message ); console . log ( data ); }); session . on ( 'NodeWorker.attachedToWorker' , ( data ) => { workerSessionId = data . params . sessionId ; post ( \"Runtime.evaluate\" , { includeCommandLineAPI : true , expression : `const inspector = process.binding('inspector'); inspector.open(); inspector.url(); ` } ); }); const worker = new Worker ( './httpServer.js' , { workerData : { port : 80 }}); worker . on ( 'online' , () => { session . post ( \"NodeWorker.enable\" ,{ waitForDebuggerOnStart : false }, ( err ) => { err && console . log ( \"NodeWorker.enable\" , err );}); }); setInterval (() => {}, 100000 ); \u6267\u884c\u4e0a\u9762\u7684\u4ee3\u7801\u5c31\u62ff\u5230\u4ee5\u4e0b\u8f93\u51fa 1 2 3 4 5 6 7 8 9 { id : 1 , result : { result : { type : 'string' , value : 'ws://127.0.0.1:9229/c0ca16c8-55aa-4651-9776-fca1b27fc718' } } } \u901a\u8fc7\u8be5\u5730\u5740\uff0c\u5ba2\u6237\u7aef\u5c31\u53ef\u4ee5\u5bf9\u5b50\u7ebf\u7a0b\u8fdb\u884c\u8c03\u8bd5\u4e86\u3002\u4e0a\u9762\u4ee3\u7801\u91cc\u4f7f\u7528process.binding\u800c\u4e0d\u662frequire\u52a0\u8f7dinspector\uff0c\u56e0\u4e3a\u521a\u624d\u901a\u8fc7NodeWorker.enable\u547d\u4ee4\u4e3a\u5b50\u7ebf\u7a0b\u521b\u5efa\u4e86\u4e00\u4e2a\u5230\u5b50\u7ebf\u7a0bInspector\u7684channel\uff0c\u800cJS\u6a21\u5757\u91cc\u5224\u65ad\u5982\u679cchannel\u975e\u7a7a\u5219\u62a5\u9519Inspector\u5df2\u7ecf\u6253\u5f00\u3002\u6240\u4ee5\u8fd9\u91cc\u9700\u8981\u7ed5\u8fc7\u8fd9\u4e2a\u9650\u5236\uff0c\u76f4\u63a5\u52a0\u8f7dC++\u6a21\u5757\u5f00\u542fWebSocket\u670d\u52a1\u5668\u3002","title":"2.2 \u5728\u5b50\u7ebf\u7a0b\u4e2d\u52a8\u6001\u6267\u884c\u811a\u672c"},{"location":"chapter25-Node.js%E5%AD%90%E7%BA%BF%E7%A8%8B%E8%B0%83%E8%AF%95%E5%92%8C%E8%AF%8A%E6%96%AD%E6%8C%87%E5%8D%97/#3","text":"\u4e0d\u4ec5\u53ef\u4ee5\u901a\u8fc7\u4e3b\u7ebf\u7a0b\u8c03\u8bd5\u5b50\u7ebf\u7a0b\uff0c\u8fd8\u53ef\u4ee5\u901a\u8fc7\u5b50\u7ebf\u7a0b\u8c03\u8bd5\u4e3b\u7ebf\u7a0b\u3002Node.js\u5728\u5b50\u7ebf\u7a0b\u66b4\u9732\u4e86connectToMainThread\u65b9\u6cd5\u8fde\u63a5\u5230\u4e3b\u7ebf\u7a0b\u7684Inspector\uff08\u53ea\u80fd\u5728work_threads\u4e2d\u4f7f\u7528\uff09\uff0c\u5b9e\u73b0\u7684\u539f\u7406\u548c\u4e4b\u524d\u5206\u6790\u7684\u7c7b\u4f3c\uff0c\u4e3b\u8981\u662f\u5b50\u7ebf\u7a0b\u8fde\u63a5\u5230\u4e3b\u7ebf\u7a0b\u7684V8 Inspector\uff0c\u901a\u8fc7\u548c\u8be5Inspector\u5b8c\u6210\u5bf9\u4e3b\u7ebf\u7a0b\u7684\u63a7\u5236\u3002\u770b\u4e0b\u9762\u4e00\u4e2a\u4f8b\u5b50\u3002 \u4e3b\u7ebf\u7a0b\u4ee3\u7801 1 2 3 4 5 6 7 8 const { Worker , workerData } = require ( 'worker_threads' ); const http = require ( 'http' ); const worker = new Worker ( './worker.js' , { workerData : { port : 80 }}); http . createServer (( _ , res ) => { res . end ( 'main' ); }). listen ( 8000 ); worker.js\u4ee3\u7801\u5982\u4e0b 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const fs = require ( 'fs' ); const { workerData : { port } } = require ( 'worker_threads' ); const { Session } = require ( 'inspector' ); const session = new Session (); session . connectToMainThread (); session . post ( 'Profiler.enable' ); session . post ( 'Profiler.start' ); setTimeout (() => { session . post ( 'Profiler.stop' , ( err , data ) => { if ( data . profile ) { fs . writeFileSync ( './profile.cpuprofile' , JSON . stringify ( data . profile )); } }); }, 5000 )","title":"3 \u5b50\u7ebf\u7a0b\u8c03\u8bd5\u4e3b\u7ebf\u7a0b"},{"location":"chapter26-vscode%E8%B0%83%E8%AF%95Node.js/","text":"\u524d\u8a00\uff1a\u8c03\u8bd5\u4ee3\u7801\u4e0d\u7ba1\u5bf9\u4e8e\u5f00\u53d1\u8fd8\u662f\u5b66\u4e60\u6e90\u7801\u90fd\u662f\u975e\u5e38\u91cd\u8981\u7684\u6280\u80fd\uff0c\u672c\u6587\u7b80\u5355\u4ecb\u7ecdvscode\u8c03\u8bd5Node.js\u76f8\u5173\u4ee3\u7801\u7684\u8c03\u8bd5\u6280\u5de7\u3002 1 \u8c03\u8bd5\u4e1a\u52a1JS \u00b6 \u8c03\u8bd5\u4e1a\u52a1JS\u53ef\u80fd\u662f\u666e\u904d\u7684\u573a\u666f\uff0c\u968f\u7740Node.js\u548c\u8c03\u8bd5\u5de5\u5177\u7684\u6210\u719f\uff0c\u8c03\u8bd5\u4e5f\u53d8\u5f97\u8d8a\u6765\u8d8a\u7b80\u5355\u3002\u4e0b\u9762\u662fvscode\u7684lauch.json\u914d\u7f6e\u3002 1 2 3 4 5 6 7 8 9 10 11 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"type\" : \"node\" , \"request\" : \"attach\" , \"name\" : \"Attact Program\" , \"port\" : 9229 } ] } 1 \u5728JS\u91cc\u8bbe\u7f6e\u65ad\u70b9\uff0c\u6267\u884cnode --inspect index.js \u542f\u52a8\u8fdb\u7a0b\uff0c\u4f1a\u8f93\u51fa\u8c03\u8bd5\u5730\u5740\u3002 2 \u70b9\u51fb\u866b\u5b50\uff0c\u7136\u540e\u70b9\u51fb\u7eff\u8272\u7684\u4e09\u89d2\u5f62\u3002 3 vscode\u4f1a\u8fde\u63a5Node.js\u7684WebSocket\u670d\u52a1\u3002 4 \u5f00\u59cb\u8c03\u8bd5\uff08\u6216\u8005\u4f7f\u7528Chrome Dev Tools\u8c03\u8bd5\uff09\u3002 2 \u8c03\u8bd5Addon\u7684C++ \u00b6 \u5199Addon\u7684\u573a\u666f\u53ef\u80fd\u4e0d\u591a\uff0c\u4f46\u662f\u5f53\u4f60\u9700\u8981\u7684\u65f6\u5019\uff0c\u4f60\u5c31\u4f1a\u9700\u8981\u8c03\u8bd5\u5b83\u3002\u4e0b\u9762\u7684\u914d\u7f6e\u53ea\u53ef\u4ee5\u8c03\u8bd5C++\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Debug node C++ addon\" , \"type\" : \"lldb\" , \"request\" : \"launch\" , \"program\" : \"node\" , \"args\" : [ \"${workspaceFolder}/node-addon-examples/1_hello_world/napi/hello.js\" ], \"cwd\" : \"${workspaceFolder}/node-addon-examples/1_hello_world/napi\" }, ] } 1 \u5728C++\u4ee3\u7801\u8bbe\u7f6e\u65ad\u70b9\u3002 2 \u6267\u884cnode-gyp configure && node-gyp build --debug\u7f16\u8bd1debug\u7248\u672c\u7684Addon\u3002 3 JS\u91cc\u52a0\u8f7ddebug\u7248\u672c\u7684Addon\u3002 4 \u70b9\u51fb\u5c0f\u866b\u5b50\u5f00\u59cb\u8c03\u8bd5\u3002 3 \u8c03\u8bd5Addon\u7684C++\u548cJS \u00b6 Addon\u901a\u5e38\u9700\u8981\u901a\u8fc7JS\u66b4\u9732\u51fa\u6765\u4f7f\u7528\uff0c\u5982\u679c\u6211\u4eec\u9700\u8981\u8c03\u8bd5C++\u548cJS\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u914d\u7f6e\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Debug node C++ addon\" , \"type\" : \"node\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/node-addon-examples/1_hello_world/napi/hello.js\" , \"cwd\" : \"${workspaceFolder}/node-addon-examples/1_hello_world/napi\" }, { \"name\" : \"Attach node C/C++ Addon\" , \"type\" : \"lldb\" , \"request\" : \"attach\" , \"pid\" : \"${command:pickMyProcess}\" } ] } \u548c2\u7684\u8fc7\u7a0b\u7c7b\u4f3c\uff0c\u70b9\u4e09\u89d2\u5f62\u5f00\u59cb\u8c03\u8bd5\uff0c\u518d\u9009\u62e9Attach node C/C++ Addon\uff0c\u7136\u540e\u518d\u6b21\u70b9\u51fb\u4e09\u89d2\u5f62\u3002 \u9009\u62e9attach\u5230hello.js\u4e2d\u3002 \u5f00\u59cb\u8c03\u8bd5\u3002 4 \u8c03\u8bd5Node.js\u6e90\u7801C++ \u00b6 \u6211\u4eec\u4e0d\u4ec5\u7528Node.js\uff0c\u6211\u4eec\u53ef\u80fd\u8fd8\u4f1a\u5b66\u4e60Node.js\u6e90\u7801\uff0c\u5b66\u4e60\u6e90\u7801\u7684\u65f6\u5019\u5c31\u5c11\u4e0d\u4e86\u8c03\u8bd5\u3002\u53ef\u4ee5\u901a\u8fc7\u4e0b\u9762\u7684\u65b9\u5f0f\u8c03\u8bd5Node.js\u7684C++\u6e90\u7801\u3002 1 ./configure --debug && make \u4f7f\u7528\u4ee5\u4e0b\u914d\u7f6e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"(lldb) \u542f\u52a8\" , \"type\" : \"cppdbg\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/out/Debug/node\" , \"args\" : [], \"stopAtEntry\" : false , \"cwd\" : \"${fileDirname}\" , \"environment\" : [], \"externalConsole\" : false , \"MIMode\" : \"lldb\" } ] } \u5728node_main.cc\u7684main\u51fd\u6570\u6216\u4efb\u4f55C++\u4ee3\u7801\u91cc\u6253\u65ad\u70b9\uff0c\u70b9\u51fb\u5c0f\u866b\u5b50\u5f00\u59cb\u8c03\u8bd5\u3002 5 \u8c03\u8bd5Node.js\u6e90\u7801C++\u548cJS\u4ee3\u7801 \u00b6 Node.js\u7684\u6e90\u7801\u4e0d\u4ec5\u4ec5\u6709C++\uff0c\u8fd8\u6709JS\uff0c\u5982\u679c\u6211\u4eec\u60f3\u540c\u65f6\u8c03\u8bd5\uff0c\u90a3\u4e48\u5c31\u4f7f\u7528\u4ee5\u4e0b\u914d\u7f6e\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"(lldb) \u542f\u52a8\" , \"type\" : \"cppdbg\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/out/Debug/node\" , \"args\" : [ \"--inspect-brk\" , \"${workspaceFolder}/out/Debug/index.js\" ], \"stopAtEntry\" : false , \"cwd\" : \"${fileDirname}\" , \"environment\" : [], \"externalConsole\" : false , \"MIMode\" : \"lldb\" } ] } 1 \u70b9\u51fb\u8c03\u8bd5\u3002 2 \u5728vscode\u8c03\u8bd5C++\uff0c\u6267\u884c\u5b8cNode.js\u542f\u52a8\u7684\u6d41\u7a0b\u540e\u4f1a\u8f93\u51fa\u8c03\u8bd5JS\u7684\u5730\u5740\u3002 3 \u5728\u6d4f\u89c8\u5668\u8fde\u63a5WebSocket\u670d\u52a1\u8c03\u8bd5JS\u3002","title":"26-vscode\u8c03\u8bd5Node.js"},{"location":"chapter26-vscode%E8%B0%83%E8%AF%95Node.js/#1-js","text":"\u8c03\u8bd5\u4e1a\u52a1JS\u53ef\u80fd\u662f\u666e\u904d\u7684\u573a\u666f\uff0c\u968f\u7740Node.js\u548c\u8c03\u8bd5\u5de5\u5177\u7684\u6210\u719f\uff0c\u8c03\u8bd5\u4e5f\u53d8\u5f97\u8d8a\u6765\u8d8a\u7b80\u5355\u3002\u4e0b\u9762\u662fvscode\u7684lauch.json\u914d\u7f6e\u3002 1 2 3 4 5 6 7 8 9 10 11 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"type\" : \"node\" , \"request\" : \"attach\" , \"name\" : \"Attact Program\" , \"port\" : 9229 } ] } 1 \u5728JS\u91cc\u8bbe\u7f6e\u65ad\u70b9\uff0c\u6267\u884cnode --inspect index.js \u542f\u52a8\u8fdb\u7a0b\uff0c\u4f1a\u8f93\u51fa\u8c03\u8bd5\u5730\u5740\u3002 2 \u70b9\u51fb\u866b\u5b50\uff0c\u7136\u540e\u70b9\u51fb\u7eff\u8272\u7684\u4e09\u89d2\u5f62\u3002 3 vscode\u4f1a\u8fde\u63a5Node.js\u7684WebSocket\u670d\u52a1\u3002 4 \u5f00\u59cb\u8c03\u8bd5\uff08\u6216\u8005\u4f7f\u7528Chrome Dev Tools\u8c03\u8bd5\uff09\u3002","title":"1 \u8c03\u8bd5\u4e1a\u52a1JS"},{"location":"chapter26-vscode%E8%B0%83%E8%AF%95Node.js/#2-addonc","text":"\u5199Addon\u7684\u573a\u666f\u53ef\u80fd\u4e0d\u591a\uff0c\u4f46\u662f\u5f53\u4f60\u9700\u8981\u7684\u65f6\u5019\uff0c\u4f60\u5c31\u4f1a\u9700\u8981\u8c03\u8bd5\u5b83\u3002\u4e0b\u9762\u7684\u914d\u7f6e\u53ea\u53ef\u4ee5\u8c03\u8bd5C++\u4ee3\u7801\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Debug node C++ addon\" , \"type\" : \"lldb\" , \"request\" : \"launch\" , \"program\" : \"node\" , \"args\" : [ \"${workspaceFolder}/node-addon-examples/1_hello_world/napi/hello.js\" ], \"cwd\" : \"${workspaceFolder}/node-addon-examples/1_hello_world/napi\" }, ] } 1 \u5728C++\u4ee3\u7801\u8bbe\u7f6e\u65ad\u70b9\u3002 2 \u6267\u884cnode-gyp configure && node-gyp build --debug\u7f16\u8bd1debug\u7248\u672c\u7684Addon\u3002 3 JS\u91cc\u52a0\u8f7ddebug\u7248\u672c\u7684Addon\u3002 4 \u70b9\u51fb\u5c0f\u866b\u5b50\u5f00\u59cb\u8c03\u8bd5\u3002","title":"2 \u8c03\u8bd5Addon\u7684C++"},{"location":"chapter26-vscode%E8%B0%83%E8%AF%95Node.js/#3-addoncjs","text":"Addon\u901a\u5e38\u9700\u8981\u901a\u8fc7JS\u66b4\u9732\u51fa\u6765\u4f7f\u7528\uff0c\u5982\u679c\u6211\u4eec\u9700\u8981\u8c03\u8bd5C++\u548cJS\uff0c\u90a3\u4e48\u5c31\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u914d\u7f6e\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"Debug node C++ addon\" , \"type\" : \"node\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/node-addon-examples/1_hello_world/napi/hello.js\" , \"cwd\" : \"${workspaceFolder}/node-addon-examples/1_hello_world/napi\" }, { \"name\" : \"Attach node C/C++ Addon\" , \"type\" : \"lldb\" , \"request\" : \"attach\" , \"pid\" : \"${command:pickMyProcess}\" } ] } \u548c2\u7684\u8fc7\u7a0b\u7c7b\u4f3c\uff0c\u70b9\u4e09\u89d2\u5f62\u5f00\u59cb\u8c03\u8bd5\uff0c\u518d\u9009\u62e9Attach node C/C++ Addon\uff0c\u7136\u540e\u518d\u6b21\u70b9\u51fb\u4e09\u89d2\u5f62\u3002 \u9009\u62e9attach\u5230hello.js\u4e2d\u3002 \u5f00\u59cb\u8c03\u8bd5\u3002","title":"3 \u8c03\u8bd5Addon\u7684C++\u548cJS"},{"location":"chapter26-vscode%E8%B0%83%E8%AF%95Node.js/#4-nodejsc","text":"\u6211\u4eec\u4e0d\u4ec5\u7528Node.js\uff0c\u6211\u4eec\u53ef\u80fd\u8fd8\u4f1a\u5b66\u4e60Node.js\u6e90\u7801\uff0c\u5b66\u4e60\u6e90\u7801\u7684\u65f6\u5019\u5c31\u5c11\u4e0d\u4e86\u8c03\u8bd5\u3002\u53ef\u4ee5\u901a\u8fc7\u4e0b\u9762\u7684\u65b9\u5f0f\u8c03\u8bd5Node.js\u7684C++\u6e90\u7801\u3002 1 ./configure --debug && make \u4f7f\u7528\u4ee5\u4e0b\u914d\u7f6e 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"(lldb) \u542f\u52a8\" , \"type\" : \"cppdbg\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/out/Debug/node\" , \"args\" : [], \"stopAtEntry\" : false , \"cwd\" : \"${fileDirname}\" , \"environment\" : [], \"externalConsole\" : false , \"MIMode\" : \"lldb\" } ] } \u5728node_main.cc\u7684main\u51fd\u6570\u6216\u4efb\u4f55C++\u4ee3\u7801\u91cc\u6253\u65ad\u70b9\uff0c\u70b9\u51fb\u5c0f\u866b\u5b50\u5f00\u59cb\u8c03\u8bd5\u3002","title":"4 \u8c03\u8bd5Node.js\u6e90\u7801C++"},{"location":"chapter26-vscode%E8%B0%83%E8%AF%95Node.js/#5-nodejscjs","text":"Node.js\u7684\u6e90\u7801\u4e0d\u4ec5\u4ec5\u6709C++\uff0c\u8fd8\u6709JS\uff0c\u5982\u679c\u6211\u4eec\u60f3\u540c\u65f6\u8c03\u8bd5\uff0c\u90a3\u4e48\u5c31\u4f7f\u7528\u4ee5\u4e0b\u914d\u7f6e\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"(lldb) \u542f\u52a8\" , \"type\" : \"cppdbg\" , \"request\" : \"launch\" , \"program\" : \"${workspaceFolder}/out/Debug/node\" , \"args\" : [ \"--inspect-brk\" , \"${workspaceFolder}/out/Debug/index.js\" ], \"stopAtEntry\" : false , \"cwd\" : \"${fileDirname}\" , \"environment\" : [], \"externalConsole\" : false , \"MIMode\" : \"lldb\" } ] } 1 \u70b9\u51fb\u8c03\u8bd5\u3002 2 \u5728vscode\u8c03\u8bd5C++\uff0c\u6267\u884c\u5b8cNode.js\u542f\u52a8\u7684\u6d41\u7a0b\u540e\u4f1a\u8f93\u51fa\u8c03\u8bd5JS\u7684\u5730\u5740\u3002 3 \u5728\u6d4f\u89c8\u5668\u8fde\u63a5WebSocket\u670d\u52a1\u8c03\u8bd5JS\u3002","title":"5 \u8c03\u8bd5Node.js\u6e90\u7801C++\u548cJS\u4ee3\u7801"}]}